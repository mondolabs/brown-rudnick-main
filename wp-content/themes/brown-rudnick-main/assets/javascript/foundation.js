'use strict';

window.whatInput = function () {

  'use strict';

  /*
    ---------------
    variables
    ---------------
  */

  // array of actively pressed keys

  var activeKeys = [];

  // cache document.body
  var body;

  // boolean: true if touch buffer timer is running
  var buffer = false;

  // the last used input type
  var currentInput = null;

  // `input` types that don't accept text
  var nonTypingInputs = ['button', 'checkbox', 'file', 'image', 'radio', 'reset', 'submit'];

  // detect version of mouse wheel event to use
  // via https://developer.mozilla.org/en-US/docs/Web/Events/wheel
  var mouseWheel = detectWheel();

  // list of modifier keys commonly used with the mouse and
  // can be safely ignored to prevent false keyboard detection
  var ignoreMap = [16, // shift
  17, // control
  18, // alt
  91, // Windows key / left Apple cmd
  93 // Windows menu / right Apple cmd
  ];

  // mapping of events to input types
  var inputMap = {
    'keydown': 'keyboard',
    'keyup': 'keyboard',
    'mousedown': 'mouse',
    'mousemove': 'mouse',
    'MSPointerDown': 'pointer',
    'MSPointerMove': 'pointer',
    'pointerdown': 'pointer',
    'pointermove': 'pointer',
    'touchstart': 'touch'
  };

  // add correct mouse wheel event mapping to `inputMap`
  inputMap[detectWheel()] = 'mouse';

  // array of all used input types
  var inputTypes = [];

  // mapping of key codes to a common name
  var keyMap = {
    9: 'tab',
    13: 'enter',
    16: 'shift',
    27: 'esc',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down'
  };

  // map of IE 10 pointer events
  var pointerMap = {
    2: 'touch',
    3: 'touch', // treat pen like touch
    4: 'mouse'
  };

  // touch buffer timer
  var timer;

  /*
    ---------------
    functions
    ---------------
  */

  // allows events that are also triggered to be filtered out for `touchstart`
  function eventBuffer() {
    clearTimer();
    setInput(event);

    buffer = true;
    timer = window.setTimeout(function () {
      buffer = false;
    }, 650);
  }

  function bufferedEvent(event) {
    if (!buffer) setInput(event);
  }

  function unBufferedEvent(event) {
    clearTimer();
    setInput(event);
  }

  function clearTimer() {
    window.clearTimeout(timer);
  }

  function setInput(event) {
    var eventKey = key(event);
    var value = inputMap[event.type];
    if (value === 'pointer') value = pointerType(event);

    // don't do anything if the value matches the input type already set
    if (currentInput !== value) {
      var eventTarget = target(event);
      var eventTargetNode = eventTarget.nodeName.toLowerCase();
      var eventTargetType = eventTargetNode === 'input' ? eventTarget.getAttribute('type') : null;

      if ( // only if the user flag to allow typing in form fields isn't set
      !body.hasAttribute('data-whatinput-formtyping') &&

      // only if currentInput has a value
      currentInput &&

      // only if the input is `keyboard`
      value === 'keyboard' &&

      // not if the key is `TAB`
      keyMap[eventKey] !== 'tab' && (

      // only if the target is a form input that accepts text
      eventTargetNode === 'textarea' || eventTargetNode === 'select' || eventTargetNode === 'input' && nonTypingInputs.indexOf(eventTargetType) < 0) ||
      // ignore modifier keys
      ignoreMap.indexOf(eventKey) > -1) {
        // ignore keyboard typing
      } else {
        switchInput(value);
      }
    }

    if (value === 'keyboard') logKeys(eventKey);
  }

  function switchInput(string) {
    currentInput = string;
    body.setAttribute('data-whatinput', currentInput);

    if (inputTypes.indexOf(currentInput) === -1) inputTypes.push(currentInput);
  }

  function key(event) {
    return event.keyCode ? event.keyCode : event.which;
  }

  function target(event) {
    return event.target || event.srcElement;
  }

  function pointerType(event) {
    if (typeof event.pointerType === 'number') {
      return pointerMap[event.pointerType];
    } else {
      return event.pointerType === 'pen' ? 'touch' : event.pointerType; // treat pen like touch
    }
  }

  // keyboard logging
  function logKeys(eventKey) {
    if (activeKeys.indexOf(keyMap[eventKey]) === -1 && keyMap[eventKey]) activeKeys.push(keyMap[eventKey]);
  }

  function unLogKeys(event) {
    var eventKey = key(event);
    var arrayPos = activeKeys.indexOf(keyMap[eventKey]);

    if (arrayPos !== -1) activeKeys.splice(arrayPos, 1);
  }

  function bindEvents() {
    body = document.body;

    // pointer events (mouse, pen, touch)
    if (window.PointerEvent) {
      body.addEventListener('pointerdown', bufferedEvent);
      body.addEventListener('pointermove', bufferedEvent);
    } else if (window.MSPointerEvent) {
      body.addEventListener('MSPointerDown', bufferedEvent);
      body.addEventListener('MSPointerMove', bufferedEvent);
    } else {

      // mouse events
      body.addEventListener('mousedown', bufferedEvent);
      body.addEventListener('mousemove', bufferedEvent);

      // touch events
      if ('ontouchstart' in window) {
        body.addEventListener('touchstart', eventBuffer);
      }
    }

    // mouse wheel
    body.addEventListener(mouseWheel, bufferedEvent);

    // keyboard events
    body.addEventListener('keydown', unBufferedEvent);
    body.addEventListener('keyup', unBufferedEvent);
    document.addEventListener('keyup', unLogKeys);
  }

  /*
    ---------------
    utilities
    ---------------
  */

  // detect version of mouse wheel event to use
  // via https://developer.mozilla.org/en-US/docs/Web/Events/wheel
  function detectWheel() {
    return mouseWheel = 'onwheel' in document.createElement('div') ? 'wheel' : // Modern browsers support "wheel"

    document.onmousewheel !== undefined ? 'mousewheel' : // Webkit and IE support at least "mousewheel"
    'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox
  }

  /*
    ---------------
    init
     don't start script unless browser cuts the mustard,
    also passes if polyfills are used
    ---------------
  */

  if ('addEventListener' in window && Array.prototype.indexOf) {

    // if the dom is already ready already (script was placed at bottom of <body>)
    if (document.body) {
      bindEvents();

      // otherwise wait for the dom to load (script was placed in the <head>)
    } else {
      document.addEventListener('DOMContentLoaded', bindEvents);
    }
  }

  /*
    ---------------
    api
    ---------------
  */

  return {

    // returns string: the current input type
    ask: function () {
      return currentInput;
    },

    // returns array: currently pressed keys
    keys: function () {
      return activeKeys;
    },

    // returns array: all the detected input types
    types: function () {
      return inputTypes;
    },

    // accepts string: manually set the input type
    set: switchInput
  };
}();
;'use strict';

!function ($) {

  "use strict";

  var FOUNDATION_VERSION = '6.2.2';

  // Global Foundation object
  // This is attached to the window, or used as a module for AMD/Browserify
  var Foundation = {
    version: FOUNDATION_VERSION,

    /**
     * Stores initialized plugins.
     */
    _plugins: {},

    /**
     * Stores generated unique ids for plugin instances
     */
    _uuids: [],

    /**
     * Returns a boolean for RTL support
     */
    rtl: function () {
      return $('html').attr('dir') === 'rtl';
    },
    /**
     * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.
     * @param {Object} plugin - The constructor of the plugin.
     */
    plugin: function (plugin, name) {
      // Object key to use when adding to global Foundation object
      // Examples: Foundation.Reveal, Foundation.OffCanvas
      var className = name || functionName(plugin);
      // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin
      // Examples: data-reveal, data-off-canvas
      var attrName = hyphenate(className);

      // Add to the Foundation object and the plugins list (for reflowing)
      this._plugins[attrName] = this[className] = plugin;
    },
    /**
     * @function
     * Populates the _uuids array with pointers to each individual plugin instance.
     * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.
     * Also fires the initialization event for each plugin, consolidating repetitive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @param {String} name - the name of the plugin, passed as a camelCased string.
     * @fires Plugin#init
     */
    registerPlugin: function (plugin, name) {
      var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();
      plugin.uuid = this.GetYoDigits(6, pluginName);

      if (!plugin.$element.attr('data-' + pluginName)) {
        plugin.$element.attr('data-' + pluginName, plugin.uuid);
      }
      if (!plugin.$element.data('zfPlugin')) {
        plugin.$element.data('zfPlugin', plugin);
      }
      /**
       * Fires when the plugin has initialized.
       * @event Plugin#init
       */
      plugin.$element.trigger('init.zf.' + pluginName);

      this._uuids.push(plugin.uuid);

      return;
    },
    /**
     * @function
     * Removes the plugins uuid from the _uuids array.
     * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.
     * Also fires the destroyed event for the plugin, consolidating repetitive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @fires Plugin#destroyed
     */
    unregisterPlugin: function (plugin) {
      var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));

      this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);
      plugin.$element.removeAttr('data-' + pluginName).removeData('zfPlugin')
      /**
       * Fires when the plugin has been destroyed.
       * @event Plugin#destroyed
       */
      .trigger('destroyed.zf.' + pluginName);
      for (var prop in plugin) {
        plugin[prop] = null; //clean up script to prep for garbage collection.
      }
      return;
    },

    /**
     * @function
     * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.
     * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`
     * @default If no argument is passed, reflow all currently active plugins.
     */
    reInit: function (plugins) {
      var isJQ = plugins instanceof $;
      try {
        if (isJQ) {
          plugins.each(function () {
            $(this).data('zfPlugin')._init();
          });
        } else {
          var type = typeof plugins,
              _this = this,
              fns = {
            'object': function (plgs) {
              plgs.forEach(function (p) {
                p = hyphenate(p);
                $('[data-' + p + ']').foundation('_init');
              });
            },
            'string': function () {
              plugins = hyphenate(plugins);
              $('[data-' + plugins + ']').foundation('_init');
            },
            'undefined': function () {
              this['object'](Object.keys(_this._plugins));
            }
          };
          fns[type](plugins);
        }
      } catch (err) {
        console.error(err);
      } finally {
        return plugins;
      }
    },

    /**
     * returns a random base-36 uid with namespacing
     * @function
     * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.
     * @param {String} namespace - name of plugin to be incorporated in uid, optional.
     * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.
     * @returns {String} - unique id
     */
    GetYoDigits: function (length, namespace) {
      length = length || 6;
      return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? '-' + namespace : '');
    },
    /**
     * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.
     * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.
     * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.
     */
    reflow: function (elem, plugins) {

      // If plugins is undefined, just grab everything
      if (typeof plugins === 'undefined') {
        plugins = Object.keys(this._plugins);
      }
      // If plugins is a string, convert it to an array with one item
      else if (typeof plugins === 'string') {
          plugins = [plugins];
        }

      var _this = this;

      // Iterate through each plugin
      $.each(plugins, function (i, name) {
        // Get the current plugin
        var plugin = _this._plugins[name];

        // Localize the search to all elements inside elem, as well as elem itself, unless elem === document
        var $elem = $(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');

        // For each plugin found, initialize it
        $elem.each(function () {
          var $el = $(this),
              opts = {};
          // Don't double-dip on plugins
          if ($el.data('zfPlugin')) {
            console.warn("Tried to initialize " + name + " on an element that already has a Foundation plugin.");
            return;
          }

          if ($el.attr('data-options')) {
            var thing = $el.attr('data-options').split(';').forEach(function (e, i) {
              var opt = e.split(':').map(function (el) {
                return el.trim();
              });
              if (opt[0]) opts[opt[0]] = parseValue(opt[1]);
            });
          }
          try {
            $el.data('zfPlugin', new plugin($(this), opts));
          } catch (er) {
            console.error(er);
          } finally {
            return;
          }
        });
      });
    },
    getFnName: functionName,
    transitionend: function ($elem) {
      var transitions = {
        'transition': 'transitionend',
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'otransitionend'
      };
      var elem = document.createElement('div'),
          end;

      for (var t in transitions) {
        if (typeof elem.style[t] !== 'undefined') {
          end = transitions[t];
        }
      }
      if (end) {
        return end;
      } else {
        end = setTimeout(function () {
          $elem.triggerHandler('transitionend', [$elem]);
        }, 1);
        return 'transitionend';
      }
    }
  };

  Foundation.util = {
    /**
     * Function for applying a debounce effect to a function call.
     * @function
     * @param {Function} func - Function to be called at end of timeout.
     * @param {Number} delay - Time in ms to delay the call of `func`.
     * @returns function
     */
    throttle: function (func, delay) {
      var timer = null;

      return function () {
        var context = this,
            args = arguments;

        if (timer === null) {
          timer = setTimeout(function () {
            func.apply(context, args);
            timer = null;
          }, delay);
        }
      };
    }
  };

  // TODO: consider not making this a jQuery function
  // TODO: need way to reflow vs. re-initialize
  /**
   * The Foundation jQuery method.
   * @param {String|Array} method - An action to perform on the current jQuery object.
   */
  var foundation = function (method) {
    var type = typeof method,
        $meta = $('meta.foundation-mq'),
        $noJS = $('.no-js');

    if (!$meta.length) {
      $('<meta class="foundation-mq">').appendTo(document.head);
    }
    if ($noJS.length) {
      $noJS.removeClass('no-js');
    }

    if (type === 'undefined') {
      //needs to initialize the Foundation object, or an individual plugin.
      Foundation.MediaQuery._init();
      Foundation.reflow(this);
    } else if (type === 'string') {
      //an individual method to invoke on a plugin or group of plugins
      var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary
      var plugClass = this.data('zfPlugin'); //determine the class of plugin

      if (plugClass !== undefined && plugClass[method] !== undefined) {
        //make sure both the class and method exist
        if (this.length === 1) {
          //if there's only one, call it directly.
          plugClass[method].apply(plugClass, args);
        } else {
          this.each(function (i, el) {
            //otherwise loop through the jQuery collection and invoke the method on each
            plugClass[method].apply($(el).data('zfPlugin'), args);
          });
        }
      } else {
        //error for no class or no method
        throw new ReferenceError("We're sorry, '" + method + "' is not an available method for " + (plugClass ? functionName(plugClass) : 'this element') + '.');
      }
    } else {
      //error for invalid argument type
      throw new TypeError('We\'re sorry, ' + type + ' is not a valid parameter. You must use a string representing the method you wish to invoke.');
    }
    return this;
  };

  window.Foundation = Foundation;
  $.fn.foundation = foundation;

  // Polyfill for requestAnimationFrame
  (function () {
    if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {
      return new Date().getTime();
    };

    var vendors = ['webkit', 'moz'];
    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
      var vp = vendors[i];
      window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
      var lastTime = 0;
      window.requestAnimationFrame = function (callback) {
        var now = Date.now();
        var nextTime = Math.max(lastTime + 16, now);
        return setTimeout(function () {
          callback(lastTime = nextTime);
        }, nextTime - now);
      };
      window.cancelAnimationFrame = clearTimeout;
    }
    /**
     * Polyfill for performance.now, required by rAF
     */
    if (!window.performance || !window.performance.now) {
      window.performance = {
        start: Date.now(),
        now: function () {
          return Date.now() - this.start;
        }
      };
    }
  })();
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
      if (typeof this !== 'function') {
        // closest thing possible to the ECMAScript 5
        // internal IsCallable function
        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
      }

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
      };

      if (this.prototype) {
        // native functions don't have a prototype
        fNOP.prototype = this.prototype;
      }
      fBound.prototype = new fNOP();

      return fBound;
    };
  }
  // Polyfill to get the name of a function in IE9
  function functionName(fn) {
    if (Function.prototype.name === undefined) {
      var funcNameRegex = /function\s([^(]{1,})\(/;
      var results = funcNameRegex.exec(fn.toString());
      return results && results.length > 1 ? results[1].trim() : "";
    } else if (fn.prototype === undefined) {
      return fn.constructor.name;
    } else {
      return fn.prototype.constructor.name;
    }
  }
  function parseValue(str) {
    if (/true/.test(str)) return true;else if (/false/.test(str)) return false;else if (!isNaN(str * 1)) return parseFloat(str);
    return str;
  }
  // Convert PascalCase to kebab-case
  // Thank you: http://stackoverflow.com/a/8955580
  function hyphenate(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }
}(jQuery);
;'use strict';

!function ($) {

  Foundation.Box = {
    ImNotTouchingYou: ImNotTouchingYou,
    GetDimensions: GetDimensions,
    GetOffsets: GetOffsets
  };

  /**
   * Compares the dimensions of an element to a container and determines collision events with container.
   * @function
   * @param {jQuery} element - jQuery object to test for collisions.
   * @param {jQuery} parent - jQuery object to use as bounding container.
   * @param {Boolean} lrOnly - set to true to check left and right values only.
   * @param {Boolean} tbOnly - set to true to check top and bottom values only.
   * @default if no parent object passed, detects collisions with `window`.
   * @returns {Boolean} - true if collision free, false if a collision in any direction.
   */
  function ImNotTouchingYou(element, parent, lrOnly, tbOnly) {
    var eleDims = GetDimensions(element),
        top,
        bottom,
        left,
        right;

    if (parent) {
      var parDims = GetDimensions(parent);

      bottom = eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top;
      top = eleDims.offset.top >= parDims.offset.top;
      left = eleDims.offset.left >= parDims.offset.left;
      right = eleDims.offset.left + eleDims.width <= parDims.width + parDims.offset.left;
    } else {
      bottom = eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top;
      top = eleDims.offset.top >= eleDims.windowDims.offset.top;
      left = eleDims.offset.left >= eleDims.windowDims.offset.left;
      right = eleDims.offset.left + eleDims.width <= eleDims.windowDims.width;
    }

    var allDirs = [bottom, top, left, right];

    if (lrOnly) {
      return left === right === true;
    }

    if (tbOnly) {
      return top === bottom === true;
    }

    return allDirs.indexOf(false) === -1;
  };

  /**
   * Uses native methods to return an object of dimension values.
   * @function
   * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.
   * @returns {Object} - nested object of integer pixel values
   * TODO - if element is window, return only those values.
   */
  function GetDimensions(elem, test) {
    elem = elem.length ? elem[0] : elem;

    if (elem === window || elem === document) {
      throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");
    }

    var rect = elem.getBoundingClientRect(),
        parRect = elem.parentNode.getBoundingClientRect(),
        winRect = document.body.getBoundingClientRect(),
        winY = window.pageYOffset,
        winX = window.pageXOffset;

    return {
      width: rect.width,
      height: rect.height,
      offset: {
        top: rect.top + winY,
        left: rect.left + winX
      },
      parentDims: {
        width: parRect.width,
        height: parRect.height,
        offset: {
          top: parRect.top + winY,
          left: parRect.left + winX
        }
      },
      windowDims: {
        width: winRect.width,
        height: winRect.height,
        offset: {
          top: winY,
          left: winX
        }
      }
    };
  }

  /**
   * Returns an object of top and left integer pixel values for dynamically rendered elements,
   * such as: Tooltip, Reveal, and Dropdown
   * @function
   * @param {jQuery} element - jQuery object for the element being positioned.
   * @param {jQuery} anchor - jQuery object for the element's anchor point.
   * @param {String} position - a string relating to the desired position of the element, relative to it's anchor
   * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.
   * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.
   * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.
   * TODO alter/rewrite to work with `em` values as well/instead of pixels
   */
  function GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {
    var $eleDims = GetDimensions(element),
        $anchorDims = anchor ? GetDimensions(anchor) : null;

    switch (position) {
      case 'top':
        return {
          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top
        };
        break;
      case 'right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset,
          top: $anchorDims.offset.top
        };
        break;
      case 'center top':
        return {
          left: $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'center bottom':
        return {
          left: isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
        break;
      case 'center left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'center right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,
          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'center':
        return {
          left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2,
          top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'reveal':
        return {
          left: ($eleDims.windowDims.width - $eleDims.width) / 2,
          top: $eleDims.windowDims.offset.top + vOffset
        };
      case 'reveal full':
        return {
          left: $eleDims.windowDims.offset.left,
          top: $eleDims.windowDims.offset.top
        };
        break;
      case 'left bottom':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top + $anchorDims.height
        };
        break;
      case 'right bottom':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset - $eleDims.width,
          top: $anchorDims.offset.top + $anchorDims.height
        };
        break;
      default:
        return {
          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
    }
  }
}(jQuery);
;/*******************************************
 *                                         *
 * This util was created by Marius Olbertz *
 * Please thank Marius on GitHub /owlbertz *
 * or the web http://www.mariusolbertz.de/ *
 *                                         *
 ******************************************/

'use strict';

!function ($) {

  var keyCodes = {
    9: 'TAB',
    13: 'ENTER',
    27: 'ESCAPE',
    32: 'SPACE',
    37: 'ARROW_LEFT',
    38: 'ARROW_UP',
    39: 'ARROW_RIGHT',
    40: 'ARROW_DOWN'
  };

  var commands = {};

  var Keyboard = {
    keys: getKeyCodes(keyCodes),

    /**
     * Parses the (keyboard) event and returns a String that represents its key
     * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
     * @param {Event} event - the event generated by the event handler
     * @return String key - String that represents the key pressed
     */
    parseKey: function (event) {
      var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();
      if (event.shiftKey) key = 'SHIFT_' + key;
      if (event.ctrlKey) key = 'CTRL_' + key;
      if (event.altKey) key = 'ALT_' + key;
      return key;
    },


    /**
     * Handles the given (keyboard) event
     * @param {Event} event - the event generated by the event handler
     * @param {String} component - Foundation component's name, e.g. Slider or Reveal
     * @param {Objects} functions - collection of functions that are to be executed
     */
    handleKey: function (event, component, functions) {
      var commandList = commands[component],
          keyCode = this.parseKey(event),
          cmds,
          command,
          fn;

      if (!commandList) return console.warn('Component not defined!');

      if (typeof commandList.ltr === 'undefined') {
        // this component does not differentiate between ltr and rtl
        cmds = commandList; // use plain list
      } else {
        // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa
        if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);else cmds = $.extend({}, commandList.rtl, commandList.ltr);
      }
      command = cmds[keyCode];

      fn = functions[command];
      if (fn && typeof fn === 'function') {
        // execute function  if exists
        var returnValue = fn.apply();
        if (functions.handled || typeof functions.handled === 'function') {
          // execute function when event was handled
          functions.handled(returnValue);
        }
      } else {
        if (functions.unhandled || typeof functions.unhandled === 'function') {
          // execute function when event was not handled
          functions.unhandled();
        }
      }
    },


    /**
     * Finds all focusable elements within the given `$element`
     * @param {jQuery} $element - jQuery object to search within
     * @return {jQuery} $focusable - all focusable elements within `$element`
     */
    findFocusable: function ($element) {
      return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {
        if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) {
          return false;
        } //only have visible elements and those that have a tabindex greater or equal 0
        return true;
      });
    },


    /**
     * Returns the component name name
     * @param {Object} component - Foundation component, e.g. Slider or Reveal
     * @return String componentName
     */

    register: function (componentName, cmds) {
      commands[componentName] = cmds;
    }
  };

  /*
   * Constants for easier comparing.
   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
   */
  function getKeyCodes(kcs) {
    var k = {};
    for (var kc in kcs) {
      k[kcs[kc]] = kcs[kc];
    }return k;
  }

  Foundation.Keyboard = Keyboard;
}(jQuery);
;'use strict';

!function ($) {

  // Default set of media queries
  var defaultQueries = {
    'default': 'only screen',
    landscape: 'only screen and (orientation: landscape)',
    portrait: 'only screen and (orientation: portrait)',
    retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'
  };

  var MediaQuery = {
    queries: [],

    current: '',

    /**
     * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.
     * @function
     * @private
     */
    _init: function () {
      var self = this;
      var extractedStyles = $('.foundation-mq').css('font-family');
      var namedQueries;

      namedQueries = parseStyleToObject(extractedStyles);

      for (var key in namedQueries) {
        if (namedQueries.hasOwnProperty(key)) {
          self.queries.push({
            name: key,
            value: 'only screen and (min-width: ' + namedQueries[key] + ')'
          });
        }
      }

      this.current = this._getCurrentSize();

      this._watcher();
    },


    /**
     * Checks if the screen is at least as wide as a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to check.
     * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.
     */
    atLeast: function (size) {
      var query = this.get(size);

      if (query) {
        return window.matchMedia(query).matches;
      }

      return false;
    },


    /**
     * Gets the media query of a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to get.
     * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.
     */
    get: function (size) {
      for (var i in this.queries) {
        if (this.queries.hasOwnProperty(i)) {
          var query = this.queries[i];
          if (size === query.name) return query.value;
        }
      }

      return null;
    },


    /**
     * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).
     * @function
     * @private
     * @returns {String} Name of the current breakpoint.
     */
    _getCurrentSize: function () {
      var matched;

      for (var i = 0; i < this.queries.length; i++) {
        var query = this.queries[i];

        if (window.matchMedia(query.value).matches) {
          matched = query;
        }
      }

      if (typeof matched === 'object') {
        return matched.name;
      } else {
        return matched;
      }
    },


    /**
     * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.
     * @function
     * @private
     */
    _watcher: function () {
      var _this = this;

      $(window).on('resize.zf.mediaquery', function () {
        var newSize = _this._getCurrentSize(),
            currentSize = _this.current;

        if (newSize !== currentSize) {
          // Change the current media query
          _this.current = newSize;

          // Broadcast the media query change on the window
          $(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);
        }
      });
    }
  };

  Foundation.MediaQuery = MediaQuery;

  // matchMedia() polyfill - Test a CSS media type/query in JS.
  // Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license
  window.matchMedia || (window.matchMedia = function () {
    'use strict';

    // For browsers that support matchMedium api such as IE 9 and webkit

    var styleMedia = window.styleMedia || window.media;

    // For those that don't support matchMedium
    if (!styleMedia) {
      var style = document.createElement('style'),
          script = document.getElementsByTagName('script')[0],
          info = null;

      style.type = 'text/css';
      style.id = 'matchmediajs-test';

      script.parentNode.insertBefore(style, script);

      // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
      info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;

      styleMedia = {
        matchMedium: function (media) {
          var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

          // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
          if (style.styleSheet) {
            style.styleSheet.cssText = text;
          } else {
            style.textContent = text;
          }

          // Test if media query is true or false
          return info.width === '1px';
        }
      };
    }

    return function (media) {
      return {
        matches: styleMedia.matchMedium(media || 'all'),
        media: media || 'all'
      };
    };
  }());

  // Thank you: https://github.com/sindresorhus/query-string
  function parseStyleToObject(str) {
    var styleObject = {};

    if (typeof str !== 'string') {
      return styleObject;
    }

    str = str.trim().slice(1, -1); // browsers re-quote string style values

    if (!str) {
      return styleObject;
    }

    styleObject = str.split('&').reduce(function (ret, param) {
      var parts = param.replace(/\+/g, ' ').split('=');
      var key = parts[0];
      var val = parts[1];
      key = decodeURIComponent(key);

      // missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
      val = val === undefined ? null : decodeURIComponent(val);

      if (!ret.hasOwnProperty(key)) {
        ret[key] = val;
      } else if (Array.isArray(ret[key])) {
        ret[key].push(val);
      } else {
        ret[key] = [ret[key], val];
      }
      return ret;
    }, {});

    return styleObject;
  }

  Foundation.MediaQuery = MediaQuery;
}(jQuery);
;'use strict';

!function ($) {

  /**
   * Motion module.
   * @module foundation.motion
   */

  var initClasses = ['mui-enter', 'mui-leave'];
  var activeClasses = ['mui-enter-active', 'mui-leave-active'];

  var Motion = {
    animateIn: function (element, animation, cb) {
      animate(true, element, animation, cb);
    },

    animateOut: function (element, animation, cb) {
      animate(false, element, animation, cb);
    }
  };

  function Move(duration, elem, fn) {
    var anim,
        prog,
        start = null;
    // console.log('called');

    function move(ts) {
      if (!start) start = window.performance.now();
      // console.log(start, ts);
      prog = ts - start;
      fn.apply(elem);

      if (prog < duration) {
        anim = window.requestAnimationFrame(move, elem);
      } else {
        window.cancelAnimationFrame(anim);
        elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
      }
    }
    anim = window.requestAnimationFrame(move);
  }

  /**
   * Animates an element in or out using a CSS transition class.
   * @function
   * @private
   * @param {Boolean} isIn - Defines if the animation is in or out.
   * @param {Object} element - jQuery or HTML object to animate.
   * @param {String} animation - CSS class to use.
   * @param {Function} cb - Callback to run when animation is finished.
   */
  function animate(isIn, element, animation, cb) {
    element = $(element).eq(0);

    if (!element.length) return;

    var initClass = isIn ? initClasses[0] : initClasses[1];
    var activeClass = isIn ? activeClasses[0] : activeClasses[1];

    // Set up the animation
    reset();

    element.addClass(animation).css('transition', 'none');

    requestAnimationFrame(function () {
      element.addClass(initClass);
      if (isIn) element.show();
    });

    // Start the animation
    requestAnimationFrame(function () {
      element[0].offsetWidth;
      element.css('transition', '').addClass(activeClass);
    });

    // Clean up the animation when it finishes
    element.one(Foundation.transitionend(element), finish);

    // Hides the element (for out animations), resets the element, and runs a callback
    function finish() {
      if (!isIn) element.hide();
      reset();
      if (cb) cb.apply(element);
    }

    // Resets transitions and removes motion-specific classes
    function reset() {
      element[0].style.transitionDuration = 0;
      element.removeClass(initClass + ' ' + activeClass + ' ' + animation);
    }
  }

  Foundation.Move = Move;
  Foundation.Motion = Motion;
}(jQuery);
;'use strict';

!function ($) {

  var Nest = {
    Feather: function (menu) {
      var type = arguments.length <= 1 || arguments[1] === undefined ? 'zf' : arguments[1];

      menu.attr('role', 'menubar');

      var items = menu.find('li').attr({ 'role': 'menuitem' }),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      menu.find('a:first').attr('tabindex', 0);

      items.each(function () {
        var $item = $(this),
            $sub = $item.children('ul');

        if ($sub.length) {
          $item.addClass(hasSubClass).attr({
            'aria-haspopup': true,
            'aria-expanded': false,
            'aria-label': $item.children('a:first').text()
          });

          $sub.addClass('submenu ' + subMenuClass).attr({
            'data-submenu': '',
            'aria-hidden': true,
            'role': 'menu'
          });
        }

        if ($item.parent('[data-submenu]').length) {
          $item.addClass('is-submenu-item ' + subItemClass);
        }
      });

      return;
    },
    Burn: function (menu, type) {
      var items = menu.find('li').removeAttr('tabindex'),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      menu.find('*').removeClass(subMenuClass + ' ' + subItemClass + ' ' + hasSubClass + ' is-submenu-item submenu is-active').removeAttr('data-submenu').css('display', '');

      // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')
      //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')
      //           .removeAttr('data-submenu'));
      // items.each(function(){
      //   var $item = $(this),
      //       $sub = $item.children('ul');
      //   if($item.parent('[data-submenu]').length){
      //     $item.removeClass('is-submenu-item ' + subItemClass);
      //   }
      //   if($sub.length){
      //     $item.removeClass('has-submenu');
      //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');
      //   }
      // });
    }
  };

  Foundation.Nest = Nest;
}(jQuery);
;'use strict';

!function ($) {

  function Timer(elem, options, cb) {
    var _this = this,
        duration = options.duration,
        //options is an object for easily adding features later.
    nameSpace = Object.keys(elem.data())[0] || 'timer',
        remain = -1,
        start,
        timer;

    this.isPaused = false;

    this.restart = function () {
      remain = -1;
      clearTimeout(timer);
      this.start();
    };

    this.start = function () {
      this.isPaused = false;
      // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      remain = remain <= 0 ? duration : remain;
      elem.data('paused', false);
      start = Date.now();
      timer = setTimeout(function () {
        if (options.infinite) {
          _this.restart(); //rerun the timer.
        }
        cb();
      }, remain);
      elem.trigger('timerstart.zf.' + nameSpace);
    };

    this.pause = function () {
      this.isPaused = true;
      //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      elem.data('paused', true);
      var end = Date.now();
      remain = remain - (end - start);
      elem.trigger('timerpaused.zf.' + nameSpace);
    };
  }

  /**
   * Runs a callback function when images are fully loaded.
   * @param {Object} images - Image(s) to check if loaded.
   * @param {Func} callback - Function to execute when image is fully loaded.
   */
  function onImagesLoaded(images, callback) {
    var self = this,
        unloaded = images.length;

    if (unloaded === 0) {
      callback();
    }

    images.each(function () {
      if (this.complete) {
        singleImageLoaded();
      } else if (typeof this.naturalWidth !== 'undefined' && this.naturalWidth > 0) {
        singleImageLoaded();
      } else {
        $(this).one('load', function () {
          singleImageLoaded();
        });
      }
    });

    function singleImageLoaded() {
      unloaded--;
      if (unloaded === 0) {
        callback();
      }
    }
  }

  Foundation.Timer = Timer;
  Foundation.onImagesLoaded = onImagesLoaded;
}(jQuery);
;'use strict';

//**************************************************
//**Work inspired by multiple jquery swipe plugins**
//**Done by Yohai Ararat ***************************
//**************************************************
(function ($) {

	$.spotSwipe = {
		version: '1.0.0',
		enabled: 'ontouchstart' in document.documentElement,
		preventDefault: false,
		moveThreshold: 75,
		timeThreshold: 200
	};

	var startPosX,
	    startPosY,
	    startTime,
	    elapsedTime,
	    isMoving = false;

	function onTouchEnd() {
		//  alert(this);
		this.removeEventListener('touchmove', onTouchMove);
		this.removeEventListener('touchend', onTouchEnd);
		isMoving = false;
	}

	function onTouchMove(e) {
		if ($.spotSwipe.preventDefault) {
			e.preventDefault();
		}
		if (isMoving) {
			var x = e.touches[0].pageX;
			var y = e.touches[0].pageY;
			var dx = startPosX - x;
			var dy = startPosY - y;
			var dir;
			elapsedTime = new Date().getTime() - startTime;
			if (Math.abs(dx) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
				dir = dx > 0 ? 'left' : 'right';
			}
			// else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
			//   dir = dy > 0 ? 'down' : 'up';
			// }
			if (dir) {
				e.preventDefault();
				onTouchEnd.call(this);
				$(this).trigger('swipe', dir).trigger('swipe' + dir);
			}
		}
	}

	function onTouchStart(e) {
		if (e.touches.length == 1) {
			startPosX = e.touches[0].pageX;
			startPosY = e.touches[0].pageY;
			isMoving = true;
			startTime = new Date().getTime();
			this.addEventListener('touchmove', onTouchMove, false);
			this.addEventListener('touchend', onTouchEnd, false);
		}
	}

	function init() {
		this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);
	}

	function teardown() {
		this.removeEventListener('touchstart', onTouchStart);
	}

	$.event.special.swipe = { setup: init };

	$.each(['left', 'up', 'down', 'right'], function () {
		$.event.special['swipe' + this] = { setup: function () {
				$(this).on('swipe', $.noop);
			} };
	});
})(jQuery);
/****************************************************
 * Method for adding psuedo drag events to elements *
 ***************************************************/
!function ($) {
	$.fn.addTouch = function () {
		this.each(function (i, el) {
			$(el).bind('touchstart touchmove touchend touchcancel', function () {
				//we pass the original event object because the jQuery event
				//object is normalized to w3c specs and does not provide the TouchList
				handleTouch(event);
			});
		});

		var handleTouch = function (event) {
			var touches = event.changedTouches,
			    first = touches[0],
			    eventTypes = {
				touchstart: 'mousedown',
				touchmove: 'mousemove',
				touchend: 'mouseup'
			},
			    type = eventTypes[event.type],
			    simulatedEvent;

			if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {
				simulatedEvent = new window.MouseEvent(type, {
					'bubbles': true,
					'cancelable': true,
					'screenX': first.screenX,
					'screenY': first.screenY,
					'clientX': first.clientX,
					'clientY': first.clientY
				});
			} else {
				simulatedEvent = document.createEvent('MouseEvent');
				simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0 /*left*/, null);
			}
			first.target.dispatchEvent(simulatedEvent);
		};
	};
}(jQuery);

//**********************************
//**From the jQuery Mobile Library**
//**need to recreate functionality**
//**and try to improve if possible**
//**********************************

/* Removing the jQuery function ****
************************************

(function( $, window, undefined ) {

	var $document = $( document ),
		// supportTouch = $.mobile.support.touch,
		touchStartEvent = 'touchstart'//supportTouch ? "touchstart" : "mousedown",
		touchStopEvent = 'touchend'//supportTouch ? "touchend" : "mouseup",
		touchMoveEvent = 'touchmove'//supportTouch ? "touchmove" : "mousemove";

	// setup new event shortcuts
	$.each( ( "touchstart touchmove touchend " +
		"swipe swipeleft swiperight" ).split( " " ), function( i, name ) {

		$.fn[ name ] = function( fn ) {
			return fn ? this.bind( name, fn ) : this.trigger( name );
		};

		// jQuery < 1.8
		if ( $.attrFn ) {
			$.attrFn[ name ] = true;
		}
	});

	function triggerCustomEvent( obj, eventType, event, bubble ) {
		var originalType = event.type;
		event.type = eventType;
		if ( bubble ) {
			$.event.trigger( event, undefined, obj );
		} else {
			$.event.dispatch.call( obj, event );
		}
		event.type = originalType;
	}

	// also handles taphold

	// Also handles swipeleft, swiperight
	$.event.special.swipe = {

		// More than this horizontal displacement, and we will suppress scrolling.
		scrollSupressionThreshold: 30,

		// More time than this, and it isn't a swipe.
		durationThreshold: 1000,

		// Swipe horizontal displacement must be more than this.
		horizontalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		// Swipe vertical displacement must be less than this.
		verticalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		getLocation: function ( event ) {
			var winPageX = window.pageXOffset,
				winPageY = window.pageYOffset,
				x = event.clientX,
				y = event.clientY;

			if ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||
				event.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {

				// iOS4 clientX/clientY have the value that should have been
				// in pageX/pageY. While pageX/page/ have the value 0
				x = x - winPageX;
				y = y - winPageY;
			} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {

				// Some Android browsers have totally bogus values for clientX/Y
				// when scrolling/zooming a page. Detectable since clientX/clientY
				// should never be smaller than pageX/pageY minus page scroll
				x = event.pageX - winPageX;
				y = event.pageY - winPageY;
			}

			return {
				x: x,
				y: y
			};
		},

		start: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ],
						origin: $( event.target )
					};
		},

		stop: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ]
					};
		},

		handleSwipe: function( start, stop, thisObject, origTarget ) {
			if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
				Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
				Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {
				var direction = start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight";

				triggerCustomEvent( thisObject, "swipe", $.Event( "swipe", { target: origTarget, swipestart: start, swipestop: stop }), true );
				triggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );
				return true;
			}
			return false;

		},

		// This serves as a flag to ensure that at most one swipe event event is
		// in work at any given time
		eventInProgress: false,

		setup: function() {
			var events,
				thisObject = this,
				$this = $( thisObject ),
				context = {};

			// Retrieve the events data for this element and add the swipe context
			events = $.data( this, "mobile-events" );
			if ( !events ) {
				events = { length: 0 };
				$.data( this, "mobile-events", events );
			}
			events.length++;
			events.swipe = context;

			context.start = function( event ) {

				// Bail if we're already working on a swipe event
				if ( $.event.special.swipe.eventInProgress ) {
					return;
				}
				$.event.special.swipe.eventInProgress = true;

				var stop,
					start = $.event.special.swipe.start( event ),
					origTarget = event.target,
					emitted = false;

				context.move = function( event ) {
					if ( !start || event.isDefaultPrevented() ) {
						return;
					}

					stop = $.event.special.swipe.stop( event );
					if ( !emitted ) {
						emitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );
						if ( emitted ) {

							// Reset the context to make way for the next swipe event
							$.event.special.swipe.eventInProgress = false;
						}
					}
					// prevent scrolling
					if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
						event.preventDefault();
					}
				};

				context.stop = function() {
						emitted = true;

						// Reset the context to make way for the next swipe event
						$.event.special.swipe.eventInProgress = false;
						$document.off( touchMoveEvent, context.move );
						context.move = null;
				};

				$document.on( touchMoveEvent, context.move )
					.one( touchStopEvent, context.stop );
			};
			$this.on( touchStartEvent, context.start );
		},

		teardown: function() {
			var events, context;

			events = $.data( this, "mobile-events" );
			if ( events ) {
				context = events.swipe;
				delete events.swipe;
				events.length--;
				if ( events.length === 0 ) {
					$.removeData( this, "mobile-events" );
				}
			}

			if ( context ) {
				if ( context.start ) {
					$( this ).off( touchStartEvent, context.start );
				}
				if ( context.move ) {
					$document.off( touchMoveEvent, context.move );
				}
				if ( context.stop ) {
					$document.off( touchStopEvent, context.stop );
				}
			}
		}
	};
	$.each({
		swipeleft: "swipe.left",
		swiperight: "swipe.right"
	}, function( event, sourceEvent ) {

		$.event.special[ event ] = {
			setup: function() {
				$( this ).bind( sourceEvent, $.noop );
			},
			teardown: function() {
				$( this ).unbind( sourceEvent );
			}
		};
	});
})( jQuery, this );
*/
;'use strict';

!function ($) {

  var MutationObserver = function () {
    var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
    for (var i = 0; i < prefixes.length; i++) {
      if (prefixes[i] + 'MutationObserver' in window) {
        return window[prefixes[i] + 'MutationObserver'];
      }
    }
    return false;
  }();

  var triggers = function (el, type) {
    el.data(type).split(' ').forEach(function (id) {
      $('#' + id)[type === 'close' ? 'trigger' : 'triggerHandler'](type + '.zf.trigger', [el]);
    });
  };
  // Elements with [data-open] will reveal a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-open]', function () {
    triggers($(this), 'open');
  });

  // Elements with [data-close] will close a plugin that supports it when clicked.
  // If used without a value on [data-close], the event will bubble, allowing it to close a parent component.
  $(document).on('click.zf.trigger', '[data-close]', function () {
    var id = $(this).data('close');
    if (id) {
      triggers($(this), 'close');
    } else {
      $(this).trigger('close.zf.trigger');
    }
  });

  // Elements with [data-toggle] will toggle a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-toggle]', function () {
    triggers($(this), 'toggle');
  });

  // Elements with [data-closable] will respond to close.zf.trigger events.
  $(document).on('close.zf.trigger', '[data-closable]', function (e) {
    e.stopPropagation();
    var animation = $(this).data('closable');

    if (animation !== '') {
      Foundation.Motion.animateOut($(this), animation, function () {
        $(this).trigger('closed.zf');
      });
    } else {
      $(this).fadeOut().trigger('closed.zf');
    }
  });

  $(document).on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', function () {
    var id = $(this).data('toggle-focus');
    $('#' + id).triggerHandler('toggle.zf.trigger', [$(this)]);
  });

  /**
  * Fires once after all other scripts have loaded
  * @function
  * @private
  */
  $(window).load(function () {
    checkListeners();
  });

  function checkListeners() {
    eventsListener();
    resizeListener();
    scrollListener();
    closemeListener();
  }

  //******** only fires this function once on load, if there's something to watch ********
  function closemeListener(pluginName) {
    var yetiBoxes = $('[data-yeti-box]'),
        plugNames = ['dropdown', 'tooltip', 'reveal'];

    if (pluginName) {
      if (typeof pluginName === 'string') {
        plugNames.push(pluginName);
      } else if (typeof pluginName === 'object' && typeof pluginName[0] === 'string') {
        plugNames.concat(pluginName);
      } else {
        console.error('Plugin names must be strings');
      }
    }
    if (yetiBoxes.length) {
      var listeners = plugNames.map(function (name) {
        return 'closeme.zf.' + name;
      }).join(' ');

      $(window).off(listeners).on(listeners, function (e, pluginId) {
        var plugin = e.namespace.split('.')[0];
        var plugins = $('[data-' + plugin + ']').not('[data-yeti-box="' + pluginId + '"]');

        plugins.each(function () {
          var _this = $(this);

          _this.triggerHandler('close.zf.trigger', [_this]);
        });
      });
    }
  }

  function resizeListener(debounce) {
    var timer = void 0,
        $nodes = $('[data-resize]');
    if ($nodes.length) {
      $(window).off('resize.zf.trigger').on('resize.zf.trigger', function (e) {
        if (timer) {
          clearTimeout(timer);
        }

        timer = setTimeout(function () {

          if (!MutationObserver) {
            //fallback for IE 9
            $nodes.each(function () {
              $(this).triggerHandler('resizeme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a resize event
          $nodes.attr('data-events', "resize");
        }, debounce || 10); //default time to emit resize event
      });
    }
  }

  function scrollListener(debounce) {
    var timer = void 0,
        $nodes = $('[data-scroll]');
    if ($nodes.length) {
      $(window).off('scroll.zf.trigger').on('scroll.zf.trigger', function (e) {
        if (timer) {
          clearTimeout(timer);
        }

        timer = setTimeout(function () {

          if (!MutationObserver) {
            //fallback for IE 9
            $nodes.each(function () {
              $(this).triggerHandler('scrollme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a scroll event
          $nodes.attr('data-events', "scroll");
        }, debounce || 10); //default time to emit scroll event
      });
    }
  }

  function eventsListener() {
    if (!MutationObserver) {
      return false;
    }
    var nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');

    //element callback
    var listeningElementsMutation = function (mutationRecordsList) {
      var $target = $(mutationRecordsList[0].target);
      //trigger the event handler for the element depending on type
      switch ($target.attr("data-events")) {

        case "resize":
          $target.triggerHandler('resizeme.zf.trigger', [$target]);
          break;

        case "scroll":
          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);
          break;

        // case "mutate" :
        // console.log('mutate', $target);
        // $target.triggerHandler('mutate.zf.trigger');
        //
        // //make sure we don't get stuck in an infinite loop from sloppy codeing
        // if ($target.index('[data-mutate]') == $("[data-mutate]").length-1) {
        //   domMutationObserver();
        // }
        // break;

        default:
          return false;
        //nothing
      }
    };

    if (nodes.length) {
      //for each element that needs to listen for resizing, scrolling, (or coming soon mutation) add a single observer
      for (var i = 0; i <= nodes.length - 1; i++) {
        var elementObserver = new MutationObserver(listeningElementsMutation);
        elementObserver.observe(nodes[i], { attributes: true, childList: false, characterData: false, subtree: false, attributeFilter: ["data-events"] });
      }
    }
  }

  // ------------------------------------

  // [PH]
  // Foundation.CheckWatchers = checkWatchers;
  Foundation.IHearYou = checkListeners;
  // Foundation.ISeeYou = scrollListener;
  // Foundation.IFeelYou = closemeListener;
}(jQuery);

// function domMutationObserver(debounce) {
//   // !!! This is coming soon and needs more work; not active  !!! //
//   var timer,
//   nodes = document.querySelectorAll('[data-mutate]');
//   //
//   if (nodes.length) {
//     // var MutationObserver = (function () {
//     //   var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
//     //   for (var i=0; i < prefixes.length; i++) {
//     //     if (prefixes[i] + 'MutationObserver' in window) {
//     //       return window[prefixes[i] + 'MutationObserver'];
//     //     }
//     //   }
//     //   return false;
//     // }());
//
//
//     //for the body, we need to listen for all changes effecting the style and class attributes
//     var bodyObserver = new MutationObserver(bodyMutation);
//     bodyObserver.observe(document.body, { attributes: true, childList: true, characterData: false, subtree:true, attributeFilter:["style", "class"]});
//
//
//     //body callback
//     function bodyMutation(mutate) {
//       //trigger all listening elements and signal a mutation event
//       if (timer) { clearTimeout(timer); }
//
//       timer = setTimeout(function() {
//         bodyObserver.disconnect();
//         $('[data-mutate]').attr('data-events',"mutate");
//       }, debounce || 150);
//     }
//   }
// }
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Abide module.
   * @module foundation.abide
   */

  var Abide = function () {
    /**
     * Creates a new instance of Abide.
     * @class
     * @fires Abide#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Abide(element) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      _classCallCheck(this, Abide);

      this.$element = element;
      this.options = $.extend({}, Abide.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Abide');
    }

    /**
     * Initializes the Abide plugin and calls functions to get Abide functioning on load.
     * @private
     */


    _createClass(Abide, [{
      key: '_init',
      value: function _init() {
        this.$inputs = this.$element.find('input, textarea, select');

        this._events();
      }

      /**
       * Initializes events for Abide.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this2 = this;

        this.$element.off('.abide').on('reset.zf.abide', function () {
          _this2.resetForm();
        }).on('submit.zf.abide', function () {
          return _this2.validateForm();
        });

        if (this.options.validateOn === 'fieldChange') {
          this.$inputs.off('change.zf.abide').on('change.zf.abide', function (e) {
            _this2.validateInput($(e.target));
          });
        }

        if (this.options.liveValidate) {
          this.$inputs.off('input.zf.abide').on('input.zf.abide', function (e) {
            _this2.validateInput($(e.target));
          });
        }
      }

      /**
       * Calls necessary functions to update Abide upon DOM change
       * @private
       */

    }, {
      key: '_reflow',
      value: function _reflow() {
        this._init();
      }

      /**
       * Checks whether or not a form element has the required attribute and if it's checked or not
       * @param {Object} element - jQuery object to check for required attribute
       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
       */

    }, {
      key: 'requiredCheck',
      value: function requiredCheck($el) {
        if (!$el.attr('required')) return true;

        var isGood = true;

        switch ($el[0].type) {
          case 'checkbox':
            isGood = $el[0].checked;
            break;

          case 'select':
          case 'select-one':
          case 'select-multiple':
            var opt = $el.find('option:selected');
            if (!opt.length || !opt.val()) isGood = false;
            break;

          default:
            if (!$el.val() || !$el.val().length) isGood = false;
        }

        return isGood;
      }

      /**
       * Based on $el, get the first element with selector in this order:
       * 1. The element's direct sibling('s).
       * 3. The element's parent's children.
       *
       * This allows for multiple form errors per input, though if none are found, no form errors will be shown.
       *
       * @param {Object} $el - jQuery object to use as reference to find the form error selector.
       * @returns {Object} jQuery object with the selector.
       */

    }, {
      key: 'findFormError',
      value: function findFormError($el) {
        var $error = $el.siblings(this.options.formErrorSelector);

        if (!$error.length) {
          $error = $el.parent().find(this.options.formErrorSelector);
        }

        return $error;
      }

      /**
       * Get the first element in this order:
       * 2. The <label> with the attribute `[for="someInputId"]`
       * 3. The `.closest()` <label>
       *
       * @param {Object} $el - jQuery object to check for required attribute
       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
       */

    }, {
      key: 'findLabel',
      value: function findLabel($el) {
        var id = $el[0].id;
        var $label = this.$element.find('label[for="' + id + '"]');

        if (!$label.length) {
          return $el.closest('label');
        }

        return $label;
      }

      /**
       * Get the set of labels associated with a set of radio els in this order
       * 2. The <label> with the attribute `[for="someInputId"]`
       * 3. The `.closest()` <label>
       *
       * @param {Object} $el - jQuery object to check for required attribute
       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
       */

    }, {
      key: 'findRadioLabels',
      value: function findRadioLabels($els) {
        var _this3 = this;

        var labels = $els.map(function (i, el) {
          var id = el.id;
          var $label = _this3.$element.find('label[for="' + id + '"]');

          if (!$label.length) {
            $label = $(el).closest('label');
          }
          return $label[0];
        });

        return $(labels);
      }

      /**
       * Adds the CSS error class as specified by the Abide settings to the label, input, and the form
       * @param {Object} $el - jQuery object to add the class to
       */

    }, {
      key: 'addErrorClasses',
      value: function addErrorClasses($el) {
        var $label = this.findLabel($el);
        var $formError = this.findFormError($el);

        if ($label.length) {
          $label.addClass(this.options.labelErrorClass);
        }

        if ($formError.length) {
          $formError.addClass(this.options.formErrorClass);
        }

        $el.addClass(this.options.inputErrorClass).attr('data-invalid', '');
      }

      /**
       * Remove CSS error classes etc from an entire radio button group
       * @param {String} groupName - A string that specifies the name of a radio button group
       *
       */

    }, {
      key: 'removeRadioErrorClasses',
      value: function removeRadioErrorClasses(groupName) {
        var $els = this.$element.find(':radio[name="' + groupName + '"]');
        var $labels = this.findRadioLabels($els);
        var $formErrors = this.findFormError($els);

        if ($labels.length) {
          $labels.removeClass(this.options.labelErrorClass);
        }

        if ($formErrors.length) {
          $formErrors.removeClass(this.options.formErrorClass);
        }

        $els.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');
      }

      /**
       * Removes CSS error class as specified by the Abide settings from the label, input, and the form
       * @param {Object} $el - jQuery object to remove the class from
       */

    }, {
      key: 'removeErrorClasses',
      value: function removeErrorClasses($el) {
        // radios need to clear all of the els
        if ($el[0].type == 'radio') {
          return this.removeRadioErrorClasses($el.attr('name'));
        }

        var $label = this.findLabel($el);
        var $formError = this.findFormError($el);

        if ($label.length) {
          $label.removeClass(this.options.labelErrorClass);
        }

        if ($formError.length) {
          $formError.removeClass(this.options.formErrorClass);
        }

        $el.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');
      }

      /**
       * Goes through a form to find inputs and proceeds to validate them in ways specific to their type
       * @fires Abide#invalid
       * @fires Abide#valid
       * @param {Object} element - jQuery object to validate, should be an HTML input
       * @returns {Boolean} goodToGo - If the input is valid or not.
       */

    }, {
      key: 'validateInput',
      value: function validateInput($el) {
        var clearRequire = this.requiredCheck($el),
            validated = false,
            customValidator = true,
            validator = $el.attr('data-validator'),
            equalTo = true;

        // don't validate ignored inputs or hidden inputs
        if ($el.is('[data-abide-ignore]') || $el.is('[type="hidden"]')) {
          return true;
        }

        switch ($el[0].type) {
          case 'radio':
            validated = this.validateRadio($el.attr('name'));
            break;

          case 'checkbox':
            validated = clearRequire;
            break;

          case 'select':
          case 'select-one':
          case 'select-multiple':
            validated = clearRequire;
            break;

          default:
            validated = this.validateText($el);
        }

        if (validator) {
          customValidator = this.matchValidation($el, validator, $el.attr('required'));
        }

        if ($el.attr('data-equalto')) {
          equalTo = this.options.validators.equalTo($el);
        }

        var goodToGo = [clearRequire, validated, customValidator, equalTo].indexOf(false) === -1;
        var message = (goodToGo ? 'valid' : 'invalid') + '.zf.abide';

        this[goodToGo ? 'removeErrorClasses' : 'addErrorClasses']($el);

        /**
         * Fires when the input is done checking for validation. Event trigger is either `valid.zf.abide` or `invalid.zf.abide`
         * Trigger includes the DOM element of the input.
         * @event Abide#valid
         * @event Abide#invalid
         */
        $el.trigger(message, [$el]);

        return goodToGo;
      }

      /**
       * Goes through a form and if there are any invalid inputs, it will display the form error element
       * @returns {Boolean} noError - true if no errors were detected...
       * @fires Abide#formvalid
       * @fires Abide#forminvalid
       */

    }, {
      key: 'validateForm',
      value: function validateForm() {
        var acc = [];
        var _this = this;

        this.$inputs.each(function () {
          acc.push(_this.validateInput($(this)));
        });

        var noError = acc.indexOf(false) === -1;

        this.$element.find('[data-abide-error]').css('display', noError ? 'none' : 'block');

        /**
         * Fires when the form is finished validating. Event trigger is either `formvalid.zf.abide` or `forminvalid.zf.abide`.
         * Trigger includes the element of the form.
         * @event Abide#formvalid
         * @event Abide#forminvalid
         */
        this.$element.trigger((noError ? 'formvalid' : 'forminvalid') + '.zf.abide', [this.$element]);

        return noError;
      }

      /**
       * Determines whether or a not a text input is valid based on the pattern specified in the attribute. If no matching pattern is found, returns true.
       * @param {Object} $el - jQuery object to validate, should be a text input HTML element
       * @param {String} pattern - string value of one of the RegEx patterns in Abide.options.patterns
       * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified
       */

    }, {
      key: 'validateText',
      value: function validateText($el, pattern) {
        // A pattern can be passed to this function, or it will be infered from the input's "pattern" attribute, or it's "type" attribute
        pattern = pattern || $el.attr('pattern') || $el.attr('type');
        var inputText = $el.val();
        var valid = false;

        if (inputText.length) {
          // If the pattern attribute on the element is in Abide's list of patterns, then test that regexp
          if (this.options.patterns.hasOwnProperty(pattern)) {
            valid = this.options.patterns[pattern].test(inputText);
          }
          // If the pattern name isn't also the type attribute of the field, then test it as a regexp
          else if (pattern !== $el.attr('type')) {
              valid = new RegExp(pattern).test(inputText);
            } else {
              valid = true;
            }
        }
        // An empty field is valid if it's not required
        else if (!$el.prop('required')) {
            valid = true;
          }

        return valid;
      }

      /**
       * Determines whether or a not a radio input is valid based on whether or not it is required and selected. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all radio buttons in its group.
       * @param {String} groupName - A string that specifies the name of a radio button group
       * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)
       */

    }, {
      key: 'validateRadio',
      value: function validateRadio(groupName) {
        // If at least one radio in the group has the `required` attribute, the group is considered required
        // Per W3C spec, all radio buttons in a group should have `required`, but we're being nice
        var $group = this.$element.find(':radio[name="' + groupName + '"]');
        var valid = false,
            required = false;

        // For the group to be required, at least one radio needs to be required
        $group.each(function (i, e) {
          if ($(e).attr('required')) {
            required = true;
          }
        });
        if (!required) valid = true;

        if (!valid) {
          // For the group to be valid, at least one radio needs to be checked
          $group.each(function (i, e) {
            if ($(e).prop('checked')) {
              valid = true;
            }
          });
        };

        return valid;
      }

      /**
       * Determines if a selected input passes a custom validation function. Multiple validations can be used, if passed to the element with `data-validator="foo bar baz"` in a space separated listed.
       * @param {Object} $el - jQuery input element.
       * @param {String} validators - a string of function names matching functions in the Abide.options.validators object.
       * @param {Boolean} required - self explanatory?
       * @returns {Boolean} - true if validations passed.
       */

    }, {
      key: 'matchValidation',
      value: function matchValidation($el, validators, required) {
        var _this4 = this;

        required = required ? true : false;

        var clear = validators.split(' ').map(function (v) {
          return _this4.options.validators[v]($el, required, $el.parent());
        });
        return clear.indexOf(false) === -1;
      }

      /**
       * Resets form inputs and styles
       * @fires Abide#formreset
       */

    }, {
      key: 'resetForm',
      value: function resetForm() {
        var $form = this.$element,
            opts = this.options;

        $('.' + opts.labelErrorClass, $form).not('small').removeClass(opts.labelErrorClass);
        $('.' + opts.inputErrorClass, $form).not('small').removeClass(opts.inputErrorClass);
        $(opts.formErrorSelector + '.' + opts.formErrorClass).removeClass(opts.formErrorClass);
        $form.find('[data-abide-error]').css('display', 'none');
        $(':input', $form).not(':button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]').val('').removeAttr('data-invalid');
        $(':input:radio', $form).not('[data-abide-ignore]').prop('checked', false).removeAttr('data-invalid');
        $(':input:checkbox', $form).not('[data-abide-ignore]').prop('checked', false).removeAttr('data-invalid');
        /**
         * Fires when the form has been reset.
         * @event Abide#formreset
         */
        $form.trigger('formreset.zf.abide', [$form]);
      }

      /**
       * Destroys an instance of Abide.
       * Removes error styles and classes from elements, without resetting their values.
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        var _this = this;
        this.$element.off('.abide').find('[data-abide-error]').css('display', 'none');

        this.$inputs.off('.abide').each(function () {
          _this.removeErrorClasses($(this));
        });

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Abide;
  }();

  /**
   * Default settings for plugin
   */


  Abide.defaults = {
    /**
     * The default event to validate inputs. Checkboxes and radios validate immediately.
     * Remove or change this value for manual validation.
     * @option
     * @example 'fieldChange'
     */
    validateOn: 'fieldChange',

    /**
     * Class to be applied to input labels on failed validation.
     * @option
     * @example 'is-invalid-label'
     */
    labelErrorClass: 'is-invalid-label',

    /**
     * Class to be applied to inputs on failed validation.
     * @option
     * @example 'is-invalid-input'
     */
    inputErrorClass: 'is-invalid-input',

    /**
     * Class selector to use to target Form Errors for show/hide.
     * @option
     * @example '.form-error'
     */
    formErrorSelector: '.form-error',

    /**
     * Class added to Form Errors on failed validation.
     * @option
     * @example 'is-visible'
     */
    formErrorClass: 'is-visible',

    /**
     * Set to true to validate text inputs on any value change.
     * @option
     * @example false
     */
    liveValidate: false,

    patterns: {
      alpha: /^[a-zA-Z]+$/,
      alpha_numeric: /^[a-zA-Z0-9]+$/,
      integer: /^[-+]?\d+$/,
      number: /^[-+]?\d*(?:[\.\,]\d+)?$/,

      // amex, visa, diners
      card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,
      cvv: /^([0-9]){3,4}$/,

      // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address
      email: /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,

      url: /^(https?|ftp|file|ssh):\/\/(((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/,
      // abc.de
      domain: /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,8}$/,

      datetime: /^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,
      // YYYY-MM-DD
      date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,
      // HH:MM:SS
      time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,
      dateISO: /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
      // MM/DD/YYYY
      month_day_year: /^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,
      // DD/MM/YYYY
      day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,

      // #FFF or #FFFFFF
      color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/
    },

    /**
     * Optional validation functions to be used. `equalTo` being the only default included function.
     * Functions should return only a boolean if the input is valid or not. Functions are given the following arguments:
     * el : The jQuery element to validate.
     * required : Boolean value of the required attribute be present or not.
     * parent : The direct parent of the input.
     * @option
     */
    validators: {
      equalTo: function (el, required, parent) {
        return $('#' + el.attr('data-equalto')).val() === el.val();
      }
    }
  };

  // Window exports
  Foundation.plugin(Abide, 'Abide');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Accordion module.
   * @module foundation.accordion
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   */

  var Accordion = function () {
    /**
     * Creates a new instance of an accordion.
     * @class
     * @fires Accordion#init
     * @param {jQuery} element - jQuery object to make into an accordion.
     * @param {Object} options - a plain object with settings to override the default options.
     */
    function Accordion(element, options) {
      _classCallCheck(this, Accordion);

      this.$element = element;
      this.options = $.extend({}, Accordion.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Accordion');
      Foundation.Keyboard.register('Accordion', {
        'ENTER': 'toggle',
        'SPACE': 'toggle',
        'ARROW_DOWN': 'next',
        'ARROW_UP': 'previous'
      });
    }

    /**
     * Initializes the accordion by animating the preset active pane(s).
     * @private
     */


    _createClass(Accordion, [{
      key: '_init',
      value: function _init() {
        this.$element.attr('role', 'tablist');
        this.$tabs = this.$element.children('li, [data-accordion-item]');

        this.$tabs.each(function (idx, el) {
          var $el = $(el),
              $content = $el.children('[data-tab-content]'),
              id = $content[0].id || Foundation.GetYoDigits(6, 'accordion'),
              linkId = el.id || id + '-label';

          $el.find('a:first').attr({
            'aria-controls': id,
            'role': 'tab',
            'id': linkId,
            'aria-expanded': false,
            'aria-selected': false
          });

          $content.attr({ 'role': 'tabpanel', 'aria-labelledby': linkId, 'aria-hidden': true, 'id': id });
        });
        var $initActive = this.$element.find('.is-active').children('[data-tab-content]');
        if ($initActive.length) {
          this.down($initActive, true);
        }
        this._events();
      }

      /**
       * Adds event handlers for items within the accordion.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;

        this.$tabs.each(function () {
          var $elem = $(this);
          var $tabContent = $elem.children('[data-tab-content]');
          if ($tabContent.length) {
            $elem.children('a').off('click.zf.accordion keydown.zf.accordion').on('click.zf.accordion', function (e) {
              // $(this).children('a').on('click.zf.accordion', function(e) {
              e.preventDefault();
              if ($elem.hasClass('is-active')) {
                if (_this.options.allowAllClosed || $elem.siblings().hasClass('is-active')) {
                  _this.up($tabContent);
                }
              } else {
                _this.down($tabContent);
              }
            }).on('keydown.zf.accordion', function (e) {
              Foundation.Keyboard.handleKey(e, 'Accordion', {
                toggle: function () {
                  _this.toggle($tabContent);
                },
                next: function () {
                  var $a = $elem.next().find('a').focus();
                  if (!_this.options.multiExpand) {
                    $a.trigger('click.zf.accordion');
                  }
                },
                previous: function () {
                  var $a = $elem.prev().find('a').focus();
                  if (!_this.options.multiExpand) {
                    $a.trigger('click.zf.accordion');
                  }
                },
                handled: function () {
                  e.preventDefault();
                  e.stopPropagation();
                }
              });
            });
          }
        });
      }

      /**
       * Toggles the selected content pane's open/close state.
       * @param {jQuery} $target - jQuery object of the pane to toggle.
       * @function
       */

    }, {
      key: 'toggle',
      value: function toggle($target) {
        if ($target.parent().hasClass('is-active')) {
          if (this.options.allowAllClosed || $target.parent().siblings().hasClass('is-active')) {
            this.up($target);
          } else {
            return;
          }
        } else {
          this.down($target);
        }
      }

      /**
       * Opens the accordion tab defined by `$target`.
       * @param {jQuery} $target - Accordion pane to open.
       * @param {Boolean} firstTime - flag to determine if reflow should happen.
       * @fires Accordion#down
       * @function
       */

    }, {
      key: 'down',
      value: function down($target, firstTime) {
        var _this2 = this;

        if (!this.options.multiExpand && !firstTime) {
          var $currentActive = this.$element.children('.is-active').children('[data-tab-content]');
          if ($currentActive.length) {
            this.up($currentActive);
          }
        }

        $target.attr('aria-hidden', false).parent('[data-tab-content]').addBack().parent().addClass('is-active');

        $target.slideDown(this.options.slideSpeed, function () {
          /**
           * Fires when the tab is done opening.
           * @event Accordion#down
           */
          _this2.$element.trigger('down.zf.accordion', [$target]);
        });

        $('#' + $target.attr('aria-labelledby')).attr({
          'aria-expanded': true,
          'aria-selected': true
        });
      }

      /**
       * Closes the tab defined by `$target`.
       * @param {jQuery} $target - Accordion tab to close.
       * @fires Accordion#up
       * @function
       */

    }, {
      key: 'up',
      value: function up($target) {
        var $aunts = $target.parent().siblings(),
            _this = this;
        var canClose = this.options.multiExpand ? $aunts.hasClass('is-active') : $target.parent().hasClass('is-active');

        if (!this.options.allowAllClosed && !canClose) {
          return;
        }

        // Foundation.Move(this.options.slideSpeed, $target, function(){
        $target.slideUp(_this.options.slideSpeed, function () {
          /**
           * Fires when the tab is done collapsing up.
           * @event Accordion#up
           */
          _this.$element.trigger('up.zf.accordion', [$target]);
        });
        // });

        $target.attr('aria-hidden', true).parent().removeClass('is-active');

        $('#' + $target.attr('aria-labelledby')).attr({
          'aria-expanded': false,
          'aria-selected': false
        });
      }

      /**
       * Destroys an instance of an accordion.
       * @fires Accordion#destroyed
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.find('[data-tab-content]').stop(true).slideUp(0).css('display', '');
        this.$element.find('a').off('.zf.accordion');

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Accordion;
  }();

  Accordion.defaults = {
    /**
     * Amount of time to animate the opening of an accordion pane.
     * @option
     * @example 250
     */
    slideSpeed: 250,
    /**
     * Allow the accordion to have multiple open panes.
     * @option
     * @example false
     */
    multiExpand: false,
    /**
     * Allow the accordion to close all panes.
     * @option
     * @example false
     */
    allowAllClosed: false
  };

  // Window exports
  Foundation.plugin(Accordion, 'Accordion');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * AccordionMenu module.
   * @module foundation.accordionMenu
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   * @requires foundation.util.nest
   */

  var AccordionMenu = function () {
    /**
     * Creates a new instance of an accordion menu.
     * @class
     * @fires AccordionMenu#init
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function AccordionMenu(element, options) {
      _classCallCheck(this, AccordionMenu);

      this.$element = element;
      this.options = $.extend({}, AccordionMenu.defaults, this.$element.data(), options);

      Foundation.Nest.Feather(this.$element, 'accordion');

      this._init();

      Foundation.registerPlugin(this, 'AccordionMenu');
      Foundation.Keyboard.register('AccordionMenu', {
        'ENTER': 'toggle',
        'SPACE': 'toggle',
        'ARROW_RIGHT': 'open',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'close',
        'ESCAPE': 'closeAll',
        'TAB': 'down',
        'SHIFT_TAB': 'up'
      });
    }

    /**
     * Initializes the accordion menu by hiding all nested menus.
     * @private
     */


    _createClass(AccordionMenu, [{
      key: '_init',
      value: function _init() {
        this.$element.find('[data-submenu]').not('.is-active').slideUp(0); //.find('a').css('padding-left', '1rem');
        this.$element.attr({
          'role': 'tablist',
          'aria-multiselectable': this.options.multiOpen
        });

        this.$menuLinks = this.$element.find('.is-accordion-submenu-parent');
        this.$menuLinks.each(function () {
          var linkId = this.id || Foundation.GetYoDigits(6, 'acc-menu-link'),
              $elem = $(this),
              $sub = $elem.children('[data-submenu]'),
              subId = $sub[0].id || Foundation.GetYoDigits(6, 'acc-menu'),
              isActive = $sub.hasClass('is-active');
          $elem.attr({
            'aria-controls': subId,
            'aria-expanded': isActive,
            'role': 'tab',
            'id': linkId
          });
          $sub.attr({
            'aria-labelledby': linkId,
            'aria-hidden': !isActive,
            'role': 'tabpanel',
            'id': subId
          });
        });
        var initPanes = this.$element.find('.is-active');
        if (initPanes.length) {
          var _this = this;
          initPanes.each(function () {
            _this.down($(this));
          });
        }
        this._events();
      }

      /**
       * Adds event handlers for items within the menu.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;

        this.$element.find('li').each(function () {
          var $submenu = $(this).children('[data-submenu]');

          if ($submenu.length) {
            $(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {
              e.preventDefault();

              _this.toggle($submenu);
            });
          }
        }).on('keydown.zf.accordionmenu', function (e) {
          var $element = $(this),
              $elements = $element.parent('ul').children('li'),
              $prevElement,
              $nextElement,
              $target = $element.children('[data-submenu]');

          $elements.each(function (i) {
            if ($(this).is($element)) {
              $prevElement = $elements.eq(Math.max(0, i - 1)).find('a').first();
              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1)).find('a').first();

              if ($(this).children('[data-submenu]:visible').length) {
                // has open sub menu
                $nextElement = $element.find('li:first-child').find('a').first();
              }
              if ($(this).is(':first-child')) {
                // is first element of sub menu
                $prevElement = $element.parents('li').first().find('a').first();
              } else if ($prevElement.children('[data-submenu]:visible').length) {
                // if previous element has open sub menu
                $prevElement = $prevElement.find('li:last-child').find('a').first();
              }
              if ($(this).is(':last-child')) {
                // is last element of sub menu
                $nextElement = $element.parents('li').first().next('li').find('a').first();
              }

              return;
            }
          });
          Foundation.Keyboard.handleKey(e, 'AccordionMenu', {
            open: function () {
              if ($target.is(':hidden')) {
                _this.down($target);
                $target.find('li').first().find('a').first().focus();
              }
            },
            close: function () {
              if ($target.length && !$target.is(':hidden')) {
                // close active sub of this item
                _this.up($target);
              } else if ($element.parent('[data-submenu]').length) {
                // close currently open sub
                _this.up($element.parent('[data-submenu]'));
                $element.parents('li').first().find('a').first().focus();
              }
            },
            up: function () {
              $prevElement.attr('tabindex', -1).focus();
              return true;
            },
            down: function () {
              $nextElement.attr('tabindex', -1).focus();
              return true;
            },
            toggle: function () {
              if ($element.children('[data-submenu]').length) {
                _this.toggle($element.children('[data-submenu]'));
              }
            },
            closeAll: function () {
              _this.hideAll();
            },
            handled: function (preventDefault) {
              if (preventDefault) {
                e.preventDefault();
              }
              e.stopImmediatePropagation();
            }
          });
        }); //.attr('tabindex', 0);
      }

      /**
       * Closes all panes of the menu.
       * @function
       */

    }, {
      key: 'hideAll',
      value: function hideAll() {
        this.$element.find('[data-submenu]').slideUp(this.options.slideSpeed);
      }

      /**
       * Toggles the open/close state of a submenu.
       * @function
       * @param {jQuery} $target - the submenu to toggle
       */

    }, {
      key: 'toggle',
      value: function toggle($target) {
        if (!$target.is(':animated')) {
          if (!$target.is(':hidden')) {
            this.up($target);
          } else {
            this.down($target);
          }
        }
      }

      /**
       * Opens the sub-menu defined by `$target`.
       * @param {jQuery} $target - Sub-menu to open.
       * @fires AccordionMenu#down
       */

    }, {
      key: 'down',
      value: function down($target) {
        var _this = this;

        if (!this.options.multiOpen) {
          this.up(this.$element.find('.is-active').not($target.parentsUntil(this.$element).add($target)));
        }

        $target.addClass('is-active').attr({ 'aria-hidden': false }).parent('.is-accordion-submenu-parent').attr({ 'aria-expanded': true });

        //Foundation.Move(this.options.slideSpeed, $target, function() {
        $target.slideDown(_this.options.slideSpeed, function () {
          /**
           * Fires when the menu is done opening.
           * @event AccordionMenu#down
           */
          _this.$element.trigger('down.zf.accordionMenu', [$target]);
        });
        //});
      }

      /**
       * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.
       * @param {jQuery} $target - Sub-menu to close.
       * @fires AccordionMenu#up
       */

    }, {
      key: 'up',
      value: function up($target) {
        var _this = this;
        //Foundation.Move(this.options.slideSpeed, $target, function(){
        $target.slideUp(_this.options.slideSpeed, function () {
          /**
           * Fires when the menu is done collapsing up.
           * @event AccordionMenu#up
           */
          _this.$element.trigger('up.zf.accordionMenu', [$target]);
        });
        //});

        var $menus = $target.find('[data-submenu]').slideUp(0).addBack().attr('aria-hidden', true);

        $menus.parent('.is-accordion-submenu-parent').attr('aria-expanded', false);
      }

      /**
       * Destroys an instance of accordion menu.
       * @fires AccordionMenu#destroyed
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.find('[data-submenu]').slideDown(0).css('display', '');
        this.$element.find('a').off('click.zf.accordionMenu');

        Foundation.Nest.Burn(this.$element, 'accordion');
        Foundation.unregisterPlugin(this);
      }
    }]);

    return AccordionMenu;
  }();

  AccordionMenu.defaults = {
    /**
     * Amount of time to animate the opening of a submenu in ms.
     * @option
     * @example 250
     */
    slideSpeed: 250,
    /**
     * Allow the menu to have multiple open panes.
     * @option
     * @example true
     */
    multiOpen: true
  };

  // Window exports
  Foundation.plugin(AccordionMenu, 'AccordionMenu');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Drilldown module.
   * @module foundation.drilldown
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   * @requires foundation.util.nest
   */

  var Drilldown = function () {
    /**
     * Creates a new instance of a drilldown menu.
     * @class
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Drilldown(element, options) {
      _classCallCheck(this, Drilldown);

      this.$element = element;
      this.options = $.extend({}, Drilldown.defaults, this.$element.data(), options);

      Foundation.Nest.Feather(this.$element, 'drilldown');

      this._init();

      Foundation.registerPlugin(this, 'Drilldown');
      Foundation.Keyboard.register('Drilldown', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'previous',
        'ESCAPE': 'close',
        'TAB': 'down',
        'SHIFT_TAB': 'up'
      });
    }

    /**
     * Initializes the drilldown by creating jQuery collections of elements
     * @private
     */


    _createClass(Drilldown, [{
      key: '_init',
      value: function _init() {
        this.$submenuAnchors = this.$element.find('li.is-drilldown-submenu-parent').children('a');
        this.$submenus = this.$submenuAnchors.parent('li').children('[data-submenu]');
        this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'menuitem').find('a');

        this._prepareMenu();

        this._keyboardEvents();
      }

      /**
       * prepares drilldown menu by setting attributes to links and elements
       * sets a min height to prevent content jumping
       * wraps the element if not already wrapped
       * @private
       * @function
       */

    }, {
      key: '_prepareMenu',
      value: function _prepareMenu() {
        var _this = this;
        // if(!this.options.holdOpen){
        //   this._menuLinkEvents();
        // }
        this.$submenuAnchors.each(function () {
          var $link = $(this);
          var $sub = $link.parent();
          if (_this.options.parentLink) {
            $link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li class="is-submenu-parent-item is-submenu-item is-drilldown-submenu-item" role="menu-item"></li>');
          }
          $link.data('savedHref', $link.attr('href')).removeAttr('href');
          $link.children('[data-submenu]').attr({
            'aria-hidden': true,
            'tabindex': 0,
            'role': 'menu'
          });
          _this._events($link);
        });
        this.$submenus.each(function () {
          var $menu = $(this),
              $back = $menu.find('.js-drilldown-back');
          if (!$back.length) {
            $menu.prepend(_this.options.backButton);
          }
          _this._back($menu);
        });
        if (!this.$element.parent().hasClass('is-drilldown')) {
          this.$wrapper = $(this.options.wrapper).addClass('is-drilldown');
          this.$wrapper = this.$element.wrap(this.$wrapper).parent().css(this._getMaxDims());
        }
      }

      /**
       * Adds event handlers to elements in the menu.
       * @function
       * @private
       * @param {jQuery} $elem - the current menu item to add handlers to.
       */

    }, {
      key: '_events',
      value: function _events($elem) {
        var _this = this;

        $elem.off('click.zf.drilldown').on('click.zf.drilldown', function (e) {
          if ($(e.target).parentsUntil('ul', 'li').hasClass('is-drilldown-submenu-parent')) {
            e.stopImmediatePropagation();
            e.preventDefault();
          }

          // if(e.target !== e.currentTarget.firstElementChild){
          //   return false;
          // }
          _this._show($elem.parent('li'));

          if (_this.options.closeOnClick) {
            var $body = $('body');
            $body.off('.zf.drilldown').on('click.zf.drilldown', function (e) {
              if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {
                return;
              }
              e.preventDefault();
              _this._hideAll();
              $body.off('.zf.drilldown');
            });
          }
        });
      }

      /**
       * Adds keydown event listener to `li`'s in the menu.
       * @private
       */

    }, {
      key: '_keyboardEvents',
      value: function _keyboardEvents() {
        var _this = this;

        this.$menuItems.add(this.$element.find('.js-drilldown-back > a')).on('keydown.zf.drilldown', function (e) {

          var $element = $(this),
              $elements = $element.parent('li').parent('ul').children('li').children('a'),
              $prevElement,
              $nextElement;

          $elements.each(function (i) {
            if ($(this).is($element)) {
              $prevElement = $elements.eq(Math.max(0, i - 1));
              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));
              return;
            }
          });

          Foundation.Keyboard.handleKey(e, 'Drilldown', {
            next: function () {
              if ($element.is(_this.$submenuAnchors)) {
                _this._show($element.parent('li'));
                $element.parent('li').one(Foundation.transitionend($element), function () {
                  $element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();
                });
                return true;
              }
            },
            previous: function () {
              _this._hide($element.parent('li').parent('ul'));
              $element.parent('li').parent('ul').one(Foundation.transitionend($element), function () {
                setTimeout(function () {
                  $element.parent('li').parent('ul').parent('li').children('a').first().focus();
                }, 1);
              });
              return true;
            },
            up: function () {
              $prevElement.focus();
              return true;
            },
            down: function () {
              $nextElement.focus();
              return true;
            },
            close: function () {
              _this._back();
              //_this.$menuItems.first().focus(); // focus to first element
            },
            open: function () {
              if (!$element.is(_this.$menuItems)) {
                // not menu item means back button
                _this._hide($element.parent('li').parent('ul'));
                $element.parent('li').parent('ul').one(Foundation.transitionend($element), function () {
                  setTimeout(function () {
                    $element.parent('li').parent('ul').parent('li').children('a').first().focus();
                  }, 1);
                });
              } else if ($element.is(_this.$submenuAnchors)) {
                _this._show($element.parent('li'));
                $element.parent('li').one(Foundation.transitionend($element), function () {
                  $element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();
                });
              }
              return true;
            },
            handled: function (preventDefault) {
              if (preventDefault) {
                e.preventDefault();
              }
              e.stopImmediatePropagation();
            }
          });
        }); // end keyboardAccess
      }

      /**
       * Closes all open elements, and returns to root menu.
       * @function
       * @fires Drilldown#closed
       */

    }, {
      key: '_hideAll',
      value: function _hideAll() {
        var $elem = this.$element.find('.is-drilldown-submenu.is-active').addClass('is-closing');
        $elem.one(Foundation.transitionend($elem), function (e) {
          $elem.removeClass('is-active is-closing');
        });
        /**
         * Fires when the menu is fully closed.
         * @event Drilldown#closed
         */
        this.$element.trigger('closed.zf.drilldown');
      }

      /**
       * Adds event listener for each `back` button, and closes open menus.
       * @function
       * @fires Drilldown#back
       * @param {jQuery} $elem - the current sub-menu to add `back` event.
       */

    }, {
      key: '_back',
      value: function _back($elem) {
        var _this = this;
        $elem.off('click.zf.drilldown');
        $elem.children('.js-drilldown-back').on('click.zf.drilldown', function (e) {
          e.stopImmediatePropagation();
          // console.log('mouseup on back');
          _this._hide($elem);
        });
      }

      /**
       * Adds event listener to menu items w/o submenus to close open menus on click.
       * @function
       * @private
       */

    }, {
      key: '_menuLinkEvents',
      value: function _menuLinkEvents() {
        var _this = this;
        this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown', function (e) {
          // e.stopImmediatePropagation();
          setTimeout(function () {
            _this._hideAll();
          }, 0);
        });
      }

      /**
       * Opens a submenu.
       * @function
       * @fires Drilldown#open
       * @param {jQuery} $elem - the current element with a submenu to open, i.e. the `li` tag.
       */

    }, {
      key: '_show',
      value: function _show($elem) {
        $elem.children('[data-submenu]').addClass('is-active');
        /**
         * Fires when the submenu has opened.
         * @event Drilldown#open
         */
        this.$element.trigger('open.zf.drilldown', [$elem]);
      }
    }, {
      key: '_hide',


      /**
       * Hides a submenu
       * @function
       * @fires Drilldown#hide
       * @param {jQuery} $elem - the current sub-menu to hide, i.e. the `ul` tag.
       */
      value: function _hide($elem) {
        var _this = this;
        $elem.addClass('is-closing').one(Foundation.transitionend($elem), function () {
          $elem.removeClass('is-active is-closing');
          $elem.blur();
        });
        /**
         * Fires when the submenu has closed.
         * @event Drilldown#hide
         */
        $elem.trigger('hide.zf.drilldown', [$elem]);
      }

      /**
       * Iterates through the nested menus to calculate the min-height, and max-width for the menu.
       * Prevents content jumping.
       * @function
       * @private
       */

    }, {
      key: '_getMaxDims',
      value: function _getMaxDims() {
        var max = 0,
            result = {};
        this.$submenus.add(this.$element).each(function () {
          var numOfElems = $(this).children('li').length;
          max = numOfElems > max ? numOfElems : max;
        });

        result['min-height'] = max * this.$menuItems[0].getBoundingClientRect().height + 'px';
        result['max-width'] = this.$element[0].getBoundingClientRect().width + 'px';

        return result;
      }

      /**
       * Destroys the Drilldown Menu
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this._hideAll();
        Foundation.Nest.Burn(this.$element, 'drilldown');
        this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role');
        this.$submenuAnchors.each(function () {
          $(this).off('.zf.drilldown');
        });
        this.$element.find('a').each(function () {
          var $link = $(this);
          if ($link.data('savedHref')) {
            $link.attr('href', $link.data('savedHref')).removeData('savedHref');
          } else {
            return;
          }
        });
        Foundation.unregisterPlugin(this);
      }
    }]);

    return Drilldown;
  }();

  Drilldown.defaults = {
    /**
     * Markup used for JS generated back button. Prepended to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\`) if copy and pasting.
     * @option
     * @example '<\li><\a>Back<\/a><\/li>'
     */
    backButton: '<li class="js-drilldown-back"><a tabindex="0">Back</a></li>',
    /**
     * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\`) if copy and pasting.
     * @option
     * @example '<\div class="is-drilldown"><\/div>'
     */
    wrapper: '<div></div>',
    /**
     * Adds the parent link to the submenu.
     * @option
     * @example false
     */
    parentLink: false,
    /**
     * Allow the menu to return to root list on body click.
     * @option
     * @example false
     */
    closeOnClick: false
    // holdOpen: false
  };

  // Window exports
  Foundation.plugin(Drilldown, 'Drilldown');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Dropdown module.
   * @module foundation.dropdown
   * @requires foundation.util.keyboard
   * @requires foundation.util.box
   * @requires foundation.util.triggers
   */

  var Dropdown = function () {
    /**
     * Creates a new instance of a dropdown.
     * @class
     * @param {jQuery} element - jQuery object to make into a dropdown.
     *        Object should be of the dropdown panel, rather than its anchor.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Dropdown(element, options) {
      _classCallCheck(this, Dropdown);

      this.$element = element;
      this.options = $.extend({}, Dropdown.defaults, this.$element.data(), options);
      this._init();

      Foundation.registerPlugin(this, 'Dropdown');
      Foundation.Keyboard.register('Dropdown', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ESCAPE': 'close',
        'TAB': 'tab_forward',
        'SHIFT_TAB': 'tab_backward'
      });
    }

    /**
     * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.
     * @function
     * @private
     */


    _createClass(Dropdown, [{
      key: '_init',
      value: function _init() {
        var $id = this.$element.attr('id');

        this.$anchor = $('[data-toggle="' + $id + '"]') || $('[data-open="' + $id + '"]');
        this.$anchor.attr({
          'aria-controls': $id,
          'data-is-focus': false,
          'data-yeti-box': $id,
          'aria-haspopup': true,
          'aria-expanded': false

        });

        this.options.positionClass = this.getPositionClass();
        this.counter = 4;
        this.usedPositions = [];
        this.$element.attr({
          'aria-hidden': 'true',
          'data-yeti-box': $id,
          'data-resize': $id,
          'aria-labelledby': this.$anchor[0].id || Foundation.GetYoDigits(6, 'dd-anchor')
        });
        this._events();
      }

      /**
       * Helper function to determine current orientation of dropdown pane.
       * @function
       * @returns {String} position - string value of a position class.
       */

    }, {
      key: 'getPositionClass',
      value: function getPositionClass() {
        var verticalPosition = this.$element[0].className.match(/(top|left|right|bottom)/g);
        verticalPosition = verticalPosition ? verticalPosition[0] : '';
        var horizontalPosition = /float-(\S+)\s/.exec(this.$anchor[0].className);
        horizontalPosition = horizontalPosition ? horizontalPosition[1] : '';
        var position = horizontalPosition ? horizontalPosition + ' ' + verticalPosition : verticalPosition;
        return position;
      }

      /**
       * Adjusts the dropdown panes orientation by adding/removing positioning classes.
       * @function
       * @private
       * @param {String} position - position class to remove.
       */

    }, {
      key: '_reposition',
      value: function _reposition(position) {
        this.usedPositions.push(position ? position : 'bottom');
        //default, try switching to opposite side
        if (!position && this.usedPositions.indexOf('top') < 0) {
          this.$element.addClass('top');
        } else if (position === 'top' && this.usedPositions.indexOf('bottom') < 0) {
          this.$element.removeClass(position);
        } else if (position === 'left' && this.usedPositions.indexOf('right') < 0) {
          this.$element.removeClass(position).addClass('right');
        } else if (position === 'right' && this.usedPositions.indexOf('left') < 0) {
          this.$element.removeClass(position).addClass('left');
        }

        //if default change didn't work, try bottom or left first
        else if (!position && this.usedPositions.indexOf('top') > -1 && this.usedPositions.indexOf('left') < 0) {
            this.$element.addClass('left');
          } else if (position === 'top' && this.usedPositions.indexOf('bottom') > -1 && this.usedPositions.indexOf('left') < 0) {
            this.$element.removeClass(position).addClass('left');
          } else if (position === 'left' && this.usedPositions.indexOf('right') > -1 && this.usedPositions.indexOf('bottom') < 0) {
            this.$element.removeClass(position);
          } else if (position === 'right' && this.usedPositions.indexOf('left') > -1 && this.usedPositions.indexOf('bottom') < 0) {
            this.$element.removeClass(position);
          }
          //if nothing cleared, set to bottom
          else {
              this.$element.removeClass(position);
            }
        this.classChanged = true;
        this.counter--;
      }

      /**
       * Sets the position and orientation of the dropdown pane, checks for collisions.
       * Recursively calls itself if a collision is detected, with a new position class.
       * @function
       * @private
       */

    }, {
      key: '_setPosition',
      value: function _setPosition() {
        if (this.$anchor.attr('aria-expanded') === 'false') {
          return false;
        }
        var position = this.getPositionClass(),
            $eleDims = Foundation.Box.GetDimensions(this.$element),
            $anchorDims = Foundation.Box.GetDimensions(this.$anchor),
            _this = this,
            direction = position === 'left' ? 'left' : position === 'right' ? 'left' : 'top',
            param = direction === 'top' ? 'height' : 'width',
            offset = param === 'height' ? this.options.vOffset : this.options.hOffset;

        if ($eleDims.width >= $eleDims.windowDims.width || !this.counter && !Foundation.Box.ImNotTouchingYou(this.$element)) {
          this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({
            'width': $eleDims.windowDims.width - this.options.hOffset * 2,
            'height': 'auto'
          });
          this.classChanged = true;
          return false;
        }

        this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, position, this.options.vOffset, this.options.hOffset));

        while (!Foundation.Box.ImNotTouchingYou(this.$element, false, true) && this.counter) {
          this._reposition(position);
          this._setPosition();
        }
      }

      /**
       * Adds event listeners to the element utilizing the triggers utility library.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;
        this.$element.on({
          'open.zf.trigger': this.open.bind(this),
          'close.zf.trigger': this.close.bind(this),
          'toggle.zf.trigger': this.toggle.bind(this),
          'resizeme.zf.trigger': this._setPosition.bind(this)
        });

        if (this.options.hover) {
          this.$anchor.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {
            clearTimeout(_this.timeout);
            _this.timeout = setTimeout(function () {
              _this.open();
              _this.$anchor.data('hover', true);
            }, _this.options.hoverDelay);
          }).on('mouseleave.zf.dropdown', function () {
            clearTimeout(_this.timeout);
            _this.timeout = setTimeout(function () {
              _this.close();
              _this.$anchor.data('hover', false);
            }, _this.options.hoverDelay);
          });
          if (this.options.hoverPane) {
            this.$element.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {
              clearTimeout(_this.timeout);
            }).on('mouseleave.zf.dropdown', function () {
              clearTimeout(_this.timeout);
              _this.timeout = setTimeout(function () {
                _this.close();
                _this.$anchor.data('hover', false);
              }, _this.options.hoverDelay);
            });
          }
        }
        this.$anchor.add(this.$element).on('keydown.zf.dropdown', function (e) {

          var $target = $(this),
              visibleFocusableElements = Foundation.Keyboard.findFocusable(_this.$element);

          Foundation.Keyboard.handleKey(e, 'Dropdown', {
            tab_forward: function () {
              if (_this.$element.find(':focus').is(visibleFocusableElements.eq(-1))) {
                // left modal downwards, setting focus to first element
                if (_this.options.trapFocus) {
                  // if focus shall be trapped
                  visibleFocusableElements.eq(0).focus();
                  e.preventDefault();
                } else {
                  // if focus is not trapped, close dropdown on focus out
                  _this.close();
                }
              }
            },
            tab_backward: function () {
              if (_this.$element.find(':focus').is(visibleFocusableElements.eq(0)) || _this.$element.is(':focus')) {
                // left modal upwards, setting focus to last element
                if (_this.options.trapFocus) {
                  // if focus shall be trapped
                  visibleFocusableElements.eq(-1).focus();
                  e.preventDefault();
                } else {
                  // if focus is not trapped, close dropdown on focus out
                  _this.close();
                }
              }
            },
            open: function () {
              if ($target.is(_this.$anchor)) {
                _this.open();
                _this.$element.attr('tabindex', -1).focus();
                e.preventDefault();
              }
            },
            close: function () {
              _this.close();
              _this.$anchor.focus();
            }
          });
        });
      }

      /**
       * Adds an event handler to the body to close any dropdowns on a click.
       * @function
       * @private
       */

    }, {
      key: '_addBodyHandler',
      value: function _addBodyHandler() {
        var $body = $(document.body).not(this.$element),
            _this = this;
        $body.off('click.zf.dropdown').on('click.zf.dropdown', function (e) {
          if (_this.$anchor.is(e.target) || _this.$anchor.find(e.target).length) {
            return;
          }
          if (_this.$element.find(e.target).length) {
            return;
          }
          _this.close();
          $body.off('click.zf.dropdown');
        });
      }

      /**
       * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.
       * @function
       * @fires Dropdown#closeme
       * @fires Dropdown#show
       */

    }, {
      key: 'open',
      value: function open() {
        // var _this = this;
        /**
         * Fires to close other open dropdowns
         * @event Dropdown#closeme
         */
        this.$element.trigger('closeme.zf.dropdown', this.$element.attr('id'));
        this.$anchor.addClass('hover').attr({ 'aria-expanded': true });
        // this.$element/*.show()*/;
        this._setPosition();
        this.$element.addClass('is-open').attr({ 'aria-hidden': false });

        if (this.options.autoFocus) {
          var $focusable = Foundation.Keyboard.findFocusable(this.$element);
          if ($focusable.length) {
            $focusable.eq(0).focus();
          }
        }

        if (this.options.closeOnClick) {
          this._addBodyHandler();
        }

        /**
         * Fires once the dropdown is visible.
         * @event Dropdown#show
         */
        this.$element.trigger('show.zf.dropdown', [this.$element]);
      }

      /**
       * Closes the open dropdown pane.
       * @function
       * @fires Dropdown#hide
       */

    }, {
      key: 'close',
      value: function close() {
        if (!this.$element.hasClass('is-open')) {
          return false;
        }
        this.$element.removeClass('is-open').attr({ 'aria-hidden': true });

        this.$anchor.removeClass('hover').attr('aria-expanded', false);

        if (this.classChanged) {
          var curPositionClass = this.getPositionClass();
          if (curPositionClass) {
            this.$element.removeClass(curPositionClass);
          }
          this.$element.addClass(this.options.positionClass)
          /*.hide()*/.css({ height: '', width: '' });
          this.classChanged = false;
          this.counter = 4;
          this.usedPositions.length = 0;
        }
        this.$element.trigger('hide.zf.dropdown', [this.$element]);
      }

      /**
       * Toggles the dropdown pane's visibility.
       * @function
       */

    }, {
      key: 'toggle',
      value: function toggle() {
        if (this.$element.hasClass('is-open')) {
          if (this.$anchor.data('hover')) return;
          this.close();
        } else {
          this.open();
        }
      }

      /**
       * Destroys the dropdown.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.off('.zf.trigger').hide();
        this.$anchor.off('.zf.dropdown');

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Dropdown;
  }();

  Dropdown.defaults = {
    /**
     * Amount of time to delay opening a submenu on hover event.
     * @option
     * @example 250
     */
    hoverDelay: 250,
    /**
     * Allow submenus to open on hover events
     * @option
     * @example false
     */
    hover: false,
    /**
     * Don't close dropdown when hovering over dropdown pane
     * @option
     * @example true
     */
    hoverPane: false,
    /**
     * Number of pixels between the dropdown pane and the triggering element on open.
     * @option
     * @example 1
     */
    vOffset: 1,
    /**
     * Number of pixels between the dropdown pane and the triggering element on open.
     * @option
     * @example 1
     */
    hOffset: 1,
    /**
     * Class applied to adjust open position. JS will test and fill this in.
     * @option
     * @example 'top'
     */
    positionClass: '',
    /**
     * Allow the plugin to trap focus to the dropdown pane if opened with keyboard commands.
     * @option
     * @example false
     */
    trapFocus: false,
    /**
     * Allow the plugin to set focus to the first focusable element within the pane, regardless of method of opening.
     * @option
     * @example true
     */
    autoFocus: false,
    /**
     * Allows a click on the body to close the dropdown.
     * @option
     * @example false
     */
    closeOnClick: false
  };

  // Window exports
  Foundation.plugin(Dropdown, 'Dropdown');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * DropdownMenu module.
   * @module foundation.dropdown-menu
   * @requires foundation.util.keyboard
   * @requires foundation.util.box
   * @requires foundation.util.nest
   */

  var DropdownMenu = function () {
    /**
     * Creates a new instance of DropdownMenu.
     * @class
     * @fires DropdownMenu#init
     * @param {jQuery} element - jQuery object to make into a dropdown menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function DropdownMenu(element, options) {
      _classCallCheck(this, DropdownMenu);

      this.$element = element;
      this.options = $.extend({}, DropdownMenu.defaults, this.$element.data(), options);

      Foundation.Nest.Feather(this.$element, 'dropdown');
      this._init();

      Foundation.registerPlugin(this, 'DropdownMenu');
      Foundation.Keyboard.register('DropdownMenu', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'previous',
        'ESCAPE': 'close'
      });
    }

    /**
     * Initializes the plugin, and calls _prepareMenu
     * @private
     * @function
     */


    _createClass(DropdownMenu, [{
      key: '_init',
      value: function _init() {
        var subs = this.$element.find('li.is-dropdown-submenu-parent');
        this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');

        this.$menuItems = this.$element.find('[role="menuitem"]');
        this.$tabs = this.$element.children('[role="menuitem"]');
        this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);

        if (this.$element.hasClass(this.options.rightClass) || this.options.alignment === 'right' || Foundation.rtl() || this.$element.parents('.top-bar-right').is('*')) {
          this.options.alignment = 'right';
          subs.addClass('opens-left');
        } else {
          subs.addClass('opens-right');
        }
        this.changed = false;
        this._events();
      }
    }, {
      key: '_events',

      /**
       * Adds event listeners to elements within the menu
       * @private
       * @function
       */
      value: function _events() {
        var _this = this,
            hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined',
            parClass = 'is-dropdown-submenu-parent';

        // used for onClick and in the keyboard handlers
        var handleClickFn = function (e) {
          var $elem = $(e.target).parentsUntil('ul', '.' + parClass),
              hasSub = $elem.hasClass(parClass),
              hasClicked = $elem.attr('data-is-click') === 'true',
              $sub = $elem.children('.is-dropdown-submenu');

          if (hasSub) {
            if (hasClicked) {
              if (!_this.options.closeOnClick || !_this.options.clickOpen && !hasTouch || _this.options.forceFollow && hasTouch) {
                return;
              } else {
                e.stopImmediatePropagation();
                e.preventDefault();
                _this._hide($elem);
              }
            } else {
              e.preventDefault();
              e.stopImmediatePropagation();
              _this._show($elem.children('.is-dropdown-submenu'));
              $elem.add($elem.parentsUntil(_this.$element, '.' + parClass)).attr('data-is-click', true);
            }
          } else {
            return;
          }
        };

        if (this.options.clickOpen || hasTouch) {
          this.$menuItems.on('click.zf.dropdownmenu touchstart.zf.dropdownmenu', handleClickFn);
        }

        if (!this.options.disableHover) {
          this.$menuItems.on('mouseenter.zf.dropdownmenu', function (e) {
            var $elem = $(this),
                hasSub = $elem.hasClass(parClass);

            if (hasSub) {
              clearTimeout(_this.delay);
              _this.delay = setTimeout(function () {
                _this._show($elem.children('.is-dropdown-submenu'));
              }, _this.options.hoverDelay);
            }
          }).on('mouseleave.zf.dropdownmenu', function (e) {
            var $elem = $(this),
                hasSub = $elem.hasClass(parClass);
            if (hasSub && _this.options.autoclose) {
              if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) {
                return false;
              }

              clearTimeout(_this.delay);
              _this.delay = setTimeout(function () {
                _this._hide($elem);
              }, _this.options.closingTime);
            }
          });
        }
        this.$menuItems.on('keydown.zf.dropdownmenu', function (e) {
          var $element = $(e.target).parentsUntil('ul', '[role="menuitem"]'),
              isTab = _this.$tabs.index($element) > -1,
              $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),
              $prevElement,
              $nextElement;

          $elements.each(function (i) {
            if ($(this).is($element)) {
              $prevElement = $elements.eq(i - 1);
              $nextElement = $elements.eq(i + 1);
              return;
            }
          });

          var nextSibling = function () {
            if (!$element.is(':last-child')) {
              $nextElement.children('a:first').focus();
              e.preventDefault();
            }
          },
              prevSibling = function () {
            $prevElement.children('a:first').focus();
            e.preventDefault();
          },
              openSub = function () {
            var $sub = $element.children('ul.is-dropdown-submenu');
            if ($sub.length) {
              _this._show($sub);
              $element.find('li > a:first').focus();
              e.preventDefault();
            } else {
              return;
            }
          },
              closeSub = function () {
            //if ($element.is(':first-child')) {
            var close = $element.parent('ul').parent('li');
            close.children('a:first').focus();
            _this._hide(close);
            e.preventDefault();
            //}
          };
          var functions = {
            open: openSub,
            close: function () {
              _this._hide(_this.$element);
              _this.$menuItems.find('a:first').focus(); // focus to first element
              e.preventDefault();
            },
            handled: function () {
              e.stopImmediatePropagation();
            }
          };

          if (isTab) {
            if (_this.$element.hasClass(_this.options.verticalClass)) {
              // vertical menu
              if (_this.options.alignment === 'left') {
                // left aligned
                $.extend(functions, {
                  down: nextSibling,
                  up: prevSibling,
                  next: openSub,
                  previous: closeSub
                });
              } else {
                // right aligned
                $.extend(functions, {
                  down: nextSibling,
                  up: prevSibling,
                  next: closeSub,
                  previous: openSub
                });
              }
            } else {
              // horizontal menu
              $.extend(functions, {
                next: nextSibling,
                previous: prevSibling,
                down: openSub,
                up: closeSub
              });
            }
          } else {
            // not tabs -> one sub
            if (_this.options.alignment === 'left') {
              // left aligned
              $.extend(functions, {
                next: openSub,
                previous: closeSub,
                down: nextSibling,
                up: prevSibling
              });
            } else {
              // right aligned
              $.extend(functions, {
                next: closeSub,
                previous: openSub,
                down: nextSibling,
                up: prevSibling
              });
            }
          }
          Foundation.Keyboard.handleKey(e, 'DropdownMenu', functions);
        });
      }

      /**
       * Adds an event handler to the body to close any dropdowns on a click.
       * @function
       * @private
       */

    }, {
      key: '_addBodyHandler',
      value: function _addBodyHandler() {
        var $body = $(document.body),
            _this = this;
        $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu').on('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu', function (e) {
          var $link = _this.$element.find(e.target);
          if ($link.length) {
            return;
          }

          _this._hide();
          $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu');
        });
      }

      /**
       * Opens a dropdown pane, and checks for collisions first.
       * @param {jQuery} $sub - ul element that is a submenu to show
       * @function
       * @private
       * @fires DropdownMenu#show
       */

    }, {
      key: '_show',
      value: function _show($sub) {
        var idx = this.$tabs.index(this.$tabs.filter(function (i, el) {
          return $(el).find($sub).length > 0;
        }));
        var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');
        this._hide($sibs, idx);
        $sub.css('visibility', 'hidden').addClass('js-dropdown-active').attr({ 'aria-hidden': false }).parent('li.is-dropdown-submenu-parent').addClass('is-active').attr({ 'aria-expanded': true });
        var clear = Foundation.Box.ImNotTouchingYou($sub, null, true);
        if (!clear) {
          var oldClass = this.options.alignment === 'left' ? '-right' : '-left',
              $parentLi = $sub.parent('.is-dropdown-submenu-parent');
          $parentLi.removeClass('opens' + oldClass).addClass('opens-' + this.options.alignment);
          clear = Foundation.Box.ImNotTouchingYou($sub, null, true);
          if (!clear) {
            $parentLi.removeClass('opens-' + this.options.alignment).addClass('opens-inner');
          }
          this.changed = true;
        }
        $sub.css('visibility', '');
        if (this.options.closeOnClick) {
          this._addBodyHandler();
        }
        /**
         * Fires when the new dropdown pane is visible.
         * @event DropdownMenu#show
         */
        this.$element.trigger('show.zf.dropdownmenu', [$sub]);
      }

      /**
       * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.
       * @function
       * @param {jQuery} $elem - element with a submenu to hide
       * @param {Number} idx - index of the $tabs collection to hide
       * @private
       */

    }, {
      key: '_hide',
      value: function _hide($elem, idx) {
        var $toClose;
        if ($elem && $elem.length) {
          $toClose = $elem;
        } else if (idx !== undefined) {
          $toClose = this.$tabs.not(function (i, el) {
            return i === idx;
          });
        } else {
          $toClose = this.$element;
        }
        var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;

        if (somethingToClose) {
          $toClose.find('li.is-active').add($toClose).attr({
            'aria-expanded': false,
            'data-is-click': false
          }).removeClass('is-active');

          $toClose.find('ul.js-dropdown-active').attr({
            'aria-hidden': true
          }).removeClass('js-dropdown-active');

          if (this.changed || $toClose.find('opens-inner').length) {
            var oldClass = this.options.alignment === 'left' ? 'right' : 'left';
            $toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass('opens-inner opens-' + this.options.alignment).addClass('opens-' + oldClass);
            this.changed = false;
          }
          /**
           * Fires when the open menus are closed.
           * @event DropdownMenu#hide
           */
          this.$element.trigger('hide.zf.dropdownmenu', [$toClose]);
        }
      }

      /**
       * Destroys the plugin.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$menuItems.off('.zf.dropdownmenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');
        $(document.body).off('.zf.dropdownmenu');
        Foundation.Nest.Burn(this.$element, 'dropdown');
        Foundation.unregisterPlugin(this);
      }
    }]);

    return DropdownMenu;
  }();

  /**
   * Default settings for plugin
   */


  DropdownMenu.defaults = {
    /**
     * Disallows hover events from opening submenus
     * @option
     * @example false
     */
    disableHover: false,
    /**
     * Allow a submenu to automatically close on a mouseleave event, if not clicked open.
     * @option
     * @example true
     */
    autoclose: true,
    /**
     * Amount of time to delay opening a submenu on hover event.
     * @option
     * @example 50
     */
    hoverDelay: 50,
    /**
     * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.
     * @option
     * @example true
     */
    clickOpen: false,
    /**
     * Amount of time to delay closing a submenu on a mouseleave event.
     * @option
     * @example 500
     */

    closingTime: 200,
    /**
     * Position of the menu relative to what direction the submenus should open. Handled by JS.
     * @option
     * @example 'left'
     */
    alignment: 'left',
    /**
     * Allow clicks on the body to close any open submenus.
     * @option
     * @example true
     */
    closeOnClick: true,
    /**
     * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.
     * @option
     * @example 'vertical'
     */
    verticalClass: 'vertical',
    /**
     * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.
     * @option
     * @example 'align-right'
     */
    rightClass: 'align-right',
    /**
     * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.
     * @option
     * @example false
     */
    forceFollow: true
  };

  // Window exports
  Foundation.plugin(DropdownMenu, 'DropdownMenu');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Equalizer module.
   * @module foundation.equalizer
   */

  var Equalizer = function () {
    /**
     * Creates a new instance of Equalizer.
     * @class
     * @fires Equalizer#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Equalizer(element, options) {
      _classCallCheck(this, Equalizer);

      this.$element = element;
      this.options = $.extend({}, Equalizer.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Equalizer');
    }

    /**
     * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.
     * @private
     */


    _createClass(Equalizer, [{
      key: '_init',
      value: function _init() {
        var eqId = this.$element.attr('data-equalizer') || '';
        var $watched = this.$element.find('[data-equalizer-watch="' + eqId + '"]');

        this.$watched = $watched.length ? $watched : this.$element.find('[data-equalizer-watch]');
        this.$element.attr('data-resize', eqId || Foundation.GetYoDigits(6, 'eq'));

        this.hasNested = this.$element.find('[data-equalizer]').length > 0;
        this.isNested = this.$element.parentsUntil(document.body, '[data-equalizer]').length > 0;
        this.isOn = false;
        this._bindHandler = {
          onResizeMeBound: this._onResizeMe.bind(this),
          onPostEqualizedBound: this._onPostEqualized.bind(this)
        };

        var imgs = this.$element.find('img');
        var tooSmall;
        if (this.options.equalizeOn) {
          tooSmall = this._checkMQ();
          $(window).on('changed.zf.mediaquery', this._checkMQ.bind(this));
        } else {
          this._events();
        }
        if (tooSmall !== undefined && tooSmall === false || tooSmall === undefined) {
          if (imgs.length) {
            Foundation.onImagesLoaded(imgs, this._reflow.bind(this));
          } else {
            this._reflow();
          }
        }
      }

      /**
       * Removes event listeners if the breakpoint is too small.
       * @private
       */

    }, {
      key: '_pauseEvents',
      value: function _pauseEvents() {
        this.isOn = false;
        this.$element.off({
          '.zf.equalizer': this._bindHandler.onPostEqualizedBound,
          'resizeme.zf.trigger': this._bindHandler.onResizeMeBound
        });
      }

      /**
       * function to handle $elements resizeme.zf.trigger, with bound this on _bindHandler.onResizeMeBound
       * @private
       */

    }, {
      key: '_onResizeMe',
      value: function _onResizeMe(e) {
        this._reflow();
      }

      /**
       * function to handle $elements postequalized.zf.equalizer, with bound this on _bindHandler.onPostEqualizedBound
       * @private
       */

    }, {
      key: '_onPostEqualized',
      value: function _onPostEqualized(e) {
        if (e.target !== this.$element[0]) {
          this._reflow();
        }
      }

      /**
       * Initializes events for Equalizer.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;
        this._pauseEvents();
        if (this.hasNested) {
          this.$element.on('postequalized.zf.equalizer', this._bindHandler.onPostEqualizedBound);
        } else {
          this.$element.on('resizeme.zf.trigger', this._bindHandler.onResizeMeBound);
        }
        this.isOn = true;
      }

      /**
       * Checks the current breakpoint to the minimum required size.
       * @private
       */

    }, {
      key: '_checkMQ',
      value: function _checkMQ() {
        var tooSmall = !Foundation.MediaQuery.atLeast(this.options.equalizeOn);
        if (tooSmall) {
          if (this.isOn) {
            this._pauseEvents();
            this.$watched.css('height', 'auto');
          }
        } else {
          if (!this.isOn) {
            this._events();
          }
        }
        return tooSmall;
      }

      /**
       * A noop version for the plugin
       * @private
       */

    }, {
      key: '_killswitch',
      value: function _killswitch() {
        return;
      }

      /**
       * Calls necessary functions to update Equalizer upon DOM change
       * @private
       */

    }, {
      key: '_reflow',
      value: function _reflow() {
        if (!this.options.equalizeOnStack) {
          if (this._isStacked()) {
            this.$watched.css('height', 'auto');
            return false;
          }
        }
        if (this.options.equalizeByRow) {
          this.getHeightsByRow(this.applyHeightByRow.bind(this));
        } else {
          this.getHeights(this.applyHeight.bind(this));
        }
      }

      /**
       * Manually determines if the first 2 elements are *NOT* stacked.
       * @private
       */

    }, {
      key: '_isStacked',
      value: function _isStacked() {
        return this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;
      }

      /**
       * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
       * @param {Function} cb - A non-optional callback to return the heights array to.
       * @returns {Array} heights - An array of heights of children within Equalizer container
       */

    }, {
      key: 'getHeights',
      value: function getHeights(cb) {
        var heights = [];
        for (var i = 0, len = this.$watched.length; i < len; i++) {
          this.$watched[i].style.height = 'auto';
          heights.push(this.$watched[i].offsetHeight);
        }
        cb(heights);
      }

      /**
       * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
       * @param {Function} cb - A non-optional callback to return the heights array to.
       * @returns {Array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child
       */

    }, {
      key: 'getHeightsByRow',
      value: function getHeightsByRow(cb) {
        var lastElTopOffset = this.$watched.length ? this.$watched.first().offset().top : 0,
            groups = [],
            group = 0;
        //group by Row
        groups[group] = [];
        for (var i = 0, len = this.$watched.length; i < len; i++) {
          this.$watched[i].style.height = 'auto';
          //maybe could use this.$watched[i].offsetTop
          var elOffsetTop = $(this.$watched[i]).offset().top;
          if (elOffsetTop != lastElTopOffset) {
            group++;
            groups[group] = [];
            lastElTopOffset = elOffsetTop;
          }
          groups[group].push([this.$watched[i], this.$watched[i].offsetHeight]);
        }

        for (var j = 0, ln = groups.length; j < ln; j++) {
          var heights = $(groups[j]).map(function () {
            return this[1];
          }).get();
          var max = Math.max.apply(null, heights);
          groups[j].push(max);
        }
        cb(groups);
      }

      /**
       * Changes the CSS height property of each child in an Equalizer parent to match the tallest
       * @param {array} heights - An array of heights of children within Equalizer container
       * @fires Equalizer#preequalized
       * @fires Equalizer#postequalized
       */

    }, {
      key: 'applyHeight',
      value: function applyHeight(heights) {
        var max = Math.max.apply(null, heights);
        /**
         * Fires before the heights are applied
         * @event Equalizer#preequalized
         */
        this.$element.trigger('preequalized.zf.equalizer');

        this.$watched.css('height', max);

        /**
         * Fires when the heights have been applied
         * @event Equalizer#postequalized
         */
        this.$element.trigger('postequalized.zf.equalizer');
      }

      /**
       * Changes the CSS height property of each child in an Equalizer parent to match the tallest by row
       * @param {array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child
       * @fires Equalizer#preequalized
       * @fires Equalizer#preequalizedRow
       * @fires Equalizer#postequalizedRow
       * @fires Equalizer#postequalized
       */

    }, {
      key: 'applyHeightByRow',
      value: function applyHeightByRow(groups) {
        /**
         * Fires before the heights are applied
         */
        this.$element.trigger('preequalized.zf.equalizer');
        for (var i = 0, len = groups.length; i < len; i++) {
          var groupsILength = groups[i].length,
              max = groups[i][groupsILength - 1];
          if (groupsILength <= 2) {
            $(groups[i][0][0]).css({ 'height': 'auto' });
            continue;
          }
          /**
            * Fires before the heights per row are applied
            * @event Equalizer#preequalizedRow
            */
          this.$element.trigger('preequalizedrow.zf.equalizer');
          for (var j = 0, lenJ = groupsILength - 1; j < lenJ; j++) {
            $(groups[i][j][0]).css({ 'height': max });
          }
          /**
            * Fires when the heights per row have been applied
            * @event Equalizer#postequalizedRow
            */
          this.$element.trigger('postequalizedrow.zf.equalizer');
        }
        /**
         * Fires when the heights have been applied
         */
        this.$element.trigger('postequalized.zf.equalizer');
      }

      /**
       * Destroys an instance of Equalizer.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this._pauseEvents();
        this.$watched.css('height', 'auto');

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Equalizer;
  }();

  /**
   * Default settings for plugin
   */


  Equalizer.defaults = {
    /**
     * Enable height equalization when stacked on smaller screens.
     * @option
     * @example true
     */
    equalizeOnStack: true,
    /**
     * Enable height equalization row by row.
     * @option
     * @example false
     */
    equalizeByRow: false,
    /**
     * String representing the minimum breakpoint size the plugin should equalize heights on.
     * @option
     * @example 'medium'
     */
    equalizeOn: ''
  };

  // Window exports
  Foundation.plugin(Equalizer, 'Equalizer');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Interchange module.
   * @module foundation.interchange
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.timerAndImageLoader
   */

  var Interchange = function () {
    /**
     * Creates a new instance of Interchange.
     * @class
     * @fires Interchange#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Interchange(element, options) {
      _classCallCheck(this, Interchange);

      this.$element = element;
      this.options = $.extend({}, Interchange.defaults, options);
      this.rules = [];
      this.currentPath = '';

      this._init();
      this._events();

      Foundation.registerPlugin(this, 'Interchange');
    }

    /**
     * Initializes the Interchange plugin and calls functions to get interchange functioning on load.
     * @function
     * @private
     */


    _createClass(Interchange, [{
      key: '_init',
      value: function _init() {
        this._addBreakpoints();
        this._generateRules();
        this._reflow();
      }

      /**
       * Initializes events for Interchange.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        $(window).on('resize.zf.interchange', Foundation.util.throttle(this._reflow.bind(this), 50));
      }

      /**
       * Calls necessary functions to update Interchange upon DOM change
       * @function
       * @private
       */

    }, {
      key: '_reflow',
      value: function _reflow() {
        var match;

        // Iterate through each rule, but only save the last match
        for (var i in this.rules) {
          if (this.rules.hasOwnProperty(i)) {
            var rule = this.rules[i];

            if (window.matchMedia(rule.query).matches) {
              match = rule;
            }
          }
        }

        if (match) {
          this.replace(match.path);
        }
      }

      /**
       * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.
       * @function
       * @private
       */

    }, {
      key: '_addBreakpoints',
      value: function _addBreakpoints() {
        for (var i in Foundation.MediaQuery.queries) {
          if (Foundation.MediaQuery.queries.hasOwnProperty(i)) {
            var query = Foundation.MediaQuery.queries[i];
            Interchange.SPECIAL_QUERIES[query.name] = query.value;
          }
        }
      }

      /**
       * Checks the Interchange element for the provided media query + content pairings
       * @function
       * @private
       * @param {Object} element - jQuery object that is an Interchange instance
       * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys
       */

    }, {
      key: '_generateRules',
      value: function _generateRules(element) {
        var rulesList = [];
        var rules;

        if (this.options.rules) {
          rules = this.options.rules;
        } else {
          rules = this.$element.data('interchange').match(/\[.*?\]/g);
        }

        for (var i in rules) {
          if (rules.hasOwnProperty(i)) {
            var rule = rules[i].slice(1, -1).split(', ');
            var path = rule.slice(0, -1).join('');
            var query = rule[rule.length - 1];

            if (Interchange.SPECIAL_QUERIES[query]) {
              query = Interchange.SPECIAL_QUERIES[query];
            }

            rulesList.push({
              path: path,
              query: query
            });
          }
        }

        this.rules = rulesList;
      }

      /**
       * Update the `src` property of an image, or change the HTML of a container, to the specified path.
       * @function
       * @param {String} path - Path to the image or HTML partial.
       * @fires Interchange#replaced
       */

    }, {
      key: 'replace',
      value: function replace(path) {
        if (this.currentPath === path) return;

        var _this = this,
            trigger = 'replaced.zf.interchange';

        // Replacing images
        if (this.$element[0].nodeName === 'IMG') {
          this.$element.attr('src', path).load(function () {
            _this.currentPath = path;
          }).trigger(trigger);
        }
        // Replacing background images
        else if (path.match(/\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)) {
            this.$element.css({ 'background-image': 'url(' + path + ')' }).trigger(trigger);
          }
          // Replacing HTML
          else {
              $.get(path, function (response) {
                _this.$element.html(response).trigger(trigger);
                $(response).foundation();
                _this.currentPath = path;
              });
            }

        /**
         * Fires when content in an Interchange element is done being loaded.
         * @event Interchange#replaced
         */
        // this.$element.trigger('replaced.zf.interchange');
      }

      /**
       * Destroys an instance of interchange.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        //TODO this.
      }
    }]);

    return Interchange;
  }();

  /**
   * Default settings for plugin
   */


  Interchange.defaults = {
    /**
     * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.
     * @option
     */
    rules: null
  };

  Interchange.SPECIAL_QUERIES = {
    'landscape': 'screen and (orientation: landscape)',
    'portrait': 'screen and (orientation: portrait)',
    'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'
  };

  // Window exports
  Foundation.plugin(Interchange, 'Interchange');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Magellan module.
   * @module foundation.magellan
   */

  var Magellan = function () {
    /**
     * Creates a new instance of Magellan.
     * @class
     * @fires Magellan#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Magellan(element, options) {
      _classCallCheck(this, Magellan);

      this.$element = element;
      this.options = $.extend({}, Magellan.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Magellan');
    }

    /**
     * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.
     * @private
     */


    _createClass(Magellan, [{
      key: '_init',
      value: function _init() {
        var id = this.$element[0].id || Foundation.GetYoDigits(6, 'magellan');
        var _this = this;
        this.$targets = $('[data-magellan-target]');
        this.$links = this.$element.find('a');
        this.$element.attr({
          'data-resize': id,
          'data-scroll': id,
          'id': id
        });
        this.$active = $();
        this.scrollPos = parseInt(window.pageYOffset, 10);

        this._events();
      }

      /**
       * Calculates an array of pixel values that are the demarcation lines between locations on the page.
       * Can be invoked if new elements are added or the size of a location changes.
       * @function
       */

    }, {
      key: 'calcPoints',
      value: function calcPoints() {
        var _this = this,
            body = document.body,
            html = document.documentElement;

        this.points = [];
        this.winHeight = Math.round(Math.max(window.innerHeight, html.clientHeight));
        this.docHeight = Math.round(Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight));

        this.$targets.each(function () {
          var $tar = $(this),
              pt = Math.round($tar.offset().top - _this.options.threshold);
          $tar.targetPoint = pt;
          _this.points.push(pt);
        });
      }

      /**
       * Initializes events for Magellan.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this,
            $body = $('html, body'),
            opts = {
          duration: _this.options.animationDuration,
          easing: _this.options.animationEasing
        };
        $(window).one('load', function () {
          if (_this.options.deepLinking) {
            if (location.hash) {
              _this.scrollToLoc(location.hash);
            }
          }
          _this.calcPoints();
          _this._updateActive();
        });

        this.$element.on({
          'resizeme.zf.trigger': this.reflow.bind(this),
          'scrollme.zf.trigger': this._updateActive.bind(this)
        }).on('click.zf.magellan', 'a[href^="#"]', function (e) {
          e.preventDefault();
          var arrival = this.getAttribute('href');
          _this.scrollToLoc(arrival);
        });
      }

      /**
       * Function to scroll to a given location on the page.
       * @param {String} loc - a properly formatted jQuery id selector. Example: '#foo'
       * @function
       */

    }, {
      key: 'scrollToLoc',
      value: function scrollToLoc(loc) {
        var scrollPos = Math.round($(loc).offset().top - this.options.threshold / 2 - this.options.barOffset);

        $('html, body').stop(true).animate({ scrollTop: scrollPos }, this.options.animationDuration, this.options.animationEasing);
      }

      /**
       * Calls necessary functions to update Magellan upon DOM change
       * @function
       */

    }, {
      key: 'reflow',
      value: function reflow() {
        this.calcPoints();
        this._updateActive();
      }

      /**
       * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.
       * @private
       * @function
       * @fires Magellan#update
       */

    }, {
      key: '_updateActive',
      value: function _updateActive() /*evt, elem, scrollPos*/{
        var winPos = /*scrollPos ||*/parseInt(window.pageYOffset, 10),
            curIdx;

        if (winPos + this.winHeight === this.docHeight) {
          curIdx = this.points.length - 1;
        } else if (winPos < this.points[0]) {
          curIdx = 0;
        } else {
          var isDown = this.scrollPos < winPos,
              _this = this,
              curVisible = this.points.filter(function (p, i) {
            return isDown ? p - _this.options.barOffset <= winPos : p - _this.options.barOffset - _this.options.threshold <= winPos;
          });
          curIdx = curVisible.length ? curVisible.length - 1 : 0;
        }

        this.$active.removeClass(this.options.activeClass);
        this.$active = this.$links.eq(curIdx).addClass(this.options.activeClass);

        if (this.options.deepLinking) {
          var hash = this.$active[0].getAttribute('href');
          if (window.history.pushState) {
            window.history.pushState(null, null, hash);
          } else {
            window.location.hash = hash;
          }
        }

        this.scrollPos = winPos;
        /**
         * Fires when magellan is finished updating to the new active element.
         * @event Magellan#update
         */
        this.$element.trigger('update.zf.magellan', [this.$active]);
      }

      /**
       * Destroys an instance of Magellan and resets the url of the window.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.off('.zf.trigger .zf.magellan').find('.' + this.options.activeClass).removeClass(this.options.activeClass);

        if (this.options.deepLinking) {
          var hash = this.$active[0].getAttribute('href');
          window.location.hash.replace(hash, '');
        }

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Magellan;
  }();

  /**
   * Default settings for plugin
   */


  Magellan.defaults = {
    /**
     * Amount of time, in ms, the animated scrolling should take between locations.
     * @option
     * @example 500
     */
    animationDuration: 500,
    /**
     * Animation style to use when scrolling between locations.
     * @option
     * @example 'ease-in-out'
     */
    animationEasing: 'linear',
    /**
     * Number of pixels to use as a marker for location changes.
     * @option
     * @example 50
     */
    threshold: 50,
    /**
     * Class applied to the active locations link on the magellan container.
     * @option
     * @example 'active'
     */
    activeClass: 'active',
    /**
     * Allows the script to manipulate the url of the current page, and if supported, alter the history.
     * @option
     * @example true
     */
    deepLinking: false,
    /**
     * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.
     * @option
     * @example 25
     */
    barOffset: 0
  };

  // Window exports
  Foundation.plugin(Magellan, 'Magellan');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * OffCanvas module.
   * @module foundation.offcanvas
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.triggers
   * @requires foundation.util.motion
   */

  var OffCanvas = function () {
    /**
     * Creates a new instance of an off-canvas wrapper.
     * @class
     * @fires OffCanvas#init
     * @param {Object} element - jQuery object to initialize.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function OffCanvas(element, options) {
      _classCallCheck(this, OffCanvas);

      this.$element = element;
      this.options = $.extend({}, OffCanvas.defaults, this.$element.data(), options);
      this.$lastTrigger = $();
      this.$triggers = $();

      this._init();
      this._events();

      Foundation.registerPlugin(this, 'OffCanvas');
    }

    /**
     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).
     * @function
     * @private
     */


    _createClass(OffCanvas, [{
      key: '_init',
      value: function _init() {
        var id = this.$element.attr('id');

        this.$element.attr('aria-hidden', 'true');

        // Find triggers that affect this element and add aria-expanded to them
        this.$triggers = $(document).find('[data-open="' + id + '"], [data-close="' + id + '"], [data-toggle="' + id + '"]').attr('aria-expanded', 'false').attr('aria-controls', id);

        // Add a close trigger over the body if necessary
        if (this.options.closeOnClick) {
          if ($('.js-off-canvas-exit').length) {
            this.$exiter = $('.js-off-canvas-exit');
          } else {
            var exiter = document.createElement('div');
            exiter.setAttribute('class', 'js-off-canvas-exit');
            $('[data-off-canvas-content]').append(exiter);

            this.$exiter = $(exiter);
          }
        }

        this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, 'g').test(this.$element[0].className);

        if (this.options.isRevealed) {
          this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];
          this._setMQChecker();
        }
        if (!this.options.transitionTime) {
          this.options.transitionTime = parseFloat(window.getComputedStyle($('[data-off-canvas-wrapper]')[0]).transitionDuration) * 1000;
        }
      }

      /**
       * Adds event handlers to the off-canvas wrapper and the exit overlay.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        this.$element.off('.zf.trigger .zf.offcanvas').on({
          'open.zf.trigger': this.open.bind(this),
          'close.zf.trigger': this.close.bind(this),
          'toggle.zf.trigger': this.toggle.bind(this),
          'keydown.zf.offcanvas': this._handleKeyboard.bind(this)
        });

        if (this.options.closeOnClick && this.$exiter.length) {
          this.$exiter.on({ 'click.zf.offcanvas': this.close.bind(this) });
        }
      }

      /**
       * Applies event listener for elements that will reveal at certain breakpoints.
       * @private
       */

    }, {
      key: '_setMQChecker',
      value: function _setMQChecker() {
        var _this = this;

        $(window).on('changed.zf.mediaquery', function () {
          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {
            _this.reveal(true);
          } else {
            _this.reveal(false);
          }
        }).one('load.zf.offcanvas', function () {
          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {
            _this.reveal(true);
          }
        });
      }

      /**
       * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.
       * @param {Boolean} isRevealed - true if element should be revealed.
       * @function
       */

    }, {
      key: 'reveal',
      value: function reveal(isRevealed) {
        var $closer = this.$element.find('[data-close]');
        if (isRevealed) {
          this.close();
          this.isRevealed = true;
          // if (!this.options.forceTop) {
          //   var scrollPos = parseInt(window.pageYOffset);
          //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';
          // }
          // if (this.options.isSticky) { this._stick(); }
          this.$element.off('open.zf.trigger toggle.zf.trigger');
          if ($closer.length) {
            $closer.hide();
          }
        } else {
          this.isRevealed = false;
          // if (this.options.isSticky || !this.options.forceTop) {
          //   this.$element[0].style.transform = '';
          //   $(window).off('scroll.zf.offcanvas');
          // }
          this.$element.on({
            'open.zf.trigger': this.open.bind(this),
            'toggle.zf.trigger': this.toggle.bind(this)
          });
          if ($closer.length) {
            $closer.show();
          }
        }
      }

      /**
       * Opens the off-canvas menu.
       * @function
       * @param {Object} event - Event object passed from listener.
       * @param {jQuery} trigger - element that triggered the off-canvas to open.
       * @fires OffCanvas#opened
       */

    }, {
      key: 'open',
      value: function open(event, trigger) {
        if (this.$element.hasClass('is-open') || this.isRevealed) {
          return;
        }
        var _this = this,
            $body = $(document.body);

        if (this.options.forceTop) {
          $('body').scrollTop(0);
        }
        // window.pageYOffset = 0;

        // if (!this.options.forceTop) {
        //   var scrollPos = parseInt(window.pageYOffset);
        //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';
        //   if (this.$exiter.length) {
        //     this.$exiter[0].style.transform = 'translate(0,' + scrollPos + 'px)';
        //   }
        // }
        /**
         * Fires when the off-canvas menu opens.
         * @event OffCanvas#opened
         */
        Foundation.Move(this.options.transitionTime, this.$element, function () {
          $('[data-off-canvas-wrapper]').addClass('is-off-canvas-open is-open-' + _this.options.position);

          _this.$element.addClass('is-open');

          // if (_this.options.isSticky) {
          //   _this._stick();
          // }
        });

        this.$triggers.attr('aria-expanded', 'true');
        this.$element.attr('aria-hidden', 'false').trigger('opened.zf.offcanvas');

        if (this.options.closeOnClick) {
          this.$exiter.addClass('is-visible');
        }

        if (trigger) {
          this.$lastTrigger = trigger;
        }

        if (this.options.autoFocus) {
          this.$element.one(Foundation.transitionend(this.$element), function () {
            _this.$element.find('a, button').eq(0).focus();
          });
        }

        if (this.options.trapFocus) {
          $('[data-off-canvas-content]').attr('tabindex', '-1');
          this._trapFocus();
        }
      }

      /**
       * Traps focus within the offcanvas on open.
       * @private
       */

    }, {
      key: '_trapFocus',
      value: function _trapFocus() {
        var focusable = Foundation.Keyboard.findFocusable(this.$element),
            first = focusable.eq(0),
            last = focusable.eq(-1);

        focusable.off('.zf.offcanvas').on('keydown.zf.offcanvas', function (e) {
          if (e.which === 9 || e.keycode === 9) {
            if (e.target === last[0] && !e.shiftKey) {
              e.preventDefault();
              first.focus();
            }
            if (e.target === first[0] && e.shiftKey) {
              e.preventDefault();
              last.focus();
            }
          }
        });
      }

      /**
       * Allows the offcanvas to appear sticky utilizing translate properties.
       * @private
       */
      // OffCanvas.prototype._stick = function() {
      //   var elStyle = this.$element[0].style;
      //
      //   if (this.options.closeOnClick) {
      //     var exitStyle = this.$exiter[0].style;
      //   }
      //
      //   $(window).on('scroll.zf.offcanvas', function(e) {
      //     console.log(e);
      //     var pageY = window.pageYOffset;
      //     elStyle.transform = 'translate(0,' + pageY + 'px)';
      //     if (exitStyle !== undefined) { exitStyle.transform = 'translate(0,' + pageY + 'px)'; }
      //   });
      //   // this.$element.trigger('stuck.zf.offcanvas');
      // };
      /**
       * Closes the off-canvas menu.
       * @function
       * @param {Function} cb - optional cb to fire after closure.
       * @fires OffCanvas#closed
       */

    }, {
      key: 'close',
      value: function close(cb) {
        if (!this.$element.hasClass('is-open') || this.isRevealed) {
          return;
        }

        var _this = this;

        //  Foundation.Move(this.options.transitionTime, this.$element, function() {
        $('[data-off-canvas-wrapper]').removeClass('is-off-canvas-open is-open-' + _this.options.position);
        _this.$element.removeClass('is-open');
        // Foundation._reflow();
        // });
        this.$element.attr('aria-hidden', 'true')
        /**
         * Fires when the off-canvas menu opens.
         * @event OffCanvas#closed
         */
        .trigger('closed.zf.offcanvas');
        // if (_this.options.isSticky || !_this.options.forceTop) {
        //   setTimeout(function() {
        //     _this.$element[0].style.transform = '';
        //     $(window).off('scroll.zf.offcanvas');
        //   }, this.options.transitionTime);
        // }
        if (this.options.closeOnClick) {
          this.$exiter.removeClass('is-visible');
        }

        this.$triggers.attr('aria-expanded', 'false');
        if (this.options.trapFocus) {
          $('[data-off-canvas-content]').removeAttr('tabindex');
        }
      }

      /**
       * Toggles the off-canvas menu open or closed.
       * @function
       * @param {Object} event - Event object passed from listener.
       * @param {jQuery} trigger - element that triggered the off-canvas to open.
       */

    }, {
      key: 'toggle',
      value: function toggle(event, trigger) {
        if (this.$element.hasClass('is-open')) {
          this.close(event, trigger);
        } else {
          this.open(event, trigger);
        }
      }

      /**
       * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.
       * @function
       * @private
       */

    }, {
      key: '_handleKeyboard',
      value: function _handleKeyboard(event) {
        if (event.which !== 27) return;

        event.stopPropagation();
        event.preventDefault();
        this.close();
        this.$lastTrigger.focus();
      }

      /**
       * Destroys the offcanvas plugin.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.close();
        this.$element.off('.zf.trigger .zf.offcanvas');
        this.$exiter.off('.zf.offcanvas');

        Foundation.unregisterPlugin(this);
      }
    }]);

    return OffCanvas;
  }();

  OffCanvas.defaults = {
    /**
     * Allow the user to click outside of the menu to close it.
     * @option
     * @example true
     */
    closeOnClick: true,

    /**
     * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.
     * @option
     * @example 500
     */
    transitionTime: 0,

    /**
     * Direction the offcanvas opens from. Determines class applied to body.
     * @option
     * @example left
     */
    position: 'left',

    /**
     * Force the page to scroll to top on open.
     * @option
     * @example true
     */
    forceTop: true,

    /**
     * Allow the offcanvas to remain open for certain breakpoints.
     * @option
     * @example false
     */
    isRevealed: false,

    /**
     * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.
     * @option
     * @example reveal-for-large
     */
    revealOn: null,

    /**
     * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.
     * @option
     * @example true
     */
    autoFocus: true,

    /**
     * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.
     * @option
     * TODO improve the regex testing for this.
     * @example reveal-for-large
     */
    revealClass: 'reveal-for-',

    /**
     * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.
     * @option
     * @example true
     */
    trapFocus: false
  };

  // Window exports
  Foundation.plugin(OffCanvas, 'OffCanvas');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Orbit module.
   * @module foundation.orbit
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   * @requires foundation.util.timerAndImageLoader
   * @requires foundation.util.touch
   */

  var Orbit = function () {
    /**
    * Creates a new instance of an orbit carousel.
    * @class
    * @param {jQuery} element - jQuery object to make into an Orbit Carousel.
    * @param {Object} options - Overrides to the default plugin settings.
    */
    function Orbit(element, options) {
      _classCallCheck(this, Orbit);

      this.$element = element;
      this.options = $.extend({}, Orbit.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Orbit');
      Foundation.Keyboard.register('Orbit', {
        'ltr': {
          'ARROW_RIGHT': 'next',
          'ARROW_LEFT': 'previous'
        },
        'rtl': {
          'ARROW_LEFT': 'next',
          'ARROW_RIGHT': 'previous'
        }
      });
    }

    /**
    * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.
    * @function
    * @private
    */


    _createClass(Orbit, [{
      key: '_init',
      value: function _init() {
        this.$wrapper = this.$element.find('.' + this.options.containerClass);
        this.$slides = this.$element.find('.' + this.options.slideClass);
        var $images = this.$element.find('img'),
            initActive = this.$slides.filter('.is-active');

        if (!initActive.length) {
          this.$slides.eq(0).addClass('is-active');
        }

        if (!this.options.useMUI) {
          this.$slides.addClass('no-motionui');
        }

        if ($images.length) {
          Foundation.onImagesLoaded($images, this._prepareForOrbit.bind(this));
        } else {
          this._prepareForOrbit(); //hehe
        }

        if (this.options.bullets) {
          this._loadBullets();
        }

        this._events();

        if (this.options.autoPlay && this.$slides.length > 1) {
          this.geoSync();
        }

        if (this.options.accessible) {
          // allow wrapper to be focusable to enable arrow navigation
          this.$wrapper.attr('tabindex', 0);
        }
      }

      /**
      * Creates a jQuery collection of bullets, if they are being used.
      * @function
      * @private
      */

    }, {
      key: '_loadBullets',
      value: function _loadBullets() {
        this.$bullets = this.$element.find('.' + this.options.boxOfBullets).find('button');
      }

      /**
      * Sets a `timer` object on the orbit, and starts the counter for the next slide.
      * @function
      */

    }, {
      key: 'geoSync',
      value: function geoSync() {
        var _this = this;
        this.timer = new Foundation.Timer(this.$element, {
          duration: this.options.timerDelay,
          infinite: false
        }, function () {
          _this.changeSlide(true);
        });
        this.timer.start();
      }

      /**
      * Sets wrapper and slide heights for the orbit.
      * @function
      * @private
      */

    }, {
      key: '_prepareForOrbit',
      value: function _prepareForOrbit() {
        var _this = this;
        this._setWrapperHeight(function (max) {
          _this._setSlideHeight(max);
        });
      }

      /**
      * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.
      * @function
      * @private
      * @param {Function} cb - a callback function to fire when complete.
      */

    }, {
      key: '_setWrapperHeight',
      value: function _setWrapperHeight(cb) {
        //rewrite this to `for` loop
        var max = 0,
            temp,
            counter = 0;

        this.$slides.each(function () {
          temp = this.getBoundingClientRect().height;
          $(this).attr('data-slide', counter);

          if (counter) {
            //if not the first slide, set css position and display property
            $(this).css({ 'position': 'relative', 'display': 'none' });
          }
          max = temp > max ? temp : max;
          counter++;
        });

        if (counter === this.$slides.length) {
          this.$wrapper.css({ 'height': max }); //only change the wrapper height property once.
          cb(max); //fire callback with max height dimension.
        }
      }

      /**
      * Sets the max-height of each slide.
      * @function
      * @private
      */

    }, {
      key: '_setSlideHeight',
      value: function _setSlideHeight(height) {
        this.$slides.each(function () {
          $(this).css('max-height', height);
        });
      }

      /**
      * Adds event listeners to basically everything within the element.
      * @function
      * @private
      */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;

        //***************************************
        //**Now using custom event - thanks to:**
        //**      Yohai Ararat of Toronto      **
        //***************************************
        if (this.$slides.length > 1) {

          if (this.options.swipe) {
            this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit').on('swipeleft.zf.orbit', function (e) {
              e.preventDefault();
              _this.changeSlide(true);
            }).on('swiperight.zf.orbit', function (e) {
              e.preventDefault();
              _this.changeSlide(false);
            });
          }
          //***************************************

          if (this.options.autoPlay) {
            this.$slides.on('click.zf.orbit', function () {
              _this.$element.data('clickedOn', _this.$element.data('clickedOn') ? false : true);
              _this.timer[_this.$element.data('clickedOn') ? 'pause' : 'start']();
            });

            if (this.options.pauseOnHover) {
              this.$element.on('mouseenter.zf.orbit', function () {
                _this.timer.pause();
              }).on('mouseleave.zf.orbit', function () {
                if (!_this.$element.data('clickedOn')) {
                  _this.timer.start();
                }
              });
            }
          }

          if (this.options.navButtons) {
            var $controls = this.$element.find('.' + this.options.nextClass + ', .' + this.options.prevClass);
            $controls.attr('tabindex', 0)
            //also need to handle enter/return and spacebar key presses
            .on('click.zf.orbit touchend.zf.orbit', function (e) {
              e.preventDefault();
              _this.changeSlide($(this).hasClass(_this.options.nextClass));
            });
          }

          if (this.options.bullets) {
            this.$bullets.on('click.zf.orbit touchend.zf.orbit', function () {
              if (/is-active/g.test(this.className)) {
                return false;
              } //if this is active, kick out of function.
              var idx = $(this).data('slide'),
                  ltr = idx > _this.$slides.filter('.is-active').data('slide'),
                  $slide = _this.$slides.eq(idx);

              _this.changeSlide(ltr, $slide, idx);
            });
          }

          this.$wrapper.add(this.$bullets).on('keydown.zf.orbit', function (e) {
            // handle keyboard event with keyboard util
            Foundation.Keyboard.handleKey(e, 'Orbit', {
              next: function () {
                _this.changeSlide(true);
              },
              previous: function () {
                _this.changeSlide(false);
              },
              handled: function () {
                // if bullet is focused, make sure focus moves
                if ($(e.target).is(_this.$bullets)) {
                  _this.$bullets.filter('.is-active').focus();
                }
              }
            });
          });
        }
      }

      /**
      * Changes the current slide to a new one.
      * @function
      * @param {Boolean} isLTR - flag if the slide should move left to right.
      * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.
      * @param {Number} idx - the index of the new slide in its collection, if one chosen.
      * @fires Orbit#slidechange
      */

    }, {
      key: 'changeSlide',
      value: function changeSlide(isLTR, chosenSlide, idx) {
        var $curSlide = this.$slides.filter('.is-active').eq(0);

        if (/mui/g.test($curSlide[0].className)) {
          return false;
        } //if the slide is currently animating, kick out of the function

        var $firstSlide = this.$slides.first(),
            $lastSlide = this.$slides.last(),
            dirIn = isLTR ? 'Right' : 'Left',
            dirOut = isLTR ? 'Left' : 'Right',
            _this = this,
            $newSlide;

        if (!chosenSlide) {
          //most of the time, this will be auto played or clicked from the navButtons.
          $newSlide = isLTR ? //if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!
          this.options.infiniteWrap ? $curSlide.next('.' + this.options.slideClass).length ? $curSlide.next('.' + this.options.slideClass) : $firstSlide : $curSlide.next('.' + this.options.slideClass) : //pick next slide if moving left to right
          this.options.infiniteWrap ? $curSlide.prev('.' + this.options.slideClass).length ? $curSlide.prev('.' + this.options.slideClass) : $lastSlide : $curSlide.prev('.' + this.options.slideClass); //pick prev slide if moving right to left
        } else {
          $newSlide = chosenSlide;
        }

        if ($newSlide.length) {
          if (this.options.bullets) {
            idx = idx || this.$slides.index($newSlide); //grab index to update bullets
            this._updateBullets(idx);
          }

          if (this.options.useMUI) {
            Foundation.Motion.animateIn($newSlide.addClass('is-active').css({ 'position': 'absolute', 'top': 0 }), this.options['animInFrom' + dirIn], function () {
              $newSlide.css({ 'position': 'relative', 'display': 'block' }).attr('aria-live', 'polite');
            });

            Foundation.Motion.animateOut($curSlide.removeClass('is-active'), this.options['animOutTo' + dirOut], function () {
              $curSlide.removeAttr('aria-live');
              if (_this.options.autoPlay && !_this.timer.isPaused) {
                _this.timer.restart();
              }
              //do stuff?
            });
          } else {
            $curSlide.removeClass('is-active is-in').removeAttr('aria-live').hide();
            $newSlide.addClass('is-active is-in').attr('aria-live', 'polite').show();
            if (this.options.autoPlay && !this.timer.isPaused) {
              this.timer.restart();
            }
          }
          /**
          * Triggers when the slide has finished animating in.
          * @event Orbit#slidechange
          */
          this.$element.trigger('slidechange.zf.orbit', [$newSlide]);
        }
      }

      /**
      * Updates the active state of the bullets, if displayed.
      * @function
      * @private
      * @param {Number} idx - the index of the current slide.
      */

    }, {
      key: '_updateBullets',
      value: function _updateBullets(idx) {
        var $oldBullet = this.$element.find('.' + this.options.boxOfBullets).find('.is-active').removeClass('is-active').blur(),
            span = $oldBullet.find('span:last').detach(),
            $newBullet = this.$bullets.eq(idx).addClass('is-active').append(span);
      }

      /**
      * Destroys the carousel and hides the element.
      * @function
      */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();
        Foundation.unregisterPlugin(this);
      }
    }]);

    return Orbit;
  }();

  Orbit.defaults = {
    /**
    * Tells the JS to look for and loadBullets.
    * @option
    * @example true
    */
    bullets: true,
    /**
    * Tells the JS to apply event listeners to nav buttons
    * @option
    * @example true
    */
    navButtons: true,
    /**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-in-right'
    */
    animInFromRight: 'slide-in-right',
    /**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-out-right'
    */
    animOutToRight: 'slide-out-right',
    /**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-in-left'
    *
    */
    animInFromLeft: 'slide-in-left',
    /**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-out-left'
    */
    animOutToLeft: 'slide-out-left',
    /**
    * Allows Orbit to automatically animate on page load.
    * @option
    * @example true
    */
    autoPlay: true,
    /**
    * Amount of time, in ms, between slide transitions
    * @option
    * @example 5000
    */
    timerDelay: 5000,
    /**
    * Allows Orbit to infinitely loop through the slides
    * @option
    * @example true
    */
    infiniteWrap: true,
    /**
    * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library
    * @option
    * @example true
    */
    swipe: true,
    /**
    * Allows the timing function to pause animation on hover.
    * @option
    * @example true
    */
    pauseOnHover: true,
    /**
    * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys
    * @option
    * @example true
    */
    accessible: true,
    /**
    * Class applied to the container of Orbit
    * @option
    * @example 'orbit-container'
    */
    containerClass: 'orbit-container',
    /**
    * Class applied to individual slides.
    * @option
    * @example 'orbit-slide'
    */
    slideClass: 'orbit-slide',
    /**
    * Class applied to the bullet container. You're welcome.
    * @option
    * @example 'orbit-bullets'
    */
    boxOfBullets: 'orbit-bullets',
    /**
    * Class applied to the `next` navigation button.
    * @option
    * @example 'orbit-next'
    */
    nextClass: 'orbit-next',
    /**
    * Class applied to the `previous` navigation button.
    * @option
    * @example 'orbit-previous'
    */
    prevClass: 'orbit-previous',
    /**
    * Boolean to flag the js to use motion ui classes or not. Default to true for backwards compatability.
    * @option
    * @example true
    */
    useMUI: true
  };

  // Window exports
  Foundation.plugin(Orbit, 'Orbit');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * ResponsiveMenu module.
   * @module foundation.responsiveMenu
   * @requires foundation.util.triggers
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.accordionMenu
   * @requires foundation.util.drilldown
   * @requires foundation.util.dropdown-menu
   */

  var ResponsiveMenu = function () {
    /**
     * Creates a new instance of a responsive menu.
     * @class
     * @fires ResponsiveMenu#init
     * @param {jQuery} element - jQuery object to make into a dropdown menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function ResponsiveMenu(element, options) {
      _classCallCheck(this, ResponsiveMenu);

      this.$element = $(element);
      this.rules = this.$element.data('responsive-menu');
      this.currentMq = null;
      this.currentPlugin = null;

      this._init();
      this._events();

      Foundation.registerPlugin(this, 'ResponsiveMenu');
    }

    /**
     * Initializes the Menu by parsing the classes from the 'data-ResponsiveMenu' attribute on the element.
     * @function
     * @private
     */


    _createClass(ResponsiveMenu, [{
      key: '_init',
      value: function _init() {
        // The first time an Interchange plugin is initialized, this.rules is converted from a string of "classes" to an object of rules
        if (typeof this.rules === 'string') {
          var rulesTree = {};

          // Parse rules from "classes" pulled from data attribute
          var rules = this.rules.split(' ');

          // Iterate through every rule found
          for (var i = 0; i < rules.length; i++) {
            var rule = rules[i].split('-');
            var ruleSize = rule.length > 1 ? rule[0] : 'small';
            var rulePlugin = rule.length > 1 ? rule[1] : rule[0];

            if (MenuPlugins[rulePlugin] !== null) {
              rulesTree[ruleSize] = MenuPlugins[rulePlugin];
            }
          }

          this.rules = rulesTree;
        }

        if (!$.isEmptyObject(this.rules)) {
          this._checkMediaQueries();
        }
      }

      /**
       * Initializes events for the Menu.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;

        $(window).on('changed.zf.mediaquery', function () {
          _this._checkMediaQueries();
        });
        // $(window).on('resize.zf.ResponsiveMenu', function() {
        //   _this._checkMediaQueries();
        // });
      }

      /**
       * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.
       * @function
       * @private
       */

    }, {
      key: '_checkMediaQueries',
      value: function _checkMediaQueries() {
        var matchedMq,
            _this = this;
        // Iterate through each rule and find the last matching rule
        $.each(this.rules, function (key) {
          if (Foundation.MediaQuery.atLeast(key)) {
            matchedMq = key;
          }
        });

        // No match? No dice
        if (!matchedMq) return;

        // Plugin already initialized? We good
        if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return;

        // Remove existing plugin-specific CSS classes
        $.each(MenuPlugins, function (key, value) {
          _this.$element.removeClass(value.cssClass);
        });

        // Add the CSS class for the new plugin
        this.$element.addClass(this.rules[matchedMq].cssClass);

        // Create an instance of the new plugin
        if (this.currentPlugin) this.currentPlugin.destroy();
        this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});
      }

      /**
       * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.currentPlugin.destroy();
        $(window).off('.zf.ResponsiveMenu');
        Foundation.unregisterPlugin(this);
      }
    }]);

    return ResponsiveMenu;
  }();

  ResponsiveMenu.defaults = {};

  // The plugin matches the plugin classes with these plugin instances.
  var MenuPlugins = {
    dropdown: {
      cssClass: 'dropdown',
      plugin: Foundation._plugins['dropdown-menu'] || null
    },
    drilldown: {
      cssClass: 'drilldown',
      plugin: Foundation._plugins['drilldown'] || null
    },
    accordion: {
      cssClass: 'accordion-menu',
      plugin: Foundation._plugins['accordion-menu'] || null
    }
  };

  // Window exports
  Foundation.plugin(ResponsiveMenu, 'ResponsiveMenu');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * ResponsiveToggle module.
   * @module foundation.responsiveToggle
   * @requires foundation.util.mediaQuery
   */

  var ResponsiveToggle = function () {
    /**
     * Creates a new instance of Tab Bar.
     * @class
     * @fires ResponsiveToggle#init
     * @param {jQuery} element - jQuery object to attach tab bar functionality to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function ResponsiveToggle(element, options) {
      _classCallCheck(this, ResponsiveToggle);

      this.$element = $(element);
      this.options = $.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);

      this._init();
      this._events();

      Foundation.registerPlugin(this, 'ResponsiveToggle');
    }

    /**
     * Initializes the tab bar by finding the target element, toggling element, and running update().
     * @function
     * @private
     */


    _createClass(ResponsiveToggle, [{
      key: '_init',
      value: function _init() {
        var targetID = this.$element.data('responsive-toggle');
        if (!targetID) {
          console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');
        }

        this.$targetMenu = $('#' + targetID);
        this.$toggler = this.$element.find('[data-toggle]');

        this._update();
      }

      /**
       * Adds necessary event handlers for the tab bar to work.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;

        this._updateMqHandler = this._update.bind(this);

        $(window).on('changed.zf.mediaquery', this._updateMqHandler);

        this.$toggler.on('click.zf.responsiveToggle', this.toggleMenu.bind(this));
      }

      /**
       * Checks the current media query to determine if the tab bar should be visible or hidden.
       * @function
       * @private
       */

    }, {
      key: '_update',
      value: function _update() {
        // Mobile
        if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {
          this.$element.show();
          this.$targetMenu.hide();
        }

        // Desktop
        else {
            this.$element.hide();
            this.$targetMenu.show();
          }
      }

      /**
       * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.
       * @function
       * @fires ResponsiveToggle#toggled
       */

    }, {
      key: 'toggleMenu',
      value: function toggleMenu() {
        if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {
          this.$targetMenu.toggle(0);

          /**
           * Fires when the element attached to the tab bar toggles.
           * @event ResponsiveToggle#toggled
           */
          this.$element.trigger('toggled.zf.responsiveToggle');
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.off('.zf.responsiveToggle');
        this.$toggler.off('.zf.responsiveToggle');

        $(window).off('changed.zf.mediaquery', this._updateMqHandler);

        Foundation.unregisterPlugin(this);
      }
    }]);

    return ResponsiveToggle;
  }();

  ResponsiveToggle.defaults = {
    /**
     * The breakpoint after which the menu is always shown, and the tab bar is hidden.
     * @option
     * @example 'medium'
     */
    hideFor: 'medium'
  };

  // Window exports
  Foundation.plugin(ResponsiveToggle, 'ResponsiveToggle');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Reveal module.
   * @module foundation.reveal
   * @requires foundation.util.keyboard
   * @requires foundation.util.box
   * @requires foundation.util.triggers
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.motion if using animations
   */

  var Reveal = function () {
    /**
     * Creates a new instance of Reveal.
     * @class
     * @param {jQuery} element - jQuery object to use for the modal.
     * @param {Object} options - optional parameters.
     */
    function Reveal(element, options) {
      _classCallCheck(this, Reveal);

      this.$element = element;
      this.options = $.extend({}, Reveal.defaults, this.$element.data(), options);
      this._init();

      Foundation.registerPlugin(this, 'Reveal');
      Foundation.Keyboard.register('Reveal', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ESCAPE': 'close',
        'TAB': 'tab_forward',
        'SHIFT_TAB': 'tab_backward'
      });
    }

    /**
     * Initializes the modal by adding the overlay and close buttons, (if selected).
     * @private
     */


    _createClass(Reveal, [{
      key: '_init',
      value: function _init() {
        this.id = this.$element.attr('id');
        this.isActive = false;
        this.cached = { mq: Foundation.MediaQuery.current };
        this.isMobile = mobileSniff();

        this.$anchor = $('[data-open="' + this.id + '"]').length ? $('[data-open="' + this.id + '"]') : $('[data-toggle="' + this.id + '"]');
        this.$anchor.attr({
          'aria-controls': this.id,
          'aria-haspopup': true,
          'tabindex': 0
        });

        if (this.options.fullScreen || this.$element.hasClass('full')) {
          this.options.fullScreen = true;
          this.options.overlay = false;
        }
        if (this.options.overlay && !this.$overlay) {
          this.$overlay = this._makeOverlay(this.id);
        }

        this.$element.attr({
          'role': 'dialog',
          'aria-hidden': true,
          'data-yeti-box': this.id,
          'data-resize': this.id
        });

        if (this.$overlay) {
          this.$element.detach().appendTo(this.$overlay);
        } else {
          this.$element.detach().appendTo($('body'));
          this.$element.addClass('without-overlay');
        }
        this._events();
        if (this.options.deepLink && window.location.hash === '#' + this.id) {
          $(window).one('load.zf.reveal', this.open.bind(this));
        }
      }

      /**
       * Creates an overlay div to display behind the modal.
       * @private
       */

    }, {
      key: '_makeOverlay',
      value: function _makeOverlay(id) {
        var $overlay = $('<div></div>').addClass('reveal-overlay').appendTo('body');
        return $overlay;
      }

      /**
       * Updates position of modal
       * TODO:  Figure out if we actually need to cache these values or if it doesn't matter
       * @private
       */

    }, {
      key: '_updatePosition',
      value: function _updatePosition() {
        var width = this.$element.outerWidth();
        var outerWidth = $(window).width();
        var height = this.$element.outerHeight();
        var outerHeight = $(window).height();
        var left, top;
        if (this.options.hOffset === 'auto') {
          left = parseInt((outerWidth - width) / 2, 10);
        } else {
          left = parseInt(this.options.hOffset, 10);
        }
        if (this.options.vOffset === 'auto') {
          if (height > outerHeight) {
            top = parseInt(Math.min(100, outerHeight / 10), 10);
          } else {
            top = parseInt((outerHeight - height) / 4, 10);
          }
        } else {
          top = parseInt(this.options.vOffset, 10);
        }
        this.$element.css({ top: top + 'px' });
        // only worry about left if we don't have an overlay or we havea  horizontal offset,
        // otherwise we're perfectly in the middle
        if (!this.$overlay || this.options.hOffset !== 'auto') {
          this.$element.css({ left: left + 'px' });
          this.$element.css({ margin: '0px' });
        }
      }

      /**
       * Adds event handlers for the modal.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this2 = this;

        var _this = this;

        this.$element.on({
          'open.zf.trigger': this.open.bind(this),
          'close.zf.trigger': function (event, $element) {
            if (event.target === _this.$element[0] || $(event.target).parents('[data-closable]')[0] === $element) {
              // only close reveal when it's explicitly called
              return _this2.close.apply(_this2);
            }
          },
          'toggle.zf.trigger': this.toggle.bind(this),
          'resizeme.zf.trigger': function () {
            _this._updatePosition();
          }
        });

        if (this.$anchor.length) {
          this.$anchor.on('keydown.zf.reveal', function (e) {
            if (e.which === 13 || e.which === 32) {
              e.stopPropagation();
              e.preventDefault();
              _this.open();
            }
          });
        }

        if (this.options.closeOnClick && this.options.overlay) {
          this.$overlay.off('.zf.reveal').on('click.zf.reveal', function (e) {
            if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {
              return;
            }
            _this.close();
          });
        }
        if (this.options.deepLink) {
          $(window).on('popstate.zf.reveal:' + this.id, this._handleState.bind(this));
        }
      }

      /**
       * Handles modal methods on back/forward button clicks or any other event that triggers popstate.
       * @private
       */

    }, {
      key: '_handleState',
      value: function _handleState(e) {
        if (window.location.hash === '#' + this.id && !this.isActive) {
          this.open();
        } else {
          this.close();
        }
      }

      /**
       * Opens the modal controlled by `this.$anchor`, and closes all others by default.
       * @function
       * @fires Reveal#closeme
       * @fires Reveal#open
       */

    }, {
      key: 'open',
      value: function open() {
        var _this3 = this;

        if (this.options.deepLink) {
          var hash = '#' + this.id;

          if (window.history.pushState) {
            window.history.pushState(null, null, hash);
          } else {
            window.location.hash = hash;
          }
        }

        this.isActive = true;

        // Make elements invisible, but remove display: none so we can get size and positioning
        this.$element.css({ 'visibility': 'hidden' }).show().scrollTop(0);
        if (this.options.overlay) {
          this.$overlay.css({ 'visibility': 'hidden' }).show();
        }

        this._updatePosition();

        this.$element.hide().css({ 'visibility': '' });

        if (this.$overlay) {
          this.$overlay.css({ 'visibility': '' }).hide();
          if (this.$element.hasClass('fast')) {
            this.$overlay.addClass('fast');
          } else if (this.$element.hasClass('slow')) {
            this.$overlay.addClass('slow');
          }
        }

        if (!this.options.multipleOpened) {
          /**
           * Fires immediately before the modal opens.
           * Closes any other modals that are currently open
           * @event Reveal#closeme
           */
          this.$element.trigger('closeme.zf.reveal', this.id);
        }
        // Motion UI method of reveal
        if (this.options.animationIn) {
          var _this;

          (function () {
            var afterAnimationFocus = function () {
              _this.$element.attr({
                'aria-hidden': false,
                'tabindex': -1
              }).focus();
              console.log('focus');
            };

            _this = _this3;

            if (_this3.options.overlay) {
              Foundation.Motion.animateIn(_this3.$overlay, 'fade-in');
            }
            Foundation.Motion.animateIn(_this3.$element, _this3.options.animationIn, function () {
              _this3.focusableElements = Foundation.Keyboard.findFocusable(_this3.$element);
              afterAnimationFocus();
            });
          })();
        }
        // jQuery method of reveal
        else {
            if (this.options.overlay) {
              this.$overlay.show(0);
            }
            this.$element.show(this.options.showDelay);
          }

        // handle accessibility
        this.$element.attr({
          'aria-hidden': false,
          'tabindex': -1
        }).focus();

        /**
         * Fires when the modal has successfully opened.
         * @event Reveal#open
         */
        this.$element.trigger('open.zf.reveal');

        if (this.isMobile) {
          this.originalScrollPos = window.pageYOffset;
          $('html, body').addClass('is-reveal-open');
        } else {
          $('body').addClass('is-reveal-open');
        }

        setTimeout(function () {
          _this3._extraHandlers();
        }, 0);
      }

      /**
       * Adds extra event handlers for the body and window if necessary.
       * @private
       */

    }, {
      key: '_extraHandlers',
      value: function _extraHandlers() {
        var _this = this;
        this.focusableElements = Foundation.Keyboard.findFocusable(this.$element);

        if (!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen) {
          $('body').on('click.zf.reveal', function (e) {
            if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {
              return;
            }
            _this.close();
          });
        }

        if (this.options.closeOnEsc) {
          $(window).on('keydown.zf.reveal', function (e) {
            Foundation.Keyboard.handleKey(e, 'Reveal', {
              close: function () {
                if (_this.options.closeOnEsc) {
                  _this.close();
                  _this.$anchor.focus();
                }
              }
            });
          });
        }

        // lock focus within modal while tabbing
        this.$element.on('keydown.zf.reveal', function (e) {
          var $target = $(this);
          // handle keyboard event with keyboard util
          Foundation.Keyboard.handleKey(e, 'Reveal', {
            tab_forward: function () {
              if (_this.$element.find(':focus').is(_this.focusableElements.eq(-1))) {
                // left modal downwards, setting focus to first element
                _this.focusableElements.eq(0).focus();
                return true;
              }
              if (_this.focusableElements.length === 0) {
                // no focusable elements inside the modal at all, prevent tabbing in general
                return true;
              }
            },
            tab_backward: function () {
              if (_this.$element.find(':focus').is(_this.focusableElements.eq(0)) || _this.$element.is(':focus')) {
                // left modal upwards, setting focus to last element
                _this.focusableElements.eq(-1).focus();
                return true;
              }
              if (_this.focusableElements.length === 0) {
                // no focusable elements inside the modal at all, prevent tabbing in general
                return true;
              }
            },
            open: function () {
              if (_this.$element.find(':focus').is(_this.$element.find('[data-close]'))) {
                setTimeout(function () {
                  // set focus back to anchor if close button has been activated
                  _this.$anchor.focus();
                }, 1);
              } else if ($target.is(_this.focusableElements)) {
                // dont't trigger if acual element has focus (i.e. inputs, links, ...)
                _this.open();
              }
            },
            close: function () {
              if (_this.options.closeOnEsc) {
                _this.close();
                _this.$anchor.focus();
              }
            },
            handled: function (preventDefault) {
              if (preventDefault) {
                e.preventDefault();
              }
            }
          });
        });
      }

      /**
       * Closes the modal.
       * @function
       * @fires Reveal#closed
       */

    }, {
      key: 'close',
      value: function close() {
        if (!this.isActive || !this.$element.is(':visible')) {
          return false;
        }
        var _this = this;

        // Motion UI method of hiding
        if (this.options.animationOut) {
          if (this.options.overlay) {
            Foundation.Motion.animateOut(this.$overlay, 'fade-out', finishUp);
          } else {
            finishUp();
          }

          Foundation.Motion.animateOut(this.$element, this.options.animationOut);
        }
        // jQuery method of hiding
        else {
            if (this.options.overlay) {
              this.$overlay.hide(0, finishUp);
            } else {
              finishUp();
            }

            this.$element.hide(this.options.hideDelay);
          }

        // Conditionals to remove extra event listeners added on open
        if (this.options.closeOnEsc) {
          $(window).off('keydown.zf.reveal');
        }

        if (!this.options.overlay && this.options.closeOnClick) {
          $('body').off('click.zf.reveal');
        }

        this.$element.off('keydown.zf.reveal');

        function finishUp() {
          if (_this.isMobile) {
            $('html, body').removeClass('is-reveal-open');
            if (_this.originalScrollPos) {
              $('body').scrollTop(_this.originalScrollPos);
              _this.originalScrollPos = null;
            }
          } else {
            $('body').removeClass('is-reveal-open');
          }

          _this.$element.attr('aria-hidden', true);

          /**
          * Fires when the modal is done closing.
          * @event Reveal#closed
          */
          _this.$element.trigger('closed.zf.reveal');
        }

        /**
        * Resets the modal content
        * This prevents a running video to keep going in the background
        */
        if (this.options.resetOnClose) {
          this.$element.html(this.$element.html());
        }

        this.isActive = false;
        if (_this.options.deepLink) {
          if (window.history.replaceState) {
            window.history.replaceState("", document.title, window.location.pathname);
          } else {
            window.location.hash = '';
          }
        }
      }

      /**
       * Toggles the open/closed state of a modal.
       * @function
       */

    }, {
      key: 'toggle',
      value: function toggle() {
        if (this.isActive) {
          this.close();
        } else {
          this.open();
        }
      }
    }, {
      key: 'destroy',


      /**
       * Destroys an instance of a modal.
       * @function
       */
      value: function destroy() {
        if (this.options.overlay) {
          this.$element.appendTo($('body')); // move $element outside of $overlay to prevent error unregisterPlugin()
          this.$overlay.hide().off().remove();
        }
        this.$element.hide().off();
        this.$anchor.off('.zf');
        $(window).off('.zf.reveal:' + this.id);

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Reveal;
  }();

  Reveal.defaults = {
    /**
     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
     * @option
     * @example 'slide-in-left'
     */
    animationIn: '',
    /**
     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
     * @option
     * @example 'slide-out-right'
     */
    animationOut: '',
    /**
     * Time, in ms, to delay the opening of a modal after a click if no animation used.
     * @option
     * @example 10
     */
    showDelay: 0,
    /**
     * Time, in ms, to delay the closing of a modal after a click if no animation used.
     * @option
     * @example 10
     */
    hideDelay: 0,
    /**
     * Allows a click on the body/overlay to close the modal.
     * @option
     * @example true
     */
    closeOnClick: true,
    /**
     * Allows the modal to close if the user presses the `ESCAPE` key.
     * @option
     * @example true
     */
    closeOnEsc: true,
    /**
     * If true, allows multiple modals to be displayed at once.
     * @option
     * @example false
     */
    multipleOpened: false,
    /**
     * Distance, in pixels, the modal should push down from the top of the screen.
     * @option
     * @example auto
     */
    vOffset: 'auto',
    /**
     * Distance, in pixels, the modal should push in from the side of the screen.
     * @option
     * @example auto
     */
    hOffset: 'auto',
    /**
     * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.
     * @option
     * @example false
     */
    fullScreen: false,
    /**
     * Percentage of screen height the modal should push up from the bottom of the view.
     * @option
     * @example 10
     */
    btmOffsetPct: 10,
    /**
     * Allows the modal to generate an overlay div, which will cover the view when modal opens.
     * @option
     * @example true
     */
    overlay: true,
    /**
     * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.
     * @option
     * @example false
     */
    resetOnClose: false,
    /**
     * Allows the modal to alter the url on open/close, and allows the use of the `back` button to close modals. ALSO, allows a modal to auto-maniacally open on page load IF the hash === the modal's user-set id.
     * @option
     * @example false
     */
    deepLink: false
  };

  // Window exports
  Foundation.plugin(Reveal, 'Reveal');

  function iPhoneSniff() {
    return (/iP(ad|hone|od).*OS/.test(window.navigator.userAgent)
    );
  }

  function androidSniff() {
    return (/Android/.test(window.navigator.userAgent)
    );
  }

  function mobileSniff() {
    return iPhoneSniff() || androidSniff();
  }
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Slider module.
   * @module foundation.slider
   * @requires foundation.util.motion
   * @requires foundation.util.triggers
   * @requires foundation.util.keyboard
   * @requires foundation.util.touch
   */

  var Slider = function () {
    /**
     * Creates a new instance of a drilldown menu.
     * @class
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Slider(element, options) {
      _classCallCheck(this, Slider);

      this.$element = element;
      this.options = $.extend({}, Slider.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Slider');
      Foundation.Keyboard.register('Slider', {
        'ltr': {
          'ARROW_RIGHT': 'increase',
          'ARROW_UP': 'increase',
          'ARROW_DOWN': 'decrease',
          'ARROW_LEFT': 'decrease',
          'SHIFT_ARROW_RIGHT': 'increase_fast',
          'SHIFT_ARROW_UP': 'increase_fast',
          'SHIFT_ARROW_DOWN': 'decrease_fast',
          'SHIFT_ARROW_LEFT': 'decrease_fast'
        },
        'rtl': {
          'ARROW_LEFT': 'increase',
          'ARROW_RIGHT': 'decrease',
          'SHIFT_ARROW_LEFT': 'increase_fast',
          'SHIFT_ARROW_RIGHT': 'decrease_fast'
        }
      });
    }

    /**
     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).
     * @function
     * @private
     */


    _createClass(Slider, [{
      key: '_init',
      value: function _init() {
        this.inputs = this.$element.find('input');
        this.handles = this.$element.find('[data-slider-handle]');

        this.$handle = this.handles.eq(0);
        this.$input = this.inputs.length ? this.inputs.eq(0) : $('#' + this.$handle.attr('aria-controls'));
        this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);

        var isDbl = false,
            _this = this;
        if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {
          this.options.disabled = true;
          this.$element.addClass(this.options.disabledClass);
        }
        if (!this.inputs.length) {
          this.inputs = $().add(this.$input);
          this.options.binding = true;
        }
        this._setInitAttr(0);
        this._events(this.$handle);

        if (this.handles[1]) {
          this.options.doubleSided = true;
          this.$handle2 = this.handles.eq(1);
          this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : $('#' + this.$handle2.attr('aria-controls'));

          if (!this.inputs[1]) {
            this.inputs = this.inputs.add(this.$input2);
          }
          isDbl = true;

          this._setHandlePos(this.$handle, this.options.initialStart, true, function () {

            _this._setHandlePos(_this.$handle2, _this.options.initialEnd, true);
          });
          // this.$handle.triggerHandler('click.zf.slider');
          this._setInitAttr(1);
          this._events(this.$handle2);
        }

        if (!isDbl) {
          this._setHandlePos(this.$handle, this.options.initialStart, true);
        }
      }

      /**
       * Sets the position of the selected handle and fill bar.
       * @function
       * @private
       * @param {jQuery} $hndl - the selected handle to move.
       * @param {Number} location - floating point between the start and end values of the slider bar.
       * @param {Function} cb - callback function to fire on completion.
       * @fires Slider#moved
       * @fires Slider#changed
       */

    }, {
      key: '_setHandlePos',
      value: function _setHandlePos($hndl, location, noInvert, cb) {
        // don't move if the slider has been disabled since its initialization
        if (this.$element.hasClass(this.options.disabledClass)) {
          return;
        }
        //might need to alter that slightly for bars that will have odd number selections.
        location = parseFloat(location); //on input change events, convert string to number...grumble.

        // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max
        if (location < this.options.start) {
          location = this.options.start;
        } else if (location > this.options.end) {
          location = this.options.end;
        }

        var isDbl = this.options.doubleSided;

        if (isDbl) {
          //this block is to prevent 2 handles from crossing eachother. Could/should be improved.
          if (this.handles.index($hndl) === 0) {
            var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));
            location = location >= h2Val ? h2Val - this.options.step : location;
          } else {
            var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));
            location = location <= h1Val ? h1Val + this.options.step : location;
          }
        }

        //this is for single-handled vertical sliders, it adjusts the value to account for the slider being "upside-down"
        //for click and drag events, it's weird due to the scale(-1, 1) css property
        if (this.options.vertical && !noInvert) {
          location = this.options.end - location;
        }

        var _this = this,
            vert = this.options.vertical,
            hOrW = vert ? 'height' : 'width',
            lOrT = vert ? 'top' : 'left',
            handleDim = $hndl[0].getBoundingClientRect()[hOrW],
            elemDim = this.$element[0].getBoundingClientRect()[hOrW],

        //percentage of bar min/max value based on click or drag point
        pctOfBar = percent(location - this.options.start, this.options.end - this.options.start).toFixed(2),

        //number of actual pixels to shift the handle, based on the percentage obtained above
        pxToMove = (elemDim - handleDim) * pctOfBar,

        //percentage of bar to shift the handle
        movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal);
        //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value
        location = parseFloat(location.toFixed(this.options.decimal));
        // declare empty object for css adjustments, only used with 2 handled-sliders
        var css = {};

        this._setValues($hndl, location);

        // TODO update to calculate based on values set to respective inputs??
        if (isDbl) {
          var isLeftHndl = this.handles.index($hndl) === 0,

          //empty variable, will be used for min-height/width for fill bar
          dim,

          //percentage w/h of the handle compared to the slider bar
          handlePct = ~~(percent(handleDim, elemDim) * 100);
          //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar
          if (isLeftHndl) {
            //left or top percentage value to apply to the fill bar.
            css[lOrT] = movement + '%';
            //calculate the new min-height/width for the fill bar.
            dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct;
            //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider
            //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.
            if (cb && typeof cb === 'function') {
              cb();
            } //this is only needed for the initialization of 2 handled sliders
          } else {
            //just caching the value of the left/bottom handle's left/top property
            var handlePos = parseFloat(this.$handle[0].style[lOrT]);
            //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0
            //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself
            dim = movement - (isNaN(handlePos) ? this.options.initialStart / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;
          }
          // assign the min-height/width to our css object
          css['min-' + hOrW] = dim + '%';
        }

        this.$element.one('finished.zf.animate', function () {
          /**
           * Fires when the handle is done moving.
           * @event Slider#moved
           */
          _this.$element.trigger('moved.zf.slider', [$hndl]);
        });

        //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.
        var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;

        Foundation.Move(moveTime, $hndl, function () {
          //adjusting the left/top property of the handle, based on the percentage calculated above
          $hndl.css(lOrT, movement + '%');

          if (!_this.options.doubleSided) {
            //if single-handled, a simple method to expand the fill bar
            _this.$fill.css(hOrW, pctOfBar * 100 + '%');
          } else {
            //otherwise, use the css object we created above
            _this.$fill.css(css);
          }
        });

        /**
         * Fires when the value has not been change for a given time.
         * @event Slider#changed
         */
        clearTimeout(_this.timeout);
        _this.timeout = setTimeout(function () {
          _this.$element.trigger('changed.zf.slider', [$hndl]);
        }, _this.options.changedDelay);
      }

      /**
       * Sets the initial attribute for the slider element.
       * @function
       * @private
       * @param {Number} idx - index of the current handle/input to use.
       */

    }, {
      key: '_setInitAttr',
      value: function _setInitAttr(idx) {
        var id = this.inputs.eq(idx).attr('id') || Foundation.GetYoDigits(6, 'slider');
        this.inputs.eq(idx).attr({
          'id': id,
          'max': this.options.end,
          'min': this.options.start,
          'step': this.options.step
        });
        this.handles.eq(idx).attr({
          'role': 'slider',
          'aria-controls': id,
          'aria-valuemax': this.options.end,
          'aria-valuemin': this.options.start,
          'aria-valuenow': idx === 0 ? this.options.initialStart : this.options.initialEnd,
          'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',
          'tabindex': 0
        });
      }

      /**
       * Sets the input and `aria-valuenow` values for the slider element.
       * @function
       * @private
       * @param {jQuery} $handle - the currently selected handle.
       * @param {Number} val - floating point of the new value.
       */

    }, {
      key: '_setValues',
      value: function _setValues($handle, val) {
        var idx = this.options.doubleSided ? this.handles.index($handle) : 0;
        this.inputs.eq(idx).val(val);
        $handle.attr('aria-valuenow', val);
      }

      /**
       * Handles events on the slider element.
       * Calculates the new location of the current handle.
       * If there are two handles and the bar was clicked, it determines which handle to move.
       * @function
       * @private
       * @param {Object} e - the `event` object passed from the listener.
       * @param {jQuery} $handle - the current handle to calculate for, if selected.
       * @param {Number} val - floating point number for the new value of the slider.
       * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.
       */

    }, {
      key: '_handleEvent',
      value: function _handleEvent(e, $handle, val) {
        var value, hasVal;
        if (!val) {
          //click or drag events
          e.preventDefault();
          var _this = this,
              vertical = this.options.vertical,
              param = vertical ? 'height' : 'width',
              direction = vertical ? 'top' : 'left',
              eventOffset = vertical ? e.pageY : e.pageX,
              halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,
              barDim = this.$element[0].getBoundingClientRect()[param],
              windowScroll = vertical ? $(window).scrollTop() : $(window).scrollLeft();

          var elemOffset = this.$element.offset()[direction];

          // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...
          // best way to guess this is simulated is if clientY == pageY
          if (e.clientY === e.pageY) {
            eventOffset = eventOffset + windowScroll;
          }
          var eventFromBar = eventOffset - elemOffset;
          var barXY;
          if (eventFromBar < 0) {
            barXY = 0;
          } else if (eventFromBar > barDim) {
            barXY = barDim;
          } else {
            barXY = eventFromBar;
          }
          offsetPct = percent(barXY, barDim);

          value = (this.options.end - this.options.start) * offsetPct + this.options.start;

          // turn everything around for RTL, yay math!
          if (Foundation.rtl() && !this.options.vertical) {
            value = this.options.end - value;
          }

          value = _this._adjustValue(null, value);
          //boolean flag for the setHandlePos fn, specifically for vertical sliders
          hasVal = false;

          if (!$handle) {
            //figure out which handle it is, pass it to the next function.
            var firstHndlPos = absPosition(this.$handle, direction, barXY, param),
                secndHndlPos = absPosition(this.$handle2, direction, barXY, param);
            $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;
          }
        } else {
          //change event on input
          value = this._adjustValue(null, val);
          hasVal = true;
        }

        this._setHandlePos($handle, value, hasVal);
      }

      /**
       * Adjustes value for handle in regard to step value. returns adjusted value
       * @function
       * @private
       * @param {jQuery} $handle - the selected handle.
       * @param {Number} value - value to adjust. used if $handle is falsy
       */

    }, {
      key: '_adjustValue',
      value: function _adjustValue($handle, value) {
        var val,
            step = this.options.step,
            div = parseFloat(step / 2),
            left,
            prev_val,
            next_val;
        if (!!$handle) {
          val = parseFloat($handle.attr('aria-valuenow'));
        } else {
          val = value;
        }
        left = val % step;
        prev_val = val - left;
        next_val = prev_val + step;
        if (left === 0) {
          return val;
        }
        val = val >= prev_val + div ? next_val : prev_val;
        return val;
      }

      /**
       * Adds event listeners to the slider elements.
       * @function
       * @private
       * @param {jQuery} $handle - the current handle to apply listeners to.
       */

    }, {
      key: '_events',
      value: function _events($handle) {
        var _this = this,
            curHandle,
            timer;

        this.inputs.off('change.zf.slider').on('change.zf.slider', function (e) {
          var idx = _this.inputs.index($(this));
          _this._handleEvent(e, _this.handles.eq(idx), $(this).val());
        });

        if (this.options.clickSelect) {
          this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {
            if (_this.$element.data('dragging')) {
              return false;
            }

            if (!$(e.target).is('[data-slider-handle]')) {
              if (_this.options.doubleSided) {
                _this._handleEvent(e);
              } else {
                _this._handleEvent(e, _this.$handle);
              }
            }
          });
        }

        if (this.options.draggable) {
          this.handles.addTouch();

          var $body = $('body');
          $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {
            $handle.addClass('is-dragging');
            _this.$fill.addClass('is-dragging'); //
            _this.$element.data('dragging', true);

            curHandle = $(e.currentTarget);

            $body.on('mousemove.zf.slider', function (e) {
              e.preventDefault();
              _this._handleEvent(e, curHandle);
            }).on('mouseup.zf.slider', function (e) {
              _this._handleEvent(e, curHandle);

              $handle.removeClass('is-dragging');
              _this.$fill.removeClass('is-dragging');
              _this.$element.data('dragging', false);

              $body.off('mousemove.zf.slider mouseup.zf.slider');
            });
          })
          // prevent events triggered by touch
          .on('selectstart.zf.slider touchmove.zf.slider', function (e) {
            e.preventDefault();
          });
        }

        $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {
          var _$handle = $(this),
              idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,
              oldValue = parseFloat(_this.inputs.eq(idx).val()),
              newValue;

          // handle keyboard event with keyboard util
          Foundation.Keyboard.handleKey(e, 'Slider', {
            decrease: function () {
              newValue = oldValue - _this.options.step;
            },
            increase: function () {
              newValue = oldValue + _this.options.step;
            },
            decrease_fast: function () {
              newValue = oldValue - _this.options.step * 10;
            },
            increase_fast: function () {
              newValue = oldValue + _this.options.step * 10;
            },
            handled: function () {
              // only set handle pos when event was handled specially
              e.preventDefault();
              _this._setHandlePos(_$handle, newValue, true);
            }
          });
          /*if (newValue) { // if pressed key has special function, update value
            e.preventDefault();
            _this._setHandlePos(_$handle, newValue);
          }*/
        });
      }

      /**
       * Destroys the slider plugin.
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.handles.off('.zf.slider');
        this.inputs.off('.zf.slider');
        this.$element.off('.zf.slider');

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Slider;
  }();

  Slider.defaults = {
    /**
     * Minimum value for the slider scale.
     * @option
     * @example 0
     */
    start: 0,
    /**
     * Maximum value for the slider scale.
     * @option
     * @example 100
     */
    end: 100,
    /**
     * Minimum value change per change event.
     * @option
     * @example 1
     */
    step: 1,
    /**
     * Value at which the handle/input *(left handle/first input)* should be set to on initialization.
     * @option
     * @example 0
     */
    initialStart: 0,
    /**
     * Value at which the right handle/second input should be set to on initialization.
     * @option
     * @example 100
     */
    initialEnd: 100,
    /**
     * Allows the input to be located outside the container and visible. Set to by the JS
     * @option
     * @example false
     */
    binding: false,
    /**
     * Allows the user to click/tap on the slider bar to select a value.
     * @option
     * @example true
     */
    clickSelect: true,
    /**
     * Set to true and use the `vertical` class to change alignment to vertical.
     * @option
     * @example false
     */
    vertical: false,
    /**
     * Allows the user to drag the slider handle(s) to select a value.
     * @option
     * @example true
     */
    draggable: true,
    /**
     * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.
     * @option
     * @example false
     */
    disabled: false,
    /**
     * Allows the use of two handles. Double checked by the JS. Changes some logic handling.
     * @option
     * @example false
     */
    doubleSided: false,
    /**
     * Potential future feature.
     */
    // steps: 100,
    /**
     * Number of decimal places the plugin should go to for floating point precision.
     * @option
     * @example 2
     */
    decimal: 2,
    /**
     * Time delay for dragged elements.
     */
    // dragDelay: 0,
    /**
     * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.
     * @option
     * @example 200
     */
    moveTime: 200, //update this if changing the transition time in the sass
    /**
     * Class applied to disabled sliders.
     * @option
     * @example 'disabled'
     */
    disabledClass: 'disabled',
    /**
     * Will invert the default layout for a vertical<span data-tooltip title="who would do this???"> </span>slider.
     * @option
     * @example false
     */
    invertVertical: false,
    /**
     * Milliseconds before the `changed.zf-slider` event is triggered after value change.
     * @option
     * @example 500
     */
    changedDelay: 500
  };

  function percent(frac, num) {
    return frac / num;
  }
  function absPosition($handle, dir, clickPos, param) {
    return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);
  }

  // Window exports
  Foundation.plugin(Slider, 'Slider');
}(jQuery);

//*********this is in case we go to static, absolute positions instead of dynamic positioning********
// this.setSteps(function() {
//   _this._events();
//   var initStart = _this.options.positions[_this.options.initialStart - 1] || null;
//   var initEnd = _this.options.initialEnd ? _this.options.position[_this.options.initialEnd - 1] : null;
//   if (initStart || initEnd) {
//     _this._handleEvent(initStart, initEnd);
//   }
// });

//***********the other part of absolute positions*************
// Slider.prototype.setSteps = function(cb) {
//   var posChange = this.$element.outerWidth() / this.options.steps;
//   var counter = 0
//   while(counter < this.options.steps) {
//     if (counter) {
//       this.options.positions.push(this.options.positions[counter - 1] + posChange);
//     } else {
//       this.options.positions.push(posChange);
//     }
//     counter++;
//   }
//   cb();
// };
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Sticky module.
   * @module foundation.sticky
   * @requires foundation.util.triggers
   * @requires foundation.util.mediaQuery
   */

  var Sticky = function () {
    /**
     * Creates a new instance of a sticky thing.
     * @class
     * @param {jQuery} element - jQuery object to make sticky.
     * @param {Object} options - options object passed when creating the element programmatically.
     */
    function Sticky(element, options) {
      _classCallCheck(this, Sticky);

      this.$element = element;
      this.options = $.extend({}, Sticky.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Sticky');
    }

    /**
     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes
     * @function
     * @private
     */


    _createClass(Sticky, [{
      key: '_init',
      value: function _init() {
        var $parent = this.$element.parent('[data-sticky-container]'),
            id = this.$element[0].id || Foundation.GetYoDigits(6, 'sticky'),
            _this = this;

        if (!$parent.length) {
          this.wasWrapped = true;
        }
        this.$container = $parent.length ? $parent : $(this.options.container).wrapInner(this.$element);
        this.$container.addClass(this.options.containerClass);

        this.$element.addClass(this.options.stickyClass).attr({ 'data-resize': id });

        this.scrollCount = this.options.checkEvery;
        this.isStuck = false;
        $(window).one('load.zf.sticky', function () {
          if (_this.options.anchor !== '') {
            _this.$anchor = $('#' + _this.options.anchor);
          } else {
            _this._parsePoints();
          }

          _this._setSizes(function () {
            _this._calc(false);
          });
          _this._events(id.split('-').reverse().join('-'));
        });
      }

      /**
       * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.
       * @function
       * @private
       */

    }, {
      key: '_parsePoints',
      value: function _parsePoints() {
        var top = this.options.topAnchor == "" ? 1 : this.options.topAnchor,
            btm = this.options.btmAnchor == "" ? document.documentElement.scrollHeight : this.options.btmAnchor,
            pts = [top, btm],
            breaks = {};
        for (var i = 0, len = pts.length; i < len && pts[i]; i++) {
          var pt;
          if (typeof pts[i] === 'number') {
            pt = pts[i];
          } else {
            var place = pts[i].split(':'),
                anchor = $('#' + place[0]);

            pt = anchor.offset().top;
            if (place[1] && place[1].toLowerCase() === 'bottom') {
              pt += anchor[0].getBoundingClientRect().height;
            }
          }
          breaks[i] = pt;
        }

        this.points = breaks;
        return;
      }

      /**
       * Adds event handlers for the scrolling element.
       * @private
       * @param {String} id - psuedo-random id for unique scroll event listener.
       */

    }, {
      key: '_events',
      value: function _events(id) {
        var _this = this,
            scrollListener = this.scrollListener = 'scroll.zf.' + id;
        if (this.isOn) {
          return;
        }
        if (this.canStick) {
          this.isOn = true;
          $(window).off(scrollListener).on(scrollListener, function (e) {
            if (_this.scrollCount === 0) {
              _this.scrollCount = _this.options.checkEvery;
              _this._setSizes(function () {
                _this._calc(false, window.pageYOffset);
              });
            } else {
              _this.scrollCount--;
              _this._calc(false, window.pageYOffset);
            }
          });
        }

        this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {
          _this._setSizes(function () {
            _this._calc(false);
            if (_this.canStick) {
              if (!_this.isOn) {
                _this._events(id);
              }
            } else if (_this.isOn) {
              _this._pauseListeners(scrollListener);
            }
          });
        });
      }

      /**
       * Removes event handlers for scroll and change events on anchor.
       * @fires Sticky#pause
       * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`
       */

    }, {
      key: '_pauseListeners',
      value: function _pauseListeners(scrollListener) {
        this.isOn = false;
        $(window).off(scrollListener);

        /**
         * Fires when the plugin is paused due to resize event shrinking the view.
         * @event Sticky#pause
         * @private
         */
        this.$element.trigger('pause.zf.sticky');
      }

      /**
       * Called on every `scroll` event and on `_init`
       * fires functions based on booleans and cached values
       * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.
       * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.
       */

    }, {
      key: '_calc',
      value: function _calc(checkSizes, scroll) {
        if (checkSizes) {
          this._setSizes();
        }

        if (!this.canStick) {
          if (this.isStuck) {
            this._removeSticky(true);
          }
          return false;
        }

        if (!scroll) {
          scroll = window.pageYOffset;
        }

        if (scroll >= this.topPoint) {
          if (scroll <= this.bottomPoint) {
            if (!this.isStuck) {
              this._setSticky();
            }
          } else {
            if (this.isStuck) {
              this._removeSticky(false);
            }
          }
        } else {
          if (this.isStuck) {
            this._removeSticky(true);
          }
        }
      }

      /**
       * Causes the $element to become stuck.
       * Adds `position: fixed;`, and helper classes.
       * @fires Sticky#stuckto
       * @function
       * @private
       */

    }, {
      key: '_setSticky',
      value: function _setSticky() {
        var _this = this,
            stickTo = this.options.stickTo,
            mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',
            notStuckTo = stickTo === 'top' ? 'bottom' : 'top',
            css = {};

        css[mrgn] = this.options[mrgn] + 'em';
        css[stickTo] = 0;
        css[notStuckTo] = 'auto';
        css['left'] = this.$container.offset().left + parseInt(window.getComputedStyle(this.$container[0])["padding-left"], 10);
        this.isStuck = true;
        this.$element.removeClass('is-anchored is-at-' + notStuckTo).addClass('is-stuck is-at-' + stickTo).css(css)
        /**
         * Fires when the $element has become `position: fixed;`
         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`
         * @event Sticky#stuckto
         */
        .trigger('sticky.zf.stuckto:' + stickTo);
        this.$element.on("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd", function () {
          _this._setSizes();
        });
      }

      /**
       * Causes the $element to become unstuck.
       * Removes `position: fixed;`, and helper classes.
       * Adds other helper classes.
       * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.
       * @fires Sticky#unstuckfrom
       * @private
       */

    }, {
      key: '_removeSticky',
      value: function _removeSticky(isTop) {
        var stickTo = this.options.stickTo,
            stickToTop = stickTo === 'top',
            css = {},
            anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,
            mrgn = stickToTop ? 'marginTop' : 'marginBottom',
            notStuckTo = stickToTop ? 'bottom' : 'top',
            topOrBottom = isTop ? 'top' : 'bottom';

        css[mrgn] = 0;

        css['bottom'] = 'auto';
        if (isTop) {
          css['top'] = 0;
        } else {
          css['top'] = anchorPt;
        }

        css['left'] = '';
        this.isStuck = false;
        this.$element.removeClass('is-stuck is-at-' + stickTo).addClass('is-anchored is-at-' + topOrBottom).css(css)
        /**
         * Fires when the $element has become anchored.
         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`
         * @event Sticky#unstuckfrom
         */
        .trigger('sticky.zf.unstuckfrom:' + topOrBottom);
      }

      /**
       * Sets the $element and $container sizes for plugin.
       * Calls `_setBreakPoints`.
       * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.
       * @private
       */

    }, {
      key: '_setSizes',
      value: function _setSizes(cb) {
        this.canStick = Foundation.MediaQuery.atLeast(this.options.stickyOn);
        if (!this.canStick) {
          cb();
        }
        var _this = this,
            newElemWidth = this.$container[0].getBoundingClientRect().width,
            comp = window.getComputedStyle(this.$container[0]),
            pdng = parseInt(comp['padding-right'], 10);

        if (this.$anchor && this.$anchor.length) {
          this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;
        } else {
          this._parsePoints();
        }

        this.$element.css({
          'max-width': newElemWidth - pdng + 'px'
        });

        var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;
        if (this.$element.css("display") == "none") {
          newContainerHeight = 0;
        }
        this.containerHeight = newContainerHeight;
        this.$container.css({
          height: newContainerHeight
        });
        this.elemHeight = newContainerHeight;

        if (this.isStuck) {
          this.$element.css({ "left": this.$container.offset().left + parseInt(comp['padding-left'], 10) });
        }

        this._setBreakPoints(newContainerHeight, function () {
          if (cb) {
            cb();
          }
        });
      }

      /**
       * Sets the upper and lower breakpoints for the element to become sticky/unsticky.
       * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.
       * @param {Function} cb - optional callback function to be called on completion.
       * @private
       */

    }, {
      key: '_setBreakPoints',
      value: function _setBreakPoints(elemHeight, cb) {
        if (!this.canStick) {
          if (cb) {
            cb();
          } else {
            return false;
          }
        }
        var mTop = emCalc(this.options.marginTop),
            mBtm = emCalc(this.options.marginBottom),
            topPoint = this.points ? this.points[0] : this.$anchor.offset().top,
            bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,

        // topPoint = this.$anchor.offset().top || this.points[0],
        // bottomPoint = topPoint + this.anchorHeight || this.points[1],
        winHeight = window.innerHeight;

        if (this.options.stickTo === 'top') {
          topPoint -= mTop;
          bottomPoint -= elemHeight + mTop;
        } else if (this.options.stickTo === 'bottom') {
          topPoint -= winHeight - (elemHeight + mBtm);
          bottomPoint -= winHeight - mBtm;
        } else {
          //this would be the stickTo: both option... tricky
        }

        this.topPoint = topPoint;
        this.bottomPoint = bottomPoint;

        if (cb) {
          cb();
        }
      }

      /**
       * Destroys the current sticky element.
       * Resets the element to the top position first.
       * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this._removeSticky(true);

        this.$element.removeClass(this.options.stickyClass + ' is-anchored is-at-top').css({
          height: '',
          top: '',
          bottom: '',
          'max-width': ''
        }).off('resizeme.zf.trigger');
        if (this.$anchor && this.$anchor.length) {
          this.$anchor.off('change.zf.sticky');
        }
        $(window).off(this.scrollListener);

        if (this.wasWrapped) {
          this.$element.unwrap();
        } else {
          this.$container.removeClass(this.options.containerClass).css({
            height: ''
          });
        }
        Foundation.unregisterPlugin(this);
      }
    }]);

    return Sticky;
  }();

  Sticky.defaults = {
    /**
     * Customizable container template. Add your own classes for styling and sizing.
     * @option
     * @example '&lt;div data-sticky-container class="small-6 columns"&gt;&lt;/div&gt;'
     */
    container: '<div data-sticky-container></div>',
    /**
     * Location in the view the element sticks to.
     * @option
     * @example 'top'
     */
    stickTo: 'top',
    /**
     * If anchored to a single element, the id of that element.
     * @option
     * @example 'exampleId'
     */
    anchor: '',
    /**
     * If using more than one element as anchor points, the id of the top anchor.
     * @option
     * @example 'exampleId:top'
     */
    topAnchor: '',
    /**
     * If using more than one element as anchor points, the id of the bottom anchor.
     * @option
     * @example 'exampleId:bottom'
     */
    btmAnchor: '',
    /**
     * Margin, in `em`'s to apply to the top of the element when it becomes sticky.
     * @option
     * @example 1
     */
    marginTop: 1,
    /**
     * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.
     * @option
     * @example 1
     */
    marginBottom: 1,
    /**
     * Breakpoint string that is the minimum screen size an element should become sticky.
     * @option
     * @example 'medium'
     */
    stickyOn: 'medium',
    /**
     * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.
     * @option
     * @example 'sticky'
     */
    stickyClass: 'sticky',
    /**
     * Class applied to sticky container. Foundation defaults to `sticky-container`.
     * @option
     * @example 'sticky-container'
     */
    containerClass: 'sticky-container',
    /**
     * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.
     * @option
     * @example 50
     */
    checkEvery: -1
  };

  /**
   * Helper function to calculate em values
   * @param Number {em} - number of em's to calculate into pixels
   */
  function emCalc(em) {
    return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;
  }

  // Window exports
  Foundation.plugin(Sticky, 'Sticky');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Tabs module.
   * @module foundation.tabs
   * @requires foundation.util.keyboard
   * @requires foundation.util.timerAndImageLoader if tabs contain images
   */

  var Tabs = function () {
    /**
     * Creates a new instance of tabs.
     * @class
     * @fires Tabs#init
     * @param {jQuery} element - jQuery object to make into tabs.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Tabs(element, options) {
      _classCallCheck(this, Tabs);

      this.$element = element;
      this.options = $.extend({}, Tabs.defaults, this.$element.data(), options);

      this._init();
      Foundation.registerPlugin(this, 'Tabs');
      Foundation.Keyboard.register('Tabs', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'previous',
        'ARROW_DOWN': 'next',
        'ARROW_LEFT': 'previous'
        // 'TAB': 'next',
        // 'SHIFT_TAB': 'previous'
      });
    }

    /**
     * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.
     * @private
     */


    _createClass(Tabs, [{
      key: '_init',
      value: function _init() {
        var _this = this;

        this.$tabTitles = this.$element.find('.' + this.options.linkClass);
        this.$tabContent = $('[data-tabs-content="' + this.$element[0].id + '"]');

        this.$tabTitles.each(function () {
          var $elem = $(this),
              $link = $elem.find('a'),
              isActive = $elem.hasClass('is-active'),
              hash = $link[0].hash.slice(1),
              linkId = $link[0].id ? $link[0].id : hash + '-label',
              $tabContent = $('#' + hash);

          $elem.attr({ 'role': 'presentation' });

          $link.attr({
            'role': 'tab',
            'aria-controls': hash,
            'aria-selected': isActive,
            'id': linkId
          });

          $tabContent.attr({
            'role': 'tabpanel',
            'aria-hidden': !isActive,
            'aria-labelledby': linkId
          });

          if (isActive && _this.options.autoFocus) {
            $link.focus();
          }
        });

        if (this.options.matchHeight) {
          var $images = this.$tabContent.find('img');

          if ($images.length) {
            Foundation.onImagesLoaded($images, this._setHeight.bind(this));
          } else {
            this._setHeight();
          }
        }

        this._events();
      }

      /**
       * Adds event handlers for items within the tabs.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        this._addKeyHandler();
        this._addClickHandler();
        this._setHeightMqHandler = null;

        if (this.options.matchHeight) {
          this._setHeightMqHandler = this._setHeight.bind(this);

          $(window).on('changed.zf.mediaquery', this._setHeightMqHandler);
        }
      }

      /**
       * Adds click handlers for items within the tabs.
       * @private
       */

    }, {
      key: '_addClickHandler',
      value: function _addClickHandler() {
        var _this = this;

        this.$element.off('click.zf.tabs').on('click.zf.tabs', '.' + this.options.linkClass, function (e) {
          e.preventDefault();
          e.stopPropagation();
          if ($(this).hasClass('is-active')) {
            return;
          }
          _this._handleTabChange($(this));
        });
      }

      /**
       * Adds keyboard event handlers for items within the tabs.
       * @private
       */

    }, {
      key: '_addKeyHandler',
      value: function _addKeyHandler() {
        var _this = this;
        var $firstTab = _this.$element.find('li:first-of-type');
        var $lastTab = _this.$element.find('li:last-of-type');

        this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs', function (e) {
          if (e.which === 9) return;

          var $element = $(this),
              $elements = $element.parent('ul').children('li'),
              $prevElement,
              $nextElement;

          $elements.each(function (i) {
            if ($(this).is($element)) {
              if (_this.options.wrapOnKeys) {
                $prevElement = i === 0 ? $elements.last() : $elements.eq(i - 1);
                $nextElement = i === $elements.length - 1 ? $elements.first() : $elements.eq(i + 1);
              } else {
                $prevElement = $elements.eq(Math.max(0, i - 1));
                $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));
              }
              return;
            }
          });

          // handle keyboard event with keyboard util
          Foundation.Keyboard.handleKey(e, 'Tabs', {
            open: function () {
              $element.find('[role="tab"]').focus();
              _this._handleTabChange($element);
            },
            previous: function () {
              $prevElement.find('[role="tab"]').focus();
              _this._handleTabChange($prevElement);
            },
            next: function () {
              $nextElement.find('[role="tab"]').focus();
              _this._handleTabChange($nextElement);
            },
            handled: function () {
              e.stopPropagation();
              e.preventDefault();
            }
          });
        });
      }

      /**
       * Opens the tab `$targetContent` defined by `$target`.
       * @param {jQuery} $target - Tab to open.
       * @fires Tabs#change
       * @function
       */

    }, {
      key: '_handleTabChange',
      value: function _handleTabChange($target) {
        var $tabLink = $target.find('[role="tab"]'),
            hash = $tabLink[0].hash,
            $targetContent = this.$tabContent.find(hash),
            $oldTab = this.$element.find('.' + this.options.linkClass + '.is-active').removeClass('is-active').find('[role="tab"]').attr({ 'aria-selected': 'false' });

        $('#' + $oldTab.attr('aria-controls')).removeClass('is-active').attr({ 'aria-hidden': 'true' });

        $target.addClass('is-active');

        $tabLink.attr({ 'aria-selected': 'true' });

        $targetContent.addClass('is-active').attr({ 'aria-hidden': 'false' });

        /**
         * Fires when the plugin has successfully changed tabs.
         * @event Tabs#change
         */
        this.$element.trigger('change.zf.tabs', [$target]);
      }

      /**
       * Public method for selecting a content pane to display.
       * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.
       * @function
       */

    }, {
      key: 'selectTab',
      value: function selectTab(elem) {
        var idStr;

        if (typeof elem === 'object') {
          idStr = elem[0].id;
        } else {
          idStr = elem;
        }

        if (idStr.indexOf('#') < 0) {
          idStr = '#' + idStr;
        }

        var $target = this.$tabTitles.find('[href="' + idStr + '"]').parent('.' + this.options.linkClass);

        this._handleTabChange($target);
      }
    }, {
      key: '_setHeight',

      /**
       * Sets the height of each panel to the height of the tallest panel.
       * If enabled in options, gets called on media query change.
       * If loading content via external source, can be called directly or with _reflow.
       * @function
       * @private
       */
      value: function _setHeight() {
        var max = 0;
        this.$tabContent.find('.' + this.options.panelClass).css('height', '').each(function () {
          var panel = $(this),
              isActive = panel.hasClass('is-active');

          if (!isActive) {
            panel.css({ 'visibility': 'hidden', 'display': 'block' });
          }

          var temp = this.getBoundingClientRect().height;

          if (!isActive) {
            panel.css({
              'visibility': '',
              'display': ''
            });
          }

          max = temp > max ? temp : max;
        }).css('height', max + 'px');
      }

      /**
       * Destroys an instance of an tabs.
       * @fires Tabs#destroyed
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.find('.' + this.options.linkClass).off('.zf.tabs').hide().end().find('.' + this.options.panelClass).hide();

        if (this.options.matchHeight) {
          if (this._setHeightMqHandler != null) {
            $(window).off('changed.zf.mediaquery', this._setHeightMqHandler);
          }
        }

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Tabs;
  }();

  Tabs.defaults = {
    /**
     * Allows the window to scroll to content of active pane on load if set to true.
     * @option
     * @example false
     */
    autoFocus: false,

    /**
     * Allows keyboard input to 'wrap' around the tab links.
     * @option
     * @example true
     */
    wrapOnKeys: true,

    /**
     * Allows the tab content panes to match heights if set to true.
     * @option
     * @example false
     */
    matchHeight: false,

    /**
     * Class applied to `li`'s in tab link list.
     * @option
     * @example 'tabs-title'
     */
    linkClass: 'tabs-title',

    /**
     * Class applied to the content containers.
     * @option
     * @example 'tabs-panel'
     */
    panelClass: 'tabs-panel'
  };

  function checkClass($elem) {
    return $elem.hasClass('is-active');
  }

  // Window exports
  Foundation.plugin(Tabs, 'Tabs');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Toggler module.
   * @module foundation.toggler
   * @requires foundation.util.motion
   * @requires foundation.util.triggers
   */

  var Toggler = function () {
    /**
     * Creates a new instance of Toggler.
     * @class
     * @fires Toggler#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Toggler(element, options) {
      _classCallCheck(this, Toggler);

      this.$element = element;
      this.options = $.extend({}, Toggler.defaults, element.data(), options);
      this.className = '';

      this._init();
      this._events();

      Foundation.registerPlugin(this, 'Toggler');
    }

    /**
     * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.
     * @function
     * @private
     */


    _createClass(Toggler, [{
      key: '_init',
      value: function _init() {
        var input;
        // Parse animation classes if they were set
        if (this.options.animate) {
          input = this.options.animate.split(' ');

          this.animationIn = input[0];
          this.animationOut = input[1] || null;
        }
        // Otherwise, parse toggle class
        else {
            input = this.$element.data('toggler');
            // Allow for a . at the beginning of the string
            this.className = input[0] === '.' ? input.slice(1) : input;
          }

        // Add ARIA attributes to triggers
        var id = this.$element[0].id;
        $('[data-open="' + id + '"], [data-close="' + id + '"], [data-toggle="' + id + '"]').attr('aria-controls', id);
        // If the target is hidden, add aria-hidden
        this.$element.attr('aria-expanded', this.$element.is(':hidden') ? false : true);
      }

      /**
       * Initializes events for the toggle trigger.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        this.$element.off('toggle.zf.trigger').on('toggle.zf.trigger', this.toggle.bind(this));
      }

      /**
       * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was "on" or "off".
       * @function
       * @fires Toggler#on
       * @fires Toggler#off
       */

    }, {
      key: 'toggle',
      value: function toggle() {
        this[this.options.animate ? '_toggleAnimate' : '_toggleClass']();
      }
    }, {
      key: '_toggleClass',
      value: function _toggleClass() {
        this.$element.toggleClass(this.className);

        var isOn = this.$element.hasClass(this.className);
        if (isOn) {
          /**
           * Fires if the target element has the class after a toggle.
           * @event Toggler#on
           */
          this.$element.trigger('on.zf.toggler');
        } else {
          /**
           * Fires if the target element does not have the class after a toggle.
           * @event Toggler#off
           */
          this.$element.trigger('off.zf.toggler');
        }

        this._updateARIA(isOn);
      }
    }, {
      key: '_toggleAnimate',
      value: function _toggleAnimate() {
        var _this = this;

        if (this.$element.is(':hidden')) {
          Foundation.Motion.animateIn(this.$element, this.animationIn, function () {
            _this._updateARIA(true);
            this.trigger('on.zf.toggler');
          });
        } else {
          Foundation.Motion.animateOut(this.$element, this.animationOut, function () {
            _this._updateARIA(false);
            this.trigger('off.zf.toggler');
          });
        }
      }
    }, {
      key: '_updateARIA',
      value: function _updateARIA(isOn) {
        this.$element.attr('aria-expanded', isOn ? true : false);
      }

      /**
       * Destroys the instance of Toggler on the element.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.off('.zf.toggler');
        Foundation.unregisterPlugin(this);
      }
    }]);

    return Toggler;
  }();

  Toggler.defaults = {
    /**
     * Tells the plugin if the element should animated when toggled.
     * @option
     * @example false
     */
    animate: false
  };

  // Window exports
  Foundation.plugin(Toggler, 'Toggler');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Tooltip module.
   * @module foundation.tooltip
   * @requires foundation.util.box
   * @requires foundation.util.triggers
   */

  var Tooltip = function () {
    /**
     * Creates a new instance of a Tooltip.
     * @class
     * @fires Tooltip#init
     * @param {jQuery} element - jQuery object to attach a tooltip to.
     * @param {Object} options - object to extend the default configuration.
     */
    function Tooltip(element, options) {
      _classCallCheck(this, Tooltip);

      this.$element = element;
      this.options = $.extend({}, Tooltip.defaults, this.$element.data(), options);

      this.isActive = false;
      this.isClick = false;
      this._init();

      Foundation.registerPlugin(this, 'Tooltip');
    }

    /**
     * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.
     * @private
     */


    _createClass(Tooltip, [{
      key: '_init',
      value: function _init() {
        var elemId = this.$element.attr('aria-describedby') || Foundation.GetYoDigits(6, 'tooltip');

        this.options.positionClass = this.options.positionClass || this._getPositionClass(this.$element);
        this.options.tipText = this.options.tipText || this.$element.attr('title');
        this.template = this.options.template ? $(this.options.template) : this._buildTemplate(elemId);

        this.template.appendTo(document.body).text(this.options.tipText).hide();

        this.$element.attr({
          'title': '',
          'aria-describedby': elemId,
          'data-yeti-box': elemId,
          'data-toggle': elemId,
          'data-resize': elemId
        }).addClass(this.triggerClass);

        //helper variables to track movement on collisions
        this.usedPositions = [];
        this.counter = 4;
        this.classChanged = false;

        this._events();
      }

      /**
       * Grabs the current positioning class, if present, and returns the value or an empty string.
       * @private
       */

    }, {
      key: '_getPositionClass',
      value: function _getPositionClass(element) {
        if (!element) {
          return '';
        }
        // var position = element.attr('class').match(/top|left|right/g);
        var position = element[0].className.match(/\b(top|left|right)\b/g);
        position = position ? position[0] : '';
        return position;
      }
    }, {
      key: '_buildTemplate',

      /**
       * builds the tooltip element, adds attributes, and returns the template.
       * @private
       */
      value: function _buildTemplate(id) {
        var templateClasses = (this.options.tooltipClass + ' ' + this.options.positionClass + ' ' + this.options.templateClasses).trim();
        var $template = $('<div></div>').addClass(templateClasses).attr({
          'role': 'tooltip',
          'aria-hidden': true,
          'data-is-active': false,
          'data-is-focus': false,
          'id': id
        });
        return $template;
      }

      /**
       * Function that gets called if a collision event is detected.
       * @param {String} position - positioning class to try
       * @private
       */

    }, {
      key: '_reposition',
      value: function _reposition(position) {
        this.usedPositions.push(position ? position : 'bottom');

        //default, try switching to opposite side
        if (!position && this.usedPositions.indexOf('top') < 0) {
          this.template.addClass('top');
        } else if (position === 'top' && this.usedPositions.indexOf('bottom') < 0) {
          this.template.removeClass(position);
        } else if (position === 'left' && this.usedPositions.indexOf('right') < 0) {
          this.template.removeClass(position).addClass('right');
        } else if (position === 'right' && this.usedPositions.indexOf('left') < 0) {
          this.template.removeClass(position).addClass('left');
        }

        //if default change didn't work, try bottom or left first
        else if (!position && this.usedPositions.indexOf('top') > -1 && this.usedPositions.indexOf('left') < 0) {
            this.template.addClass('left');
          } else if (position === 'top' && this.usedPositions.indexOf('bottom') > -1 && this.usedPositions.indexOf('left') < 0) {
            this.template.removeClass(position).addClass('left');
          } else if (position === 'left' && this.usedPositions.indexOf('right') > -1 && this.usedPositions.indexOf('bottom') < 0) {
            this.template.removeClass(position);
          } else if (position === 'right' && this.usedPositions.indexOf('left') > -1 && this.usedPositions.indexOf('bottom') < 0) {
            this.template.removeClass(position);
          }
          //if nothing cleared, set to bottom
          else {
              this.template.removeClass(position);
            }
        this.classChanged = true;
        this.counter--;
      }

      /**
       * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.
       * if the tooltip is larger than the screen width, default to full width - any user selected margin
       * @private
       */

    }, {
      key: '_setPosition',
      value: function _setPosition() {
        var position = this._getPositionClass(this.template),
            $tipDims = Foundation.Box.GetDimensions(this.template),
            $anchorDims = Foundation.Box.GetDimensions(this.$element),
            direction = position === 'left' ? 'left' : position === 'right' ? 'left' : 'top',
            param = direction === 'top' ? 'height' : 'width',
            offset = param === 'height' ? this.options.vOffset : this.options.hOffset,
            _this = this;

        if ($tipDims.width >= $tipDims.windowDims.width || !this.counter && !Foundation.Box.ImNotTouchingYou(this.template)) {
          this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({
            // this.$element.offset(Foundation.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({
            'width': $anchorDims.windowDims.width - this.options.hOffset * 2,
            'height': 'auto'
          });
          return false;
        }

        this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, 'center ' + (position || 'bottom'), this.options.vOffset, this.options.hOffset));

        while (!Foundation.Box.ImNotTouchingYou(this.template) && this.counter) {
          this._reposition(position);
          this._setPosition();
        }
      }

      /**
       * reveals the tooltip, and fires an event to close any other open tooltips on the page
       * @fires Tooltip#closeme
       * @fires Tooltip#show
       * @function
       */

    }, {
      key: 'show',
      value: function show() {
        if (this.options.showOn !== 'all' && !Foundation.MediaQuery.atLeast(this.options.showOn)) {
          // console.error('The screen is too small to display this tooltip');
          return false;
        }

        var _this = this;
        this.template.css('visibility', 'hidden').show();
        this._setPosition();

        /**
         * Fires to close all other open tooltips on the page
         * @event Closeme#tooltip
         */
        this.$element.trigger('closeme.zf.tooltip', this.template.attr('id'));

        this.template.attr({
          'data-is-active': true,
          'aria-hidden': false
        });
        _this.isActive = true;
        // console.log(this.template);
        this.template.stop().hide().css('visibility', '').fadeIn(this.options.fadeInDuration, function () {
          //maybe do stuff?
        });
        /**
         * Fires when the tooltip is shown
         * @event Tooltip#show
         */
        this.$element.trigger('show.zf.tooltip');
      }

      /**
       * Hides the current tooltip, and resets the positioning class if it was changed due to collision
       * @fires Tooltip#hide
       * @function
       */

    }, {
      key: 'hide',
      value: function hide() {
        // console.log('hiding', this.$element.data('yeti-box'));
        var _this = this;
        this.template.stop().attr({
          'aria-hidden': true,
          'data-is-active': false
        }).fadeOut(this.options.fadeOutDuration, function () {
          _this.isActive = false;
          _this.isClick = false;
          if (_this.classChanged) {
            _this.template.removeClass(_this._getPositionClass(_this.template)).addClass(_this.options.positionClass);

            _this.usedPositions = [];
            _this.counter = 4;
            _this.classChanged = false;
          }
        });
        /**
         * fires when the tooltip is hidden
         * @event Tooltip#hide
         */
        this.$element.trigger('hide.zf.tooltip');
      }

      /**
       * adds event listeners for the tooltip and its anchor
       * TODO combine some of the listeners like focus and mouseenter, etc.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;
        var $template = this.template;
        var isFocus = false;

        if (!this.options.disableHover) {

          this.$element.on('mouseenter.zf.tooltip', function (e) {
            if (!_this.isActive) {
              _this.timeout = setTimeout(function () {
                _this.show();
              }, _this.options.hoverDelay);
            }
          }).on('mouseleave.zf.tooltip', function (e) {
            clearTimeout(_this.timeout);
            if (!isFocus || _this.isClick && !_this.options.clickOpen) {
              _this.hide();
            }
          });
        }

        if (this.options.clickOpen) {
          this.$element.on('mousedown.zf.tooltip', function (e) {
            e.stopImmediatePropagation();
            if (_this.isClick) {
              //_this.hide();
              // _this.isClick = false;
            } else {
              _this.isClick = true;
              if ((_this.options.disableHover || !_this.$element.attr('tabindex')) && !_this.isActive) {
                _this.show();
              }
            }
          });
        } else {
          this.$element.on('mousedown.zf.tooltip', function (e) {
            e.stopImmediatePropagation();
            _this.isClick = true;
          });
        }

        if (!this.options.disableForTouch) {
          this.$element.on('tap.zf.tooltip touchend.zf.tooltip', function (e) {
            _this.isActive ? _this.hide() : _this.show();
          });
        }

        this.$element.on({
          // 'toggle.zf.trigger': this.toggle.bind(this),
          // 'close.zf.trigger': this.hide.bind(this)
          'close.zf.trigger': this.hide.bind(this)
        });

        this.$element.on('focus.zf.tooltip', function (e) {
          isFocus = true;
          if (_this.isClick) {
            // If we're not showing open on clicks, we need to pretend a click-launched focus isn't
            // a real focus, otherwise on hover and come back we get bad behavior
            if (!_this.options.clickOpen) {
              isFocus = false;
            }
            return false;
          } else {
            _this.show();
          }
        }).on('focusout.zf.tooltip', function (e) {
          isFocus = false;
          _this.isClick = false;
          _this.hide();
        }).on('resizeme.zf.trigger', function () {
          if (_this.isActive) {
            _this._setPosition();
          }
        });
      }

      /**
       * adds a toggle method, in addition to the static show() & hide() functions
       * @function
       */

    }, {
      key: 'toggle',
      value: function toggle() {
        if (this.isActive) {
          this.hide();
        } else {
          this.show();
        }
      }

      /**
       * Destroys an instance of tooltip, removes template element from the view.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.attr('title', this.template.text()).off('.zf.trigger .zf.tootip')
        //  .removeClass('has-tip')
        .removeAttr('aria-describedby').removeAttr('data-yeti-box').removeAttr('data-toggle').removeAttr('data-resize');

        this.template.remove();

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Tooltip;
  }();

  Tooltip.defaults = {
    disableForTouch: false,
    /**
     * Time, in ms, before a tooltip should open on hover.
     * @option
     * @example 200
     */
    hoverDelay: 200,
    /**
     * Time, in ms, a tooltip should take to fade into view.
     * @option
     * @example 150
     */
    fadeInDuration: 150,
    /**
     * Time, in ms, a tooltip should take to fade out of view.
     * @option
     * @example 150
     */
    fadeOutDuration: 150,
    /**
     * Disables hover events from opening the tooltip if set to true
     * @option
     * @example false
     */
    disableHover: false,
    /**
     * Optional addtional classes to apply to the tooltip template on init.
     * @option
     * @example 'my-cool-tip-class'
     */
    templateClasses: '',
    /**
     * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.
     * @option
     * @example 'tooltip'
     */
    tooltipClass: 'tooltip',
    /**
     * Class applied to the tooltip anchor element.
     * @option
     * @example 'has-tip'
     */
    triggerClass: 'has-tip',
    /**
     * Minimum breakpoint size at which to open the tooltip.
     * @option
     * @example 'small'
     */
    showOn: 'small',
    /**
     * Custom template to be used to generate markup for tooltip.
     * @option
     * @example '&lt;div class="tooltip"&gt;&lt;/div&gt;'
     */
    template: '',
    /**
     * Text displayed in the tooltip template on open.
     * @option
     * @example 'Some cool space fact here.'
     */
    tipText: '',
    touchCloseText: 'Tap to close.',
    /**
     * Allows the tooltip to remain open if triggered with a click or touch event.
     * @option
     * @example true
     */
    clickOpen: true,
    /**
     * Additional positioning classes, set by the JS
     * @option
     * @example 'top'
     */
    positionClass: '',
    /**
     * Distance, in pixels, the template should push away from the anchor on the Y axis.
     * @option
     * @example 10
     */
    vOffset: 10,
    /**
     * Distance, in pixels, the template should push away from the anchor on the X axis, if aligned to a side.
     * @option
     * @example 12
     */
    hOffset: 12
  };

  /**
   * TODO utilize resize event trigger
   */

  // Window exports
  Foundation.plugin(Tooltip, 'Tooltip');
}(jQuery);
;'use strict';

// Polyfill for requestAnimationFrame

(function () {
  if (!Date.now) Date.now = function () {
    return new Date().getTime();
  };

  var vendors = ['webkit', 'moz'];
  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
    var vp = vendors[i];
    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
  }
  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
    var lastTime = 0;
    window.requestAnimationFrame = function (callback) {
      var now = Date.now();
      var nextTime = Math.max(lastTime + 16, now);
      return setTimeout(function () {
        callback(lastTime = nextTime);
      }, nextTime - now);
    };
    window.cancelAnimationFrame = clearTimeout;
  }
})();

var initClasses = ['mui-enter', 'mui-leave'];
var activeClasses = ['mui-enter-active', 'mui-leave-active'];

// Find the right "transitionend" event for this browser
var endEvent = function () {
  var transitions = {
    'transition': 'transitionend',
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'otransitionend'
  };
  var elem = window.document.createElement('div');

  for (var t in transitions) {
    if (typeof elem.style[t] !== 'undefined') {
      return transitions[t];
    }
  }

  return null;
}();

function animate(isIn, element, animation, cb) {
  element = $(element).eq(0);

  if (!element.length) return;

  if (endEvent === null) {
    isIn ? element.show() : element.hide();
    cb();
    return;
  }

  var initClass = isIn ? initClasses[0] : initClasses[1];
  var activeClass = isIn ? activeClasses[0] : activeClasses[1];

  // Set up the animation
  reset();
  element.addClass(animation);
  element.css('transition', 'none');
  requestAnimationFrame(function () {
    element.addClass(initClass);
    if (isIn) element.show();
  });

  // Start the animation
  requestAnimationFrame(function () {
    element[0].offsetWidth;
    element.css('transition', '');
    element.addClass(activeClass);
  });

  // Clean up the animation when it finishes
  element.one('transitionend', finish);

  // Hides the element (for out animations), resets the element, and runs a callback
  function finish() {
    if (!isIn) element.hide();
    reset();
    if (cb) cb.apply(element);
  }

  // Resets transitions and removes motion-specific classes
  function reset() {
    element[0].style.transitionDuration = 0;
    element.removeClass(initClass + ' ' + activeClass + ' ' + animation);
  }
}

var MotionUI = {
  animateIn: function (element, animation, cb) {
    animate(true, element, animation, cb);
  },

  animateOut: function (element, animation, cb) {
    animate(false, element, animation, cb);
  }
};
;"use strict";

// Snap.svg 0.4.1
//
// Copyright (c) 2013 – 2015 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// build: 2015-04-13

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\

(function (glob) {
    var version = "0.4.2",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        comaseparator = /\s*,\s*/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
        return a - b;
    },
        current_event,
        stop,
        events = { n: {} },
        firstDefined = function () {
        for (var i = 0, ii = this.length; i < ii; i++) {
            if (typeof this[i] != "undefined") {
                return this[i];
            }
        }
    },
        lastDefined = function () {
        var i = this.length;
        while (--i) {
            if (typeof this[i] != "undefined") {
                return this[i];
            }
        }
    },

    /*\
     * eve
     [ method ]
      * Fires event with given `name`, given scope and other parameters.
      > Arguments
      - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers
      = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
    \*/
    eve = function (name, scope) {
        name = String(name);
        var e = events,
            oldstop = stop,
            args = Array.prototype.slice.call(arguments, 2),
            listeners = eve.listeners(name),
            z = 0,
            f = false,
            l,
            indexed = [],
            queue = {},
            out = [],
            ce = current_event,
            errors = [];
        out.firstDefined = firstDefined;
        out.lastDefined = lastDefined;
        current_event = name;
        stop = 0;
        for (var i = 0, ii = listeners.length; i < ii; i++) {
            if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
        }indexed.sort(numsort);
        while (indexed[z] < 0) {
            l = queue[indexed[z++]];
            out.push(l.apply(scope, args));
            if (stop) {
                stop = oldstop;
                return out;
            }
        }
        for (i = 0; i < ii; i++) {
            l = listeners[i];
            if ("zIndex" in l) {
                if (l.zIndex == indexed[z]) {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                    do {
                        z++;
                        l = queue[indexed[z]];
                        l && out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                    } while (l);
                } else {
                    queue[l.zIndex] = l;
                }
            } else {
                out.push(l.apply(scope, args));
                if (stop) {
                    break;
                }
            }
        }
        stop = oldstop;
        current_event = ce;
        return out;
    };
    // Undocumented. Debug only.
    eve._events = events;
    /*\
     * eve.listeners
     [ method ]
      * Internal method which gives you array of all event handlers that will be triggered by the given `name`.
      > Arguments
      - name (string) name of the event, dot (`.`) or slash (`/`) separated
      = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };

    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt` function will be called before `eatIt`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
    \*/
    eve.on = function (name, f) {
        name = String(name);
        if (typeof f != "function") {
            return function () {};
        }
        var names = name.split(comaseparator);
        for (var i = 0, ii = names.length; i < ii; i++) {
            (function (name) {
                var names = name.split(separator),
                    e = events,
                    exist;
                for (var i = 0, ii = names.length; i < ii; i++) {
                    e = e.n;
                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = { n: {} });
                }
                e.f = e.f || [];
                for (i = 0, ii = e.f.length; i < ii; i++) {
                    if (e.f[i] == f) {
                        exist = true;
                        break;
                    }
                }!exist && e.f.push(f);
            })(names[i]);
        }
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     > Arguments
     - event (string) event name
     - varargs (…) and any other arguments
     = (function) possible event handler function
    \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
    \*/
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = { n: {} };
            return;
        }
        var names = name.split(comaseparator);
        if (names.length > 1) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                eve.off(names[i], f);
            }
            return;
        }
        names = name.split(separator);
        var e,
            key,
            splice,
            i,
            ii,
            j,
            jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) {
                        if (e[has](key)) {
                            splice.push(e[key]);
                        }
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) {
                            if (e.f[j] == f) {
                                e.f.splice(j, 1);
                                break;
                            }
                        }!e.f.length && delete e.f;
                    }
                    for (key in e.n) {
                        if (e.n[has](key) && e.n[key].f) {
                            var funcs = e.n[key].f;
                            for (j = 0, jj = funcs.length; j < jj; j++) {
                                if (funcs[j] == f) {
                                    funcs.splice(j, 1);
                                    break;
                                }
                            }!funcs.length && delete e.n[key].f;
                        }
                    }
                } else {
                    delete e.f;
                    for (key in e.n) {
                        if (e.n[has](key) && e.n[key].f) {
                            delete e.n[key].f;
                        }
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.unbind(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    typeof module != "undefined" && module.exports ? module.exports = eve : typeof define === "function" && define.amd ? define("eve", [], function () {
        return eve;
    }) : glob.eve = eve;
})(this);

(function (glob, factory) {
    // AMD support
    if (typeof define == "function" && define.amd) {
        // Define as an anonymous module
        define(["eve"], function (eve) {
            return factory(glob, eve);
        });
    } else if (typeof exports != 'undefined') {
        // Next for Node.js or CommonJS
        var eve = require('eve');
        module.exports = factory(glob, eve);
    } else {
        // Browser globals (glob is window)
        // Snap adds itself to window
        factory(glob, glob.eve);
    }
})(window || this, function (window, eve) {

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    var mina = function (eve) {
        var animations = {},
            requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
            setTimeout(callback, 16);
        },
            isArray = Array.isArray || function (a) {
            return a instanceof Array || Object.prototype.toString.call(a) == "[object Array]";
        },
            idgen = 0,
            idprefix = "M" + (+new Date()).toString(36),
            ID = function () {
            return idprefix + (idgen++).toString(36);
        },
            diff = function (a, b, A, B) {
            if (isArray(a)) {
                res = [];
                for (var i = 0, ii = a.length; i < ii; i++) {
                    res[i] = diff(a[i], b, A[i], B);
                }
                return res;
            }
            var dif = (A - a) / (B - b);
            return function (bb) {
                return a + dif * (bb - b);
            };
        },
            timer = Date.now || function () {
            return +new Date();
        },
            sta = function (val) {
            var a = this;
            if (val == null) {
                return a.s;
            }
            var ds = a.s - val;
            a.b += a.dur * ds;
            a.B += a.dur * ds;
            a.s = val;
        },
            speed = function (val) {
            var a = this;
            if (val == null) {
                return a.spd;
            }
            a.spd = val;
        },
            duration = function (val) {
            var a = this;
            if (val == null) {
                return a.dur;
            }
            a.s = a.s * val / a.dur;
            a.dur = val;
        },
            stopit = function () {
            var a = this;
            delete animations[a.id];
            a.update();
            eve("mina.stop." + a.id, a);
        },
            pause = function () {
            var a = this;
            if (a.pdif) {
                return;
            }
            delete animations[a.id];
            a.update();
            a.pdif = a.get() - a.b;
        },
            resume = function () {
            var a = this;
            if (!a.pdif) {
                return;
            }
            a.b = a.get() - a.pdif;
            delete a.pdif;
            animations[a.id] = a;
        },
            update = function () {
            var a = this,
                res;
            if (isArray(a.start)) {
                res = [];
                for (var j = 0, jj = a.start.length; j < jj; j++) {
                    res[j] = +a.start[j] + (a.end[j] - a.start[j]) * a.easing(a.s);
                }
            } else {
                res = +a.start + (a.end - a.start) * a.easing(a.s);
            }
            a.set(res);
        },
            frame = function () {
            var len = 0;
            for (var i in animations) {
                if (animations.hasOwnProperty(i)) {
                    var a = animations[i],
                        b = a.get(),
                        res;
                    len++;
                    a.s = (b - a.b) / (a.dur / a.spd);
                    if (a.s >= 1) {
                        delete animations[i];
                        a.s = 1;
                        len--;
                        (function (a) {
                            setTimeout(function () {
                                eve("mina.finish." + a.id, a);
                            });
                        })(a);
                    }
                    a.update();
                }
            }len && requestAnimFrame(frame);
        },

        /*\
         * mina
         [ method ]
         **
         * Generic animation of numbers
         **
         - a (number) start _slave_ number
         - A (number) end _slave_ number
         - b (number) start _master_ number (start time in general case)
         - B (number) end _master_ number (end time in gereal case)
         - get (function) getter of _master_ number (see @mina.time)
         - set (function) setter of _slave_ number
         - easing (function) #optional easing function, default is @mina.linear
         = (object) animation descriptor
         o {
         o         id (string) animation id,
         o         start (number) start _slave_ number,
         o         end (number) end _slave_ number,
         o         b (number) start _master_ number,
         o         s (number) animation status (0..1),
         o         dur (number) animation duration,
         o         spd (number) animation speed,
         o         get (function) getter of _master_ number (see @mina.time),
         o         set (function) setter of _slave_ number,
         o         easing (function) easing function, default is @mina.linear,
         o         status (function) status getter/setter,
         o         speed (function) speed getter/setter,
         o         duration (function) duration getter/setter,
         o         stop (function) animation stopper
         o         pause (function) pauses the animation
         o         resume (function) resumes the animation
         o         update (function) calles setter with the right value of the animation
         o }
        \*/
        mina = function (a, A, b, B, get, set, easing) {
            var anim = {
                id: ID(),
                start: a,
                end: A,
                b: b,
                s: 0,
                dur: B - b,
                spd: 1,
                get: get,
                set: set,
                easing: easing || mina.linear,
                status: sta,
                speed: speed,
                duration: duration,
                stop: stopit,
                pause: pause,
                resume: resume,
                update: update
            };
            animations[anim.id] = anim;
            var len = 0,
                i;
            for (i in animations) {
                if (animations.hasOwnProperty(i)) {
                    len++;
                    if (len == 2) {
                        break;
                    }
                }
            }len == 1 && requestAnimFrame(frame);
            return anim;
        };
        /*\
         * mina.time
         [ method ]
         **
         * Returns the current time. Equivalent to:
         | function () {
         |     return (new Date).getTime();
         | }
        \*/
        mina.time = timer;
        /*\
         * mina.getById
         [ method ]
         **
         * Returns an animation by its id
         - id (string) animation's id
         = (object) See @mina
        \*/
        mina.getById = function (id) {
            return animations[id] || null;
        };

        /*\
         * mina.linear
         [ method ]
         **
         * Default linear easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.linear = function (n) {
            return n;
        };
        /*\
         * mina.easeout
         [ method ]
         **
         * Easeout easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.easeout = function (n) {
            return Math.pow(n, 1.7);
        };
        /*\
         * mina.easein
         [ method ]
         **
         * Easein easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.easein = function (n) {
            return Math.pow(n, .48);
        };
        /*\
         * mina.easeinout
         [ method ]
         **
         * Easeinout easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.easeinout = function (n) {
            if (n == 1) {
                return 1;
            }
            if (n == 0) {
                return 0;
            }
            var q = .48 - n / 1.04,
                Q = Math.sqrt(.1734 + q * q),
                x = Q - q,
                X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                y = -Q - q,
                Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                t = X + Y + .5;
            return (1 - t) * 3 * t * t + t * t * t;
        };
        /*\
         * mina.backin
         [ method ]
         **
         * Backin easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.backin = function (n) {
            if (n == 1) {
                return 1;
            }
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        };
        /*\
         * mina.backout
         [ method ]
         **
         * Backout easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.backout = function (n) {
            if (n == 0) {
                return 0;
            }
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        };
        /*\
         * mina.elastic
         [ method ]
         **
         * Elastic easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.elastic = function (n) {
            if (n == !!n) {
                return n;
            }
            return Math.pow(2, -10 * n) * Math.sin((n - .075) * (2 * Math.PI) / .3) + 1;
        };
        /*\
         * mina.bounce
         [ method ]
         **
         * Bounce easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.bounce = function (n) {
            var s = 7.5625,
                p = 2.75,
                l;
            if (n < 1 / p) {
                l = s * n * n;
            } else {
                if (n < 2 / p) {
                    n -= 1.5 / p;
                    l = s * n * n + .75;
                } else {
                    if (n < 2.5 / p) {
                        n -= 2.25 / p;
                        l = s * n * n + .9375;
                    } else {
                        n -= 2.625 / p;
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        };
        window.mina = mina;
        return mina;
    }(typeof eve == "undefined" ? function () {} : eve);
    // Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.

    var Snap = function (root) {
        Snap.version = "0.4.0";
        /*\
         * Snap
         [ method ]
         **
         * Creates a drawing surface or wraps existing SVG element.
         **
         - width (number|string) width of surface
         - height (number|string) height of surface
         * or
         - DOM (SVGElement) element to be wrapped into Snap structure
         * or
         - array (array) array of elements (will return set of elements)
         * or
         - query (string) CSS query selector
         = (object) @Element
        \*/
        function Snap(w, h) {
            if (w) {
                if (w.nodeType) {
                    return wrap(w);
                }
                if (is(w, "array") && Snap.set) {
                    return Snap.set.apply(Snap, w);
                }
                if (w instanceof Element) {
                    return w;
                }
                if (h == null) {
                    w = glob.doc.querySelector(String(w));
                    return wrap(w);
                }
            }
            w = w == null ? "100%" : w;
            h = h == null ? "100%" : h;
            return new Paper(w, h);
        }
        Snap.toString = function () {
            return "Snap v" + this.version;
        };
        Snap._ = {};
        var glob = {
            win: root.window,
            doc: root.window.document
        };
        Snap._.glob = glob;
        var has = "hasOwnProperty",
            Str = String,
            toFloat = parseFloat,
            toInt = parseInt,
            math = Math,
            mmax = math.max,
            mmin = math.min,
            abs = math.abs,
            pow = math.pow,
            PI = math.PI,
            round = math.round,
            E = "",
            S = " ",
            objectToString = Object.prototype.toString,
            ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
            colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
            bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
            reURLValue = /^url\(#?([^)]+)\)$/,
            separator = Snap._.separator = /[,\s]+/,
            whitespace = /[\s]/g,
            commaSpaces = /[\s]*,[\s]*/,
            hsrg = { hs: 1, rg: 1 },
            pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
            tCommand = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
            pathValues = /(-?\d*\.?\d*(?:e[\-+]?\\d+)?)[\s]*,?[\s]*/ig,
            idgen = 0,
            idprefix = "S" + (+new Date()).toString(36),
            ID = function (el) {
            return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);
        },
            xlink = "http://www.w3.org/1999/xlink",
            xmlns = "http://www.w3.org/2000/svg",
            hub = {},
            URL = Snap.url = function (url) {
            return "url('#" + url + "')";
        };

        function $(el, attr) {
            if (attr) {
                if (el == "#text") {
                    el = glob.doc.createTextNode(attr.text || attr["#text"] || "");
                }
                if (el == "#comment") {
                    el = glob.doc.createComment(attr.text || attr["#text"] || "");
                }
                if (typeof el == "string") {
                    el = $(el);
                }
                if (typeof attr == "string") {
                    if (el.nodeType == 1) {
                        if (attr.substring(0, 6) == "xlink:") {
                            return el.getAttributeNS(xlink, attr.substring(6));
                        }
                        if (attr.substring(0, 4) == "xml:") {
                            return el.getAttributeNS(xmlns, attr.substring(4));
                        }
                        return el.getAttribute(attr);
                    } else if (attr == "text") {
                        return el.nodeValue;
                    } else {
                        return null;
                    }
                }
                if (el.nodeType == 1) {
                    for (var key in attr) {
                        if (attr[has](key)) {
                            var val = Str(attr[key]);
                            if (val) {
                                if (key.substring(0, 6) == "xlink:") {
                                    el.setAttributeNS(xlink, key.substring(6), val);
                                } else if (key.substring(0, 4) == "xml:") {
                                    el.setAttributeNS(xmlns, key.substring(4), val);
                                } else {
                                    el.setAttribute(key, val);
                                }
                            } else {
                                el.removeAttribute(key);
                            }
                        }
                    }
                } else if ("text" in attr) {
                    el.nodeValue = attr.text;
                }
            } else {
                el = glob.doc.createElementNS(xmlns, el);
            }
            return el;
        }
        Snap._.$ = $;
        Snap._.id = ID;
        function getAttrs(el) {
            var attrs = el.attributes,
                name,
                out = {};
            for (var i = 0; i < attrs.length; i++) {
                if (attrs[i].namespaceURI == xlink) {
                    name = "xlink:";
                } else {
                    name = "";
                }
                name += attrs[i].name;
                out[name] = attrs[i].textContent;
            }
            return out;
        }
        function is(o, type) {
            type = Str.prototype.toLowerCase.call(type);
            if (type == "finite") {
                return isFinite(o);
            }
            if (type == "array" && (o instanceof Array || Array.isArray && Array.isArray(o))) {
                return true;
            }
            return type == "null" && o === null || type == typeof o && o !== null || type == "object" && o === Object(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
        }
        /*\
         * Snap.format
         [ method ]
         **
         * Replaces construction of type `{<name>}` to the corresponding argument
         **
         - token (string) string to format
         - json (object) object which properties are used as a replacement
         = (string) formatted string
         > Usage
         | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
         | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
         |     x: 10,
         |     y: 20,
         |     dim: {
         |         width: 40,
         |         height: 50,
         |         "negative width": -40
         |     }
         | }));
        \*/
        Snap.format = function () {
            var tokenRegex = /\{([^\}]+)\}/g,
                objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,
                // matches .xxxxx or ["xxxxx"] to run over object properties
            replacer = function (all, key, obj) {
                var res = obj;
                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                    name = name || quotedName;
                    if (res) {
                        if (name in res) {
                            res = res[name];
                        }
                        typeof res == "function" && isFunc && (res = res());
                    }
                });
                res = (res == null || res == obj ? all : res) + "";
                return res;
            };
            return function (str, obj) {
                return Str(str).replace(tokenRegex, function (all, key) {
                    return replacer(all, key, obj);
                });
            };
        }();
        function clone(obj) {
            if (typeof obj == "function" || Object(obj) !== obj) {
                return obj;
            }
            var res = new obj.constructor();
            for (var key in obj) {
                if (obj[has](key)) {
                    res[key] = clone(obj[key]);
                }
            }return res;
        }
        Snap._.clone = clone;
        function repush(array, item) {
            for (var i = 0, ii = array.length; i < ii; i++) {
                if (array[i] === item) {
                    return array.push(array.splice(i, 1)[0]);
                }
            }
        }
        function cacher(f, scope, postprocessor) {
            function newf() {
                var arg = Array.prototype.slice.call(arguments, 0),
                    args = arg.join("\u2400"),
                    cache = newf.cache = newf.cache || {},
                    count = newf.count = newf.count || [];
                if (cache[has](args)) {
                    repush(count, args);
                    return postprocessor ? postprocessor(cache[args]) : cache[args];
                }
                count.length >= 1e3 && delete cache[count.shift()];
                count.push(args);
                cache[args] = f.apply(scope, arg);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            return newf;
        }
        Snap._.cacher = cacher;
        function angle(x1, y1, x2, y2, x3, y3) {
            if (x3 == null) {
                var x = x1 - x2,
                    y = y1 - y2;
                if (!x && !y) {
                    return 0;
                }
                return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
            } else {
                return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
            }
        }
        function rad(deg) {
            return deg % 360 * PI / 180;
        }
        function deg(rad) {
            return rad * 180 / PI % 360;
        }
        function x_y() {
            return this.x + S + this.y;
        }
        function x_y_w_h() {
            return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
        }

        /*\
         * Snap.rad
         [ method ]
         **
         * Transform angle to radians
         - deg (number) angle in degrees
         = (number) angle in radians
        \*/
        Snap.rad = rad;
        /*\
         * Snap.deg
         [ method ]
         **
         * Transform angle to degrees
         - rad (number) angle in radians
         = (number) angle in degrees
        \*/
        Snap.deg = deg;
        /*\
         * Snap.sin
         [ method ]
         **
         * Equivalent to `Math.sin()` only works with degrees, not radians.
         - angle (number) angle in degrees
         = (number) sin
        \*/
        Snap.sin = function (angle) {
            return math.sin(Snap.rad(angle));
        };
        /*\
         * Snap.tan
         [ method ]
         **
         * Equivalent to `Math.tan()` only works with degrees, not radians.
         - angle (number) angle in degrees
         = (number) tan
        \*/
        Snap.tan = function (angle) {
            return math.tan(Snap.rad(angle));
        };
        /*\
         * Snap.cos
         [ method ]
         **
         * Equivalent to `Math.cos()` only works with degrees, not radians.
         - angle (number) angle in degrees
         = (number) cos
        \*/
        Snap.cos = function (angle) {
            return math.cos(Snap.rad(angle));
        };
        /*\
         * Snap.asin
         [ method ]
         **
         * Equivalent to `Math.asin()` only works with degrees, not radians.
         - num (number) value
         = (number) asin in degrees
        \*/
        Snap.asin = function (num) {
            return Snap.deg(math.asin(num));
        };
        /*\
         * Snap.acos
         [ method ]
         **
         * Equivalent to `Math.acos()` only works with degrees, not radians.
         - num (number) value
         = (number) acos in degrees
        \*/
        Snap.acos = function (num) {
            return Snap.deg(math.acos(num));
        };
        /*\
         * Snap.atan
         [ method ]
         **
         * Equivalent to `Math.atan()` only works with degrees, not radians.
         - num (number) value
         = (number) atan in degrees
        \*/
        Snap.atan = function (num) {
            return Snap.deg(math.atan(num));
        };
        /*\
         * Snap.atan2
         [ method ]
         **
         * Equivalent to `Math.atan2()` only works with degrees, not radians.
         - num (number) value
         = (number) atan2 in degrees
        \*/
        Snap.atan2 = function (num) {
            return Snap.deg(math.atan2(num));
        };
        /*\
         * Snap.angle
         [ method ]
         **
         * Returns an angle between two or three points
         > Parameters
         - x1 (number) x coord of first point
         - y1 (number) y coord of first point
         - x2 (number) x coord of second point
         - y2 (number) y coord of second point
         - x3 (number) #optional x coord of third point
         - y3 (number) #optional y coord of third point
         = (number) angle in degrees
        \*/
        Snap.angle = angle;
        /*\
         * Snap.len
         [ method ]
         **
         * Returns distance between two points
         > Parameters
         - x1 (number) x coord of first point
         - y1 (number) y coord of first point
         - x2 (number) x coord of second point
         - y2 (number) y coord of second point
         = (number) distance
        \*/
        Snap.len = function (x1, y1, x2, y2) {
            return Math.sqrt(Snap.len2(x1, y1, x2, y2));
        };
        /*\
         * Snap.len2
         [ method ]
         **
         * Returns squared distance between two points
         > Parameters
         - x1 (number) x coord of first point
         - y1 (number) y coord of first point
         - x2 (number) x coord of second point
         - y2 (number) y coord of second point
         = (number) distance
        \*/
        Snap.len2 = function (x1, y1, x2, y2) {
            return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
        };
        /*\
         * Snap.closestPoint
         [ method ]
         **
         * Returns closest point to a given one on a given path.
         > Parameters
         - path (Element) path element
         - x (number) x coord of a point
         - y (number) y coord of a point
         = (object) in format
         {
            x (number) x coord of the point on the path
            y (number) y coord of the point on the path
            length (number) length of the path to the point
            distance (number) distance from the given point to the path
         }
        \*/
        // Copied from http://bl.ocks.org/mbostock/8027637
        Snap.closestPoint = function (path, x, y) {
            function distance2(p) {
                var dx = p.x - x,
                    dy = p.y - y;
                return dx * dx + dy * dy;
            }
            var pathNode = path.node,
                pathLength = pathNode.getTotalLength(),
                precision = pathLength / pathNode.pathSegList.numberOfItems * .125,
                best,
                bestLength,
                bestDistance = Infinity;

            // linear scan for coarse approximation
            for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
                if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
                    best = scan, bestLength = scanLength, bestDistance = scanDistance;
                }
            }

            // binary search for precise estimate
            precision *= .5;
            while (precision > .5) {
                var before, after, beforeLength, afterLength, beforeDistance, afterDistance;
                if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
                    best = before, bestLength = beforeLength, bestDistance = beforeDistance;
                } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
                    best = after, bestLength = afterLength, bestDistance = afterDistance;
                } else {
                    precision *= .5;
                }
            }

            best = {
                x: best.x,
                y: best.y,
                length: bestLength,
                distance: Math.sqrt(bestDistance)
            };
            return best;
        };
        /*\
         * Snap.is
         [ method ]
         **
         * Handy replacement for the `typeof` operator
         - o (…) any object or primitive
         - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
         = (boolean) `true` if given value is of given type
        \*/
        Snap.is = is;
        /*\
         * Snap.snapTo
         [ method ]
         **
         * Snaps given value to given grid
         - values (array|number) given array of values or step of the grid
         - value (number) value to adjust
         - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
         = (number) adjusted value
        \*/
        Snap.snapTo = function (values, value, tolerance) {
            tolerance = is(tolerance, "finite") ? tolerance : 10;
            if (is(values, "array")) {
                var i = values.length;
                while (i--) {
                    if (abs(values[i] - value) <= tolerance) {
                        return values[i];
                    }
                }
            } else {
                values = +values;
                var rem = value % values;
                if (rem < tolerance) {
                    return value - rem;
                }
                if (rem > values - tolerance) {
                    return value - rem + values;
                }
            }
            return value;
        };
        // Colour
        /*\
         * Snap.getRGB
         [ method ]
         **
         * Parses color string as RGB object
         - color (string) color string in one of the following formats:
         # <ul>
         #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
         #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
         #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
         #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
         #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>
         #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
         #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>
         #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
         #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>
         #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
         #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>
         #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
         #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>
         #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
         #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>
         # </ul>
         * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
         = (object) RGB object in the following format:
         o {
         o     r (number) red,
         o     g (number) green,
         o     b (number) blue,
         o     hex (string) color in HTML/CSS format: #••••••,
         o     error (boolean) true if string can't be parsed
         o }
        \*/
        Snap.getRGB = cacher(function (colour) {
            if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
                return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString };
            }
            if (colour == "none") {
                return { r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString };
            }
            !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
            if (!colour) {
                return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString };
            }
            var res,
                red,
                green,
                blue,
                opacity,
                t,
                values,
                rgb = colour.match(colourRegExp);
            if (rgb) {
                if (rgb[2]) {
                    blue = toInt(rgb[2].substring(5), 16);
                    green = toInt(rgb[2].substring(3, 5), 16);
                    red = toInt(rgb[2].substring(1, 3), 16);
                }
                if (rgb[3]) {
                    blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                    green = toInt((t = rgb[3].charAt(2)) + t, 16);
                    red = toInt((t = rgb[3].charAt(1)) + t, 16);
                }
                if (rgb[4]) {
                    values = rgb[4].split(commaSpaces);
                    red = toFloat(values[0]);
                    values[0].slice(-1) == "%" && (red *= 2.55);
                    green = toFloat(values[1]);
                    values[1].slice(-1) == "%" && (green *= 2.55);
                    blue = toFloat(values[2]);
                    values[2].slice(-1) == "%" && (blue *= 2.55);
                    rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                }
                if (rgb[5]) {
                    values = rgb[5].split(commaSpaces);
                    red = toFloat(values[0]);
                    values[0].slice(-1) == "%" && (red /= 100);
                    green = toFloat(values[1]);
                    values[1].slice(-1) == "%" && (green /= 100);
                    blue = toFloat(values[2]);
                    values[2].slice(-1) == "%" && (blue /= 100);
                    (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                    rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                    return Snap.hsb2rgb(red, green, blue, opacity);
                }
                if (rgb[6]) {
                    values = rgb[6].split(commaSpaces);
                    red = toFloat(values[0]);
                    values[0].slice(-1) == "%" && (red /= 100);
                    green = toFloat(values[1]);
                    values[1].slice(-1) == "%" && (green /= 100);
                    blue = toFloat(values[2]);
                    values[2].slice(-1) == "%" && (blue /= 100);
                    (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                    rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                    return Snap.hsl2rgb(red, green, blue, opacity);
                }
                red = mmin(math.round(red), 255);
                green = mmin(math.round(green), 255);
                blue = mmin(math.round(blue), 255);
                opacity = mmin(mmax(opacity, 0), 1);
                rgb = { r: red, g: green, b: blue, toString: rgbtoString };
                rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
                rgb.opacity = is(opacity, "finite") ? opacity : 1;
                return rgb;
            }
            return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString };
        }, Snap);
        /*\
         * Snap.hsb
         [ method ]
         **
         * Converts HSB values to a hex representation of the color
         - h (number) hue
         - s (number) saturation
         - b (number) value or brightness
         = (string) hex representation of the color
        \*/
        Snap.hsb = cacher(function (h, s, b) {
            return Snap.hsb2rgb(h, s, b).hex;
        });
        /*\
         * Snap.hsl
         [ method ]
         **
         * Converts HSL values to a hex representation of the color
         - h (number) hue
         - s (number) saturation
         - l (number) luminosity
         = (string) hex representation of the color
        \*/
        Snap.hsl = cacher(function (h, s, l) {
            return Snap.hsl2rgb(h, s, l).hex;
        });
        /*\
         * Snap.rgb
         [ method ]
         **
         * Converts RGB values to a hex representation of the color
         - r (number) red
         - g (number) green
         - b (number) blue
         = (string) hex representation of the color
        \*/
        Snap.rgb = cacher(function (r, g, b, o) {
            if (is(o, "finite")) {
                var round = math.round;
                return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
            }
            return "#" + (16777216 | b | g << 8 | r << 16).toString(16).slice(1);
        });
        var toHex = function (color) {
            var i = glob.doc.getElementsByTagName("head")[0] || glob.doc.getElementsByTagName("svg")[0],
                red = "rgb(255, 0, 0)";
            toHex = cacher(function (color) {
                if (color.toLowerCase() == "red") {
                    return red;
                }
                i.style.color = red;
                i.style.color = color;
                var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                return out == red ? null : out;
            });
            return toHex(color);
        },
            hsbtoString = function () {
            return "hsb(" + [this.h, this.s, this.b] + ")";
        },
            hsltoString = function () {
            return "hsl(" + [this.h, this.s, this.l] + ")";
        },
            rgbtoString = function () {
            return this.opacity == 1 || this.opacity == null ? this.hex : "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
        },
            prepareRGB = function (r, g, b) {
            if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
                b = r.b;
                g = r.g;
                r = r.r;
            }
            if (g == null && is(r, string)) {
                var clr = Snap.getRGB(r);
                r = clr.r;
                g = clr.g;
                b = clr.b;
            }
            if (r > 1 || g > 1 || b > 1) {
                r /= 255;
                g /= 255;
                b /= 255;
            }

            return [r, g, b];
        },
            packageRGB = function (r, g, b, o) {
            r = math.round(r * 255);
            g = math.round(g * 255);
            b = math.round(b * 255);
            var rgb = {
                r: r,
                g: g,
                b: b,
                opacity: is(o, "finite") ? o : 1,
                hex: Snap.rgb(r, g, b),
                toString: rgbtoString
            };
            is(o, "finite") && (rgb.opacity = o);
            return rgb;
        };
        /*\
         * Snap.color
         [ method ]
         **
         * Parses the color string and returns an object featuring the color's component values
         - clr (string) color string in one of the supported formats (see @Snap.getRGB)
         = (object) Combined RGB/HSB object in the following format:
         o {
         o     r (number) red,
         o     g (number) green,
         o     b (number) blue,
         o     hex (string) color in HTML/CSS format: #••••••,
         o     error (boolean) `true` if string can't be parsed,
         o     h (number) hue,
         o     s (number) saturation,
         o     v (number) value (brightness),
         o     l (number) lightness
         o }
        \*/
        Snap.color = function (clr) {
            var rgb;
            if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
                rgb = Snap.hsb2rgb(clr);
                clr.r = rgb.r;
                clr.g = rgb.g;
                clr.b = rgb.b;
                clr.opacity = 1;
                clr.hex = rgb.hex;
            } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
                rgb = Snap.hsl2rgb(clr);
                clr.r = rgb.r;
                clr.g = rgb.g;
                clr.b = rgb.b;
                clr.opacity = 1;
                clr.hex = rgb.hex;
            } else {
                if (is(clr, "string")) {
                    clr = Snap.getRGB(clr);
                }
                if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
                    rgb = Snap.rgb2hsl(clr);
                    clr.h = rgb.h;
                    clr.s = rgb.s;
                    clr.l = rgb.l;
                    rgb = Snap.rgb2hsb(clr);
                    clr.v = rgb.b;
                } else {
                    clr = { hex: "none" };
                    clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
                    clr.error = 1;
                }
            }
            clr.toString = rgbtoString;
            return clr;
        };
        /*\
         * Snap.hsb2rgb
         [ method ]
         **
         * Converts HSB values to an RGB object
         - h (number) hue
         - s (number) saturation
         - v (number) value or brightness
         = (object) RGB object in the following format:
         o {
         o     r (number) red,
         o     g (number) green,
         o     b (number) blue,
         o     hex (string) color in HTML/CSS format: #••••••
         o }
        \*/
        Snap.hsb2rgb = function (h, s, v, o) {
            if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
                v = h.b;
                s = h.s;
                o = h.o;
                h = h.h;
            }
            h *= 360;
            var R, G, B, X, C;
            h = h % 360 / 60;
            C = v * s;
            X = C * (1 - abs(h % 2 - 1));
            R = G = B = v - C;

            h = ~~h;
            R += [C, X, 0, 0, X, C][h];
            G += [X, C, C, X, 0, 0][h];
            B += [0, 0, X, C, C, X][h];
            return packageRGB(R, G, B, o);
        };
        /*\
         * Snap.hsl2rgb
         [ method ]
         **
         * Converts HSL values to an RGB object
         - h (number) hue
         - s (number) saturation
         - l (number) luminosity
         = (object) RGB object in the following format:
         o {
         o     r (number) red,
         o     g (number) green,
         o     b (number) blue,
         o     hex (string) color in HTML/CSS format: #••••••
         o }
        \*/
        Snap.hsl2rgb = function (h, s, l, o) {
            if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
                l = h.l;
                s = h.s;
                h = h.h;
            }
            if (h > 1 || s > 1 || l > 1) {
                h /= 360;
                s /= 100;
                l /= 100;
            }
            h *= 360;
            var R, G, B, X, C;
            h = h % 360 / 60;
            C = 2 * s * (l < .5 ? l : 1 - l);
            X = C * (1 - abs(h % 2 - 1));
            R = G = B = l - C / 2;

            h = ~~h;
            R += [C, X, 0, 0, X, C][h];
            G += [X, C, C, X, 0, 0][h];
            B += [0, 0, X, C, C, X][h];
            return packageRGB(R, G, B, o);
        };
        /*\
         * Snap.rgb2hsb
         [ method ]
         **
         * Converts RGB values to an HSB object
         - r (number) red
         - g (number) green
         - b (number) blue
         = (object) HSB object in the following format:
         o {
         o     h (number) hue,
         o     s (number) saturation,
         o     b (number) brightness
         o }
        \*/
        Snap.rgb2hsb = function (r, g, b) {
            b = prepareRGB(r, g, b);
            r = b[0];
            g = b[1];
            b = b[2];

            var H, S, V, C;
            V = mmax(r, g, b);
            C = V - mmin(r, g, b);
            H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4;
            H = (H + 360) % 6 * 60 / 360;
            S = C == 0 ? 0 : C / V;
            return { h: H, s: S, b: V, toString: hsbtoString };
        };
        /*\
         * Snap.rgb2hsl
         [ method ]
         **
         * Converts RGB values to an HSL object
         - r (number) red
         - g (number) green
         - b (number) blue
         = (object) HSL object in the following format:
         o {
         o     h (number) hue,
         o     s (number) saturation,
         o     l (number) luminosity
         o }
        \*/
        Snap.rgb2hsl = function (r, g, b) {
            b = prepareRGB(r, g, b);
            r = b[0];
            g = b[1];
            b = b[2];

            var H, S, L, M, m, C;
            M = mmax(r, g, b);
            m = mmin(r, g, b);
            C = M - m;
            H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4;
            H = (H + 360) % 6 * 60 / 360;
            L = (M + m) / 2;
            S = C == 0 ? 0 : L < .5 ? C / (2 * L) : C / (2 - 2 * L);
            return { h: H, s: S, l: L, toString: hsltoString };
        };

        // Transformations
        /*\
         * Snap.parsePathString
         [ method ]
         **
         * Utility method
         **
         * Parses given path string into an array of arrays of path segments
         - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
         = (array) array of segments
        \*/
        Snap.parsePathString = function (pathString) {
            if (!pathString) {
                return null;
            }
            var pth = Snap.path(pathString);
            if (pth.arr) {
                return Snap.path.clone(pth.arr);
            }

            var paramCounts = { a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0 },
                data = [];
            if (is(pathString, "array") && is(pathString[0], "array")) {
                // rough assumption
                data = Snap.path.clone(pathString);
            }
            if (!data.length) {
                Str(pathString).replace(pathCommand, function (a, b, c) {
                    var params = [],
                        name = b.toLowerCase();
                    c.replace(pathValues, function (a, b) {
                        b && params.push(+b);
                    });
                    if (name == "m" && params.length > 2) {
                        data.push([b].concat(params.splice(0, 2)));
                        name = "l";
                        b = b == "m" ? "l" : "L";
                    }
                    if (name == "o" && params.length == 1) {
                        data.push([b, params[0]]);
                    }
                    if (name == "r") {
                        data.push([b].concat(params));
                    } else while (params.length >= paramCounts[name]) {
                        data.push([b].concat(params.splice(0, paramCounts[name])));
                        if (!paramCounts[name]) {
                            break;
                        }
                    }
                });
            }
            data.toString = Snap.path.toString;
            pth.arr = Snap.path.clone(data);
            return data;
        };
        /*\
         * Snap.parseTransformString
         [ method ]
         **
         * Utility method
         **
         * Parses given transform string into an array of transformations
         - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
         = (array) array of transformations
        \*/
        var parseTransformString = Snap.parseTransformString = function (TString) {
            if (!TString) {
                return null;
            }
            var paramCounts = { r: 3, s: 4, t: 2, m: 6 },
                data = [];
            if (is(TString, "array") && is(TString[0], "array")) {
                // rough assumption
                data = Snap.path.clone(TString);
            }
            if (!data.length) {
                Str(TString).replace(tCommand, function (a, b, c) {
                    var params = [],
                        name = b.toLowerCase();
                    c.replace(pathValues, function (a, b) {
                        b && params.push(+b);
                    });
                    data.push([b].concat(params));
                });
            }
            data.toString = Snap.path.toString;
            return data;
        };
        function svgTransform2string(tstr) {
            var res = [];
            tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
                params = params.split(/\s*,\s*|\s+/);
                if (name == "rotate" && params.length == 1) {
                    params.push(0, 0);
                }
                if (name == "scale") {
                    if (params.length > 2) {
                        params = params.slice(0, 2);
                    } else if (params.length == 2) {
                        params.push(0, 0);
                    }
                    if (params.length == 1) {
                        params.push(params[0], 0, 0);
                    }
                }
                if (name == "skewX") {
                    res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
                } else if (name == "skewY") {
                    res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
                } else {
                    res.push([name.charAt(0)].concat(params));
                }
                return all;
            });
            return res;
        }
        Snap._.svgTransform2string = svgTransform2string;
        Snap._.rgTransform = /^[a-z][\s]*-?\.?\d/i;
        function transform2matrix(tstr, bbox) {
            var tdata = parseTransformString(tstr),
                m = new Snap.Matrix();
            if (tdata) {
                for (var i = 0, ii = tdata.length; i < ii; i++) {
                    var t = tdata[i],
                        tlen = t.length,
                        command = Str(t[0]).toLowerCase(),
                        absolute = t[0] != command,
                        inver = absolute ? m.invert() : 0,
                        x1,
                        y1,
                        x2,
                        y2,
                        bb;
                    if (command == "t" && tlen == 2) {
                        m.translate(t[1], 0);
                    } else if (command == "t" && tlen == 3) {
                        if (absolute) {
                            x1 = inver.x(0, 0);
                            y1 = inver.y(0, 0);
                            x2 = inver.x(t[1], t[2]);
                            y2 = inver.y(t[1], t[2]);
                            m.translate(x2 - x1, y2 - y1);
                        } else {
                            m.translate(t[1], t[2]);
                        }
                    } else if (command == "r") {
                        if (tlen == 2) {
                            bb = bb || bbox;
                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.rotate(t[1], x2, y2);
                            } else {
                                m.rotate(t[1], t[2], t[3]);
                            }
                        }
                    } else if (command == "s") {
                        if (tlen == 2 || tlen == 3) {
                            bb = bb || bbox;
                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.scale(t[1], t[1], x2, y2);
                            } else {
                                m.scale(t[1], t[1], t[2], t[3]);
                            }
                        } else if (tlen == 5) {
                            if (absolute) {
                                x2 = inver.x(t[3], t[4]);
                                y2 = inver.y(t[3], t[4]);
                                m.scale(t[1], t[2], x2, y2);
                            } else {
                                m.scale(t[1], t[2], t[3], t[4]);
                            }
                        }
                    } else if (command == "m" && tlen == 7) {
                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                    }
                }
            }
            return m;
        }
        Snap._.transform2matrix = transform2matrix;
        Snap._unit2px = unit2px;
        var contains = glob.doc.contains || glob.doc.compareDocumentPosition ? function (a, b) {
            var adown = a.nodeType == 9 ? a.documentElement : a,
                bup = b && b.parentNode;
            return a == bup || !!(bup && bup.nodeType == 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        } : function (a, b) {
            if (b) {
                while (b) {
                    b = b.parentNode;
                    if (b == a) {
                        return true;
                    }
                }
            }
            return false;
        };
        function getSomeDefs(el) {
            var p = el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || el.node.parentNode && wrap(el.node.parentNode) || Snap.select("svg") || Snap(0, 0),
                pdefs = p.select("defs"),
                defs = pdefs == null ? false : pdefs.node;
            if (!defs) {
                defs = make("defs", p.node).node;
            }
            return defs;
        }
        function getSomeSVG(el) {
            return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select("svg");
        }
        Snap._.getSomeDefs = getSomeDefs;
        Snap._.getSomeSVG = getSomeSVG;
        function unit2px(el, name, value) {
            var svg = getSomeSVG(el).node,
                out = {},
                mgr = svg.querySelector(".svg---mgr");
            if (!mgr) {
                mgr = $("rect");
                $(mgr, { x: -9e9, y: -9e9, width: 10, height: 10, "class": "svg---mgr", fill: "none" });
                svg.appendChild(mgr);
            }
            function getW(val) {
                if (val == null) {
                    return E;
                }
                if (val == +val) {
                    return val;
                }
                $(mgr, { width: val });
                try {
                    return mgr.getBBox().width;
                } catch (e) {
                    return 0;
                }
            }
            function getH(val) {
                if (val == null) {
                    return E;
                }
                if (val == +val) {
                    return val;
                }
                $(mgr, { height: val });
                try {
                    return mgr.getBBox().height;
                } catch (e) {
                    return 0;
                }
            }
            function set(nam, f) {
                if (name == null) {
                    out[nam] = f(el.attr(nam) || 0);
                } else if (nam == name) {
                    out = f(value == null ? el.attr(nam) || 0 : value);
                }
            }
            switch (el.type) {
                case "rect":
                    set("rx", getW);
                    set("ry", getH);
                case "image":
                    set("width", getW);
                    set("height", getH);
                case "text":
                    set("x", getW);
                    set("y", getH);
                    break;
                case "circle":
                    set("cx", getW);
                    set("cy", getH);
                    set("r", getW);
                    break;
                case "ellipse":
                    set("cx", getW);
                    set("cy", getH);
                    set("rx", getW);
                    set("ry", getH);
                    break;
                case "line":
                    set("x1", getW);
                    set("x2", getW);
                    set("y1", getH);
                    set("y2", getH);
                    break;
                case "marker":
                    set("refX", getW);
                    set("markerWidth", getW);
                    set("refY", getH);
                    set("markerHeight", getH);
                    break;
                case "radialGradient":
                    set("fx", getW);
                    set("fy", getH);
                    break;
                case "tspan":
                    set("dx", getW);
                    set("dy", getH);
                    break;
                default:
                    set(name, getW);
            }
            svg.removeChild(mgr);
            return out;
        }
        /*\
         * Snap.select
         [ method ]
         **
         * Wraps a DOM element specified by CSS selector as @Element
         - query (string) CSS selector of the element
         = (Element) the current element
        \*/
        Snap.select = function (query) {
            query = Str(query).replace(/([^\\]):/g, "$1\\:");
            return wrap(glob.doc.querySelector(query));
        };
        /*\
         * Snap.selectAll
         [ method ]
         **
         * Wraps DOM elements specified by CSS selector as set or array of @Element
         - query (string) CSS selector of the element
         = (Element) the current element
        \*/
        Snap.selectAll = function (query) {
            var nodelist = glob.doc.querySelectorAll(query),
                set = (Snap.set || Array)();
            for (var i = 0; i < nodelist.length; i++) {
                set.push(wrap(nodelist[i]));
            }
            return set;
        };

        function add2group(list) {
            if (!is(list, "array")) {
                list = Array.prototype.slice.call(arguments, 0);
            }
            var i = 0,
                j = 0,
                node = this.node;
            while (this[i]) {
                delete this[i++];
            }for (i = 0; i < list.length; i++) {
                if (list[i].type == "set") {
                    list[i].forEach(function (el) {
                        node.appendChild(el.node);
                    });
                } else {
                    node.appendChild(list[i].node);
                }
            }
            var children = node.childNodes;
            for (i = 0; i < children.length; i++) {
                this[j++] = wrap(children[i]);
            }
            return this;
        }
        // Hub garbage collector every 10s
        setInterval(function () {
            for (var key in hub) {
                if (hub[has](key)) {
                    var el = hub[key],
                        node = el.node;
                    if (el.type != "svg" && !node.ownerSVGElement || el.type == "svg" && (!node.parentNode || "ownerSVGElement" in node.parentNode && !node.ownerSVGElement)) {
                        delete hub[key];
                    }
                }
            }
        }, 1e4);
        function Element(el) {
            if (el.snap in hub) {
                return hub[el.snap];
            }
            var svg;
            try {
                svg = el.ownerSVGElement;
            } catch (e) {}
            /*\
             * Element.node
             [ property (object) ]
             **
             * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
             > Usage
             | // draw a circle at coordinate 10,10 with radius of 10
             | var c = paper.circle(10, 10, 10);
             | c.node.onclick = function () {
             |     c.attr("fill", "red");
             | };
            \*/
            this.node = el;
            if (svg) {
                this.paper = new Paper(svg);
            }
            /*\
             * Element.type
             [ property (string) ]
             **
             * SVG tag name of the given element.
            \*/
            this.type = el.tagName || el.nodeName;
            var id = this.id = ID(this);
            this.anims = {};
            this._ = {
                transform: []
            };
            el.snap = id;
            hub[id] = this;
            if (this.type == "g") {
                this.add = add2group;
            }
            if (this.type in { g: 1, mask: 1, pattern: 1, symbol: 1 }) {
                for (var method in Paper.prototype) {
                    if (Paper.prototype[has](method)) {
                        this[method] = Paper.prototype[method];
                    }
                }
            }
        }
        /*\
          * Element.attr
          [ method ]
          **
          * Gets or sets given attributes of the element.
          **
          - params (object) contains key-value pairs of attributes you want to set
          * or
          - param (string) name of the attribute
          = (Element) the current element
          * or
          = (string) value of attribute
          > Usage
          | el.attr({
          |     fill: "#fc0",
          |     stroke: "#000",
          |     strokeWidth: 2, // CamelCase...
          |     "fill-opacity": 0.5, // or dash-separated names
          |     width: "*=2" // prefixed values
          | });
          | console.log(el.attr("fill")); // #fc0
          * Prefixed values in format `"+=10"` supported. All four operations
          * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`
          * and `-`: `"+=2em"`.
         \*/
        Element.prototype.attr = function (params, value) {
            var el = this,
                node = el.node;
            if (!params) {
                if (node.nodeType != 1) {
                    return {
                        text: node.nodeValue
                    };
                }
                var attr = node.attributes,
                    out = {};
                for (var i = 0, ii = attr.length; i < ii; i++) {
                    out[attr[i].nodeName] = attr[i].nodeValue;
                }
                return out;
            }
            if (is(params, "string")) {
                if (arguments.length > 1) {
                    var json = {};
                    json[params] = value;
                    params = json;
                } else {
                    return eve("snap.util.getattr." + params, el).firstDefined();
                }
            }
            for (var att in params) {
                if (params[has](att)) {
                    eve("snap.util.attr." + att, el, params[att]);
                }
            }
            return el;
        };
        /*\
         * Snap.parse
         [ method ]
         **
         * Parses SVG fragment and converts it into a @Fragment
         **
         - svg (string) SVG string
         = (Fragment) the @Fragment
        \*/
        Snap.parse = function (svg) {
            var f = glob.doc.createDocumentFragment(),
                full = true,
                div = glob.doc.createElement("div");
            svg = Str(svg);
            if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
                svg = "<svg>" + svg + "</svg>";
                full = false;
            }
            div.innerHTML = svg;
            svg = div.getElementsByTagName("svg")[0];
            if (svg) {
                if (full) {
                    f = svg;
                } else {
                    while (svg.firstChild) {
                        f.appendChild(svg.firstChild);
                    }
                }
            }
            return new Fragment(f);
        };
        function Fragment(frag) {
            this.node = frag;
        }
        /*\
         * Snap.fragment
         [ method ]
         **
         * Creates a DOM fragment from a given list of elements or strings
         **
         - varargs (…) SVG string
         = (Fragment) the @Fragment
        \*/
        Snap.fragment = function () {
            var args = Array.prototype.slice.call(arguments, 0),
                f = glob.doc.createDocumentFragment();
            for (var i = 0, ii = args.length; i < ii; i++) {
                var item = args[i];
                if (item.node && item.node.nodeType) {
                    f.appendChild(item.node);
                }
                if (item.nodeType) {
                    f.appendChild(item);
                }
                if (typeof item == "string") {
                    f.appendChild(Snap.parse(item).node);
                }
            }
            return new Fragment(f);
        };

        function make(name, parent) {
            var res = $(name);
            parent.appendChild(res);
            var el = wrap(res);
            return el;
        }
        function Paper(w, h) {
            var res,
                desc,
                defs,
                proto = Paper.prototype;
            if (w && w.tagName == "svg") {
                if (w.snap in hub) {
                    return hub[w.snap];
                }
                var doc = w.ownerDocument;
                res = new Element(w);
                desc = w.getElementsByTagName("desc")[0];
                defs = w.getElementsByTagName("defs")[0];
                if (!desc) {
                    desc = $("desc");
                    desc.appendChild(doc.createTextNode("Created with Snap"));
                    res.node.appendChild(desc);
                }
                if (!defs) {
                    defs = $("defs");
                    res.node.appendChild(defs);
                }
                res.defs = defs;
                for (var key in proto) {
                    if (proto[has](key)) {
                        res[key] = proto[key];
                    }
                }res.paper = res.root = res;
            } else {
                res = make("svg", glob.doc.body);
                $(res.node, {
                    height: h,
                    version: 1.1,
                    width: w,
                    xmlns: xmlns
                });
            }
            return res;
        }
        function wrap(dom) {
            if (!dom) {
                return dom;
            }
            if (dom instanceof Element || dom instanceof Fragment) {
                return dom;
            }
            if (dom.tagName && dom.tagName.toLowerCase() == "svg") {
                return new Paper(dom);
            }
            if (dom.tagName && dom.tagName.toLowerCase() == "object" && dom.type == "image/svg+xml") {
                return new Paper(dom.contentDocument.getElementsByTagName("svg")[0]);
            }
            return new Element(dom);
        }

        Snap._.make = make;
        Snap._.wrap = wrap;
        /*\
         * Paper.el
         [ method ]
         **
         * Creates an element on paper with a given name and no attributes
         **
         - name (string) tag name
         - attr (object) attributes
         = (Element) the current element
         > Usage
         | var c = paper.circle(10, 10, 10); // is the same as...
         | var c = paper.el("circle").attr({
         |     cx: 10,
         |     cy: 10,
         |     r: 10
         | });
         | // and the same as
         | var c = paper.el("circle", {
         |     cx: 10,
         |     cy: 10,
         |     r: 10
         | });
        \*/
        Paper.prototype.el = function (name, attr) {
            var el = make(name, this.node);
            attr && el.attr(attr);
            return el;
        };
        /*\
         * Element.children
         [ method ]
         **
         * Returns array of all the children of the element.
         = (array) array of Elements
        \*/
        Element.prototype.children = function () {
            var out = [],
                ch = this.node.childNodes;
            for (var i = 0, ii = ch.length; i < ii; i++) {
                out[i] = Snap(ch[i]);
            }
            return out;
        };
        function jsonFiller(root, o) {
            for (var i = 0, ii = root.length; i < ii; i++) {
                var item = {
                    type: root[i].type,
                    attr: root[i].attr()
                },
                    children = root[i].children();
                o.push(item);
                if (children.length) {
                    jsonFiller(children, item.childNodes = []);
                }
            }
        }
        /*\
         * Element.toJSON
         [ method ]
         **
         * Returns object representation of the given element and all its children.
         = (object) in format
         o {
         o     type (string) this.type,
         o     attr (object) attributes map,
         o     childNodes (array) optional array of children in the same format
         o }
        \*/
        Element.prototype.toJSON = function () {
            var out = [];
            jsonFiller([this], out);
            return out[0];
        };
        // default
        eve.on("snap.util.getattr", function () {
            var att = eve.nt();
            att = att.substring(att.lastIndexOf(".") + 1);
            var css = att.replace(/[A-Z]/g, function (letter) {
                return "-" + letter.toLowerCase();
            });
            if (cssAttr[has](css)) {
                return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
            } else {
                return $(this.node, att);
            }
        });
        var cssAttr = {
            "alignment-baseline": 0,
            "baseline-shift": 0,
            "clip": 0,
            "clip-path": 0,
            "clip-rule": 0,
            "color": 0,
            "color-interpolation": 0,
            "color-interpolation-filters": 0,
            "color-profile": 0,
            "color-rendering": 0,
            "cursor": 0,
            "direction": 0,
            "display": 0,
            "dominant-baseline": 0,
            "enable-background": 0,
            "fill": 0,
            "fill-opacity": 0,
            "fill-rule": 0,
            "filter": 0,
            "flood-color": 0,
            "flood-opacity": 0,
            "font": 0,
            "font-family": 0,
            "font-size": 0,
            "font-size-adjust": 0,
            "font-stretch": 0,
            "font-style": 0,
            "font-variant": 0,
            "font-weight": 0,
            "glyph-orientation-horizontal": 0,
            "glyph-orientation-vertical": 0,
            "image-rendering": 0,
            "kerning": 0,
            "letter-spacing": 0,
            "lighting-color": 0,
            "marker": 0,
            "marker-end": 0,
            "marker-mid": 0,
            "marker-start": 0,
            "mask": 0,
            "opacity": 0,
            "overflow": 0,
            "pointer-events": 0,
            "shape-rendering": 0,
            "stop-color": 0,
            "stop-opacity": 0,
            "stroke": 0,
            "stroke-dasharray": 0,
            "stroke-dashoffset": 0,
            "stroke-linecap": 0,
            "stroke-linejoin": 0,
            "stroke-miterlimit": 0,
            "stroke-opacity": 0,
            "stroke-width": 0,
            "text-anchor": 0,
            "text-decoration": 0,
            "text-rendering": 0,
            "unicode-bidi": 0,
            "visibility": 0,
            "word-spacing": 0,
            "writing-mode": 0
        };

        eve.on("snap.util.attr", function (value) {
            var att = eve.nt(),
                attr = {};
            att = att.substring(att.lastIndexOf(".") + 1);
            attr[att] = value;
            var style = att.replace(/-(\w)/gi, function (all, letter) {
                return letter.toUpperCase();
            }),
                css = att.replace(/[A-Z]/g, function (letter) {
                return "-" + letter.toLowerCase();
            });
            if (cssAttr[has](css)) {
                this.node.style[style] = value == null ? E : value;
            } else {
                $(this.node, attr);
            }
        });
        (function (proto) {})(Paper.prototype);

        // simple ajax
        /*\
         * Snap.ajax
         [ method ]
         **
         * Simple implementation of Ajax
         **
         - url (string) URL
         - postData (object|string) data for post request
         - callback (function) callback
         - scope (object) #optional scope of callback
         * or
         - url (string) URL
         - callback (function) callback
         - scope (object) #optional scope of callback
         = (XMLHttpRequest) the XMLHttpRequest object, just in case
        \*/
        Snap.ajax = function (url, postData, callback, scope) {
            var req = new XMLHttpRequest(),
                id = ID();
            if (req) {
                if (is(postData, "function")) {
                    scope = callback;
                    callback = postData;
                    postData = null;
                } else if (is(postData, "object")) {
                    var pd = [];
                    for (var key in postData) {
                        if (postData.hasOwnProperty(key)) {
                            pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
                        }
                    }postData = pd.join("&");
                }
                req.open(postData ? "POST" : "GET", url, true);
                if (postData) {
                    req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                    req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                }
                if (callback) {
                    eve.once("snap.ajax." + id + ".0", callback);
                    eve.once("snap.ajax." + id + ".200", callback);
                    eve.once("snap.ajax." + id + ".304", callback);
                }
                req.onreadystatechange = function () {
                    if (req.readyState != 4) return;
                    eve("snap.ajax." + id + "." + req.status, scope, req);
                };
                if (req.readyState == 4) {
                    return req;
                }
                req.send(postData);
                return req;
            }
        };
        /*\
         * Snap.load
         [ method ]
         **
         * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
         **
         - url (string) URL
         - callback (function) callback
         - scope (object) #optional scope of callback
        \*/
        Snap.load = function (url, callback, scope) {
            Snap.ajax(url, function (req) {
                var f = Snap.parse(req.responseText);
                scope ? callback.call(scope, f) : callback(f);
            });
        };
        var getOffset = function (elem) {
            var box = elem.getBoundingClientRect(),
                doc = elem.ownerDocument,
                body = doc.body,
                docElem = doc.documentElement,
                clientTop = docElem.clientTop || body.clientTop || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,
                left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
            return {
                y: top,
                x: left
            };
        };
        /*\
         * Snap.getElementByPoint
         [ method ]
         **
         * Returns you topmost element under given point.
         **
         = (object) Snap element object
         - x (number) x coordinate from the top left corner of the window
         - y (number) y coordinate from the top left corner of the window
         > Usage
         | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
        \*/
        Snap.getElementByPoint = function (x, y) {
            var paper = this,
                svg = paper.canvas,
                target = glob.doc.elementFromPoint(x, y);
            if (glob.win.opera && target.tagName == "svg") {
                var so = getOffset(target),
                    sr = target.createSVGRect();
                sr.x = x - so.x;
                sr.y = y - so.y;
                sr.width = sr.height = 1;
                var hits = target.getIntersectionList(sr, null);
                if (hits.length) {
                    target = hits[hits.length - 1];
                }
            }
            if (!target) {
                return null;
            }
            return wrap(target);
        };
        /*\
         * Snap.plugin
         [ method ]
         **
         * Let you write plugins. You pass in a function with five arguments, like this:
         | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {
         |     Snap.newmethod = function () {};
         |     Element.prototype.newmethod = function () {};
         |     Paper.prototype.newmethod = function () {};
         | });
         * Inside the function you have access to all main objects (and their
         * prototypes). This allow you to extend anything you want.
         **
         - f (function) your plugin body
        \*/
        Snap.plugin = function (f) {
            f(Snap, Element, Paper, glob, Fragment);
        };
        glob.win.Snap = Snap;
        return Snap;
    }(window || this);

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    // http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var elproto = Element.prototype,
            is = Snap.is,
            Str = String,
            unit2px = Snap._unit2px,
            $ = Snap._.$,
            make = Snap._.make,
            getSomeDefs = Snap._.getSomeDefs,
            has = "hasOwnProperty",
            wrap = Snap._.wrap;
        /*\
         * Element.getBBox
         [ method ]
         **
         * Returns the bounding box descriptor for the given element
         **
         = (object) bounding box descriptor:
         o {
         o     cx: (number) x of the center,
         o     cy: (number) x of the center,
         o     h: (number) height,
         o     height: (number) height,
         o     path: (string) path command for the box,
         o     r0: (number) radius of a circle that fully encloses the box,
         o     r1: (number) radius of the smallest circle that can be enclosed,
         o     r2: (number) radius of the largest circle that can be enclosed,
         o     vb: (string) box as a viewbox command,
         o     w: (number) width,
         o     width: (number) width,
         o     x2: (number) x of the right side,
         o     x: (number) x of the left side,
         o     y2: (number) y of the bottom edge,
         o     y: (number) y of the top edge
         o }
        \*/
        elproto.getBBox = function (isWithoutTransform) {
            if (!Snap.Matrix || !Snap.path) {
                return this.node.getBBox();
            }
            var el = this,
                m = new Snap.Matrix();
            if (el.removed) {
                return Snap._.box();
            }
            while (el.type == "use") {
                if (!isWithoutTransform) {
                    m = m.add(el.transform().localMatrix.translate(el.attr("x") || 0, el.attr("y") || 0));
                }
                if (el.original) {
                    el = el.original;
                } else {
                    var href = el.attr("xlink:href");
                    el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf("#") + 1));
                }
            }
            var _ = el._,
                pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;
            try {
                if (isWithoutTransform) {
                    _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());
                    return Snap._.box(_.bboxwt);
                } else {
                    el.realPath = pathfinder(el);
                    el.matrix = el.transform().localMatrix;
                    _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));
                    return Snap._.box(_.bbox);
                }
            } catch (e) {
                // Firefox doesn’t give you bbox of hidden element
                return Snap._.box();
            }
        };
        var propString = function () {
            return this.string;
        };
        function extractTransform(el, tstr) {
            if (tstr == null) {
                var doReturn = true;
                if (el.type == "linearGradient" || el.type == "radialGradient") {
                    tstr = el.node.getAttribute("gradientTransform");
                } else if (el.type == "pattern") {
                    tstr = el.node.getAttribute("patternTransform");
                } else {
                    tstr = el.node.getAttribute("transform");
                }
                if (!tstr) {
                    return new Snap.Matrix();
                }
                tstr = Snap._.svgTransform2string(tstr);
            } else {
                if (!Snap._.rgTransform.test(tstr)) {
                    tstr = Snap._.svgTransform2string(tstr);
                } else {
                    tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || "");
                }
                if (is(tstr, "array")) {
                    tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
                }
                el._.transform = tstr;
            }
            var m = Snap._.transform2matrix(tstr, el.getBBox(1));
            if (doReturn) {
                return m;
            } else {
                el.matrix = m;
            }
        }
        /*\
         * Element.transform
         [ method ]
         **
         * Gets or sets transformation of the element
         **
         - tstr (string) transform string in Snap or SVG format
         = (Element) the current element
         * or
         = (object) transformation descriptor:
         o {
         o     string (string) transform string,
         o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
         o     localMatrix (Matrix) matrix of transformations applied only to the element,
         o     diffMatrix (Matrix) matrix of difference between global and local transformations,
         o     global (string) global transformation as string,
         o     local (string) local transformation as string,
         o     toString (function) returns `string` property
         o }
        \*/
        elproto.transform = function (tstr) {
            var _ = this._;
            if (tstr == null) {
                var papa = this,
                    global = new Snap.Matrix(this.node.getCTM()),
                    local = extractTransform(this),
                    ms = [local],
                    m = new Snap.Matrix(),
                    i,
                    localString = local.toTransformString(),
                    string = Str(local) == Str(this.matrix) ? Str(_.transform) : localString;
                while (papa.type != "svg" && (papa = papa.parent())) {
                    ms.push(extractTransform(papa));
                }
                i = ms.length;
                while (i--) {
                    m.add(ms[i]);
                }
                return {
                    string: string,
                    globalMatrix: global,
                    totalMatrix: m,
                    localMatrix: local,
                    diffMatrix: global.clone().add(local.invert()),
                    global: global.toTransformString(),
                    total: m.toTransformString(),
                    local: localString,
                    toString: propString
                };
            }
            if (tstr instanceof Snap.Matrix) {
                this.matrix = tstr;
                this._.transform = tstr.toTransformString();
            } else {
                extractTransform(this, tstr);
            }

            if (this.node) {
                if (this.type == "linearGradient" || this.type == "radialGradient") {
                    $(this.node, { gradientTransform: this.matrix });
                } else if (this.type == "pattern") {
                    $(this.node, { patternTransform: this.matrix });
                } else {
                    $(this.node, { transform: this.matrix });
                }
            }

            return this;
        };
        /*\
         * Element.parent
         [ method ]
         **
         * Returns the element's parent
         **
         = (Element) the parent element
        \*/
        elproto.parent = function () {
            return wrap(this.node.parentNode);
        };
        /*\
         * Element.append
         [ method ]
         **
         * Appends the given element to current one
         **
         - el (Element|Set) element to append
         = (Element) the parent element
        \*/
        /*\
         * Element.add
         [ method ]
         **
         * See @Element.append
        \*/
        elproto.append = elproto.add = function (el) {
            if (el) {
                if (el.type == "set") {
                    var it = this;
                    el.forEach(function (el) {
                        it.add(el);
                    });
                    return this;
                }
                el = wrap(el);
                this.node.appendChild(el.node);
                el.paper = this.paper;
            }
            return this;
        };
        /*\
         * Element.appendTo
         [ method ]
         **
         * Appends the current element to the given one
         **
         - el (Element) parent element to append to
         = (Element) the child element
        \*/
        elproto.appendTo = function (el) {
            if (el) {
                el = wrap(el);
                el.append(this);
            }
            return this;
        };
        /*\
         * Element.prepend
         [ method ]
         **
         * Prepends the given element to the current one
         **
         - el (Element) element to prepend
         = (Element) the parent element
        \*/
        elproto.prepend = function (el) {
            if (el) {
                if (el.type == "set") {
                    var it = this,
                        first;
                    el.forEach(function (el) {
                        if (first) {
                            first.after(el);
                        } else {
                            it.prepend(el);
                        }
                        first = el;
                    });
                    return this;
                }
                el = wrap(el);
                var parent = el.parent();
                this.node.insertBefore(el.node, this.node.firstChild);
                this.add && this.add();
                el.paper = this.paper;
                this.parent() && this.parent().add();
                parent && parent.add();
            }
            return this;
        };
        /*\
         * Element.prependTo
         [ method ]
         **
         * Prepends the current element to the given one
         **
         - el (Element) parent element to prepend to
         = (Element) the child element
        \*/
        elproto.prependTo = function (el) {
            el = wrap(el);
            el.prepend(this);
            return this;
        };
        /*\
         * Element.before
         [ method ]
         **
         * Inserts given element before the current one
         **
         - el (Element) element to insert
         = (Element) the parent element
        \*/
        elproto.before = function (el) {
            if (el.type == "set") {
                var it = this;
                el.forEach(function (el) {
                    var parent = el.parent();
                    it.node.parentNode.insertBefore(el.node, it.node);
                    parent && parent.add();
                });
                this.parent().add();
                return this;
            }
            el = wrap(el);
            var parent = el.parent();
            this.node.parentNode.insertBefore(el.node, this.node);
            this.parent() && this.parent().add();
            parent && parent.add();
            el.paper = this.paper;
            return this;
        };
        /*\
         * Element.after
         [ method ]
         **
         * Inserts given element after the current one
         **
         - el (Element) element to insert
         = (Element) the parent element
        \*/
        elproto.after = function (el) {
            el = wrap(el);
            var parent = el.parent();
            if (this.node.nextSibling) {
                this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
            } else {
                this.node.parentNode.appendChild(el.node);
            }
            this.parent() && this.parent().add();
            parent && parent.add();
            el.paper = this.paper;
            return this;
        };
        /*\
         * Element.insertBefore
         [ method ]
         **
         * Inserts the element after the given one
         **
         - el (Element) element next to whom insert to
         = (Element) the parent element
        \*/
        elproto.insertBefore = function (el) {
            el = wrap(el);
            var parent = this.parent();
            el.node.parentNode.insertBefore(this.node, el.node);
            this.paper = el.paper;
            parent && parent.add();
            el.parent() && el.parent().add();
            return this;
        };
        /*\
         * Element.insertAfter
         [ method ]
         **
         * Inserts the element after the given one
         **
         - el (Element) element next to whom insert to
         = (Element) the parent element
        \*/
        elproto.insertAfter = function (el) {
            el = wrap(el);
            var parent = this.parent();
            el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
            this.paper = el.paper;
            parent && parent.add();
            el.parent() && el.parent().add();
            return this;
        };
        /*\
         * Element.remove
         [ method ]
         **
         * Removes element from the DOM
         = (Element) the detached element
        \*/
        elproto.remove = function () {
            var parent = this.parent();
            this.node.parentNode && this.node.parentNode.removeChild(this.node);
            delete this.paper;
            this.removed = true;
            parent && parent.add();
            return this;
        };
        /*\
         * Element.select
         [ method ]
         **
         * Gathers the nested @Element matching the given set of CSS selectors
         **
         - query (string) CSS selector
         = (Element) result of query selection
        \*/
        elproto.select = function (query) {
            return wrap(this.node.querySelector(query));
        };
        /*\
         * Element.selectAll
         [ method ]
         **
         * Gathers nested @Element objects matching the given set of CSS selectors
         **
         - query (string) CSS selector
         = (Set|array) result of query selection
        \*/
        elproto.selectAll = function (query) {
            var nodelist = this.node.querySelectorAll(query),
                set = (Snap.set || Array)();
            for (var i = 0; i < nodelist.length; i++) {
                set.push(wrap(nodelist[i]));
            }
            return set;
        };
        /*\
         * Element.asPX
         [ method ]
         **
         * Returns given attribute of the element as a `px` value (not %, em, etc.)
         **
         - attr (string) attribute name
         - value (string) #optional attribute value
         = (Element) result of query selection
        \*/
        elproto.asPX = function (attr, value) {
            if (value == null) {
                value = this.attr(attr);
            }
            return +unit2px(this, attr, value);
        };
        // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
        /*\
         * Element.use
         [ method ]
         **
         * Creates a `<use>` element linked to the current element
         **
         = (Element) the `<use>` element
        \*/
        elproto.use = function () {
            var use,
                id = this.node.id;
            if (!id) {
                id = this.id;
                $(this.node, {
                    id: id
                });
            }
            if (this.type == "linearGradient" || this.type == "radialGradient" || this.type == "pattern") {
                use = make(this.type, this.node.parentNode);
            } else {
                use = make("use", this.node.parentNode);
            }
            $(use.node, {
                "xlink:href": "#" + id
            });
            use.original = this;
            return use;
        };
        function fixids(el) {
            var els = el.selectAll("*"),
                it,
                url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
                ids = [],
                uses = {};
            function urltest(it, name) {
                var val = $(it.node, name);
                val = val && val.match(url);
                val = val && val[2];
                if (val && val.charAt() == "#") {
                    val = val.substring(1);
                } else {
                    return;
                }
                if (val) {
                    uses[val] = (uses[val] || []).concat(function (id) {
                        var attr = {};
                        attr[name] = URL(id);
                        $(it.node, attr);
                    });
                }
            }
            function linktest(it) {
                var val = $(it.node, "xlink:href");
                if (val && val.charAt() == "#") {
                    val = val.substring(1);
                } else {
                    return;
                }
                if (val) {
                    uses[val] = (uses[val] || []).concat(function (id) {
                        it.attr("xlink:href", "#" + id);
                    });
                }
            }
            for (var i = 0, ii = els.length; i < ii; i++) {
                it = els[i];
                urltest(it, "fill");
                urltest(it, "stroke");
                urltest(it, "filter");
                urltest(it, "mask");
                urltest(it, "clip-path");
                linktest(it);
                var oldid = $(it.node, "id");
                if (oldid) {
                    $(it.node, { id: it.id });
                    ids.push({
                        old: oldid,
                        id: it.id
                    });
                }
            }
            for (i = 0, ii = ids.length; i < ii; i++) {
                var fs = uses[ids[i].old];
                if (fs) {
                    for (var j = 0, jj = fs.length; j < jj; j++) {
                        fs[j](ids[i].id);
                    }
                }
            }
        }
        /*\
         * Element.clone
         [ method ]
         **
         * Creates a clone of the element and inserts it after the element
         **
         = (Element) the clone
        \*/
        elproto.clone = function () {
            var clone = wrap(this.node.cloneNode(true));
            if ($(clone.node, "id")) {
                $(clone.node, { id: clone.id });
            }
            fixids(clone);
            clone.insertAfter(this);
            return clone;
        };
        /*\
         * Element.toDefs
         [ method ]
         **
         * Moves element to the shared `<defs>` area
         **
         = (Element) the element
        \*/
        elproto.toDefs = function () {
            var defs = getSomeDefs(this);
            defs.appendChild(this.node);
            return this;
        };
        /*\
         * Element.toPattern
         [ method ]
         **
         * Creates a `<pattern>` element from the current element
         **
         * To create a pattern you have to specify the pattern rect:
         - x (string|number)
         - y (string|number)
         - width (string|number)
         - height (string|number)
         = (Element) the `<pattern>` element
         * You can use pattern later on as an argument for `fill` attribute:
         | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
         |         fill: "none",
         |         stroke: "#bada55",
         |         strokeWidth: 5
         |     }).pattern(0, 0, 10, 10),
         |     c = paper.circle(200, 200, 100);
         | c.attr({
         |     fill: p
         | });
        \*/
        elproto.pattern = elproto.toPattern = function (x, y, width, height) {
            var p = make("pattern", getSomeDefs(this));
            if (x == null) {
                x = this.getBBox();
            }
            if (is(x, "object") && "x" in x) {
                y = x.y;
                width = x.width;
                height = x.height;
                x = x.x;
            }
            $(p.node, {
                x: x,
                y: y,
                width: width,
                height: height,
                patternUnits: "userSpaceOnUse",
                id: p.id,
                viewBox: [x, y, width, height].join(" ")
            });
            p.node.appendChild(this.node);
            return p;
        };
        // SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
        // SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
        /*\
         * Element.marker
         [ method ]
         **
         * Creates a `<marker>` element from the current element
         **
         * To create a marker you have to specify the bounding rect and reference point:
         - x (number)
         - y (number)
         - width (number)
         - height (number)
         - refX (number)
         - refY (number)
         = (Element) the `<marker>` element
         * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
        \*/
        // TODO add usage for markers
        elproto.marker = function (x, y, width, height, refX, refY) {
            var p = make("marker", getSomeDefs(this));
            if (x == null) {
                x = this.getBBox();
            }
            if (is(x, "object") && "x" in x) {
                y = x.y;
                width = x.width;
                height = x.height;
                refX = x.refX || x.cx;
                refY = x.refY || x.cy;
                x = x.x;
            }
            $(p.node, {
                viewBox: [x, y, width, height].join(" "),
                markerWidth: width,
                markerHeight: height,
                orient: "auto",
                refX: refX || 0,
                refY: refY || 0,
                id: p.id
            });
            p.node.appendChild(this.node);
            return p;
        };
        // animation
        function slice(from, to, f) {
            return function (arr) {
                var res = arr.slice(from, to);
                if (res.length == 1) {
                    res = res[0];
                }
                return f ? f(res) : res;
            };
        }
        var Animation = function (attr, ms, easing, callback) {
            if (typeof easing == "function" && !easing.length) {
                callback = easing;
                easing = mina.linear;
            }
            this.attr = attr;
            this.dur = ms;
            easing && (this.easing = easing);
            callback && (this.callback = callback);
        };
        Snap._.Animation = Animation;
        /*\
         * Snap.animation
         [ method ]
         **
         * Creates an animation object
         **
         - attr (object) attributes of final destination
         - duration (number) duration of the animation, in milliseconds
         - easing (function) #optional one of easing functions of @mina or custom one
         - callback (function) #optional callback function that fires when animation ends
         = (object) animation object
        \*/
        Snap.animation = function (attr, ms, easing, callback) {
            return new Animation(attr, ms, easing, callback);
        };
        /*\
         * Element.inAnim
         [ method ]
         **
         * Returns a set of animations that may be able to manipulate the current element
         **
         = (object) in format:
         o {
         o     anim (object) animation object,
         o     mina (object) @mina object,
         o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,
         o     status (function) gets or sets the status of the animation,
         o     stop (function) stops the animation
         o }
        \*/
        elproto.inAnim = function () {
            var el = this,
                res = [];
            for (var id in el.anims) {
                if (el.anims[has](id)) {
                    (function (a) {
                        res.push({
                            anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
                            mina: a,
                            curStatus: a.status(),
                            status: function (val) {
                                return a.status(val);
                            },
                            stop: function () {
                                a.stop();
                            }
                        });
                    })(el.anims[id]);
                }
            }return res;
        };
        /*\
         * Snap.animate
         [ method ]
         **
         * Runs generic animation of one number into another with a caring function
         **
         - from (number|array) number or array of numbers
         - to (number|array) number or array of numbers
         - setter (function) caring function that accepts one number argument
         - duration (number) duration, in milliseconds
         - easing (function) #optional easing function from @mina or custom
         - callback (function) #optional callback function to execute when animation ends
         = (object) animation object in @mina format
         o {
         o     id (string) animation id, consider it read-only,
         o     duration (function) gets or sets the duration of the animation,
         o     easing (function) easing,
         o     speed (function) gets or sets the speed of the animation,
         o     status (function) gets or sets the status of the animation,
         o     stop (function) stops the animation
         o }
         | var rect = Snap().rect(0, 0, 10, 10);
         | Snap.animate(0, 10, function (val) {
         |     rect.attr({
         |         x: val
         |     });
         | }, 1000);
         | // in given context is equivalent to
         | rect.animate({x: 10}, 1000);
        \*/
        Snap.animate = function (from, to, setter, ms, easing, callback) {
            if (typeof easing == "function" && !easing.length) {
                callback = easing;
                easing = mina.linear;
            }
            var now = mina.time(),
                anim = mina(from, to, now, now + ms, mina.time, setter, easing);
            callback && eve.once("mina.finish." + anim.id, callback);
            return anim;
        };
        /*\
         * Element.stop
         [ method ]
         **
         * Stops all the animations for the current element
         **
         = (Element) the current element
        \*/
        elproto.stop = function () {
            var anims = this.inAnim();
            for (var i = 0, ii = anims.length; i < ii; i++) {
                anims[i].stop();
            }
            return this;
        };
        /*\
         * Element.animate
         [ method ]
         **
         * Animates the given attributes of the element
         **
         - attrs (object) key-value pairs of destination attributes
         - duration (number) duration of the animation in milliseconds
         - easing (function) #optional easing function from @mina or custom
         - callback (function) #optional callback function that executes when the animation ends
         = (Element) the current element
        \*/
        elproto.animate = function (attrs, ms, easing, callback) {
            if (typeof easing == "function" && !easing.length) {
                callback = easing;
                easing = mina.linear;
            }
            if (attrs instanceof Animation) {
                callback = attrs.callback;
                easing = attrs.easing;
                ms = attrs.dur;
                attrs = attrs.attr;
            }
            var fkeys = [],
                tkeys = [],
                keys = {},
                from,
                to,
                f,
                eq,
                el = this;
            for (var key in attrs) {
                if (attrs[has](key)) {
                    if (el.equal) {
                        eq = el.equal(key, Str(attrs[key]));
                        from = eq.from;
                        to = eq.to;
                        f = eq.f;
                    } else {
                        from = +el.attr(key);
                        to = +attrs[key];
                    }
                    var len = is(from, "array") ? from.length : 1;
                    keys[key] = slice(fkeys.length, fkeys.length + len, f);
                    fkeys = fkeys.concat(from);
                    tkeys = tkeys.concat(to);
                }
            }var now = mina.time(),
                anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
                var attr = {};
                for (var key in keys) {
                    if (keys[has](key)) {
                        attr[key] = keys[key](val);
                    }
                }el.attr(attr);
            }, easing);
            el.anims[anim.id] = anim;
            anim._attrs = attrs;
            anim._callback = callback;
            eve("snap.animcreated." + el.id, anim);
            eve.once("mina.finish." + anim.id, function () {
                delete el.anims[anim.id];
                callback && callback.call(el);
            });
            eve.once("mina.stop." + anim.id, function () {
                delete el.anims[anim.id];
            });
            return el;
        };
        var eldata = {};
        /*\
         * Element.data
         [ method ]
         **
         * Adds or retrieves given value associated with given key. (Don’t confuse
         * with `data-` attributes)
         *
         * See also @Element.removeData
         - key (string) key to store data
         - value (any) #optional value to store
         = (object) @Element
         * or, if value is not specified:
         = (any) value
         > Usage
         | for (var i = 0, i < 5, i++) {
         |     paper.circle(10 + 15 * i, 10, 10)
         |          .attr({fill: "#000"})
         |          .data("i", i)
         |          .click(function () {
         |             alert(this.data("i"));
         |          });
         | }
        \*/
        elproto.data = function (key, value) {
            var data = eldata[this.id] = eldata[this.id] || {};
            if (arguments.length == 0) {
                eve("snap.data.get." + this.id, this, data, null);
                return data;
            }
            if (arguments.length == 1) {
                if (Snap.is(key, "object")) {
                    for (var i in key) {
                        if (key[has](i)) {
                            this.data(i, key[i]);
                        }
                    }return this;
                }
                eve("snap.data.get." + this.id, this, data[key], key);
                return data[key];
            }
            data[key] = value;
            eve("snap.data.set." + this.id, this, value, key);
            return this;
        };
        /*\
         * Element.removeData
         [ method ]
         **
         * Removes value associated with an element by given key.
         * If key is not provided, removes all the data of the element.
         - key (string) #optional key
         = (object) @Element
        \*/
        elproto.removeData = function (key) {
            if (key == null) {
                eldata[this.id] = {};
            } else {
                eldata[this.id] && delete eldata[this.id][key];
            }
            return this;
        };
        /*\
         * Element.outerSVG
         [ method ]
         **
         * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
         *
         * See also @Element.innerSVG
         = (string) SVG code for the element
        \*/
        /*\
         * Element.toString
         [ method ]
         **
         * See @Element.outerSVG
        \*/
        elproto.outerSVG = elproto.toString = toString(1);
        /*\
         * Element.innerSVG
         [ method ]
         **
         * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
         = (string) SVG code for the element
        \*/
        elproto.innerSVG = toString();
        function toString(type) {
            return function () {
                var res = type ? "<" + this.type : "",
                    attr = this.node.attributes,
                    chld = this.node.childNodes;
                if (type) {
                    for (var i = 0, ii = attr.length; i < ii; i++) {
                        res += " " + attr[i].name + '="' + attr[i].value.replace(/"/g, '\\"') + '"';
                    }
                }
                if (chld.length) {
                    type && (res += ">");
                    for (i = 0, ii = chld.length; i < ii; i++) {
                        if (chld[i].nodeType == 3) {
                            res += chld[i].nodeValue;
                        } else if (chld[i].nodeType == 1) {
                            res += wrap(chld[i]).toString();
                        }
                    }
                    type && (res += "</" + this.type + ">");
                } else {
                    type && (res += "/>");
                }
                return res;
            };
        }
        elproto.toDataURL = function () {
            if (window && window.btoa) {
                var bb = this.getBBox(),
                    svg = Snap.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>', {
                    x: +bb.x.toFixed(3),
                    y: +bb.y.toFixed(3),
                    width: +bb.width.toFixed(3),
                    height: +bb.height.toFixed(3),
                    contents: this.outerSVG()
                });
                return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
            }
        };
        /*\
         * Fragment.select
         [ method ]
         **
         * See @Element.select
        \*/
        Fragment.prototype.select = elproto.select;
        /*\
         * Fragment.selectAll
         [ method ]
         **
         * See @Element.selectAll
        \*/
        Fragment.prototype.selectAll = elproto.selectAll;
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var objectToString = Object.prototype.toString,
            Str = String,
            math = Math,
            E = "";
        function Matrix(a, b, c, d, e, f) {
            if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
                this.a = a.a;
                this.b = a.b;
                this.c = a.c;
                this.d = a.d;
                this.e = a.e;
                this.f = a.f;
                return;
            }
            if (a != null) {
                this.a = +a;
                this.b = +b;
                this.c = +c;
                this.d = +d;
                this.e = +e;
                this.f = +f;
            } else {
                this.a = 1;
                this.b = 0;
                this.c = 0;
                this.d = 1;
                this.e = 0;
                this.f = 0;
            }
        }
        (function (matrixproto) {
            /*\
             * Matrix.add
             [ method ]
             **
             * Adds the given matrix to existing one
             - a (number)
             - b (number)
             - c (number)
             - d (number)
             - e (number)
             - f (number)
             * or
             - matrix (object) @Matrix
            \*/
            matrixproto.add = function (a, b, c, d, e, f) {
                var out = [[], [], []],
                    m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                    matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                    x,
                    y,
                    z,
                    res;

                if (a && a instanceof Matrix) {
                    matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
                }

                for (x = 0; x < 3; x++) {
                    for (y = 0; y < 3; y++) {
                        res = 0;
                        for (z = 0; z < 3; z++) {
                            res += m[x][z] * matrix[z][y];
                        }
                        out[x][y] = res;
                    }
                }
                this.a = out[0][0];
                this.b = out[1][0];
                this.c = out[0][1];
                this.d = out[1][1];
                this.e = out[0][2];
                this.f = out[1][2];
                return this;
            };
            /*\
             * Matrix.invert
             [ method ]
             **
             * Returns an inverted version of the matrix
             = (object) @Matrix
            \*/
            matrixproto.invert = function () {
                var me = this,
                    x = me.a * me.d - me.b * me.c;
                return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
            };
            /*\
             * Matrix.clone
             [ method ]
             **
             * Returns a copy of the matrix
             = (object) @Matrix
            \*/
            matrixproto.clone = function () {
                return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
            };
            /*\
             * Matrix.translate
             [ method ]
             **
             * Translate the matrix
             - x (number) horizontal offset distance
             - y (number) vertical offset distance
            \*/
            matrixproto.translate = function (x, y) {
                return this.add(1, 0, 0, 1, x, y);
            };
            /*\
             * Matrix.scale
             [ method ]
             **
             * Scales the matrix
             - x (number) amount to be scaled, with `1` resulting in no change
             - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
             - cx (number) #optional horizontal origin point from which to scale
             - cy (number) #optional vertical origin point from which to scale
             * Default cx, cy is the middle point of the element.
            \*/
            matrixproto.scale = function (x, y, cx, cy) {
                y == null && (y = x);
                (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
                this.add(x, 0, 0, y, 0, 0);
                (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
                return this;
            };
            /*\
             * Matrix.rotate
             [ method ]
             **
             * Rotates the matrix
             - a (number) angle of rotation, in degrees
             - x (number) horizontal origin point from which to rotate
             - y (number) vertical origin point from which to rotate
            \*/
            matrixproto.rotate = function (a, x, y) {
                a = Snap.rad(a);
                x = x || 0;
                y = y || 0;
                var cos = +math.cos(a).toFixed(9),
                    sin = +math.sin(a).toFixed(9);
                this.add(cos, sin, -sin, cos, x, y);
                return this.add(1, 0, 0, 1, -x, -y);
            };
            /*\
             * Matrix.x
             [ method ]
             **
             * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
             - x (number)
             - y (number)
             = (number) x
            \*/
            matrixproto.x = function (x, y) {
                return x * this.a + y * this.c + this.e;
            };
            /*\
             * Matrix.y
             [ method ]
             **
             * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
             - x (number)
             - y (number)
             = (number) y
            \*/
            matrixproto.y = function (x, y) {
                return x * this.b + y * this.d + this.f;
            };
            matrixproto.get = function (i) {
                return +this[Str.fromCharCode(97 + i)].toFixed(4);
            };
            matrixproto.toString = function () {
                return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
            };
            matrixproto.offset = function () {
                return [this.e.toFixed(4), this.f.toFixed(4)];
            };
            function norm(a) {
                return a[0] * a[0] + a[1] * a[1];
            }
            function normalize(a) {
                var mag = math.sqrt(norm(a));
                a[0] && (a[0] /= mag);
                a[1] && (a[1] /= mag);
            }
            /*\
             * Matrix.determinant
             [ method ]
             **
             * Finds determinant of the given matrix.
             = (number) determinant
            \*/
            matrixproto.determinant = function () {
                return this.a * this.d - this.b * this.c;
            };
            /*\
             * Matrix.split
             [ method ]
             **
             * Splits matrix into primitive transformations
             = (object) in format:
             o dx (number) translation by x
             o dy (number) translation by y
             o scalex (number) scale by x
             o scaley (number) scale by y
             o shear (number) shear
             o rotate (number) rotation in deg
             o isSimple (boolean) could it be represented via simple transformations
            \*/
            matrixproto.split = function () {
                var out = {};
                // translation
                out.dx = this.e;
                out.dy = this.f;

                // scale and shear
                var row = [[this.a, this.c], [this.b, this.d]];
                out.scalex = math.sqrt(norm(row[0]));
                normalize(row[0]);

                out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
                row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

                out.scaley = math.sqrt(norm(row[1]));
                normalize(row[1]);
                out.shear /= out.scaley;

                if (this.determinant() < 0) {
                    out.scalex = -out.scalex;
                }

                // rotation
                var sin = -row[0][1],
                    cos = row[1][1];
                if (cos < 0) {
                    out.rotate = Snap.deg(math.acos(cos));
                    if (sin < 0) {
                        out.rotate = 360 - out.rotate;
                    }
                } else {
                    out.rotate = Snap.deg(math.asin(sin));
                }

                out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
                out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
                out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
                return out;
            };
            /*\
             * Matrix.toTransformString
             [ method ]
             **
             * Returns transform string that represents given matrix
             = (string) transform string
            \*/
            matrixproto.toTransformString = function (shorter) {
                var s = shorter || this.split();
                if (!+s.shear.toFixed(9)) {
                    s.scalex = +s.scalex.toFixed(4);
                    s.scaley = +s.scaley.toFixed(4);
                    s.rotate = +s.rotate.toFixed(4);
                    return (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) + (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) + (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E);
                } else {
                    return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
                }
            };
        })(Matrix.prototype);
        /*\
         * Snap.Matrix
         [ method ]
         **
         * Matrix constructor, extend on your own risk.
         * To create matrices use @Snap.matrix.
        \*/
        Snap.Matrix = Matrix;
        /*\
         * Snap.matrix
         [ method ]
         **
         * Utility method
         **
         * Returns a matrix based on the given parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         * or
         - svgMatrix (SVGMatrix)
         = (object) @Matrix
        \*/
        Snap.matrix = function (a, b, c, d, e, f) {
            return new Matrix(a, b, c, d, e, f);
        };
    });
    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var has = "hasOwnProperty",
            make = Snap._.make,
            wrap = Snap._.wrap,
            is = Snap.is,
            getSomeDefs = Snap._.getSomeDefs,
            reURLValue = /^url\(#?([^)]+)\)$/,
            $ = Snap._.$,
            URL = Snap.url,
            Str = String,
            separator = Snap._.separator,
            E = "";
        // Attributes event handlers
        eve.on("snap.util.attr.mask", function (value) {
            if (value instanceof Element || value instanceof Fragment) {
                eve.stop();
                if (value instanceof Fragment && value.node.childNodes.length == 1) {
                    value = value.node.firstChild;
                    getSomeDefs(this).appendChild(value);
                    value = wrap(value);
                }
                if (value.type == "mask") {
                    var mask = value;
                } else {
                    mask = make("mask", getSomeDefs(this));
                    mask.node.appendChild(value.node);
                }
                !mask.node.id && $(mask.node, {
                    id: mask.id
                });
                $(this.node, {
                    mask: URL(mask.id)
                });
            }
        });
        (function (clipIt) {
            eve.on("snap.util.attr.clip", clipIt);
            eve.on("snap.util.attr.clip-path", clipIt);
            eve.on("snap.util.attr.clipPath", clipIt);
        })(function (value) {
            if (value instanceof Element || value instanceof Fragment) {
                eve.stop();
                if (value.type == "clipPath") {
                    var clip = value;
                } else {
                    clip = make("clipPath", getSomeDefs(this));
                    clip.node.appendChild(value.node);
                    !clip.node.id && $(clip.node, {
                        id: clip.id
                    });
                }
                $(this.node, {
                    "clip-path": URL(clip.node.id || clip.id)
                });
            }
        });
        function fillStroke(name) {
            return function (value) {
                eve.stop();
                if (value instanceof Fragment && value.node.childNodes.length == 1 && (value.node.firstChild.tagName == "radialGradient" || value.node.firstChild.tagName == "linearGradient" || value.node.firstChild.tagName == "pattern")) {
                    value = value.node.firstChild;
                    getSomeDefs(this).appendChild(value);
                    value = wrap(value);
                }
                if (value instanceof Element) {
                    if (value.type == "radialGradient" || value.type == "linearGradient" || value.type == "pattern") {
                        if (!value.node.id) {
                            $(value.node, {
                                id: value.id
                            });
                        }
                        var fill = URL(value.node.id);
                    } else {
                        fill = value.attr(name);
                    }
                } else {
                    fill = Snap.color(value);
                    if (fill.error) {
                        var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);
                        if (grad) {
                            if (!grad.node.id) {
                                $(grad.node, {
                                    id: grad.id
                                });
                            }
                            fill = URL(grad.node.id);
                        } else {
                            fill = value;
                        }
                    } else {
                        fill = Str(fill);
                    }
                }
                var attrs = {};
                attrs[name] = fill;
                $(this.node, attrs);
                this.node.style[name] = E;
            };
        }
        eve.on("snap.util.attr.fill", fillStroke("fill"));
        eve.on("snap.util.attr.stroke", fillStroke("stroke"));
        var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
        eve.on("snap.util.grad.parse", function parseGrad(string) {
            string = Str(string);
            var tokens = string.match(gradrg);
            if (!tokens) {
                return null;
            }
            var type = tokens[1],
                params = tokens[2],
                stops = tokens[3];
            params = params.split(/\s*,\s*/).map(function (el) {
                return +el == el ? +el : el;
            });
            if (params.length == 1 && params[0] == 0) {
                params = [];
            }
            stops = stops.split("-");
            stops = stops.map(function (el) {
                el = el.split(":");
                var out = {
                    color: el[0]
                };
                if (el[1]) {
                    out.offset = parseFloat(el[1]);
                }
                return out;
            });
            return {
                type: type,
                params: params,
                stops: stops
            };
        });

        eve.on("snap.util.attr.d", function (value) {
            eve.stop();
            if (is(value, "array") && is(value[0], "array")) {
                value = Snap.path.toString.call(value);
            }
            value = Str(value);
            if (value.match(/[ruo]/i)) {
                value = Snap.path.toAbsolute(value);
            }
            $(this.node, { d: value });
        })(-1);
        eve.on("snap.util.attr.#text", function (value) {
            eve.stop();
            value = Str(value);
            var txt = glob.doc.createTextNode(value);
            while (this.node.firstChild) {
                this.node.removeChild(this.node.firstChild);
            }
            this.node.appendChild(txt);
        })(-1);
        eve.on("snap.util.attr.path", function (value) {
            eve.stop();
            this.attr({ d: value });
        })(-1);
        eve.on("snap.util.attr.class", function (value) {
            eve.stop();
            this.node.className.baseVal = value;
        })(-1);
        eve.on("snap.util.attr.viewBox", function (value) {
            var vb;
            if (is(value, "object") && "x" in value) {
                vb = [value.x, value.y, value.width, value.height].join(" ");
            } else if (is(value, "array")) {
                vb = value.join(" ");
            } else {
                vb = value;
            }
            $(this.node, {
                viewBox: vb
            });
            eve.stop();
        })(-1);
        eve.on("snap.util.attr.transform", function (value) {
            this.transform(value);
            eve.stop();
        })(-1);
        eve.on("snap.util.attr.r", function (value) {
            if (this.type == "rect") {
                eve.stop();
                $(this.node, {
                    rx: value,
                    ry: value
                });
            }
        })(-1);
        eve.on("snap.util.attr.textpath", function (value) {
            eve.stop();
            if (this.type == "text") {
                var id, tp, node;
                if (!value && this.textPath) {
                    tp = this.textPath;
                    while (tp.node.firstChild) {
                        this.node.appendChild(tp.node.firstChild);
                    }
                    tp.remove();
                    delete this.textPath;
                    return;
                }
                if (is(value, "string")) {
                    var defs = getSomeDefs(this),
                        path = wrap(defs.parentNode).path(value);
                    defs.appendChild(path.node);
                    id = path.id;
                    path.attr({ id: id });
                } else {
                    value = wrap(value);
                    if (value instanceof Element) {
                        id = value.attr("id");
                        if (!id) {
                            id = value.id;
                            value.attr({ id: id });
                        }
                    }
                }
                if (id) {
                    tp = this.textPath;
                    node = this.node;
                    if (tp) {
                        tp.attr({ "xlink:href": "#" + id });
                    } else {
                        tp = $("textPath", {
                            "xlink:href": "#" + id
                        });
                        while (node.firstChild) {
                            tp.appendChild(node.firstChild);
                        }
                        node.appendChild(tp);
                        this.textPath = wrap(tp);
                    }
                }
            }
        })(-1);
        eve.on("snap.util.attr.text", function (value) {
            if (this.type == "text") {
                var i = 0,
                    node = this.node,
                    tuner = function (chunk) {
                    var out = $("tspan");
                    if (is(chunk, "array")) {
                        for (var i = 0; i < chunk.length; i++) {
                            out.appendChild(tuner(chunk[i]));
                        }
                    } else {
                        out.appendChild(glob.doc.createTextNode(chunk));
                    }
                    out.normalize && out.normalize();
                    return out;
                };
                while (node.firstChild) {
                    node.removeChild(node.firstChild);
                }
                var tuned = tuner(value);
                while (tuned.firstChild) {
                    node.appendChild(tuned.firstChild);
                }
            }
            eve.stop();
        })(-1);
        function setFontSize(value) {
            eve.stop();
            if (value == +value) {
                value += "px";
            }
            this.node.style.fontSize = value;
        }
        eve.on("snap.util.attr.fontSize", setFontSize)(-1);
        eve.on("snap.util.attr.font-size", setFontSize)(-1);

        eve.on("snap.util.getattr.transform", function () {
            eve.stop();
            return this.transform();
        })(-1);
        eve.on("snap.util.getattr.textpath", function () {
            eve.stop();
            return this.textPath;
        })(-1);
        // Markers
        (function () {
            function getter(end) {
                return function () {
                    eve.stop();
                    var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
                    if (style == "none") {
                        return style;
                    } else {
                        return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
                    }
                };
            }
            function setter(end) {
                return function (value) {
                    eve.stop();
                    var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
                    if (value == "" || !value) {
                        this.node.style[name] = "none";
                        return;
                    }
                    if (value.type == "marker") {
                        var id = value.node.id;
                        if (!id) {
                            $(value.node, { id: value.id });
                        }
                        this.node.style[name] = URL(id);
                        return;
                    }
                };
            }
            eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
            eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
            eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
            eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
            eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
            eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
            eve.on("snap.util.attr.marker-end", setter("end"))(-1);
            eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
            eve.on("snap.util.attr.marker-start", setter("start"))(-1);
            eve.on("snap.util.attr.markerStart", setter("start"))(-1);
            eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
            eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
        })();
        eve.on("snap.util.getattr.r", function () {
            if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
                eve.stop();
                return $(this.node, "rx");
            }
        })(-1);
        function textExtract(node) {
            var out = [];
            var children = node.childNodes;
            for (var i = 0, ii = children.length; i < ii; i++) {
                var chi = children[i];
                if (chi.nodeType == 3) {
                    out.push(chi.nodeValue);
                }
                if (chi.tagName == "tspan") {
                    if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
                        out.push(chi.firstChild.nodeValue);
                    } else {
                        out.push(textExtract(chi));
                    }
                }
            }
            return out;
        }
        eve.on("snap.util.getattr.text", function () {
            if (this.type == "text" || this.type == "tspan") {
                eve.stop();
                var out = textExtract(this.node);
                return out.length == 1 ? out[0] : out;
            }
        })(-1);
        eve.on("snap.util.getattr.#text", function () {
            return this.node.textContent;
        })(-1);
        eve.on("snap.util.getattr.viewBox", function () {
            eve.stop();
            var vb = $(this.node, "viewBox");
            if (vb) {
                vb = vb.split(separator);
                return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
            } else {
                return;
            }
        })(-1);
        eve.on("snap.util.getattr.points", function () {
            var p = $(this.node, "points");
            eve.stop();
            if (p) {
                return p.split(separator);
            } else {
                return;
            }
        })(-1);
        eve.on("snap.util.getattr.path", function () {
            var p = $(this.node, "d");
            eve.stop();
            return p;
        })(-1);
        eve.on("snap.util.getattr.class", function () {
            return this.node.className.baseVal;
        })(-1);
        function getFontSize() {
            eve.stop();
            return this.node.style.fontSize;
        }
        eve.on("snap.util.getattr.fontSize", getFontSize)(-1);
        eve.on("snap.util.getattr.font-size", getFontSize)(-1);
    });

    // Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    // http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var rgNotSpace = /\S+/g,
            rgBadSpace = /[\t\r\n\f]/g,
            rgTrim = /(^\s+|\s+$)/g,
            Str = String,
            elproto = Element.prototype;
        /*\
         * Element.addClass
         [ method ]
         **
         * Adds given class name or list of class names to the element.
         - value (string) class name or space separated list of class names
         **
         = (Element) original element.
        \*/
        elproto.addClass = function (value) {
            var classes = Str(value || "").match(rgNotSpace) || [],
                elem = this.node,
                className = elem.className.baseVal,
                curClasses = className.match(rgNotSpace) || [],
                j,
                pos,
                clazz,
                finalValue;

            if (classes.length) {
                j = 0;
                while (clazz = classes[j++]) {
                    pos = curClasses.indexOf(clazz);
                    if (!~pos) {
                        curClasses.push(clazz);
                    }
                }

                finalValue = curClasses.join(" ");
                if (className != finalValue) {
                    elem.className.baseVal = finalValue;
                }
            }
            return this;
        };
        /*\
         * Element.removeClass
         [ method ]
         **
         * Removes given class name or list of class names from the element.
         - value (string) class name or space separated list of class names
         **
         = (Element) original element.
        \*/
        elproto.removeClass = function (value) {
            var classes = Str(value || "").match(rgNotSpace) || [],
                elem = this.node,
                className = elem.className.baseVal,
                curClasses = className.match(rgNotSpace) || [],
                j,
                pos,
                clazz,
                finalValue;
            if (curClasses.length) {
                j = 0;
                while (clazz = classes[j++]) {
                    pos = curClasses.indexOf(clazz);
                    if (~pos) {
                        curClasses.splice(pos, 1);
                    }
                }

                finalValue = curClasses.join(" ");
                if (className != finalValue) {
                    elem.className.baseVal = finalValue;
                }
            }
            return this;
        };
        /*\
         * Element.hasClass
         [ method ]
         **
         * Checks if the element has a given class name in the list of class names applied to it.
         - value (string) class name
         **
         = (boolean) `true` if the element has given class
        \*/
        elproto.hasClass = function (value) {
            var elem = this.node,
                className = elem.className.baseVal,
                curClasses = className.match(rgNotSpace) || [];
            return !!~curClasses.indexOf(value);
        };
        /*\
         * Element.toggleClass
         [ method ]
         **
         * Add or remove one or more classes from the element, depending on either
         * the class’s presence or the value of the `flag` argument.
         - value (string) class name or space separated list of class names
         - flag (boolean) value to determine whether the class should be added or removed
         **
         = (Element) original element.
        \*/
        elproto.toggleClass = function (value, flag) {
            if (flag != null) {
                if (flag) {
                    return this.addClass(value);
                } else {
                    return this.removeClass(value);
                }
            }
            var classes = (value || "").match(rgNotSpace) || [],
                elem = this.node,
                className = elem.className.baseVal,
                curClasses = className.match(rgNotSpace) || [],
                j,
                pos,
                clazz,
                finalValue;
            j = 0;
            while (clazz = classes[j++]) {
                pos = curClasses.indexOf(clazz);
                if (~pos) {
                    curClasses.splice(pos, 1);
                } else {
                    curClasses.push(clazz);
                }
            }

            finalValue = curClasses.join(" ");
            if (className != finalValue) {
                elem.className.baseVal = finalValue;
            }
            return this;
        };
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var operators = {
            "+": function (x, y) {
                return x + y;
            },
            "-": function (x, y) {
                return x - y;
            },
            "/": function (x, y) {
                return x / y;
            },
            "*": function (x, y) {
                return x * y;
            }
        },
            Str = String,
            reUnit = /[a-z]+$/i,
            reAddon = /^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;
        function getNumber(val) {
            return val;
        }
        function getUnit(unit) {
            return function (val) {
                return +val.toFixed(3) + unit;
            };
        }
        eve.on("snap.util.attr", function (val) {
            var plus = Str(val).match(reAddon);
            if (plus) {
                var evnt = eve.nt(),
                    name = evnt.substring(evnt.lastIndexOf(".") + 1),
                    a = this.attr(name),
                    atr = {};
                eve.stop();
                var unit = plus[3] || "",
                    aUnit = a.match(reUnit),
                    op = operators[plus[1]];
                if (aUnit && aUnit == unit) {
                    val = op(parseFloat(a), +plus[2]);
                } else {
                    a = this.asPX(name);
                    val = op(this.asPX(name), this.asPX(name, plus[2] + unit));
                }
                if (isNaN(a) || isNaN(val)) {
                    return;
                }
                atr[name] = val;
                this.attr(atr);
            }
        })(-10);
        eve.on("snap.util.equal", function (name, b) {
            var A,
                B,
                a = Str(this.attr(name) || ""),
                el = this,
                bplus = Str(b).match(reAddon);
            if (bplus) {
                eve.stop();
                var unit = bplus[3] || "",
                    aUnit = a.match(reUnit),
                    op = operators[bplus[1]];
                if (aUnit && aUnit == unit) {
                    return {
                        from: parseFloat(a),
                        to: op(parseFloat(a), +bplus[2]),
                        f: getUnit(aUnit)
                    };
                } else {
                    a = this.asPX(name);
                    return {
                        from: a,
                        to: op(a, this.asPX(name, bplus[2] + unit)),
                        f: getNumber
                    };
                }
            }
        })(-10);
    });
    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var proto = Paper.prototype,
            is = Snap.is;
        /*\
         * Paper.rect
         [ method ]
         *
         * Draws a rectangle
         **
         - x (number) x coordinate of the top left corner
         - y (number) y coordinate of the top left corner
         - width (number) width
         - height (number) height
         - rx (number) #optional horizontal radius for rounded corners, default is 0
         - ry (number) #optional vertical radius for rounded corners, default is rx or 0
         = (object) the `rect` element
         **
         > Usage
         | // regular rectangle
         | var c = paper.rect(10, 10, 50, 50);
         | // rectangle with rounded corners
         | var c = paper.rect(40, 40, 50, 50, 10);
        \*/
        proto.rect = function (x, y, w, h, rx, ry) {
            var attr;
            if (ry == null) {
                ry = rx;
            }
            if (is(x, "object") && x == "[object Object]") {
                attr = x;
            } else if (x != null) {
                attr = {
                    x: x,
                    y: y,
                    width: w,
                    height: h
                };
                if (rx != null) {
                    attr.rx = rx;
                    attr.ry = ry;
                }
            }
            return this.el("rect", attr);
        };
        /*\
         * Paper.circle
         [ method ]
         **
         * Draws a circle
         **
         - x (number) x coordinate of the centre
         - y (number) y coordinate of the centre
         - r (number) radius
         = (object) the `circle` element
         **
         > Usage
         | var c = paper.circle(50, 50, 40);
        \*/
        proto.circle = function (cx, cy, r) {
            var attr;
            if (is(cx, "object") && cx == "[object Object]") {
                attr = cx;
            } else if (cx != null) {
                attr = {
                    cx: cx,
                    cy: cy,
                    r: r
                };
            }
            return this.el("circle", attr);
        };

        var preload = function () {
            function onerror() {
                this.parentNode.removeChild(this);
            }
            return function (src, f) {
                var img = glob.doc.createElement("img"),
                    body = glob.doc.body;
                img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
                img.onload = function () {
                    f.call(img);
                    img.onload = img.onerror = null;
                    body.removeChild(img);
                };
                img.onerror = onerror;
                body.appendChild(img);
                img.src = src;
            };
        }();

        /*\
         * Paper.image
         [ method ]
         **
         * Places an image on the surface
         **
         - src (string) URI of the source image
         - x (number) x offset position
         - y (number) y offset position
         - width (number) width of the image
         - height (number) height of the image
         = (object) the `image` element
         * or
         = (object) Snap element object with type `image`
         **
         > Usage
         | var c = paper.image("apple.png", 10, 10, 80, 80);
        \*/
        proto.image = function (src, x, y, width, height) {
            var el = this.el("image");
            if (is(src, "object") && "src" in src) {
                el.attr(src);
            } else if (src != null) {
                var set = {
                    "xlink:href": src,
                    preserveAspectRatio: "none"
                };
                if (x != null && y != null) {
                    set.x = x;
                    set.y = y;
                }
                if (width != null && height != null) {
                    set.width = width;
                    set.height = height;
                } else {
                    preload(src, function () {
                        Snap._.$(el.node, {
                            width: this.offsetWidth,
                            height: this.offsetHeight
                        });
                    });
                }
                Snap._.$(el.node, set);
            }
            return el;
        };
        /*\
         * Paper.ellipse
         [ method ]
         **
         * Draws an ellipse
         **
         - x (number) x coordinate of the centre
         - y (number) y coordinate of the centre
         - rx (number) horizontal radius
         - ry (number) vertical radius
         = (object) the `ellipse` element
         **
         > Usage
         | var c = paper.ellipse(50, 50, 40, 20);
        \*/
        proto.ellipse = function (cx, cy, rx, ry) {
            var attr;
            if (is(cx, "object") && cx == "[object Object]") {
                attr = cx;
            } else if (cx != null) {
                attr = {
                    cx: cx,
                    cy: cy,
                    rx: rx,
                    ry: ry
                };
            }
            return this.el("ellipse", attr);
        };
        // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
        /*\
         * Paper.path
         [ method ]
         **
         * Creates a `<path>` element using the given string as the path's definition
         - pathString (string) #optional path string in SVG format
         * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
         | "M10,20L30,40"
         * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
         *
         # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
         # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
         # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
         # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
         # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
         # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
         # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
         # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
         # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
         # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
         # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
         # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
         # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
         * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
         * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.
         > Usage
         | var c = paper.path("M10 10L90 90");
         | // draw a diagonal line:
         | // move to 10,10, line to 90,90
        \*/
        proto.path = function (d) {
            var attr;
            if (is(d, "object") && !is(d, "array")) {
                attr = d;
            } else if (d) {
                attr = { d: d };
            }
            return this.el("path", attr);
        };
        /*\
         * Paper.g
         [ method ]
         **
         * Creates a group element
         **
         - varargs (…) #optional elements to nest within the group
         = (object) the `g` element
         **
         > Usage
         | var c1 = paper.circle(),
         |     c2 = paper.rect(),
         |     g = paper.g(c2, c1); // note that the order of elements is different
         * or
         | var c1 = paper.circle(),
         |     c2 = paper.rect(),
         |     g = paper.g();
         | g.add(c2, c1);
        \*/
        /*\
         * Paper.group
         [ method ]
         **
         * See @Paper.g
        \*/
        proto.group = proto.g = function (first) {
            var attr,
                el = this.el("g");
            if (arguments.length == 1 && first && !first.type) {
                el.attr(first);
            } else if (arguments.length) {
                el.add(Array.prototype.slice.call(arguments, 0));
            }
            return el;
        };
        /*\
         * Paper.svg
         [ method ]
         **
         * Creates a nested SVG element.
         - x (number) @optional X of the element
         - y (number) @optional Y of the element
         - width (number) @optional width of the element
         - height (number) @optional height of the element
         - vbx (number) @optional viewbox X
         - vby (number) @optional viewbox Y
         - vbw (number) @optional viewbox width
         - vbh (number) @optional viewbox height
         **
         = (object) the `svg` element
         **
        \*/
        proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {
            var attrs = {};
            if (is(x, "object") && y == null) {
                attrs = x;
            } else {
                if (x != null) {
                    attrs.x = x;
                }
                if (y != null) {
                    attrs.y = y;
                }
                if (width != null) {
                    attrs.width = width;
                }
                if (height != null) {
                    attrs.height = height;
                }
                if (vbx != null && vby != null && vbw != null && vbh != null) {
                    attrs.viewBox = [vbx, vby, vbw, vbh];
                }
            }
            return this.el("svg", attrs);
        };
        /*\
         * Paper.mask
         [ method ]
         **
         * Equivalent in behaviour to @Paper.g, except it’s a mask.
         **
         = (object) the `mask` element
         **
        \*/
        proto.mask = function (first) {
            var attr,
                el = this.el("mask");
            if (arguments.length == 1 && first && !first.type) {
                el.attr(first);
            } else if (arguments.length) {
                el.add(Array.prototype.slice.call(arguments, 0));
            }
            return el;
        };
        /*\
         * Paper.ptrn
         [ method ]
         **
         * Equivalent in behaviour to @Paper.g, except it’s a pattern.
         - x (number) @optional X of the element
         - y (number) @optional Y of the element
         - width (number) @optional width of the element
         - height (number) @optional height of the element
         - vbx (number) @optional viewbox X
         - vby (number) @optional viewbox Y
         - vbw (number) @optional viewbox width
         - vbh (number) @optional viewbox height
         **
         = (object) the `pattern` element
         **
        \*/
        proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {
            if (is(x, "object")) {
                var attr = x;
            } else {
                attr = { patternUnits: "userSpaceOnUse" };
                if (x) {
                    attr.x = x;
                }
                if (y) {
                    attr.y = y;
                }
                if (width != null) {
                    attr.width = width;
                }
                if (height != null) {
                    attr.height = height;
                }
                if (vx != null && vy != null && vw != null && vh != null) {
                    attr.viewBox = [vx, vy, vw, vh];
                } else {
                    attr.viewBox = [x || 0, y || 0, width || 0, height || 0];
                }
            }
            return this.el("pattern", attr);
        };
        /*\
         * Paper.use
         [ method ]
         **
         * Creates a <use> element.
         - id (string) @optional id of element to link
         * or
         - id (Element) @optional element to link
         **
         = (object) the `use` element
         **
        \*/
        proto.use = function (id) {
            if (id != null) {
                if (id instanceof Element) {
                    if (!id.attr("id")) {
                        id.attr({ id: Snap._.id(id) });
                    }
                    id = id.attr("id");
                }
                if (String(id).charAt() == "#") {
                    id = id.substring(1);
                }
                return this.el("use", { "xlink:href": "#" + id });
            } else {
                return Element.prototype.use.call(this);
            }
        };
        /*\
         * Paper.symbol
         [ method ]
         **
         * Creates a <symbol> element.
         - vbx (number) @optional viewbox X
         - vby (number) @optional viewbox Y
         - vbw (number) @optional viewbox width
         - vbh (number) @optional viewbox height
         = (object) the `symbol` element
         **
        \*/
        proto.symbol = function (vx, vy, vw, vh) {
            var attr = {};
            if (vx != null && vy != null && vw != null && vh != null) {
                attr.viewBox = [vx, vy, vw, vh];
            }

            return this.el("symbol", attr);
        };
        /*\
         * Paper.text
         [ method ]
         **
         * Draws a text string
         **
         - x (number) x coordinate position
         - y (number) y coordinate position
         - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
         = (object) the `text` element
         **
         > Usage
         | var t1 = paper.text(50, 50, "Snap");
         | var t2 = paper.text(50, 50, ["S","n","a","p"]);
         | // Text path usage
         | t1.attr({textpath: "M10,10L100,100"});
         | // or
         | var pth = paper.path("M10,10L100,100");
         | t1.attr({textpath: pth});
        \*/
        proto.text = function (x, y, text) {
            var attr = {};
            if (is(x, "object")) {
                attr = x;
            } else if (x != null) {
                attr = {
                    x: x,
                    y: y,
                    text: text || ""
                };
            }
            return this.el("text", attr);
        };
        /*\
         * Paper.line
         [ method ]
         **
         * Draws a line
         **
         - x1 (number) x coordinate position of the start
         - y1 (number) y coordinate position of the start
         - x2 (number) x coordinate position of the end
         - y2 (number) y coordinate position of the end
         = (object) the `line` element
         **
         > Usage
         | var t1 = paper.line(50, 50, 100, 100);
        \*/
        proto.line = function (x1, y1, x2, y2) {
            var attr = {};
            if (is(x1, "object")) {
                attr = x1;
            } else if (x1 != null) {
                attr = {
                    x1: x1,
                    x2: x2,
                    y1: y1,
                    y2: y2
                };
            }
            return this.el("line", attr);
        };
        /*\
         * Paper.polyline
         [ method ]
         **
         * Draws a polyline
         **
         - points (array) array of points
         * or
         - varargs (…) points
         = (object) the `polyline` element
         **
         > Usage
         | var p1 = paper.polyline([10, 10, 100, 100]);
         | var p2 = paper.polyline(10, 10, 100, 100);
        \*/
        proto.polyline = function (points) {
            if (arguments.length > 1) {
                points = Array.prototype.slice.call(arguments, 0);
            }
            var attr = {};
            if (is(points, "object") && !is(points, "array")) {
                attr = points;
            } else if (points != null) {
                attr = { points: points };
            }
            return this.el("polyline", attr);
        };
        /*\
         * Paper.polygon
         [ method ]
         **
         * Draws a polygon. See @Paper.polyline
        \*/
        proto.polygon = function (points) {
            if (arguments.length > 1) {
                points = Array.prototype.slice.call(arguments, 0);
            }
            var attr = {};
            if (is(points, "object") && !is(points, "array")) {
                attr = points;
            } else if (points != null) {
                attr = { points: points };
            }
            return this.el("polygon", attr);
        };
        // gradients
        (function () {
            var $ = Snap._.$;
            // gradients' helpers
            function Gstops() {
                return this.selectAll("stop");
            }
            function GaddStop(color, offset) {
                var stop = $("stop"),
                    attr = {
                    offset: +offset + "%"
                };
                color = Snap.color(color);
                attr["stop-color"] = color.hex;
                if (color.opacity < 1) {
                    attr["stop-opacity"] = color.opacity;
                }
                $(stop, attr);
                this.node.appendChild(stop);
                return this;
            }
            function GgetBBox() {
                if (this.type == "linearGradient") {
                    var x1 = $(this.node, "x1") || 0,
                        x2 = $(this.node, "x2") || 1,
                        y1 = $(this.node, "y1") || 0,
                        y2 = $(this.node, "y2") || 0;
                    return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
                } else {
                    var cx = this.node.cx || .5,
                        cy = this.node.cy || .5,
                        r = this.node.r || 0;
                    return Snap._.box(cx - r, cy - r, r * 2, r * 2);
                }
            }
            function gradient(defs, str) {
                var grad = eve("snap.util.grad.parse", null, str).firstDefined(),
                    el;
                if (!grad) {
                    return null;
                }
                grad.params.unshift(defs);
                if (grad.type.toLowerCase() == "l") {
                    el = gradientLinear.apply(0, grad.params);
                } else {
                    el = gradientRadial.apply(0, grad.params);
                }
                if (grad.type != grad.type.toLowerCase()) {
                    $(el.node, {
                        gradientUnits: "userSpaceOnUse"
                    });
                }
                var stops = grad.stops,
                    len = stops.length,
                    start = 0,
                    j = 0;
                function seed(i, end) {
                    var step = (end - start) / (i - j);
                    for (var k = j; k < i; k++) {
                        stops[k].offset = +(+start + step * (k - j)).toFixed(2);
                    }
                    j = i;
                    start = end;
                }
                len--;
                for (var i = 0; i < len; i++) {
                    if ("offset" in stops[i]) {
                        seed(i, stops[i].offset);
                    }
                }stops[len].offset = stops[len].offset || 100;
                seed(len, stops[len].offset);
                for (i = 0; i <= len; i++) {
                    var stop = stops[i];
                    el.addStop(stop.color, stop.offset);
                }
                return el;
            }
            function gradientLinear(defs, x1, y1, x2, y2) {
                var el = Snap._.make("linearGradient", defs);
                el.stops = Gstops;
                el.addStop = GaddStop;
                el.getBBox = GgetBBox;
                if (x1 != null) {
                    $(el.node, {
                        x1: x1,
                        y1: y1,
                        x2: x2,
                        y2: y2
                    });
                }
                return el;
            }
            function gradientRadial(defs, cx, cy, r, fx, fy) {
                var el = Snap._.make("radialGradient", defs);
                el.stops = Gstops;
                el.addStop = GaddStop;
                el.getBBox = GgetBBox;
                if (cx != null) {
                    $(el.node, {
                        cx: cx,
                        cy: cy,
                        r: r
                    });
                }
                if (fx != null && fy != null) {
                    $(el.node, {
                        fx: fx,
                        fy: fy
                    });
                }
                return el;
            }
            /*\
             * Paper.gradient
             [ method ]
             **
             * Creates a gradient element
             **
             - gradient (string) gradient descriptor
             > Gradient Descriptor
             * The gradient descriptor is an expression formatted as
             * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
             * either linear or radial.  The uppercase `L` or `R` letters
             * indicate absolute coordinates offset from the SVG surface.
             * Lowercase `l` or `r` letters indicate coordinates
             * calculated relative to the element to which the gradient is
             * applied.  Coordinates specify a linear gradient vector as
             * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
             * `r` and optional `fx`, `fy` specifying a focal point away
             * from the center of the circle. Specify `<colors>` as a list
             * of dash-separated CSS color values.  Each color may be
             * followed by a custom offset value, separated with a colon
             * character.
             > Examples
             * Linear gradient, relative from top-left corner to bottom-right
             * corner, from black through red to white:
             | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
             * Linear gradient, absolute from (0, 0) to (100, 100), from black
             * through red at 25% to white:
             | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25-#fff");
             * Radial gradient, relative from the center of the element with radius
             * half the width, from black to white:
             | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
             * To apply the gradient:
             | paper.circle(50, 50, 40).attr({
             |     fill: g
             | });
             = (object) the `gradient` element
            \*/
            proto.gradient = function (str) {
                return gradient(this.defs, str);
            };
            proto.gradientLinear = function (x1, y1, x2, y2) {
                return gradientLinear(this.defs, x1, y1, x2, y2);
            };
            proto.gradientRadial = function (cx, cy, r, fx, fy) {
                return gradientRadial(this.defs, cx, cy, r, fx, fy);
            };
            /*\
             * Paper.toString
             [ method ]
             **
             * Returns SVG code for the @Paper
             = (string) SVG code for the @Paper
            \*/
            proto.toString = function () {
                var doc = this.node.ownerDocument,
                    f = doc.createDocumentFragment(),
                    d = doc.createElement("div"),
                    svg = this.node.cloneNode(true),
                    res;
                f.appendChild(d);
                d.appendChild(svg);
                Snap._.$(svg, { xmlns: "http://www.w3.org/2000/svg" });
                res = d.innerHTML;
                f.removeChild(f.firstChild);
                return res;
            };
            /*\
             * Paper.toDataURL
             [ method ]
             **
             * Returns SVG code for the @Paper as Data URI string.
             = (string) Data URI string
            \*/
            proto.toDataURL = function () {
                if (window && window.btoa) {
                    return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(this)));
                }
            };
            /*\
             * Paper.clear
             [ method ]
             **
             * Removes all child nodes of the paper, except <defs>.
            \*/
            proto.clear = function () {
                var node = this.node.firstChild,
                    next;
                while (node) {
                    next = node.nextSibling;
                    if (node.tagName != "defs") {
                        node.parentNode.removeChild(node);
                    } else {
                        proto.clear.call({ node: node });
                    }
                    node = next;
                }
            };
        })();
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob) {
        var elproto = Element.prototype,
            is = Snap.is,
            clone = Snap._.clone,
            has = "hasOwnProperty",
            p2s = /,?([a-z]),?/gi,
            toFloat = parseFloat,
            math = Math,
            PI = math.PI,
            mmin = math.min,
            mmax = math.max,
            pow = math.pow,
            abs = math.abs;
        function paths(ps) {
            var p = paths.ps = paths.ps || {};
            if (p[ps]) {
                p[ps].sleep = 100;
            } else {
                p[ps] = {
                    sleep: 100
                };
            }
            setTimeout(function () {
                for (var key in p) {
                    if (p[has](key) && key != ps) {
                        p[key].sleep--;
                        !p[key].sleep && delete p[key];
                    }
                }
            });
            return p[ps];
        }
        function box(x, y, width, height) {
            if (x == null) {
                x = y = width = height = 0;
            }
            if (y == null) {
                y = x.y;
                width = x.width;
                height = x.height;
                x = x.x;
            }
            return {
                x: x,
                y: y,
                width: width,
                w: width,
                height: height,
                h: height,
                x2: x + width,
                y2: y + height,
                cx: x + width / 2,
                cy: y + height / 2,
                r1: math.min(width, height) / 2,
                r2: math.max(width, height) / 2,
                r0: math.sqrt(width * width + height * height) / 2,
                path: rectPath(x, y, width, height),
                vb: [x, y, width, height].join(" ")
            };
        }
        function toString() {
            return this.join(",").replace(p2s, "$1");
        }
        function pathClone(pathArray) {
            var res = clone(pathArray);
            res.toString = toString;
            return res;
        }
        function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
            if (length == null) {
                return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
            } else {
                return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
            }
        }
        function getLengthFactory(istotal, subpath) {
            function O(val) {
                return +(+val).toFixed(3);
            }
            return Snap._.cacher(function (path, length, onlystart) {
                if (path instanceof Element) {
                    path = path.attr("d");
                }
                path = path2curve(path);
                var x,
                    y,
                    p,
                    l,
                    sp = "",
                    subpaths = {},
                    point,
                    len = 0;
                for (var i = 0, ii = path.length; i < ii; i++) {
                    p = path[i];
                    if (p[0] == "M") {
                        x = +p[1];
                        y = +p[2];
                    } else {
                        l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                        if (len + l > length) {
                            if (subpath && !subpaths.start) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                sp += ["C" + O(point.start.x), O(point.start.y), O(point.m.x), O(point.m.y), O(point.x), O(point.y)];
                                if (onlystart) {
                                    return sp;
                                }
                                subpaths.start = sp;
                                sp = ["M" + O(point.x), O(point.y) + "C" + O(point.n.x), O(point.n.y), O(point.end.x), O(point.end.y), O(p[5]), O(p[6])].join();
                                len += l;
                                x = +p[5];
                                y = +p[6];
                                continue;
                            }
                            if (!istotal && !subpath) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                return point;
                            }
                        }
                        len += l;
                        x = +p[5];
                        y = +p[6];
                    }
                    sp += p.shift() + p;
                }
                subpaths.end = sp;
                point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                return point;
            }, null, Snap._.clone);
        }
        var getTotalLength = getLengthFactory(1),
            getPointAtLength = getLengthFactory(),
            getSubpathsAtLength = getLengthFactory(0, 1);
        function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t,
                t13 = pow(t1, 3),
                t12 = pow(t1, 2),
                t2 = t * t,
                t3 = t2 * t,
                x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
                y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
                mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
                my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
                nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
                ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
                ax = t1 * p1x + t * c1x,
                ay = t1 * p1y + t * c1y,
                cx = t1 * c2x + t * p2x,
                cy = t1 * c2y + t * p2y,
                alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
            // (mx > nx || my < ny) && (alpha += 180);
            return {
                x: x,
                y: y,
                m: { x: mx, y: my },
                n: { x: nx, y: ny },
                start: { x: ax, y: ay },
                end: { x: cx, y: cy },
                alpha: alpha
            };
        }
        function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            if (!Snap.is(p1x, "array")) {
                p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
            }
            var bbox = curveDim.apply(null, p1x);
            return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
        }
        function isPointInsideBBox(bbox, x, y) {
            return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
        }
        function isBBoxIntersect(bbox1, bbox2) {
            bbox1 = box(bbox1);
            bbox2 = box(bbox2);
            return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
        }
        function base3(t, p1, p2, p3, p4) {
            var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
                t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
            return t * t2 - 3 * p1 + 3 * p2;
        }
        function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
            if (z == null) {
                z = 1;
            }
            z = z > 1 ? 1 : z < 0 ? 0 : z;
            var z2 = z / 2,
                n = 12,
                Tvalues = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816],
                Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
                sum = 0;
            for (var i = 0; i < n; i++) {
                var ct = z2 * Tvalues[i] + z2,
                    xbase = base3(ct, x1, x2, x3, x4),
                    ybase = base3(ct, y1, y2, y3, y4),
                    comb = xbase * xbase + ybase * ybase;
                sum += Cvalues[i] * math.sqrt(comb);
            }
            return z2 * sum;
        }
        function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
            if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
                return;
            }
            var t = 1,
                step = t / 2,
                t2 = t - step,
                l,
                e = .01;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
            while (abs(l - ll) > e) {
                step /= 2;
                t2 += (l < ll ? 1 : -1) * step;
                l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
            }
            return t2;
        }
        function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {
                return;
            }
            var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
                ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
                denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

            if (!denominator) {
                return;
            }
            var px = nx / denominator,
                py = ny / denominator,
                px2 = +px.toFixed(2),
                py2 = +py.toFixed(2);
            if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {
                return;
            }
            return { x: px, y: py };
        }
        function inter(bez1, bez2) {
            return interHelper(bez1, bez2);
        }
        function interCount(bez1, bez2) {
            return interHelper(bez1, bez2, 1);
        }
        function interHelper(bez1, bez2, justCount) {
            var bbox1 = bezierBBox(bez1),
                bbox2 = bezierBBox(bez2);
            if (!isBBoxIntersect(bbox1, bbox2)) {
                return justCount ? 0 : [];
            }
            var l1 = bezlen.apply(0, bez1),
                l2 = bezlen.apply(0, bez2),
                n1 = ~~(l1 / 8),
                n2 = ~~(l2 / 8),
                dots1 = [],
                dots2 = [],
                xy = {},
                res = justCount ? 0 : [];
            for (var i = 0; i < n1 + 1; i++) {
                var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
                dots1.push({ x: p.x, y: p.y, t: i / n1 });
            }
            for (i = 0; i < n2 + 1; i++) {
                p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
                dots2.push({ x: p.x, y: p.y, t: i / n2 });
            }
            for (i = 0; i < n1; i++) {
                for (var j = 0; j < n2; j++) {
                    var di = dots1[i],
                        di1 = dots1[i + 1],
                        dj = dots2[j],
                        dj1 = dots2[j + 1],
                        ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                        cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                        is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                    if (is) {
                        if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                            continue;
                        }
                        xy[is.x.toFixed(4)] = is.y.toFixed(4);
                        var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                            t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                            if (justCount) {
                                res++;
                            } else {
                                res.push({
                                    x: is.x,
                                    y: is.y,
                                    t1: t1,
                                    t2: t2
                                });
                            }
                        }
                    }
                }
            }
            return res;
        }
        function pathIntersection(path1, path2) {
            return interPathHelper(path1, path2);
        }
        function pathIntersectionNumber(path1, path2) {
            return interPathHelper(path1, path2, 1);
        }
        function interPathHelper(path1, path2, justCount) {
            path1 = path2curve(path1);
            path2 = path2curve(path2);
            var x1,
                y1,
                x2,
                y2,
                x1m,
                y1m,
                x2m,
                y2m,
                bez1,
                bez2,
                res = justCount ? 0 : [];
            for (var i = 0, ii = path1.length; i < ii; i++) {
                var pi = path1[i];
                if (pi[0] == "M") {
                    x1 = x1m = pi[1];
                    y1 = y1m = pi[2];
                } else {
                    if (pi[0] == "C") {
                        bez1 = [x1, y1].concat(pi.slice(1));
                        x1 = bez1[6];
                        y1 = bez1[7];
                    } else {
                        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                        x1 = x1m;
                        y1 = y1m;
                    }
                    for (var j = 0, jj = path2.length; j < jj; j++) {
                        var pj = path2[j];
                        if (pj[0] == "M") {
                            x2 = x2m = pj[1];
                            y2 = y2m = pj[2];
                        } else {
                            if (pj[0] == "C") {
                                bez2 = [x2, y2].concat(pj.slice(1));
                                x2 = bez2[6];
                                y2 = bez2[7];
                            } else {
                                bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                                x2 = x2m;
                                y2 = y2m;
                            }
                            var intr = interHelper(bez1, bez2, justCount);
                            if (justCount) {
                                res += intr;
                            } else {
                                for (var k = 0, kk = intr.length; k < kk; k++) {
                                    intr[k].segment1 = i;
                                    intr[k].segment2 = j;
                                    intr[k].bez1 = bez1;
                                    intr[k].bez2 = bez2;
                                }
                                res = res.concat(intr);
                            }
                        }
                    }
                }
            }
            return res;
        }
        function isPointInsidePath(path, x, y) {
            var bbox = pathBBox(path);
            return isPointInsideBBox(bbox, x, y) && interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
        }
        function pathBBox(path) {
            var pth = paths(path);
            if (pth.bbox) {
                return clone(pth.bbox);
            }
            if (!path) {
                return box();
            }
            path = path2curve(path);
            var x = 0,
                y = 0,
                X = [],
                Y = [],
                p;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = p[1];
                    y = p[2];
                    X.push(x);
                    Y.push(y);
                } else {
                    var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    X = X.concat(dim.min.x, dim.max.x);
                    Y = Y.concat(dim.min.y, dim.max.y);
                    x = p[5];
                    y = p[6];
                }
            }
            var xmin = mmin.apply(0, X),
                ymin = mmin.apply(0, Y),
                xmax = mmax.apply(0, X),
                ymax = mmax.apply(0, Y),
                bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
            pth.bbox = clone(bb);
            return bb;
        }
        function rectPath(x, y, w, h, r) {
            if (r) {
                return [["M", +x + +r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
            res.toString = toString;
            return res;
        }
        function ellipsePath(x, y, rx, ry, a) {
            if (a == null && ry == null) {
                ry = rx;
            }
            x = +x;
            y = +y;
            rx = +rx;
            ry = +ry;
            if (a != null) {
                var rad = Math.PI / 180,
                    x1 = x + rx * Math.cos(-ry * rad),
                    x2 = x + rx * Math.cos(-a * rad),
                    y1 = y + rx * Math.sin(-ry * rad),
                    y2 = y + rx * Math.sin(-a * rad),
                    res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
            } else {
                res = [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
            }
            res.toString = toString;
            return res;
        }
        var unit2px = Snap._unit2px,
            getPath = {
            path: function (el) {
                return el.attr("path");
            },
            circle: function (el) {
                var attr = unit2px(el);
                return ellipsePath(attr.cx, attr.cy, attr.r);
            },
            ellipse: function (el) {
                var attr = unit2px(el);
                return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);
            },
            rect: function (el) {
                var attr = unit2px(el);
                return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);
            },
            image: function (el) {
                var attr = unit2px(el);
                return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);
            },
            line: function (el) {
                return "M" + [el.attr("x1") || 0, el.attr("y1") || 0, el.attr("x2"), el.attr("y2")];
            },
            polyline: function (el) {
                return "M" + el.attr("points");
            },
            polygon: function (el) {
                return "M" + el.attr("points") + "z";
            },
            deflt: function (el) {
                var bbox = el.node.getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        };
        function pathToRelative(pathArray) {
            var pth = paths(pathArray),
                lowerCase = String.prototype.toLowerCase;
            if (pth.rel) {
                return pathClone(pth.rel);
            }
            if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
                pathArray = Snap.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res.push(["M", x, y]);
            }
            for (var i = start, ii = pathArray.length; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i].length;
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res.toString = toString;
            pth.rel = pathClone(res);
            return res;
        }
        function pathToAbsolute(pathArray) {
            var pth = paths(pathArray);
            if (pth.abs) {
                return pathClone(pth.abs);
            }
            if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) {
                // rough assumption
                pathArray = Snap.parsePathString(pathArray);
            }
            if (!pathArray || !pathArray.length) {
                return [["M", 0, 0]];
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0,
                pa0;
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                pa0 = pa[0];
                if (pa0 != pa0.toUpperCase()) {
                    r[0] = pa0.toUpperCase();
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +pa[6] + x;
                            r[7] = +pa[7] + y;
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "R":
                            var dots = [x, y].concat(pa.slice(1));
                            for (var j = 2, jj = dots.length; j < jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }
                            res.pop();
                            res = res.concat(catmullRom2bezier(dots, crz));
                            break;
                        case "O":
                            res.pop();
                            dots = ellipsePath(x, y, pa[1], pa[2]);
                            dots.push(dots[0]);
                            res = res.concat(dots);
                            break;
                        case "U":
                            res.pop();
                            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                            r = ["U"].concat(res[res.length - 1].slice(-2));
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +pa[j] + (j % 2 ? x : y);
                            }
                    }
                } else if (pa0 == "R") {
                    dots = [x, y].concat(pa.slice(1));
                    res.pop();
                    res = res.concat(catmullRom2bezier(dots, crz));
                    r = ["R"].concat(pa.slice(-2));
                } else if (pa0 == "O") {
                    res.pop();
                    dots = ellipsePath(x, y, pa[1], pa[2]);
                    dots.push(dots[0]);
                    res = res.concat(dots);
                } else if (pa0 == "U") {
                    res.pop();
                    res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                    r = ["U"].concat(res[res.length - 1].slice(-2));
                } else {
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        r[k] = pa[k];
                    }
                }
                pa0 = pa0.toUpperCase();
                if (pa0 != "O") {
                    switch (r[0]) {
                        case "Z":
                            x = +mx;
                            y = +my;
                            break;
                        case "H":
                            x = r[1];
                            break;
                        case "V":
                            y = r[1];
                            break;
                        case "M":
                            mx = r[r.length - 2];
                            my = r[r.length - 1];
                        default:
                            x = r[r.length - 2];
                            y = r[r.length - 1];
                    }
                }
            }
            res.toString = toString;
            pth.abs = pathClone(res);
            return res;
        }
        function l2c(x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        }
        function q2c(x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;
            return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
        }
        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = Snap._.cacher(function (x, y, rad) {
                var X = x * math.cos(rad) - y * math.sin(rad),
                    Y = x * math.sin(rad) + y * math.cos(rad);
                return { x: X, y: Y };
            });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = math.cos(PI / 180 * angle),
                    sin = math.sin(PI / 180 * angle),
                    x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;
                var h = x * x / (rx * rx) + y * y / (ry * ry);
                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4].concat(res);
            } else {
                res = [m2, m3, m4].concat(res).join().split(",");
                var newres = [];
                for (var i = 0, ii = res.length; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        }
        function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        }

        // Returns bounding box of cubic bezier curve.
        // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
        // Original version: NISHIO Hirokazu
        // Modifications: https://github.com/timo22345
        function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
            var tvalues = [],
                bounds = [[], []],
                a,
                b,
                c,
                t,
                t1,
                t2,
                b2ac,
                sqrtb2ac;
            for (var i = 0; i < 2; ++i) {
                if (i == 0) {
                    b = 6 * x0 - 12 * x1 + 6 * x2;
                    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                    c = 3 * x1 - 3 * x0;
                } else {
                    b = 6 * y0 - 12 * y1 + 6 * y2;
                    a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                    c = 3 * y1 - 3 * y0;
                }
                if (abs(a) < 1e-12) {
                    if (abs(b) < 1e-12) {
                        continue;
                    }
                    t = -c / b;
                    if (0 < t && t < 1) {
                        tvalues.push(t);
                    }
                    continue;
                }
                b2ac = b * b - 4 * c * a;
                sqrtb2ac = math.sqrt(b2ac);
                if (b2ac < 0) {
                    continue;
                }
                t1 = (-b + sqrtb2ac) / (2 * a);
                if (0 < t1 && t1 < 1) {
                    tvalues.push(t1);
                }
                t2 = (-b - sqrtb2ac) / (2 * a);
                if (0 < t2 && t2 < 1) {
                    tvalues.push(t2);
                }
            }

            var x,
                y,
                j = tvalues.length,
                jlen = j,
                mt;
            while (j--) {
                t = tvalues[j];
                mt = 1 - t;
                bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
                bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
            }

            bounds[0][jlen] = x0;
            bounds[1][jlen] = y0;
            bounds[0][jlen + 1] = x3;
            bounds[1][jlen + 1] = y3;
            bounds[0].length = bounds[1].length = jlen + 2;

            return {
                min: { x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1]) },
                max: { x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1]) }
            };
        }

        function path2curve(path, path2) {
            var pth = !path2 && paths(path);
            if (!path2 && pth.curve) {
                return pathClone(pth.curve);
            }
            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
                attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
                processPath = function (path, d, pcom) {
                var nx, ny;
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                        break;
                    case "S":
                        if (pcom == "C" || pcom == "S") {
                            // In "S" case we have to take into account, if the previous command is C/S.
                            nx = d.x * 2 - d.bx; // And reflect the previous
                            ny = d.y * 2 - d.by; // command's control point relative to the current point.
                        } else {
                            // or some else or nothing
                            nx = d.x;
                            ny = d.y;
                        }
                        path = ["C", nx, ny].concat(path.slice(1));
                        break;
                    case "T":
                        if (pcom == "Q" || pcom == "T") {
                            // In "T" case we have to take into account, if the previous command is Q/T.
                            d.qx = d.x * 2 - d.qx; // And make a reflection similar
                            d.qy = d.y * 2 - d.qy; // to case "S".
                        } else {
                            // or something else or nothing
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
                fixArc = function (pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
                        p2 && (pcoms2[i] = "A"); // the same as above
                        pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
                fixM = function (path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
                pcoms1 = [],
                // path commands of original path p
            pcoms2 = [],
                // path commands of original path p2
            pfirst = "",
                // temporary holder for original path command
            pcom = ""; // holder for previous path command of original path
            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                p[i] && (pfirst = p[i][0]); // save current path command

                if (pfirst != "C") // C is not saved yet, because it may be result of conversion
                    {
                        pcoms1[i] = pfirst; // Save current path command
                        i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
                    }
                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

                if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
                // which may produce multiple C:s
                // so we have to make sure that C is also C in original path

                fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

                if (p2) {
                    // the same procedures is done to p2
                    p2[i] && (pfirst = p2[i][0]);
                    if (pfirst != "C") {
                        pcoms2[i] = pfirst;
                        i && (pcom = pcoms2[i - 1]);
                    }
                    p2[i] = processPath(p2[i], attrs2, pcom);

                    if (pcoms2[i] != "A" && pfirst == "C") {
                        pcoms2[i] = "C";
                    }

                    fixArc(p2, i);
                }
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg.length,
                    seg2len = p2 && seg2.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            if (!p2) {
                pth.curve = pathClone(p);
            }
            return p2 ? [p, p2] : p;
        }
        function mapPath(path, matrix) {
            if (!matrix) {
                return path;
            }
            var x, y, i, j, ii, jj, pathi;
            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        }

        // http://schepers.cc/getting-to-the-point
        function catmullRom2bezier(crp, z) {
            var d = [];
            for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
                var p = [{ x: +crp[i - 2], y: +crp[i - 1] }, { x: +crp[i], y: +crp[i + 1] }, { x: +crp[i + 2], y: +crp[i + 3] }, { x: +crp[i + 4], y: +crp[i + 5] }];
                if (z) {
                    if (!i) {
                        p[0] = { x: +crp[iLen - 2], y: +crp[iLen - 1] };
                    } else if (iLen - 4 == i) {
                        p[3] = { x: +crp[0], y: +crp[1] };
                    } else if (iLen - 2 == i) {
                        p[2] = { x: +crp[0], y: +crp[1] };
                        p[3] = { x: +crp[2], y: +crp[3] };
                    }
                } else {
                    if (iLen - 4 == i) {
                        p[3] = p[2];
                    } else if (!i) {
                        p[0] = { x: +crp[i], y: +crp[i + 1] };
                    }
                }
                d.push(["C", (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
            }

            return d;
        }

        // export
        Snap.path = paths;

        /*\
         * Snap.path.getTotalLength
         [ method ]
         **
         * Returns the length of the given path in pixels
         **
         - path (string) SVG path string
         **
         = (number) length
        \*/
        Snap.path.getTotalLength = getTotalLength;
        /*\
         * Snap.path.getPointAtLength
         [ method ]
         **
         * Returns the coordinates of the point located at the given length along the given path
         **
         - path (string) SVG path string
         - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
         **
         = (object) representation of the point:
         o {
         o     x: (number) x coordinate,
         o     y: (number) y coordinate,
         o     alpha: (number) angle of derivative
         o }
        \*/
        Snap.path.getPointAtLength = getPointAtLength;
        /*\
         * Snap.path.getSubpath
         [ method ]
         **
         * Returns the subpath of a given path between given start and end lengths
         **
         - path (string) SVG path string
         - from (number) length, in pixels, from the start of the path to the start of the segment
         - to (number) length, in pixels, from the start of the path to the end of the segment
         **
         = (string) path string definition for the segment
        \*/
        Snap.path.getSubpath = function (path, from, to) {
            if (this.getTotalLength(path) - to < 1e-6) {
                return getSubpathsAtLength(path, from).end;
            }
            var a = getSubpathsAtLength(path, to, 1);
            return from ? getSubpathsAtLength(a, from).end : a;
        };
        /*\
         * Element.getTotalLength
         [ method ]
         **
         * Returns the length of the path in pixels (only works for `path` elements)
         = (number) length
        \*/
        elproto.getTotalLength = function () {
            if (this.node.getTotalLength) {
                return this.node.getTotalLength();
            }
        };
        // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
        /*\
         * Element.getPointAtLength
         [ method ]
         **
         * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
         **
         - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
         **
         = (object) representation of the point:
         o {
         o     x: (number) x coordinate,
         o     y: (number) y coordinate,
         o     alpha: (number) angle of derivative
         o }
        \*/
        elproto.getPointAtLength = function (length) {
            return getPointAtLength(this.attr("d"), length);
        };
        // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
        /*\
         * Element.getSubpath
         [ method ]
         **
         * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
         **
         - from (number) length, in pixels, from the start of the path to the start of the segment
         - to (number) length, in pixels, from the start of the path to the end of the segment
         **
         = (string) path string definition for the segment
        \*/
        elproto.getSubpath = function (from, to) {
            return Snap.path.getSubpath(this.attr("d"), from, to);
        };
        Snap._.box = box;
        /*\
         * Snap.path.findDotsAtSegment
         [ method ]
         **
         * Utility method
         **
         * Finds dot coordinates on the given cubic beziér curve at the given t
         - p1x (number) x of the first point of the curve
         - p1y (number) y of the first point of the curve
         - c1x (number) x of the first anchor of the curve
         - c1y (number) y of the first anchor of the curve
         - c2x (number) x of the second anchor of the curve
         - c2y (number) y of the second anchor of the curve
         - p2x (number) x of the second point of the curve
         - p2y (number) y of the second point of the curve
         - t (number) position on the curve (0..1)
         = (object) point information in format:
         o {
         o     x: (number) x coordinate of the point,
         o     y: (number) y coordinate of the point,
         o     m: {
         o         x: (number) x coordinate of the left anchor,
         o         y: (number) y coordinate of the left anchor
         o     },
         o     n: {
         o         x: (number) x coordinate of the right anchor,
         o         y: (number) y coordinate of the right anchor
         o     },
         o     start: {
         o         x: (number) x coordinate of the start of the curve,
         o         y: (number) y coordinate of the start of the curve
         o     },
         o     end: {
         o         x: (number) x coordinate of the end of the curve,
         o         y: (number) y coordinate of the end of the curve
         o     },
         o     alpha: (number) angle of the curve derivative at the point
         o }
        \*/
        Snap.path.findDotsAtSegment = findDotsAtSegment;
        /*\
         * Snap.path.bezierBBox
         [ method ]
         **
         * Utility method
         **
         * Returns the bounding box of a given cubic beziér curve
         - p1x (number) x of the first point of the curve
         - p1y (number) y of the first point of the curve
         - c1x (number) x of the first anchor of the curve
         - c1y (number) y of the first anchor of the curve
         - c2x (number) x of the second anchor of the curve
         - c2y (number) y of the second anchor of the curve
         - p2x (number) x of the second point of the curve
         - p2y (number) y of the second point of the curve
         * or
         - bez (array) array of six points for beziér curve
         = (object) bounding box
         o {
         o     x: (number) x coordinate of the left top point of the box,
         o     y: (number) y coordinate of the left top point of the box,
         o     x2: (number) x coordinate of the right bottom point of the box,
         o     y2: (number) y coordinate of the right bottom point of the box,
         o     width: (number) width of the box,
         o     height: (number) height of the box
         o }
        \*/
        Snap.path.bezierBBox = bezierBBox;
        /*\
         * Snap.path.isPointInsideBBox
         [ method ]
         **
         * Utility method
         **
         * Returns `true` if given point is inside bounding box
         - bbox (string) bounding box
         - x (string) x coordinate of the point
         - y (string) y coordinate of the point
         = (boolean) `true` if point is inside
        \*/
        Snap.path.isPointInsideBBox = isPointInsideBBox;
        Snap.closest = function (x, y, X, Y) {
            var r = 100,
                b = box(x - r / 2, y - r / 2, r, r),
                inside = [],
                getter = X[0].hasOwnProperty("x") ? function (i) {
                return {
                    x: X[i].x,
                    y: X[i].y
                };
            } : function (i) {
                return {
                    x: X[i],
                    y: Y[i]
                };
            },
                found = 0;
            while (r <= 1e6 && !found) {
                for (var i = 0, ii = X.length; i < ii; i++) {
                    var xy = getter(i);
                    if (isPointInsideBBox(b, xy.x, xy.y)) {
                        found++;
                        inside.push(xy);
                        break;
                    }
                }
                if (!found) {
                    r *= 2;
                    b = box(x - r / 2, y - r / 2, r, r);
                }
            }
            if (r == 1e6) {
                return;
            }
            var len = Infinity,
                res;
            for (i = 0, ii = inside.length; i < ii; i++) {
                var l = Snap.len(x, y, inside[i].x, inside[i].y);
                if (len > l) {
                    len = l;
                    inside[i].len = l;
                    res = inside[i];
                }
            }
            return res;
        };
        /*\
         * Snap.path.isBBoxIntersect
         [ method ]
         **
         * Utility method
         **
         * Returns `true` if two bounding boxes intersect
         - bbox1 (string) first bounding box
         - bbox2 (string) second bounding box
         = (boolean) `true` if bounding boxes intersect
        \*/
        Snap.path.isBBoxIntersect = isBBoxIntersect;
        /*\
         * Snap.path.intersection
         [ method ]
         **
         * Utility method
         **
         * Finds intersections of two paths
         - path1 (string) path string
         - path2 (string) path string
         = (array) dots of intersection
         o [
         o     {
         o         x: (number) x coordinate of the point,
         o         y: (number) y coordinate of the point,
         o         t1: (number) t value for segment of path1,
         o         t2: (number) t value for segment of path2,
         o         segment1: (number) order number for segment of path1,
         o         segment2: (number) order number for segment of path2,
         o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,
         o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
         o     }
         o ]
        \*/
        Snap.path.intersection = pathIntersection;
        Snap.path.intersectionNumber = pathIntersectionNumber;
        /*\
         * Snap.path.isPointInside
         [ method ]
         **
         * Utility method
         **
         * Returns `true` if given point is inside a given closed path.
         *
         * Note: fill mode doesn’t affect the result of this method.
         - path (string) path string
         - x (number) x of the point
         - y (number) y of the point
         = (boolean) `true` if point is inside the path
        \*/
        Snap.path.isPointInside = isPointInsidePath;
        /*\
         * Snap.path.getBBox
         [ method ]
         **
         * Utility method
         **
         * Returns the bounding box of a given path
         - path (string) path string
         = (object) bounding box
         o {
         o     x: (number) x coordinate of the left top point of the box,
         o     y: (number) y coordinate of the left top point of the box,
         o     x2: (number) x coordinate of the right bottom point of the box,
         o     y2: (number) y coordinate of the right bottom point of the box,
         o     width: (number) width of the box,
         o     height: (number) height of the box
         o }
        \*/
        Snap.path.getBBox = pathBBox;
        Snap.path.get = getPath;
        /*\
         * Snap.path.toRelative
         [ method ]
         **
         * Utility method
         **
         * Converts path coordinates into relative values
         - path (string) path string
         = (array) path string
        \*/
        Snap.path.toRelative = pathToRelative;
        /*\
         * Snap.path.toAbsolute
         [ method ]
         **
         * Utility method
         **
         * Converts path coordinates into absolute values
         - path (string) path string
         = (array) path string
        \*/
        Snap.path.toAbsolute = pathToAbsolute;
        /*\
         * Snap.path.toCubic
         [ method ]
         **
         * Utility method
         **
         * Converts path to a new path where all segments are cubic beziér curves
         - pathString (string|array) path string or array of segments
         = (array) array of segments
        \*/
        Snap.path.toCubic = path2curve;
        /*\
         * Snap.path.map
         [ method ]
         **
         * Transform the path string with the given matrix
         - path (string) path string
         - matrix (object) see @Matrix
         = (string) transformed path string
        \*/
        Snap.path.map = mapPath;
        Snap.path.toString = toString;
        Snap.path.clone = pathClone;
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob) {
        var mmax = Math.max,
            mmin = Math.min;

        // Set
        var Set = function (items) {
            this.items = [];
            this.bindings = {};
            this.length = 0;
            this.type = "set";
            if (items) {
                for (var i = 0, ii = items.length; i < ii; i++) {
                    if (items[i]) {
                        this[this.items.length] = this.items[this.items.length] = items[i];
                        this.length++;
                    }
                }
            }
        },
            setproto = Set.prototype;
        /*\
         * Set.push
         [ method ]
         **
         * Adds each argument to the current set
         = (object) original element
        \*/
        setproto.push = function () {
            var item, len;
            for (var i = 0, ii = arguments.length; i < ii; i++) {
                item = arguments[i];
                if (item) {
                    len = this.items.length;
                    this[len] = this.items[len] = item;
                    this.length++;
                }
            }
            return this;
        };
        /*\
         * Set.pop
         [ method ]
         **
         * Removes last element and returns it
         = (object) element
        \*/
        setproto.pop = function () {
            this.length && delete this[this.length--];
            return this.items.pop();
        };
        /*\
         * Set.forEach
         [ method ]
         **
         * Executes given function for each element in the set
         *
         * If the function returns `false`, the loop stops running.
         **
         - callback (function) function to run
         - thisArg (object) context object for the callback
         = (object) Set object
        \*/
        setproto.forEach = function (callback, thisArg) {
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                if (callback.call(thisArg, this.items[i], i) === false) {
                    return this;
                }
            }
            return this;
        };
        /*\
         * Set.animate
         [ method ]
         **
         * Animates each element in set in sync.
         *
         **
         - attrs (object) key-value pairs of destination attributes
         - duration (number) duration of the animation in milliseconds
         - easing (function) #optional easing function from @mina or custom
         - callback (function) #optional callback function that executes when the animation ends
         * or
         - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`
         > Usage
         | // animate all elements in set to radius 10
         | set.animate({r: 10}, 500, mina.easein);
         | // or
         | // animate first element to radius 10, but second to radius 20 and in different time
         | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);
         = (Element) the current element
        \*/
        setproto.animate = function (attrs, ms, easing, callback) {
            if (typeof easing == "function" && !easing.length) {
                callback = easing;
                easing = mina.linear;
            }
            if (attrs instanceof Snap._.Animation) {
                callback = attrs.callback;
                easing = attrs.easing;
                ms = easing.dur;
                attrs = attrs.attr;
            }
            var args = arguments;
            if (Snap.is(attrs, "array") && Snap.is(args[args.length - 1], "array")) {
                var each = true;
            }
            var begin,
                handler = function () {
                if (begin) {
                    this.b = begin;
                } else {
                    begin = this.b;
                }
            },
                cb = 0,
                set = this,
                callbacker = callback && function () {
                if (++cb == set.length) {
                    callback.call(this);
                }
            };
            return this.forEach(function (el, i) {
                eve.once("snap.animcreated." + el.id, handler);
                if (each) {
                    args[i] && el.animate.apply(el, args[i]);
                } else {
                    el.animate(attrs, ms, easing, callbacker);
                }
            });
        };
        setproto.remove = function () {
            while (this.length) {
                this.pop().remove();
            }
            return this;
        };
        /*\
         * Set.bind
         [ method ]
         **
         * Specifies how to handle a specific attribute when applied
         * to a set.
         *
         **
         - attr (string) attribute name
         - callback (function) function to run
         * or
         - attr (string) attribute name
         - element (Element) specific element in the set to apply the attribute to
         * or
         - attr (string) attribute name
         - element (Element) specific element in the set to apply the attribute to
         - eattr (string) attribute on the element to bind the attribute to
         = (object) Set object
        \*/
        setproto.bind = function (attr, a, b) {
            var data = {};
            if (typeof a == "function") {
                this.bindings[attr] = a;
            } else {
                var aname = b || attr;
                this.bindings[attr] = function (v) {
                    data[aname] = v;
                    a.attr(data);
                };
            }
            return this;
        };
        setproto.attr = function (value) {
            var unbound = {};
            for (var k in value) {
                if (this.bindings[k]) {
                    this.bindings[k](value[k]);
                } else {
                    unbound[k] = value[k];
                }
            }
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                this.items[i].attr(unbound);
            }
            return this;
        };
        /*\
         * Set.clear
         [ method ]
         **
         * Removes all elements from the set
        \*/
        setproto.clear = function () {
            while (this.length) {
                this.pop();
            }
        };
        /*\
         * Set.splice
         [ method ]
         **
         * Removes range of elements from the set
         **
         - index (number) position of the deletion
         - count (number) number of element to remove
         - insertion… (object) #optional elements to insert
         = (object) set elements that were deleted
        \*/
        setproto.splice = function (index, count, insertion) {
            index = index < 0 ? mmax(this.length + index, 0) : index;
            count = mmax(0, mmin(this.length - index, count));
            var tail = [],
                todel = [],
                args = [],
                i;
            for (i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            for (i = 0; i < count; i++) {
                todel.push(this[index + i]);
            }
            for (; i < this.length - index; i++) {
                tail.push(this[index + i]);
            }
            var arglen = args.length;
            for (i = 0; i < arglen + tail.length; i++) {
                this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
            }
            i = this.items.length = this.length -= count - arglen;
            while (this[i]) {
                delete this[i++];
            }
            return new Set(todel);
        };
        /*\
         * Set.exclude
         [ method ]
         **
         * Removes given element from the set
         **
         - element (object) element to remove
         = (boolean) `true` if object was found and removed from the set
        \*/
        setproto.exclude = function (el) {
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (this[i] == el) {
                    this.splice(i, 1);
                    return true;
                }
            }return false;
        };
        setproto.insertAfter = function (el) {
            var i = this.items.length;
            while (i--) {
                this.items[i].insertAfter(el);
            }
            return this;
        };
        setproto.getBBox = function () {
            var x = [],
                y = [],
                x2 = [],
                y2 = [];
            for (var i = this.items.length; i--;) {
                if (!this.items[i].removed) {
                    var box = this.items[i].getBBox();
                    x.push(box.x);
                    y.push(box.y);
                    x2.push(box.x + box.width);
                    y2.push(box.y + box.height);
                }
            }x = mmin.apply(0, x);
            y = mmin.apply(0, y);
            x2 = mmax.apply(0, x2);
            y2 = mmax.apply(0, y2);
            return {
                x: x,
                y: y,
                x2: x2,
                y2: y2,
                width: x2 - x,
                height: y2 - y,
                cx: x + (x2 - x) / 2,
                cy: y + (y2 - y) / 2
            };
        };
        setproto.clone = function (s) {
            s = new Set();
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                s.push(this.items[i].clone());
            }
            return s;
        };
        setproto.toString = function () {
            return "Snap\u2018s set";
        };
        setproto.type = "set";
        // export
        Snap.Set = Set;
        Snap.set = function () {
            var set = new Set();
            if (arguments.length) {
                set.push.apply(set, Array.prototype.slice.call(arguments, 0));
            }
            return set;
        };
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob) {
        var names = {},
            reUnit = /[a-z]+$/i,
            Str = String;
        names.stroke = names.fill = "colour";
        function getEmpty(item) {
            var l = item[0];
            switch (l.toLowerCase()) {
                case "t":
                    return [l, 0, 0];
                case "m":
                    return [l, 1, 0, 0, 1, 0, 0];
                case "r":
                    if (item.length == 4) {
                        return [l, 0, item[2], item[3]];
                    } else {
                        return [l, 0];
                    }
                case "s":
                    if (item.length == 5) {
                        return [l, 1, 1, item[3], item[4]];
                    } else if (item.length == 3) {
                        return [l, 1, 1];
                    } else {
                        return [l, 1];
                    }
            }
        }
        function equaliseTransform(t1, t2, getBBox) {
            t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
            t1 = Snap.parseTransformString(t1) || [];
            t2 = Snap.parseTransformString(t2) || [];
            var maxlength = Math.max(t1.length, t2.length),
                from = [],
                to = [],
                i = 0,
                j,
                jj,
                tt1,
                tt2;
            for (; i < maxlength; i++) {
                tt1 = t1[i] || getEmpty(t2[i]);
                tt2 = t2[i] || getEmpty(tt1);
                if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) {
                    t1 = Snap._.transform2matrix(t1, getBBox());
                    t2 = Snap._.transform2matrix(t2, getBBox());
                    from = [["m", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];
                    to = [["m", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];
                    break;
                }
                from[i] = [];
                to[i] = [];
                for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {
                    j in tt1 && (from[i][j] = tt1[j]);
                    j in tt2 && (to[i][j] = tt2[j]);
                }
            }
            return {
                from: path2array(from),
                to: path2array(to),
                f: getPath(from)
            };
        }
        function getNumber(val) {
            return val;
        }
        function getUnit(unit) {
            return function (val) {
                return +val.toFixed(3) + unit;
            };
        }
        function getViewBox(val) {
            return val.join(" ");
        }
        function getColour(clr) {
            return Snap.rgb(clr[0], clr[1], clr[2]);
        }
        function getPath(path) {
            var k = 0,
                i,
                ii,
                j,
                jj,
                out,
                a,
                b = [];
            for (i = 0, ii = path.length; i < ii; i++) {
                out = "[";
                a = ['"' + path[i][0] + '"'];
                for (j = 1, jj = path[i].length; j < jj; j++) {
                    a[j] = "val[" + k++ + "]";
                }
                out += a + "]";
                b[i] = out;
            }
            return Function("val", "return Snap.path.toString.call([" + b + "])");
        }
        function path2array(path) {
            var out = [];
            for (var i = 0, ii = path.length; i < ii; i++) {
                for (var j = 1, jj = path[i].length; j < jj; j++) {
                    out.push(path[i][j]);
                }
            }
            return out;
        }
        function isNumeric(obj) {
            return isFinite(parseFloat(obj));
        }
        function arrayEqual(arr1, arr2) {
            if (!Snap.is(arr1, "array") || !Snap.is(arr2, "array")) {
                return false;
            }
            return arr1.toString() == arr2.toString();
        }
        Element.prototype.equal = function (name, b) {
            return eve("snap.util.equal", this, name, b).firstDefined();
        };
        eve.on("snap.util.equal", function (name, b) {
            var A,
                B,
                a = Str(this.attr(name) || ""),
                el = this;
            if (isNumeric(a) && isNumeric(b)) {
                return {
                    from: parseFloat(a),
                    to: parseFloat(b),
                    f: getNumber
                };
            }
            if (names[name] == "colour") {
                A = Snap.color(a);
                B = Snap.color(b);
                return {
                    from: [A.r, A.g, A.b, A.opacity],
                    to: [B.r, B.g, B.b, B.opacity],
                    f: getColour
                };
            }
            if (name == "viewBox") {
                A = this.attr(name).vb.split(" ").map(Number);
                B = b.split(" ").map(Number);
                return {
                    from: A,
                    to: B,
                    f: getViewBox
                };
            }
            if (name == "transform" || name == "gradientTransform" || name == "patternTransform") {
                if (b instanceof Snap.Matrix) {
                    b = b.toTransformString();
                }
                if (!Snap._.rgTransform.test(b)) {
                    b = Snap._.svgTransform2string(b);
                }
                return equaliseTransform(a, b, function () {
                    return el.getBBox(1);
                });
            }
            if (name == "d" || name == "path") {
                A = Snap.path.toCubic(a, b);
                return {
                    from: path2array(A[0]),
                    to: path2array(A[1]),
                    f: getPath(A[0])
                };
            }
            if (name == "points") {
                A = Str(a).split(Snap._.separator);
                B = Str(b).split(Snap._.separator);
                return {
                    from: A,
                    to: B,
                    f: function (val) {
                        return val;
                    }
                };
            }
            var aUnit = a.match(reUnit),
                bUnit = Str(b).match(reUnit);
            if (aUnit && arrayEqual(aUnit, bUnit)) {
                return {
                    from: parseFloat(a),
                    to: parseFloat(b),
                    f: getUnit(aUnit)
                };
            } else {
                return {
                    from: this.asPX(name),
                    to: this.asPX(name, b),
                    f: getNumber
                };
            }
        });
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob) {
        var elproto = Element.prototype,
            has = "hasOwnProperty",
            supportsTouch = "createTouch" in glob.doc,
            events = ["click", "dblclick", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "touchstart", "touchmove", "touchend", "touchcancel"],
            touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
            getScroll = function (xy, el) {
            var name = xy == "y" ? "scrollTop" : "scrollLeft",
                doc = el && el.node ? el.node.ownerDocument : glob.doc;
            return doc[name in doc.documentElement ? "documentElement" : "body"][name];
        },
            preventDefault = function () {
            this.returnValue = false;
        },
            preventTouch = function () {
            return this.originalEvent.preventDefault();
        },
            stopPropagation = function () {
            this.cancelBubble = true;
        },
            stopTouch = function () {
            return this.originalEvent.stopPropagation();
        },
            addEvent = function (obj, type, fn, element) {
            var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
                f = function (e) {
                var scrollY = getScroll("y", element),
                    scrollX = getScroll("x", element);
                if (supportsTouch && touchMap[has](type)) {
                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
                            var olde = e;
                            e = e.targetTouches[i];
                            e.originalEvent = olde;
                            e.preventDefault = preventTouch;
                            e.stopPropagation = stopTouch;
                            break;
                        }
                    }
                }
                var x = e.clientX + scrollX,
                    y = e.clientY + scrollY;
                return fn.call(element, e, x, y);
            };

            if (type !== realName) {
                obj.addEventListener(type, f, false);
            }

            obj.addEventListener(realName, f, false);

            return function () {
                if (type !== realName) {
                    obj.removeEventListener(type, f, false);
                }

                obj.removeEventListener(realName, f, false);
                return true;
            };
        },
            drag = [],
            dragMove = function (e) {
            var x = e.clientX,
                y = e.clientY,
                scrollY = getScroll("y"),
                scrollX = getScroll("x"),
                dragi,
                j = drag.length;
            while (j--) {
                dragi = drag[j];
                if (supportsTouch) {
                    var i = e.touches && e.touches.length,
                        touch;
                    while (i--) {
                        touch = e.touches[i];
                        if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
                            x = touch.clientX;
                            y = touch.clientY;
                            (e.originalEvent ? e.originalEvent : e).preventDefault();
                            break;
                        }
                    }
                } else {
                    e.preventDefault();
                }
                var node = dragi.el.node,
                    o,
                    next = node.nextSibling,
                    parent = node.parentNode,
                    display = node.style.display;
                // glob.win.opera && parent.removeChild(node);
                // node.style.display = "none";
                // o = dragi.el.paper.getElementByPoint(x, y);
                // node.style.display = display;
                // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
                x += scrollX;
                y += scrollY;
                eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
            }
        },
            dragUp = function (e) {
            Snap.unmousemove(dragMove).unmouseup(dragUp);
            var i = drag.length,
                dragi;
            while (i--) {
                dragi = drag[i];
                dragi.el._drag = {};
                eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
                eve.off("snap.drag.*." + dragi.el.id);
            }
            drag = [];
        };
        /*\
         * Element.click
         [ method ]
         **
         * Adds a click event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unclick
         [ method ]
         **
         * Removes a click event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.dblclick
         [ method ]
         **
         * Adds a double click event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.undblclick
         [ method ]
         **
         * Removes a double click event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.mousedown
         [ method ]
         **
         * Adds a mousedown event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unmousedown
         [ method ]
         **
         * Removes a mousedown event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.mousemove
         [ method ]
         **
         * Adds a mousemove event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unmousemove
         [ method ]
         **
         * Removes a mousemove event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.mouseout
         [ method ]
         **
         * Adds a mouseout event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unmouseout
         [ method ]
         **
         * Removes a mouseout event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.mouseover
         [ method ]
         **
         * Adds a mouseover event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unmouseover
         [ method ]
         **
         * Removes a mouseover event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.mouseup
         [ method ]
         **
         * Adds a mouseup event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unmouseup
         [ method ]
         **
         * Removes a mouseup event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.touchstart
         [ method ]
         **
         * Adds a touchstart event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.untouchstart
         [ method ]
         **
         * Removes a touchstart event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.touchmove
         [ method ]
         **
         * Adds a touchmove event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.untouchmove
         [ method ]
         **
         * Removes a touchmove event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.touchend
         [ method ]
         **
         * Adds a touchend event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.untouchend
         [ method ]
         **
         * Removes a touchend event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.touchcancel
         [ method ]
         **
         * Adds a touchcancel event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.untouchcancel
         [ method ]
         **
         * Removes a touchcancel event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        for (var i = events.length; i--;) {
            (function (eventName) {
                Snap[eventName] = elproto[eventName] = function (fn, scope) {
                    if (Snap.is(fn, "function")) {
                        this.events = this.events || [];
                        this.events.push({
                            name: eventName,
                            f: fn,
                            unbind: addEvent(this.node || document, eventName, fn, scope || this)
                        });
                    } else {
                        for (var i = 0, ii = this.events.length; i < ii; i++) {
                            if (this.events[i].name == eventName) {
                                try {
                                    this.events[i].f.call(this);
                                } catch (e) {}
                            }
                        }
                    }
                    return this;
                };
                Snap["un" + eventName] = elproto["un" + eventName] = function (fn) {
                    var events = this.events || [],
                        l = events.length;
                    while (l--) {
                        if (events[l].name == eventName && (events[l].f == fn || !fn)) {
                            events[l].unbind();
                            events.splice(l, 1);
                            !events.length && delete this.events;
                            return this;
                        }
                    }return this;
                };
            })(events[i]);
        }
        /*\
         * Element.hover
         [ method ]
         **
         * Adds hover event handlers to the element
         - f_in (function) handler for hover in
         - f_out (function) handler for hover out
         - icontext (object) #optional context for hover in handler
         - ocontext (object) #optional context for hover out handler
         = (object) @Element
        \*/
        elproto.hover = function (f_in, f_out, scope_in, scope_out) {
            return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
        };
        /*\
         * Element.unhover
         [ method ]
         **
         * Removes hover event handlers from the element
         - f_in (function) handler for hover in
         - f_out (function) handler for hover out
         = (object) @Element
        \*/
        elproto.unhover = function (f_in, f_out) {
            return this.unmouseover(f_in).unmouseout(f_out);
        };
        var draggable = [];
        // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
        // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
        // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
        // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
        /*\
         * Element.drag
         [ method ]
         **
         * Adds event handlers for an element's drag gesture
         **
         - onmove (function) handler for moving
         - onstart (function) handler for drag start
         - onend (function) handler for drag end
         - mcontext (object) #optional context for moving handler
         - scontext (object) #optional context for drag start handler
         - econtext (object) #optional context for drag end handler
         * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, 
         * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element 
         * `drag.over.<id>` fires as well.
         *
         * Start event and start handler are called in specified context or in context of the element with following parameters:
         o x (number) x position of the mouse
         o y (number) y position of the mouse
         o event (object) DOM event object
         * Move event and move handler are called in specified context or in context of the element with following parameters:
         o dx (number) shift by x from the start point
         o dy (number) shift by y from the start point
         o x (number) x position of the mouse
         o y (number) y position of the mouse
         o event (object) DOM event object
         * End event and end handler are called in specified context or in context of the element with following parameters:
         o event (object) DOM event object
         = (object) @Element
        \*/
        elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
            var el = this;
            if (!arguments.length) {
                var origTransform;
                return el.drag(function (dx, dy) {
                    this.attr({
                        transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
                    });
                }, function () {
                    origTransform = this.transform().local;
                });
            }
            function start(e, x, y) {
                (e.originalEvent || e).preventDefault();
                el._drag.x = x;
                el._drag.y = y;
                el._drag.id = e.identifier;
                !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
                drag.push({ el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope });
                onstart && eve.on("snap.drag.start." + el.id, onstart);
                onmove && eve.on("snap.drag.move." + el.id, onmove);
                onend && eve.on("snap.drag.end." + el.id, onend);
                eve("snap.drag.start." + el.id, start_scope || move_scope || el, x, y, e);
            }
            function init(e, x, y) {
                eve("snap.draginit." + el.id, el, e, x, y);
            }
            eve.on("snap.draginit." + el.id, start);
            el._drag = {};
            draggable.push({ el: el, start: start, init: init });
            el.mousedown(init);
            return el;
        };
        /*
         * Element.onDragOver
         [ method ]
         **
         * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
         - f (function) handler for event, first argument would be the element you are dragging over
        \*/
        // elproto.onDragOver = function (f) {
        //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
        // };
        /*\
         * Element.undrag
         [ method ]
         **
         * Removes all drag event handlers from the given element
        \*/
        elproto.undrag = function () {
            var i = draggable.length;
            while (i--) {
                if (draggable[i].el == this) {
                    this.unmousedown(draggable[i].init);
                    draggable.splice(i, 1);
                    eve.unbind("snap.drag.*." + this.id);
                    eve.unbind("snap.draginit." + this.id);
                }
            }!draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
            return this;
        };
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob) {
        var elproto = Element.prototype,
            pproto = Paper.prototype,
            rgurl = /^\s*url\((.+)\)/,
            Str = String,
            $ = Snap._.$;
        Snap.filter = {};
        /*\
         * Paper.filter
         [ method ]
         **
         * Creates a `<filter>` element
         **
         - filstr (string) SVG fragment of filter provided as a string
         = (object) @Element
         * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
         > Usage
         | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
         |     c = paper.circle(10, 10, 10).attr({
         |         filter: f
         |     });
        \*/
        pproto.filter = function (filstr) {
            var paper = this;
            if (paper.type != "svg") {
                paper = paper.paper;
            }
            var f = Snap.parse(Str(filstr)),
                id = Snap._.id(),
                width = paper.node.offsetWidth,
                height = paper.node.offsetHeight,
                filter = $("filter");
            $(filter, {
                id: id,
                filterUnits: "userSpaceOnUse"
            });
            filter.appendChild(f.node);
            paper.defs.appendChild(filter);
            return new Element(filter);
        };

        eve.on("snap.util.getattr.filter", function () {
            eve.stop();
            var p = $(this.node, "filter");
            if (p) {
                var match = Str(p).match(rgurl);
                return match && Snap.select(match[1]);
            }
        });
        eve.on("snap.util.attr.filter", function (value) {
            if (value instanceof Element && value.type == "filter") {
                eve.stop();
                var id = value.node.id;
                if (!id) {
                    $(value.node, { id: value.id });
                    id = value.id;
                }
                $(this.node, {
                    filter: Snap.url(id)
                });
            }
            if (!value || value == "none") {
                eve.stop();
                this.node.removeAttribute("filter");
            }
        });
        /*\
         * Snap.filter.blur
         [ method ]
         **
         * Returns an SVG markup string for the blur filter
         **
         - x (number) amount of horizontal blur, in pixels
         - y (number) #optional amount of vertical blur, in pixels
         = (string) filter representation
         > Usage
         | var f = paper.filter(Snap.filter.blur(5, 10)),
         |     c = paper.circle(10, 10, 10).attr({
         |         filter: f
         |     });
        \*/
        Snap.filter.blur = function (x, y) {
            if (x == null) {
                x = 2;
            }
            var def = y == null ? x : [x, y];
            return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
                def: def
            });
        };
        Snap.filter.blur.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.shadow
         [ method ]
         **
         * Returns an SVG markup string for the shadow filter
         **
         - dx (number) #optional horizontal shift of the shadow, in pixels
         - dy (number) #optional vertical shift of the shadow, in pixels
         - blur (number) #optional amount of blur
         - color (string) #optional color of the shadow
         - opacity (number) #optional `0..1` opacity of the shadow
         * or
         - dx (number) #optional horizontal shift of the shadow, in pixels
         - dy (number) #optional vertical shift of the shadow, in pixels
         - color (string) #optional color of the shadow
         - opacity (number) #optional `0..1` opacity of the shadow
         * which makes blur default to `4`. Or
         - dx (number) #optional horizontal shift of the shadow, in pixels
         - dy (number) #optional vertical shift of the shadow, in pixels
         - opacity (number) #optional `0..1` opacity of the shadow
         = (string) filter representation
         > Usage
         | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),
         |     c = paper.circle(10, 10, 10).attr({
         |         filter: f
         |     });
        \*/
        Snap.filter.shadow = function (dx, dy, blur, color, opacity) {
            if (typeof blur == "string") {
                color = blur;
                opacity = color;
                blur = 4;
            }
            if (typeof color != "string") {
                opacity = color;
                color = "#000";
            }
            color = color || "#000";
            if (blur == null) {
                blur = 4;
            }
            if (opacity == null) {
                opacity = 1;
            }
            if (dx == null) {
                dx = 0;
                dy = 2;
            }
            if (dy == null) {
                dy = dx;
            }
            color = Snap.color(color);
            return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
                color: color,
                dx: dx,
                dy: dy,
                blur: blur,
                opacity: opacity
            });
        };
        Snap.filter.shadow.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.grayscale
         [ method ]
         **
         * Returns an SVG markup string for the grayscale filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.grayscale = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
                a: 0.2126 + 0.7874 * (1 - amount),
                b: 0.7152 - 0.7152 * (1 - amount),
                c: 0.0722 - 0.0722 * (1 - amount),
                d: 0.2126 - 0.2126 * (1 - amount),
                e: 0.7152 + 0.2848 * (1 - amount),
                f: 0.0722 - 0.0722 * (1 - amount),
                g: 0.2126 - 0.2126 * (1 - amount),
                h: 0.0722 + 0.9278 * (1 - amount)
            });
        };
        Snap.filter.grayscale.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.sepia
         [ method ]
         **
         * Returns an SVG markup string for the sepia filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.sepia = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
                a: 0.393 + 0.607 * (1 - amount),
                b: 0.769 - 0.769 * (1 - amount),
                c: 0.189 - 0.189 * (1 - amount),
                d: 0.349 - 0.349 * (1 - amount),
                e: 0.686 + 0.314 * (1 - amount),
                f: 0.168 - 0.168 * (1 - amount),
                g: 0.272 - 0.272 * (1 - amount),
                h: 0.534 - 0.534 * (1 - amount),
                i: 0.131 + 0.869 * (1 - amount)
            });
        };
        Snap.filter.sepia.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.saturate
         [ method ]
         **
         * Returns an SVG markup string for the saturate filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.saturate = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
                amount: 1 - amount
            });
        };
        Snap.filter.saturate.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.hueRotate
         [ method ]
         **
         * Returns an SVG markup string for the hue-rotate filter
         **
         - angle (number) angle of rotation
         = (string) filter representation
        \*/
        Snap.filter.hueRotate = function (angle) {
            angle = angle || 0;
            return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
                angle: angle
            });
        };
        Snap.filter.hueRotate.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.invert
         [ method ]
         **
         * Returns an SVG markup string for the invert filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.invert = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            //        <feColorMatrix type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0" color-interpolation-filters="sRGB"/>
            return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
                amount: amount,
                amount2: 1 - amount
            });
        };
        Snap.filter.invert.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.brightness
         [ method ]
         **
         * Returns an SVG markup string for the brightness filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.brightness = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
                amount: amount
            });
        };
        Snap.filter.brightness.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.contrast
         [ method ]
         **
         * Returns an SVG markup string for the contrast filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.contrast = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
                amount: amount,
                amount2: .5 - amount / 2
            });
        };
        Snap.filter.contrast.toString = function () {
            return this();
        };
    });

    // Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    // http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var box = Snap._.box,
            is = Snap.is,
            firstLetter = /^[^a-z]*([tbmlrc])/i,
            toString = function () {
            return "T" + this.dx + "," + this.dy;
        };
        /*\
         * Element.getAlign
         [ method ]
         **
         * Returns shift needed to align the element relatively to given element.
         * If no elements specified, parent `<svg>` container will be used.
         - el (object) @optional alignment element
         - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
         = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string
         > Usage
         | el.transform(el.getAlign(el2, "top"));
         * or
         | var dy = el.getAlign(el2, "top").dy;
        \*/
        Element.prototype.getAlign = function (el, way) {
            if (way == null && is(el, "string")) {
                way = el;
                el = null;
            }
            el = el || this.paper;
            var bx = el.getBBox ? el.getBBox() : box(el),
                bb = this.getBBox(),
                out = {};
            way = way && way.match(firstLetter);
            way = way ? way[1].toLowerCase() : "c";
            switch (way) {
                case "t":
                    out.dx = 0;
                    out.dy = bx.y - bb.y;
                    break;
                case "b":
                    out.dx = 0;
                    out.dy = bx.y2 - bb.y2;
                    break;
                case "m":
                    out.dx = 0;
                    out.dy = bx.cy - bb.cy;
                    break;
                case "l":
                    out.dx = bx.x - bb.x;
                    out.dy = 0;
                    break;
                case "r":
                    out.dx = bx.x2 - bb.x2;
                    out.dy = 0;
                    break;
                default:
                    out.dx = bx.cx - bb.cx;
                    out.dy = 0;
                    break;
            }
            out.toString = toString;
            return out;
        };
        /*\
         * Element.align
         [ method ]
         **
         * Aligns the element relatively to given one via transformation.
         * If no elements specified, parent `<svg>` container will be used.
         - el (object) @optional alignment element
         - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
         = (object) this element
         > Usage
         | el.align(el2, "top");
         * or
         | el.align("middle");
        \*/
        Element.prototype.align = function (el, way) {
            return this.transform("..." + this.getAlign(el, way));
        };
    });

    return Snap;
});
;'use strict';

/////    /////    /////    /////
/////    /////    /////    /////
/////    /////    /////    /////
/////    /////    /////    /////
/////             /////    /////
/////             /////    /////
/////    /////    /////    /////
/////    /////    /////    /////
/////    /////
/////    /////
/////    /////    /////    /////
/////    /////    /////    /////
/////    /////    /////    /////
/////    /////    /////    /////

/**
 * ScrollReveal
 * ------------
 * Version : 3.3.1
 * Website : scrollrevealjs.org
 * Repo    : github.com/jlmakes/scrollreveal.js
 * Author  : Julian Lloyd (@jlmakes)
 */

;(function () {
  'use strict';

  var sr;
  var _requestAnimationFrame;

  function ScrollReveal(config) {
    // Support instantiation without the `new` keyword.
    if (typeof this === 'undefined' || Object.getPrototypeOf(this) !== ScrollReveal.prototype) {
      return new ScrollReveal(config);
    }

    sr = this; // Save reference to instance.
    sr.version = '3.3.1';
    sr.tools = new Tools(); // *required utilities

    if (sr.isSupported()) {
      sr.tools.extend(sr.defaults, config || {});

      _resolveContainer(sr.defaults);

      sr.store = {
        elements: {},
        containers: []
      };

      sr.sequences = {};
      sr.history = [];
      sr.uid = 0;
      sr.initialized = false;
    } else if (typeof console !== 'undefined' && console !== null) {
      // Note: IE9 only supports console if devtools are open.
      console.log('ScrollReveal is not supported in this browser.');
    }

    return sr;
  }

  /**
   * Configuration
   * -------------
   * This object signature can be passed directly to the ScrollReveal constructor,
   * or as the second argument of the `reveal()` method.
   */

  ScrollReveal.prototype.defaults = {
    // 'bottom', 'left', 'top', 'right'
    origin: 'bottom',

    // Can be any valid CSS distance, e.g. '5rem', '10%', '20vw', etc.
    distance: '20px',

    // Time in milliseconds.
    duration: 500,
    delay: 0,

    // Starting angles in degrees, will transition from these values to 0 in all axes.
    rotate: { x: 0, y: 0, z: 0 },

    // Starting opacity value, before transitioning to the computed opacity.
    opacity: 0,

    // Starting scale value, will transition from this value to 1
    scale: 0.9,

    // Accepts any valid CSS easing, e.g. 'ease', 'ease-in-out', 'linear', etc.
    easing: 'cubic-bezier(0.6, 0.2, 0.1, 1)',

    // `<html>` is the default reveal container. You can pass either:
    // DOM Node, e.g. document.querySelector('.fooContainer')
    // Selector, e.g. '.fooContainer'
    container: window.document.documentElement,

    // true/false to control reveal animations on mobile.
    mobile: true,

    // true:  reveals occur every time elements become visible
    // false: reveals occur once as elements become visible
    reset: false,

    // 'always' — delay for all reveal animations
    // 'once'   — delay only the first time reveals occur
    // 'onload' - delay only for animations triggered by first load
    useDelay: 'always',

    // Change when an element is considered in the viewport. The default value
    // of 0.20 means 20% of an element must be visible for its reveal to occur.
    viewFactor: 0.2,

    // Pixel values that alter the container boundaries.
    // e.g. Set `{ top: 48 }`, if you have a 48px tall fixed toolbar.
    // --
    // Visual Aid: https://scrollrevealjs.org/assets/viewoffset.png
    viewOffset: { top: 0, right: 0, bottom: 0, left: 0 },

    // Callbacks that fire for each completed element reveal, and if
    // `config.reset = true`, for each completed element reset. When creating your
    // callbacks, remember they are passed the element’s DOM node that triggered
    // it as the first argument.
    beforeReveal: function (domEl) {},
    afterReveal: function (domEl) {},
    beforeReset: function (domEl) {},
    afterReset: function (domEl) {}
  };

  /**
   * Check if client supports CSS Transform and CSS Transition.
   * @return {boolean}
   */
  ScrollReveal.prototype.isSupported = function () {
    var style = document.documentElement.style;
    return 'WebkitTransition' in style && 'WebkitTransform' in style || 'transition' in style && 'transform' in style;
  };

  /**
   * Creates a reveal set, a group of elements that will animate when they
   * become visible. If [interval] is provided, a new sequence is created
   * that will ensure elements reveal in the order they appear in the DOM.
   *
   * @param {Node|NodeList|string} [target]   The node, node list or selector to use for animation.
   * @param {Object}               [config]   Override the defaults for this reveal set.
   * @param {number}               [interval] Time between sequenced element animations (milliseconds).
   * @param {boolean}              [sync]     Used internally when updating reveals for async content.
   *
   * @return {Object} The current ScrollReveal instance.
   */
  ScrollReveal.prototype.reveal = function (target, config, interval, sync) {
    var container;
    var elements;
    var elem;
    var elemId;
    var sequence;
    var sequenceId;

    // No custom configuration was passed, but a sequence interval instead.
    // let’s shuffle things around to make sure everything works.
    if (config !== undefined && typeof config === 'number') {
      interval = config;
      config = {};
    } else if (config === undefined || config === null) {
      config = {};
    }

    container = _resolveContainer(config);
    elements = _getRevealElements(target, container);

    if (!elements.length) {
      console.log('ScrollReveal: reveal on "' + target + '" failed, no elements found.');
      return sr;
    }

    // Prepare a new sequence if an interval is passed.
    if (interval && typeof interval === 'number') {
      sequenceId = _nextUid();

      sequence = sr.sequences[sequenceId] = {
        id: sequenceId,
        interval: interval,
        elemIds: [],
        active: false
      };
    }

    // Begin main loop to configure ScrollReveal elements.
    for (var i = 0; i < elements.length; i++) {
      // Check if the element has already been configured and grab it from the store.
      elemId = elements[i].getAttribute('data-sr-id');
      if (elemId) {
        elem = sr.store.elements[elemId];
      } else {
        // Otherwise, let’s do some basic setup.
        elem = {
          id: _nextUid(),
          domEl: elements[i],
          seen: false,
          revealing: false
        };
        elem.domEl.setAttribute('data-sr-id', elem.id);
      }

      // Sequence only setup
      if (sequence) {
        elem.sequence = {
          id: sequence.id,
          index: sequence.elemIds.length
        };

        sequence.elemIds.push(elem.id);
      }

      // New or existing element, it’s time to update its configuration, styles,
      // and send the updates to our store.
      _configure(elem, config, container);
      _style(elem);
      _updateStore(elem);

      // We need to make sure elements are set to visibility: visible, even when
      // on mobile and `config.mobile === false`, or if unsupported.
      if (sr.tools.isMobile() && !elem.config.mobile || !sr.isSupported()) {
        elem.domEl.setAttribute('style', elem.styles.inline);
        elem.disabled = true;
      } else if (!elem.revealing) {
        // Otherwise, proceed normally.
        elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.initial);
      }
    }

    // Each `reveal()` is recorded so that when calling `sync()` while working
    // with asynchronously loaded content, it can re-trace your steps but with
    // all your new elements now in the DOM.

    // Since `reveal()` is called internally by `sync()`, we don’t want to
    // record or intiialize each reveal during syncing.
    if (!sync && sr.isSupported()) {
      _record(target, config, interval);

      // We push initialization to the event queue using setTimeout, so that we can
      // give ScrollReveal room to process all reveal calls before putting things into motion.
      // --
      // Philip Roberts - What the heck is the event loop anyway? (JSConf EU 2014)
      // https://www.youtube.com/watch?v=8aGhZQkoFbQ
      if (sr.initTimeout) {
        window.clearTimeout(sr.initTimeout);
      }
      sr.initTimeout = window.setTimeout(_init, 0);
    }

    return sr;
  };

  /**
   * Re-runs `reveal()` for each record stored in history, effectively capturing
   * any content loaded asynchronously that matches existing reveal set targets.
   * @return {Object} The current ScrollReveal instance.
   */
  ScrollReveal.prototype.sync = function () {
    if (sr.history.length && sr.isSupported()) {
      for (var i = 0; i < sr.history.length; i++) {
        var record = sr.history[i];
        sr.reveal(record.target, record.config, record.interval, true);
      }
      _init();
    } else {
      console.log('ScrollReveal: sync failed, no reveals found.');
    }
    return sr;
  };

  /**
   * Private Methods
   * ---------------
   */

  function _resolveContainer(config) {
    if (config && config.container) {
      if (typeof config.container === 'string') {
        return window.document.documentElement.querySelector(config.container);
      } else if (sr.tools.isNode(config.container)) {
        return config.container;
      } else {
        console.log('ScrollReveal: invalid container "' + config.container + '" provided.');
        console.log('ScrollReveal: falling back to default container.');
      }
    }
    return sr.defaults.container;
  }

  /**
   * check to see if a node or node list was passed in as the target,
   * otherwise query the container using target as a selector.
   *
   * @param {Node|NodeList|string} [target]    client input for reveal target.
   * @param {Node}                 [container] parent element for selector queries.
   *
   * @return {array} elements to be revealed.
   */
  function _getRevealElements(target, container) {
    if (typeof target === 'string') {
      return Array.prototype.slice.call(container.querySelectorAll(target));
    } else if (sr.tools.isNode(target)) {
      return [target];
    } else if (sr.tools.isNodeList(target)) {
      return Array.prototype.slice.call(target);
    }
    return [];
  }

  /**
   * A consistent way of creating unique IDs.
   * @returns {number}
   */
  function _nextUid() {
    return ++sr.uid;
  }

  function _configure(elem, config, container) {
    // If a container was passed as a part of the config object,
    // let’s overwrite it with the resolved container passed in.
    if (config.container) config.container = container;
    // If the element hasn’t already been configured, let’s use a clone of the
    // defaults extended by the configuration passed as the second argument.
    if (!elem.config) {
      elem.config = sr.tools.extendClone(sr.defaults, config);
    } else {
      // Otherwise, let’s use a clone of the existing element configuration extended
      // by the configuration passed as the second argument.
      elem.config = sr.tools.extendClone(elem.config, config);
    }

    // Infer CSS Transform axis from origin string.
    if (elem.config.origin === 'top' || elem.config.origin === 'bottom') {
      elem.config.axis = 'Y';
    } else {
      elem.config.axis = 'X';
    }
  }

  function _style(elem) {
    var computed = window.getComputedStyle(elem.domEl);

    if (!elem.styles) {
      elem.styles = {
        transition: {},
        transform: {},
        computed: {}
      };

      // Capture any existing inline styles, and add our visibility override.
      // --
      // See section 4.2. in the Documentation:
      // https://github.com/jlmakes/scrollreveal.js#42-improve-user-experience
      elem.styles.inline = elem.domEl.getAttribute('style') || '';
      elem.styles.inline += '; visibility: visible; ';

      // grab the elements existing opacity.
      elem.styles.computed.opacity = computed.opacity;

      // grab the elements existing transitions.
      if (!computed.transition || computed.transition === 'all 0s ease 0s') {
        elem.styles.computed.transition = '';
      } else {
        elem.styles.computed.transition = computed.transition + ', ';
      }
    }

    // Create transition styles
    elem.styles.transition.instant = _generateTransition(elem, 0);
    elem.styles.transition.delayed = _generateTransition(elem, elem.config.delay);

    // Generate transform styles, first with the webkit prefix.
    elem.styles.transform.initial = ' -webkit-transform:';
    elem.styles.transform.target = ' -webkit-transform:';
    _generateTransform(elem);

    // And again without any prefix.
    elem.styles.transform.initial += 'transform:';
    elem.styles.transform.target += 'transform:';
    _generateTransform(elem);
  }

  function _generateTransition(elem, delay) {
    var config = elem.config;

    return '-webkit-transition: ' + elem.styles.computed.transition + '-webkit-transform ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's, opacity ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's; ' + 'transition: ' + elem.styles.computed.transition + 'transform ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's, opacity ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's; ';
  }

  function _generateTransform(elem) {
    var config = elem.config;
    var cssDistance;
    var transform = elem.styles.transform;

    // Let’s make sure our our pixel distances are negative for top and left.
    // e.g. origin = 'top' and distance = '25px' starts at `top: -25px` in CSS.
    if (config.origin === 'top' || config.origin === 'left') {
      cssDistance = /^-/.test(config.distance) ? config.distance.substr(1) : '-' + config.distance;
    } else {
      cssDistance = config.distance;
    }

    if (parseInt(config.distance)) {
      transform.initial += ' translate' + config.axis + '(' + cssDistance + ')';
      transform.target += ' translate' + config.axis + '(0)';
    }
    if (config.scale) {
      transform.initial += ' scale(' + config.scale + ')';
      transform.target += ' scale(1)';
    }
    if (config.rotate.x) {
      transform.initial += ' rotateX(' + config.rotate.x + 'deg)';
      transform.target += ' rotateX(0)';
    }
    if (config.rotate.y) {
      transform.initial += ' rotateY(' + config.rotate.y + 'deg)';
      transform.target += ' rotateY(0)';
    }
    if (config.rotate.z) {
      transform.initial += ' rotateZ(' + config.rotate.z + 'deg)';
      transform.target += ' rotateZ(0)';
    }
    transform.initial += '; opacity: ' + config.opacity + ';';
    transform.target += '; opacity: ' + elem.styles.computed.opacity + ';';
  }

  function _updateStore(elem) {
    var container = elem.config.container;

    // If this element’s container isn’t already in the store, let’s add it.
    if (container && sr.store.containers.indexOf(container) === -1) {
      sr.store.containers.push(elem.config.container);
    }

    // Update the element stored with our new element.
    sr.store.elements[elem.id] = elem;
  }

  function _record(target, config, interval) {
    // Save the `reveal()` arguments that triggered this `_record()` call, so we
    // can re-trace our steps when calling the `sync()` method.
    var record = {
      target: target,
      config: config,
      interval: interval
    };
    sr.history.push(record);
  }

  function _init() {
    if (sr.isSupported()) {
      // Initial animate call triggers valid reveal animations on first load.
      // Subsequent animate calls are made inside the event handler.
      _animate();

      // Then we loop through all container nodes in the store and bind event
      // listeners to each.
      for (var i = 0; i < sr.store.containers.length; i++) {
        sr.store.containers[i].addEventListener('scroll', _handler);
        sr.store.containers[i].addEventListener('resize', _handler);
      }

      // Let’s also do a one-time binding of window event listeners.
      if (!sr.initialized) {
        window.addEventListener('scroll', _handler);
        window.addEventListener('resize', _handler);
        sr.initialized = true;
      }
    }
    return sr;
  }

  function _handler() {
    _requestAnimationFrame(_animate);
  }

  function _setActiveSequences() {
    var active;
    var elem;
    var elemId;
    var sequence;

    // Loop through all sequences
    sr.tools.forOwn(sr.sequences, function (sequenceId) {
      sequence = sr.sequences[sequenceId];
      active = false;

      // For each sequenced elemenet, let’s check visibility and if
      // any are visible, set it’s sequence to active.
      for (var i = 0; i < sequence.elemIds.length; i++) {
        elemId = sequence.elemIds[i];
        elem = sr.store.elements[elemId];
        if (_isElemVisible(elem) && !active) {
          active = true;
        }
      }

      sequence.active = active;
    });
  }

  function _animate() {
    var delayed;
    var elem;

    _setActiveSequences();

    // Loop through all elements in the store
    sr.tools.forOwn(sr.store.elements, function (elemId) {
      elem = sr.store.elements[elemId];
      delayed = _shouldUseDelay(elem);

      // Let’s see if we should revealand if so,
      // trigger the `beforeReveal` callback and
      // determine whether or not to use delay.
      if (_shouldReveal(elem)) {
        elem.config.beforeReveal(elem.domEl);
        if (delayed) {
          elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.target + elem.styles.transition.delayed);
        } else {
          elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.target + elem.styles.transition.instant);
        }

        // Let’s queue the `afterReveal` callback
        // and mark the element as seen and revealing.
        _queueCallback('reveal', elem, delayed);
        elem.revealing = true;
        elem.seen = true;

        if (elem.sequence) {
          _queueNextInSequence(elem, delayed);
        }
      } else if (_shouldReset(elem)) {
        //Otherwise reset our element and
        // trigger the `beforeReset` callback.
        elem.config.beforeReset(elem.domEl);
        elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.initial + elem.styles.transition.instant);
        // And queue the `afterReset` callback.
        _queueCallback('reset', elem);
        elem.revealing = false;
      }
    });
  }

  function _queueNextInSequence(elem, delayed) {
    var elapsed = 0;
    var delay = 0;
    var sequence = sr.sequences[elem.sequence.id];

    // We’re processing a sequenced element, so let's block other elements in this sequence.
    sequence.blocked = true;

    // Since we’re triggering animations a part of a sequence after animations on first load,
    // we need to check for that condition and explicitly add the delay to our timer.
    if (delayed && elem.config.useDelay === 'onload') {
      delay = elem.config.delay;
    }

    // If a sequence timer is already running, capture the elapsed time and clear it.
    if (elem.sequence.timer) {
      elapsed = Math.abs(elem.sequence.timer.started - new Date());
      window.clearTimeout(elem.sequence.timer);
    }

    // Start a new timer.
    elem.sequence.timer = { started: new Date() };
    elem.sequence.timer.clock = window.setTimeout(function () {
      // Sequence interval has passed, so unblock the sequence and re-run the handler.
      sequence.blocked = false;
      elem.sequence.timer = null;
      _handler();
    }, Math.abs(sequence.interval) + delay - elapsed);
  }

  function _queueCallback(type, elem, delayed) {
    var elapsed = 0;
    var duration = 0;
    var callback = 'after';

    // Check which callback we’re working with.
    switch (type) {
      case 'reveal':
        duration = elem.config.duration;
        if (delayed) {
          duration += elem.config.delay;
        }
        callback += 'Reveal';
        break;

      case 'reset':
        duration = elem.config.duration;
        callback += 'Reset';
        break;
    }

    // If a timer is already running, capture the elapsed time and clear it.
    if (elem.timer) {
      elapsed = Math.abs(elem.timer.started - new Date());
      window.clearTimeout(elem.timer.clock);
    }

    // Start a new timer.
    elem.timer = { started: new Date() };
    elem.timer.clock = window.setTimeout(function () {
      // The timer completed, so let’s fire the callback and null the timer.
      elem.config[callback](elem.domEl);
      elem.timer = null;
    }, duration - elapsed);
  }

  function _shouldReveal(elem) {
    if (elem.sequence) {
      var sequence = sr.sequences[elem.sequence.id];
      return sequence.active && !sequence.blocked && !elem.revealing && !elem.disabled;
    }
    return _isElemVisible(elem) && !elem.revealing && !elem.disabled;
  }

  function _shouldUseDelay(elem) {
    var config = elem.config.useDelay;
    return config === 'always' || config === 'onload' && !sr.initialized || config === 'once' && !elem.seen;
  }

  function _shouldReset(elem) {
    if (elem.sequence) {
      var sequence = sr.sequences[elem.sequence.id];
      return !sequence.active && elem.config.reset && elem.revealing && !elem.disabled;
    }
    return !_isElemVisible(elem) && elem.config.reset && elem.revealing && !elem.disabled;
  }

  function _getContainer(container) {
    return {
      width: container.clientWidth,
      height: container.clientHeight
    };
  }

  function _getScrolled(container) {
    // Return the container scroll values, plus the its offset.
    if (container && container !== window.document.documentElement) {
      var offset = _getOffset(container);
      return {
        x: container.scrollLeft + offset.left,
        y: container.scrollTop + offset.top
      };
    } else {
      // Otherwise, default to the window object’s scroll values.
      return {
        x: window.pageXOffset,
        y: window.pageYOffset
      };
    }
  }

  function _getOffset(domEl) {
    var offsetTop = 0;
    var offsetLeft = 0;

    // Grab the element’s dimensions.
    var offsetHeight = domEl.offsetHeight;
    var offsetWidth = domEl.offsetWidth;

    // Now calculate the distance between the element and its parent, then
    // again for the parent to its parent, and again etc... until we have the
    // total distance of the element to the document’s top and left origin.
    do {
      if (!isNaN(domEl.offsetTop)) {
        offsetTop += domEl.offsetTop;
      }
      if (!isNaN(domEl.offsetLeft)) {
        offsetLeft += domEl.offsetLeft;
      }
      domEl = domEl.offsetParent;
    } while (domEl);

    return {
      top: offsetTop,
      left: offsetLeft,
      height: offsetHeight,
      width: offsetWidth
    };
  }

  function _isElemVisible(elem) {
    var offset = _getOffset(elem.domEl);
    var container = _getContainer(elem.config.container);
    var scrolled = _getScrolled(elem.config.container);
    var vF = elem.config.viewFactor;

    // Define the element geometry.
    var elemHeight = offset.height;
    var elemWidth = offset.width;
    var elemTop = offset.top;
    var elemLeft = offset.left;
    var elemBottom = elemTop + elemHeight;
    var elemRight = elemLeft + elemWidth;

    return confirmBounds() || isPositionFixed();

    function confirmBounds() {
      // Define the element’s functional boundaries using its view factor.
      var top = elemTop + elemHeight * vF;
      var left = elemLeft + elemWidth * vF;
      var bottom = elemBottom - elemHeight * vF;
      var right = elemRight - elemWidth * vF;

      // Define the container functional boundaries using its view offset.
      var viewTop = scrolled.y + elem.config.viewOffset.top;
      var viewLeft = scrolled.x + elem.config.viewOffset.left;
      var viewBottom = scrolled.y - elem.config.viewOffset.bottom + container.height;
      var viewRight = scrolled.x - elem.config.viewOffset.right + container.width;

      return top < viewBottom && bottom > viewTop && left > viewLeft && right < viewRight;
    }

    function isPositionFixed() {
      return window.getComputedStyle(elem.domEl).position === 'fixed';
    }
  }

  /**
   * Utilities
   * ---------
   */

  function Tools() {}

  Tools.prototype.isObject = function (object) {
    return object !== null && typeof object === 'object' && object.constructor === Object;
  };

  Tools.prototype.isNode = function (object) {
    return typeof window.Node === 'object' ? object instanceof window.Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
  };

  Tools.prototype.isNodeList = function (object) {
    var prototypeToString = Object.prototype.toString.call(object);
    var regex = /^\[object (HTMLCollection|NodeList|Object)\]$/;

    return typeof window.NodeList === 'object' ? object instanceof window.NodeList : object && typeof object === 'object' && regex.test(prototypeToString) && typeof object.length === 'number' && (object.length === 0 || this.isNode(object[0]));
  };

  Tools.prototype.forOwn = function (object, callback) {
    if (!this.isObject(object)) {
      throw new TypeError('Expected "object", but received "' + typeof object + '".');
    } else {
      for (var property in object) {
        if (object.hasOwnProperty(property)) {
          callback(property);
        }
      }
    }
  };

  Tools.prototype.extend = function (target, source) {
    this.forOwn(source, function (property) {
      if (this.isObject(source[property])) {
        if (!target[property] || !this.isObject(target[property])) {
          target[property] = {};
        }
        this.extend(target[property], source[property]);
      } else {
        target[property] = source[property];
      }
    }.bind(this));
    return target;
  };

  Tools.prototype.extendClone = function (target, source) {
    return this.extend(this.extend({}, target), source);
  };

  Tools.prototype.isMobile = function () {
    return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    );
  };

  /**
   * Polyfills
   * --------
   */

  _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };

  /**
   * Module Wrapper
   * --------------
   */
  if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
    define(function () {
      return ScrollReveal;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = ScrollReveal;
  } else {
    window.ScrollReveal = ScrollReveal;
  }
})();
;'use strict';

var BR = {
	addListeners: function () {
		// $('a.link').hover( 
		// 	function(){
		// 		var redHover = $(this).find('span');
		// 		$(redHover).animate({"marginBottom":"10px"}, 300);
		// 		$(redHover).animate({"opacity":"1"}, 300);

		// 	},
		// 	function(){
		// 		var redHover = $(this).find('span');
		// 		$(redHover).animate({"marginBottom":"0"}, 300);
		// 		$(redHover).animate({"opacity":"0"}, 300);
		// 	}
		// )
		$('.close__modal').click(function (event) {
			$(this).closest('.modal__background').fadeOut('300').addClass('hidden');
		});
		$('.accordion__trigger').click(function (e) {
			var triggerId = $(this).data('trigger-target');
			var accordion = $('#' + triggerId);
			$(accordion).slideToggle(400);
			// $(accordion).slideToggle(300, function(){
			// 	$(this).toggleClass('hidden');
			// })
		});

		$('#diversityModalTrigger').click(function (event) {
			BR_COOKIES.visitDiversity();
			BR_COOKIES.showDiversityModal();
		});
	}
};

$(function () {
	BR.addListeners();
});
;"use strict";

var BR_COOKIES = {
  onLoad: function () {
    console.log("BR Cookie Scripts loaded!");
  },
  createCookie: function (name, value, days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
      var expires = "; expires=" + date.toGMTString();
    } else var expires = "";

    document.cookie = name + "=" + value + expires + "; path=/";
  },
  readCookie: function (name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') {
        c = c.substring(1, c.length);
      }if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },

  eraseCookie: function (name) {
    BR_COOKIES.createCookie(name, "", -1);
  },
  visitDiversity: function () {
    BR_COOKIES.createCookie("visitedDiversity", "true");
    var visitedDiversity = BR_COOKIES.readCookie("visitedDiversity");
    console.log(visitedDiversity);
  },
  showDiversityModal: function () {
    console.log("Showing EOE Modal!");
    var diversityModal = $('.modal__background.diversity');
    diversityModal.removeClass('hidden').fadeIn('slow');
  }
};

$(document).ready(function () {
  BR_COOKIES.onLoad();
});
;'use strict';

var EXPANDER = {
	addListeners: function () {
		$('#showMoreRelatedExperiences, .experience_expander').click(function (event) {
			$(document.body).trigger("sticky_kit:recalc");
			var hiddenExperiences = $('.sidebar__color-block--outer-wrapper.hidden__exp');
			$(hiddenExperiences).toggleClass('hidden');
			var hiddenMenuItems = $('.sidebar-items__wrapper');
			$(hiddenMenuItems).slideToggle('300');
			var expander = $('.experience_expander');
			$(expander).toggleClass('expanded');
			if ($('#showMoreRelatedExperiences').hasClass('more')) {
				$('#showMoreRelatedExperiences').removeClass('more').addClass('less').text("SHOW LESS");
			} else {
				$('#showMoreRelatedExperiences').removeClass('less').addClass('more').text("SHOW MORE");
			}
		});
		$('.job_expander').click(function (event) {
			var expander = $(this);
			var hiddenJobDescripton = $(expander).parent().parent().next('tr').find('td');
			$(hiddenJobDescripton).slideToggle('fast');
			$(expander).toggleClass('expanded');
		});
	}
};

$(document).ready(function () {
	EXPANDER.addListeners();
});
;'use strict';

jQuery('iframe[src*="youtube.com"]').wrap("<div class='flex-video widescreen'/>");
jQuery('iframe[src*="vimeo.com"]').wrap("<div class='flex-video widescreen vimeo'/>");
;"use strict";

$(document).ready(function () {
	if ($("body").hasClass("page-template-homepage")) {
		// animate grid elements on homepage
		window.sr = ScrollReveal({ distance: '10%', duration: 900, delay: 1, reset: true, scale: 0.99, easing: 'linear' });
		sr.reveal('.homepage-grid-element');
	}
});
;"use strict";

jQuery(document).foundation();
;'use strict';

var INSIGHTS = {
	listeners: function () {
		console.log('Insights listeners js loaded');
		$('select.insight').change(function (event) {
			var selects = $('select');
			var queryStringBase = location.origin + location.pathname;
			var queryString = "";
			var filters = [];
			for (var i = selects.length - 1; i >= 0; i--) {
				var select = selects[i];
				if ($(select).val().length > 0 && $(select).val() !== "") {
					filters.push($(select));
				}
			}
			console.log("filters" + filters);
			for (var i = filters.length - 1; i >= 0; i--) {
				var paramName = $(filters[i]).attr('name');
				var paramValue = $(filters[i]).val();
				if (paramValue.length > 0 && i === filters.length - 1) {
					queryString = queryStringBase + "?" + paramName + "=" + paramValue;
					console.log(queryString);
				} else if (paramValue.length > 0) {
					queryString = queryString + "&" + paramName + "=" + paramValue;
					console.log(queryString);
				}
			}
			console.log(queryString);
			window.location.replace(queryString);
		});
	},
	onLoad: function () {
		// Get search param values from url
		var selectedGeography = $.url().param('geography_query', 'strict') || "";
		var selectedIndustry = $.url().param('industry_query', 'strict') || "";
		var selectedPractice = $.url().param('practice_query', 'strict') || "";
		var selectedLanguage = $.url().param('language_query', 'strict') || "";
		var selectedLocations = $.url().param('location_query', 'strict') || "";
		var selectedAdmission = $.url().param('admission_query', 'strict') || "";
		var selectedEducation = $.url().param('education_query', 'strict') || "";
		var selectedKeyword = $.url().param('keyword', 'strict') || "";

		// Set vars for selects for all search params
		var geographySelect = $('select#geographySelect');
		var industrySelect = $('select#industrySelect');
		var practiceSelect = $('select#practiceSelect');
		var languageSelect = $('select#languageSelect');
		var locationSelect = $('select#locationSelect');
		var admissionSelect = $('select#admissionSelect');
		var educationSelect = $('select#educationSelect');
		var keywordInput = $('input#keywordInput');

		// Change value of selects based on url params
		geographySelect.val(decodeURIComponent(selectedGeography));
		industrySelect.val(decodeURIComponent(selectedIndustry));
		practiceSelect.val(decodeURIComponent(selectedPractice));
		languageSelect.val(decodeURIComponent(selectedLanguage));
		locationSelect.val(decodeURIComponent(selectedLocations));
		admissionSelect.val(decodeURIComponent(selectedAdmission));
		educationSelect.val(decodeURIComponent(selectedEducation));
		keywordInput.val(decodeURIComponent(selectedKeyword));
	}
};

$(document).ready(function () {
	INSIGHTS.listeners();
	INSIGHTS.onLoad();
});
;'use strict';

// Joyride demo
$('#start-jr').on('click', function () {
  $(document).foundation('joyride', 'start');
});
;'use strict';

var LOCATIONSEARCHER = {
	detectChange: function () {
		$('#locationSelect').change(function (event) {
			// build query string
			var keyword = $('#locationSelect').val() || "";
			console.log(keyword);
			var queryStringBase = location.origin + location.pathname;
			var queryString = "" + "?job_location_query=" + keyword;
			console.log(queryString);
			window.location.replace(queryString);
		});
	}
};

$('document').ready(function () {
	LOCATIONSEARCHER.detectChange();
});
;'use strict';

// desktop navigation hover interactions

// edited foundation.dropdownMenu.js line 368 to make delay on closing time after mouseout event shorter 
// to restore to default, set this number to '500'

var NAV = {
	listeners: function () {
		// medium breakpoint hover interaction
		if ($(window).innerWidth() > 700) {
			$('.menu-item-has-children').on({
				mouseover: function () {
					$('.subnav__color-block').stop().show(410);
				},
				mouseout: function () {
					$('.subnav__color-block').stop().hide(410);
				}
			});
		}
	},
	desktopMenu: $('#masthead'),
	scrollEvents: function () {
		if ($(window).scrollTop() >= NAV.desktopMenu.height()) {
			$(NAV.desktopMenu).css('opacity', '0');
			$('.subnav__color-block').css({ 'width': '400%' });
			$('.menu__outer-wrapper--desktop-on-scroll').slideDown('300');
		} else {
			$(NAV.desktopMenu).css('opacity', '1');
			$('.menu__outer-wrapper--desktop-on-scroll').slideUp('300');
		}
	}
};

$(document).ready(function () {
	NAV.listeners();
	if ($(document).width() > 640) {
		$(document).scroll(function () {
			NAV.scrollEvents();
		});
	}
	if ($(window).scrollTop() >= NAV.desktopMenu.height() && $(document).width() > 640) {
		$(NAV.desktopMenu).hide();
	}
});

// var navbar = {
// 	onHover: function(){
// 		// medium breakpoint
// 		if ($(window).innerWidth() > 700 ) {
// 				$('.menu-item-has-children').on({
// 					mouseover: function(){
// 						$('.subnav__color-block').stop().show(410);
// 					},
// 					mouseout: function(){
// 						$('.subnav__color-block').stop().hide(410);
// 					}
// 				});	
// 			}
// 		},
// 		desktopMenu: $('#masthead')

// 	}

// $(document).ready(function(){

// 		navbar.onHover();


// 			if ( $(window).scrollTop() >= navbar.desktopMenu.height() ) {
// 				navbar.desktopMenu.hide();
// 				$('.menu__outer-wrapper--desktop-on-scroll').fadeIn();
// 				console.log('nav is hidden')
// 			} else {
// 				navbar.desktopMenu.show();
// 				$('.menu__outer-wrapper--desktop-on-scroll').hide();
// 			}


// 	// if ( $(document).width() > 640) {
// 	// 		$(document).scroll( function(){
// 	// 			navbar.onScroll();
// 	// 		})
// 	// 	}
// 	if ( $(window).scrollTop() >= navbar.desktopMenu.height() && $(document).width() > 640) {
// 		navbar.desktopMenu.hide();
// 	}
// 	// }
// });
;"use strict";
;'use strict';

var PEOPLE = {
	listeners: function () {
		console.log('People js loaded');
		$('.letter__link').click(function (event) {
			var letterlLinkInnerWrappers = $('.letter__link--inner-wrapper');
			var letter = $(this).data('letter');
			var letterAnchor = $("div[data-letter-anchor=" + letter + "]");
			letterlLinkInnerWrappers.removeClass('active');
			var selectedletterlLinkInnerWrapper = $(this).parent();
			selectedletterlLinkInnerWrapper.addClass('active');
			$('html,body').animate({
				scrollTop: letterAnchor.offset().top - 200
			}, 1000);
			console.log("Scrolling to " + letter);
			return false;
		});
		// $(document).resize(function(event) {
		// 	if ( $(document).width() > 640) {
		// 		PEOPLE.scrollEvents();
		// 		$(document).scroll( function(){
		// 			PEOPLE.scrollEvents();
		// 		});
		// 	}
		// });
		$('#advancedPeopleSearch').click(function (event) {
			PEOPLE.revealAdvancedSearch();
		});
		$('#peopleAdvancedSearchButton').click(function (event) {
			event.preventDefault();
			console.log("prevented!");
			var selects = $('select');
			var keyword = $("#keywordInput").val() || "";
			var queryStringBase = location.origin + location.pathname;
			var queryString = "";
			var filters = [];
			// selects values from dropdown options and determines number of filters from these
			for (var i = selects.length - 1; i >= 0; i--) {
				var select = selects[i];
				if ($(select).val().length > 0) {
					filters.push($(select));
				}
			}
			console.log(filters);
			// passes the parameters from each of the selected filters
			for (var i = filters.length - 1; i >= 0; i--) {
				var paramName = $(filters[i]).attr('name');
				var paramValue = $(filters[i]).val();
				if (paramValue.length > 0 && i === filters.length - 1) {
					queryString = queryStringBase + "?" + paramName + "=" + paramValue;
				} else if (paramValue.length > 0) {
					queryString = queryString + "&" + paramName + "=" + paramValue;
				}
			}
			if (queryString.length > 0) {
				if (keyword.length > 0) {
					queryString = queryString + "&keyword=" + keyword;
				}
			} else {
				if (keyword.length > 0) {
					queryString = queryString + "?keyword=" + keyword;
				}
			}
			// debugger;
			window.location.replace(queryString);
		});
	},
	stickySideBar: $('.sidebar__on-scroll--fixed'),
	// scrollEvents: function(){
	// 	var heightAdjustment;
	// 	if ( $('.page-template-people').length > 0 &&  $('.people__details--container').height() > $('.sidebar__on-scroll--fixed').height() ){
	// 		heightAdjustment = 800;
	// 	} else {
	// 		heightAdjustment = 263;
	// 	}
	// 	var scrollStopperOffset = $('#masthead').height() + $('.body__wrapper').height() - heightAdjustment;
	// 	if ( $(window).scrollTop() >= ($('#featuredImage').height()) && $(window).scrollTop() <= scrollStopperOffset ) {
	// 		PEOPLE.stickSideBar('top');
	// 	} else if ( $(window).scrollTop() >= scrollStopperOffset ) {
	// 		PEOPLE.stickSideBar('bottom');
	// 		console.log('bottom sticker');
	// 	} else {
	// 		PEOPLE.unstickSideBar();
	// 	}
	// },
	// stickSideBar: function(location) {
	// 	var sideBarWidth;
	// 	if ( location === 'top' ) {	
	// 		if ( $(window).width() < 1000 ) {
	// 			sideBarWidth = 'calc(75em / 4)';
	// 		} else {
	// 			sideBarWidth = 'calc(75em / 6)';
	// 		}
	// 		PEOPLE.stickySideBar.css({
	// 			position: 'fixed',
	// 			width: sideBarWidth,
	// 			top: '160px'
	// 		});
	// 	} else {
	// 		if ( $(window).width() < 1000 ) {
	// 			sideBarWidth = '25%';
	// 		} else {
	// 			sideBarWidth = '16.66667%';
	// 		}
	// 		PEOPLE.stickySideBar.css({
	// 			position: 'absolute',
	// 			width: sideBarWidth,
	// 			top: 'initial',
	// 			bottom: '60px'
	// 		});
	// 	}	
	// },
	// unstickSideBar: function() {
	// 	var sideBarWidth;
	// 	if ( $(window).width() < 1000 ) {
	// 		sideBarWidth = '25%';
	// 	} else {
	// 		sideBarWidth = '16.66667%';
	// 	}
	// 	PEOPLE.stickySideBar.css({
	// 		position: 'relative',
	// 		width: sideBarWidth,
	// 		top: 'initial'			
	// 	});
	// },
	revealAdvancedSearch: function () {
		$('#advancedSearchModal').removeClass('hidden').fadeIn('slow');
		console.log("advanced search revealed!");
	},
	hideAdvancedSearch: function () {
		$('#advancedSearchModal').addClass('hidden').fadeOut('slow');
		console.log("advanced search hidden!");
	}
};

$(document).ready(function () {
	PEOPLE.listeners();
	// if ( $(document).width() > 640) {
	// 	PEOPLE.scrollEvents();
	// 	$(document).scroll( function(){
	// 		PEOPLE.scrollEvents();
	// 	});
	// }
	var headerHeight = $('#mastheadOnScroll').height() + 140;
	console.log(headerHeight);
	if ($('.sidebar__on-scroll--fixed').length > 0) {
		console.log("STICKY");
		$('.sidebar__on-scroll--fixed').stick_in_parent({ offset_top: headerHeight });
	}
});
;'use strict';

var homepage = {
	initializeSlider: function () {

		// create SVG
		var s = Snap("#slider-svg");
		var line = s.paper.line(0, 0, 2500, 0);

		// set SVG attributes
		var animateSvg = function () {
			line.attr({
				stroke: 'transparent',
				fill: 'none',
				strokeWidth: 5,
				"fill-opacity": 0
			});
			// animate SVG line	
			line.animate({ stroke: '#c10819', fill: 'none' }, 1900, mina.linear);
		};
		animateSvg();
		// animate SVG on slide change
		$('.slider-container').on('beforeChange', function (slick, currentSlide, nextSlide) {
			animateSvg();
		});

		if ($("body").hasClass("page-template-homepage")) {
			// start Slick slider
			$('.slider-container').slick({
				slide: '.slide',
				slidesToShow: 1,
				slidesToScroll: 1,
				autoplay: true,
				autoplaySpeed: 2000,
				arrows: true,
				fade: true,
				infinite: true,
				prevArrow: $('.prev-slider-home'),
				nextArrow: $('.next-slider-home')
			});
		}
	}
};

$(document).ready(function () {
	if ($('#slider-svg').length) {
		homepage.initializeSlider();
	}
});
;'use strict';

$(window).bind(' load resize orientationChange ', function () {
  var footer = $("#footer-container");
  var pos = footer.position();
  var height = $(window).height();
  height = height - pos.top;
  height = height - footer.height() - 1;

  function stickyFooter() {
    footer.css({
      'margin-top': height + 'px'
    });
  }
  if (height > 0) {
    stickyFooter();
  }
});
;"use strict";

// Generated by CoffeeScript 1.9.2

/**
@license Sticky-kit v1.1.2 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
 */

(function () {
  var $, win;

  $ = this.jQuery || window.jQuery;

  win = $(window);

  $.fn.stick_in_parent = function (opts) {
    var doc, elm, enable_bottoming, fn, i, inner_scrolling, len, manual_spacer, offset_top, parent_selector, recalc_every, sticky_class;
    if (opts == null) {
      opts = {};
    }
    sticky_class = opts.sticky_class, inner_scrolling = opts.inner_scrolling, recalc_every = opts.recalc_every, parent_selector = opts.parent, offset_top = opts.offset_top, manual_spacer = opts.spacer, enable_bottoming = opts.bottoming;
    if (offset_top == null) {
      offset_top = 0;
    }
    if (parent_selector == null) {
      parent_selector = void 0;
    }
    if (inner_scrolling == null) {
      inner_scrolling = true;
    }
    if (sticky_class == null) {
      sticky_class = "is_stuck";
    }
    doc = $(document);
    if (enable_bottoming == null) {
      enable_bottoming = true;
    }
    fn = function (elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
      var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
      if (elm.data("sticky_kit")) {
        return;
      }
      elm.data("sticky_kit", true);
      last_scroll_height = doc.height();
      parent = elm.parent();
      if (parent_selector != null) {
        parent = parent.closest(parent_selector);
      }
      if (!parent.length) {
        throw "failed to find stick parent";
      }
      fixed = false;
      bottomed = false;
      spacer = manual_spacer != null ? manual_spacer && elm.closest(manual_spacer) : $("<div />");
      if (spacer) {
        spacer.css('position', elm.css('position'));
      }
      recalc = function () {
        var border_top, padding_top, restore;
        if (detached) {
          return;
        }
        last_scroll_height = doc.height();
        border_top = parseInt(parent.css("border-top-width"), 10);
        padding_top = parseInt(parent.css("padding-top"), 10);
        padding_bottom = parseInt(parent.css("padding-bottom"), 10);
        parent_top = parent.offset().top + border_top + padding_top;
        parent_height = parent.height();
        if (fixed) {
          fixed = false;
          bottomed = false;
          if (manual_spacer == null) {
            elm.insertAfter(spacer);
            spacer.detach();
          }
          elm.css({
            position: "",
            top: "",
            width: "",
            bottom: ""
          }).removeClass(sticky_class);
          restore = true;
        }
        top = elm.offset().top - (parseInt(elm.css("margin-top"), 10) || 0) - offset_top;
        height = elm.outerHeight(true);
        el_float = elm.css("float");
        if (spacer) {
          spacer.css({
            width: elm.outerWidth(true),
            height: height,
            display: elm.css("display"),
            "vertical-align": elm.css("vertical-align"),
            "float": el_float
          });
        }
        if (restore) {
          return tick();
        }
      };
      recalc();
      if (height === parent_height) {
        return;
      }
      last_pos = void 0;
      offset = offset_top;
      recalc_counter = recalc_every;
      tick = function () {
        var css, delta, recalced, scroll, will_bottom, win_height;
        if (detached) {
          return;
        }
        recalced = false;
        if (recalc_counter != null) {
          recalc_counter -= 1;
          if (recalc_counter <= 0) {
            recalc_counter = recalc_every;
            recalc();
            recalced = true;
          }
        }
        if (!recalced && doc.height() !== last_scroll_height) {
          recalc();
          recalced = true;
        }
        scroll = win.scrollTop();
        if (last_pos != null) {
          delta = scroll - last_pos;
        }
        last_pos = scroll;
        if (fixed) {
          if (enable_bottoming) {
            will_bottom = scroll + height + offset > parent_height + parent_top;
            if (bottomed && !will_bottom) {
              bottomed = false;
              elm.css({
                position: "fixed",
                bottom: "",
                top: offset
              }).trigger("sticky_kit:unbottom");
            }
          }
          if (scroll < top) {
            fixed = false;
            offset = offset_top;
            if (manual_spacer == null) {
              if (el_float === "left" || el_float === "right") {
                elm.insertAfter(spacer);
              }
              spacer.detach();
            }
            css = {
              position: "",
              width: "",
              top: ""
            };
            elm.css(css).removeClass(sticky_class).trigger("sticky_kit:unstick");
          }
          if (inner_scrolling) {
            win_height = win.height();
            if (height + offset_top > win_height) {
              if (!bottomed) {
                offset -= delta;
                offset = Math.max(win_height - height, offset);
                offset = Math.min(offset_top, offset);
                if (fixed) {
                  elm.css({
                    top: offset + "px"
                  });
                }
              }
            }
          }
        } else {
          if (scroll > top) {
            fixed = true;
            css = {
              position: "fixed",
              top: offset
            };
            css.width = elm.css("box-sizing") === "border-box" ? elm.outerWidth() + "px" : elm.width() + "px";
            elm.css(css).addClass(sticky_class);
            if (manual_spacer == null) {
              elm.after(spacer);
              if (el_float === "left" || el_float === "right") {
                spacer.append(elm);
              }
            }
            elm.trigger("sticky_kit:stick");
          }
        }
        if (fixed && enable_bottoming) {
          if (will_bottom == null) {
            will_bottom = scroll + height + offset > parent_height + parent_top;
          }
          if (!bottomed && will_bottom) {
            bottomed = true;
            if (parent.css("position") === "static") {
              parent.css({
                position: "relative"
              });
            }
            return elm.css({
              position: "absolute",
              bottom: padding_bottom,
              top: "auto"
            }).trigger("sticky_kit:bottom");
          }
        }
      };
      recalc_and_tick = function () {
        recalc();
        return tick();
      };
      detach = function () {
        detached = true;
        win.off("touchmove", tick);
        win.off("scroll", tick);
        win.off("resize", recalc_and_tick);
        $(document.body).off("sticky_kit:recalc", recalc_and_tick);
        elm.off("sticky_kit:detach", detach);
        elm.removeData("sticky_kit");
        elm.css({
          position: "",
          bottom: "",
          top: "",
          width: ""
        });
        parent.position("position", "");
        if (fixed) {
          if (manual_spacer == null) {
            if (el_float === "left" || el_float === "right") {
              elm.insertAfter(spacer);
            }
            spacer.remove();
          }
          return elm.removeClass(sticky_class);
        }
      };
      win.on("touchmove", tick);
      win.on("scroll", tick);
      win.on("resize", recalc_and_tick);
      $(document.body).on("sticky_kit:recalc", recalc_and_tick);
      elm.on("sticky_kit:detach", detach);
      return setTimeout(tick, 0);
    };
    for (i = 0, len = this.length; i < len; i++) {
      elm = this[i];
      fn($(elm));
    }
    return this;
  };
}).call(this);
;"use strict";

/*! Backstretch - v2.0.4 - 2013-06-19
* http://srobbin.com/jquery-plugins/backstretch/
* Copyright (c) 2013 Scott Robbin; Licensed MIT */
(function (a, d, p) {
  a.fn.backstretch = function (c, b) {
    (c === p || 0 === c.length) && a.error("No images were supplied for Backstretch");0 === a(d).scrollTop() && d.scrollTo(0, 0);return this.each(function () {
      var d = a(this),
          g = d.data("backstretch");if (g) {
        if ("string" == typeof c && "function" == typeof g[c]) {
          g[c](b);return;
        }b = a.extend(g.options, b);g.destroy(!0);
      }g = new q(this, c, b);d.data("backstretch", g);
    });
  };a.backstretch = function (c, b) {
    return a("body").backstretch(c, b).data("backstretch");
  };a.expr[":"].backstretch = function (c) {
    return a(c).data("backstretch") !== p;
  };a.fn.backstretch.defaults = { centeredX: !0, centeredY: !0, duration: 5E3, fade: 0 };var r = { left: 0, top: 0, overflow: "hidden", margin: 0, padding: 0, height: "100%", width: "100%", zIndex: -999999 },
      s = { position: "absolute", display: "none", margin: 0, padding: 0, border: "none", width: "auto", height: "auto", maxHeight: "none", maxWidth: "none", zIndex: -999999 },
      q = function (c, b, e) {
    this.options = a.extend({}, a.fn.backstretch.defaults, e || {});this.images = a.isArray(b) ? b : [b];a.each(this.images, function () {
      a("<img />")[0].src = this;
    });this.isBody = c === document.body;this.$container = a(c);this.$root = this.isBody ? l ? a(d) : a(document) : this.$container;c = this.$container.children(".backstretch").first();this.$wrap = c.length ? c : a('<div class="backstretch"></div>').css(r).appendTo(this.$container);this.isBody || (c = this.$container.css("position"), b = this.$container.css("zIndex"), this.$container.css({ position: "static" === c ? "relative" : c, zIndex: "auto" === b ? 0 : b, background: "none" }), this.$wrap.css({ zIndex: -999998 }));this.$wrap.css({ position: this.isBody && l ? "fixed" : "absolute" });this.index = 0;this.show(this.index);a(d).on("resize.backstretch", a.proxy(this.resize, this)).on("orientationchange.backstretch", a.proxy(function () {
      this.isBody && 0 === d.pageYOffset && (d.scrollTo(0, 1), this.resize());
    }, this));
  };q.prototype = { resize: function () {
      try {
        var a = { left: 0, top: 0 },
            b = this.isBody ? this.$root.width() : this.$root.innerWidth(),
            e = b,
            g = this.isBody ? d.innerHeight ? d.innerHeight : this.$root.height() : this.$root.innerHeight(),
            j = e / this.$img.data("ratio"),
            f;j >= g ? (f = (j - g) / 2, this.options.centeredY && (a.top = "-" + f + "px")) : (j = g, e = j * this.$img.data("ratio"), f = (e - b) / 2, this.options.centeredX && (a.left = "-" + f + "px"));this.$wrap.css({ width: b, height: g }).find("img:not(.deleteable)").css({ width: e, height: j }).css(a);
      } catch (h) {}return this;
    }, show: function (c) {
      if (!(Math.abs(c) > this.images.length - 1)) {
        var b = this,
            e = b.$wrap.find("img").addClass("deleteable"),
            d = { relatedTarget: b.$container[0] };b.$container.trigger(a.Event("backstretch.before", d), [b, c]);this.index = c;clearInterval(b.interval);b.$img = a("<img />").css(s).bind("load", function (f) {
          var h = this.width || a(f.target).width();f = this.height || a(f.target).height();a(this).data("ratio", h / f);a(this).fadeIn(b.options.speed || b.options.fade, function () {
            e.remove();b.paused || b.cycle();a(["after", "show"]).each(function () {
              b.$container.trigger(a.Event("backstretch." + this, d), [b, c]);
            });
          });b.resize();
        }).appendTo(b.$wrap);b.$img.attr("src", b.images[c]);return b;
      }
    }, next: function () {
      return this.show(this.index < this.images.length - 1 ? this.index + 1 : 0);
    }, prev: function () {
      return this.show(0 === this.index ? this.images.length - 1 : this.index - 1);
    }, pause: function () {
      this.paused = !0;return this;
    }, resume: function () {
      this.paused = !1;this.next();return this;
    }, cycle: function () {
      1 < this.images.length && (clearInterval(this.interval), this.interval = setInterval(a.proxy(function () {
        this.paused || this.next();
      }, this), this.options.duration));return this;
    }, destroy: function (c) {
      a(d).off("resize.backstretch orientationchange.backstretch");clearInterval(this.interval);c || this.$wrap.remove();this.$container.removeData("backstretch");
    } };var l,
      f = navigator.userAgent,
      m = navigator.platform,
      e = f.match(/AppleWebKit\/([0-9]+)/),
      e = !!e && e[1],
      h = f.match(/Fennec\/([0-9]+)/),
      h = !!h && h[1],
      n = f.match(/Opera Mobi\/([0-9]+)/),
      t = !!n && n[1],
      k = f.match(/MSIE ([0-9]+)/),
      k = !!k && k[1];l = !((-1 < m.indexOf("iPhone") || -1 < m.indexOf("iPad") || -1 < m.indexOf("iPod")) && e && 534 > e || d.operamini && "[object OperaMini]" === {}.toString.call(d.operamini) || n && 7458 > t || -1 < f.indexOf("Android") && e && 533 > e || h && 6 > h || "palmGetResource" in d && e && 534 > e || -1 < f.indexOf("MeeGo") && -1 < f.indexOf("NokiaBrowser/8.5.0") || k && 6 >= k);
})(jQuery, window);
;'use strict';

/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.6.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
(function (factory) {
    'use strict';

    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports !== 'undefined') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery);
    }
})(function ($) {
    'use strict';

    var Slick = window.Slick || {};

    Slick = function () {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this,
                dataSettings;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>',
                nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function (slider, i) {
                    return $('<button type="button" data-role="none" role="button" tabindex="0" />').text(i + 1);
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnFocus: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                useTransform: true,
                variableWidth: false,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true,
                zIndex: 1000
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                $list: null,
                touchObject: {},
                transformsEnabled: false,
                unslicked: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.focussed = false;
            _.interrupted = false;
            _.hidden = 'hidden';
            _.paused = true;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, settings, dataSettings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

            _.registerBreakpoints();
            _.init(true);
        }

        return Slick;
    }();

    Slick.prototype.activateADA = function () {
        var _ = this;

        _.$slideTrack.find('.slick-active').attr({
            'aria-hidden': 'false'
        }).find('a, input, button, select').attr({
            'tabindex': '0'
        });
    };

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function (markup, index, addBefore) {

        var _ = this;

        if (typeof index === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || index >= _.slideCount) {
            return false;
        }

        _.unload();

        if (typeof index === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function (index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();
    };

    Slick.prototype.animateHeight = function () {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };

    Slick.prototype.animateSlide = function (targetLeft, callback) {

        var animProps = {},
            _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }
        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -_.currentLeft;
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function (now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' + now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' + now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function () {
                        if (callback) {
                            callback.call();
                        }
                    }
                });
            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function () {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }
            }
        }
    };

    Slick.prototype.getNavTarget = function () {

        var _ = this,
            asNavFor = _.options.asNavFor;

        if (asNavFor && asNavFor !== null) {
            asNavFor = $(asNavFor).not(_.$slider);
        }

        return asNavFor;
    };

    Slick.prototype.asNavFor = function (index) {

        var _ = this,
            asNavFor = _.getNavTarget();

        if (asNavFor !== null && typeof asNavFor === 'object') {
            asNavFor.each(function () {
                var target = $(this).slick('getSlick');
                if (!target.unslicked) {
                    target.slideHandler(index, true);
                }
            });
        }
    };

    Slick.prototype.applyTransition = function (slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }
    };

    Slick.prototype.autoPlay = function () {

        var _ = this;

        _.autoPlayClear();

        if (_.slideCount > _.options.slidesToShow) {
            _.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);
        }
    };

    Slick.prototype.autoPlayClear = function () {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }
    };

    Slick.prototype.autoPlayIterator = function () {

        var _ = this,
            slideTo = _.currentSlide + _.options.slidesToScroll;

        if (!_.paused && !_.interrupted && !_.focussed) {

            if (_.options.infinite === false) {

                if (_.direction === 1 && _.currentSlide + 1 === _.slideCount - 1) {
                    _.direction = 0;
                } else if (_.direction === 0) {

                    slideTo = _.currentSlide - _.options.slidesToScroll;

                    if (_.currentSlide - 1 === 0) {
                        _.direction = 1;
                    }
                }
            }

            _.slideHandler(slideTo);
        }
    };

    Slick.prototype.buildArrows = function () {

        var _ = this;

        if (_.options.arrows === true) {

            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

            if (_.slideCount > _.options.slidesToShow) {

                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                if (_.htmlExpr.test(_.options.prevArrow)) {
                    _.$prevArrow.prependTo(_.options.appendArrows);
                }

                if (_.htmlExpr.test(_.options.nextArrow)) {
                    _.$nextArrow.appendTo(_.options.appendArrows);
                }

                if (_.options.infinite !== true) {
                    _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                }
            } else {

                _.$prevArrow.add(_.$nextArrow).addClass('slick-hidden').attr({
                    'aria-disabled': 'true',
                    'tabindex': '-1'
                });
            }
        }
    };

    Slick.prototype.buildDots = function () {

        var _ = this,
            i,
            dot;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$slider.addClass('slick-dotted');

            dot = $('<ul />').addClass(_.options.dotsClass);

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
            }

            _.$dots = dot.appendTo(_.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active').attr('aria-hidden', 'false');
        }
    };

    Slick.prototype.buildOut = function () {

        var _ = this;

        _.$slides = _.$slider.children(_.options.slide + ':not(.slick-cloned)').addClass('slick-slide');

        _.slideCount = _.$slides.length;

        _.$slides.each(function (index, element) {
            $(element).attr('data-slick-index', index).data('originalStyling', $(element).attr('style') || '');
        });

        _.$slider.addClass('slick-slider');

        _.$slideTrack = _.slideCount === 0 ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }
    };

    Slick.prototype.buildRows = function () {

        var _ = this,
            a,
            b,
            c,
            newSlides,
            numOfSlides,
            originalSlides,
            slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if (_.options.rows > 1) {

            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(originalSlides.length / slidesPerSection);

            for (a = 0; a < numOfSlides; a++) {
                var slide = document.createElement('div');
                for (b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for (c = 0; c < _.options.slidesPerRow; c++) {
                        var target = a * slidesPerSection + (b * _.options.slidesPerRow + c);
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }

            _.$slider.empty().append(newSlides);
            _.$slider.children().children().children().css({
                'width': 100 / _.options.slidesPerRow + '%',
                'display': 'inline-block'
            });
        }
    };

    Slick.prototype.checkResponsive = function (initial, forceUpdate) {

        var _ = this,
            breakpoint,
            targetBreakpoint,
            respondToWidth,
            triggerBreakpoint = false;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();

        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if (_.options.responsive && _.options.responsive.length && _.options.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                        _.activeBreakpoint = targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick(targetBreakpoint);
                        } else {
                            _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                            if (initial === true) {
                                _.currentSlide = _.options.initialSlide;
                            }
                            _.refresh(initial);
                        }
                        triggerBreakpoint = targetBreakpoint;
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick(targetBreakpoint);
                    } else {
                        _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                        if (initial === true) {
                            _.currentSlide = _.options.initialSlide;
                        }
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true) {
                        _.currentSlide = _.options.initialSlide;
                    }
                    _.refresh(initial);
                    triggerBreakpoint = targetBreakpoint;
                }
            }

            // only trigger breakpoints during an actual break. not on initialize.
            if (!initial && triggerBreakpoint !== false) {
                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
            }
        }
    };

    Slick.prototype.changeSlide = function (event, dontAnimate) {

        var _ = this,
            $target = $(event.currentTarget),
            indexOffset,
            slideOffset,
            unevenOffset;

        // If target is a link, prevent default action.
        if ($target.is('a')) {
            event.preventDefault();
        }

        // If target is not the <li> element (ie: a child), find the <li>.
        if (!$target.is('li')) {
            $target = $target.closest('li');
        }

        unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

            case 'previous':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                }
                break;

            case 'next':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                }
                break;

            case 'index':
                var index = event.data.index === 0 ? 0 : event.data.index || $target.index() * _.options.slidesToScroll;

                _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                $target.children().trigger('focus');
                break;

            default:
                return;
        }
    };

    Slick.prototype.checkNavigable = function (index) {

        var _ = this,
            navigables,
            prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    };

    Slick.prototype.cleanUpEvents = function () {

        var _ = this;

        if (_.options.dots && _.$dots !== null) {

            $('li', _.$dots).off('click.slick', _.changeSlide).off('mouseenter.slick', $.proxy(_.interrupt, _, true)).off('mouseleave.slick', $.proxy(_.interrupt, _, false));
        }

        _.$slider.off('focus.slick blur.slick');

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        $(document).off(_.visibilityChange, _.visibility);

        _.cleanUpSlideEvents();

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).off('ready.slick.slick-' + _.instanceUid, _.setPosition);
    };

    Slick.prototype.cleanUpSlideEvents = function () {

        var _ = this;

        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));
    };

    Slick.prototype.cleanUpRows = function () {

        var _ = this,
            originalSlides;

        if (_.options.rows > 1) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.empty().append(originalSlides);
        }
    };

    Slick.prototype.clickHandler = function (event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }
    };

    Slick.prototype.destroy = function (refresh) {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).detach();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.$prevArrow.length) {

            _.$prevArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

            if (_.htmlExpr.test(_.options.prevArrow)) {
                _.$prevArrow.remove();
            }
        }

        if (_.$nextArrow && _.$nextArrow.length) {

            _.$nextArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

            if (_.htmlExpr.test(_.options.nextArrow)) {
                _.$nextArrow.remove();
            }
        }

        if (_.$slides) {

            _.$slides.removeClass('slick-slide slick-active slick-center slick-visible slick-current').removeAttr('aria-hidden').removeAttr('data-slick-index').each(function () {
                $(this).attr('style', $(this).data('originalStyling'));
            });

            _.$slideTrack.children(this.options.slide).detach();

            _.$slideTrack.detach();

            _.$list.detach();

            _.$slider.append(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');
        _.$slider.removeClass('slick-dotted');

        _.unslicked = true;

        if (!refresh) {
            _.$slider.trigger('destroy', [_]);
        }
    };

    Slick.prototype.disableTransition = function (slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }
    };

    Slick.prototype.fadeSlide = function (slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);
        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });

            if (callback) {
                setTimeout(function () {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }
        }
    };

    Slick.prototype.fadeSlideOut = function (slideIndex) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).animate({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            }, _.options.speed, _.options.easing);
        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });
        }
    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function (filter) {

        var _ = this;

        if (filter !== null) {

            _.$slidesCache = _.$slides;

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();
        }
    };

    Slick.prototype.focusHandler = function () {

        var _ = this;

        _.$slider.off('focus.slick blur.slick').on('focus.slick blur.slick', '*:not(.slick-arrow)', function (event) {

            event.stopImmediatePropagation();
            var $sf = $(this);

            setTimeout(function () {

                if (_.options.pauseOnFocus) {
                    _.focussed = $sf.is(':focus');
                    _.autoPlay();
                }
            }, 0);
        });
    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function () {

        var _ = this;
        return _.currentSlide;
    };

    Slick.prototype.getDotCount = function () {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if (_.options.infinite === true) {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else if (!_.options.asNavFor) {
            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
        } else {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;
    };

    Slick.prototype.getLeft = function (slideIndex) {

        var _ = this,
            targetLeft,
            verticalHeight,
            verticalOffset = 0,
            targetSlide;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(true);

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = _.slideWidth * _.options.slidesToShow * -1;
                verticalOffset = verticalHeight * _.options.slidesToShow * -1;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1;
                        verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1;
                    } else {
                        _.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1;
                        verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;
                verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = slideIndex * _.slideWidth * -1 + _.slideOffset;
        } else {
            targetLeft = slideIndex * verticalHeight * -1 + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            if (_.options.rtl === true) {
                if (targetSlide[0]) {
                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                } else {
                    targetLeft = 0;
                }
            } else {
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
            }

            if (_.options.centerMode === true) {
                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }

                if (_.options.rtl === true) {
                    if (targetSlide[0]) {
                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                    } else {
                        targetLeft = 0;
                    }
                } else {
                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                }

                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;
    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function (option) {

        var _ = this;

        return _.options[option];
    };

    Slick.prototype.getNavigableIndexes = function () {

        var _ = this,
            breakPoint = 0,
            counter = 0,
            indexes = [],
            max;

        if (_.options.infinite === false) {
            max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;
    };

    Slick.prototype.getSlick = function () {

        return this;
    };

    Slick.prototype.getSlideCount = function () {

        var _ = this,
            slidesTraversed,
            swipedSlide,
            centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function (index, slide) {
                if (slide.offsetLeft - centerOffset + $(slide).outerWidth() / 2 > _.swipeLeft * -1) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;
        } else {
            return _.options.slidesToScroll;
        }
    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function (slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);
    };

    Slick.prototype.init = function (creation) {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');

            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
            _.checkResponsive(true);
            _.focusHandler();
        }

        if (creation) {
            _.$slider.trigger('init', [_]);
        }

        if (_.options.accessibility === true) {
            _.initADA();
        }

        if (_.options.autoplay) {

            _.paused = false;
            _.autoPlay();
        }
    };

    Slick.prototype.initADA = function () {
        var _ = this;
        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
            'aria-hidden': 'true',
            'tabindex': '-1'
        }).find('a, input, button, select').attr({
            'tabindex': '-1'
        });

        _.$slideTrack.attr('role', 'listbox');

        _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function (i) {
            $(this).attr({
                'role': 'option',
                'aria-describedby': 'slick-slide' + _.instanceUid + i + ''
            });
        });

        if (_.$dots !== null) {
            _.$dots.attr('role', 'tablist').find('li').each(function (i) {
                $(this).attr({
                    'role': 'presentation',
                    'aria-selected': 'false',
                    'aria-controls': 'navigation' + _.instanceUid + i + '',
                    'id': 'slick-slide' + _.instanceUid + i + ''
                });
            }).first().attr('aria-selected', 'true').end().find('button').attr('role', 'button').end().closest('div').attr('role', 'toolbar');
        }
        _.activateADA();
    };

    Slick.prototype.initArrowEvents = function () {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.off('click.slick').on('click.slick', {
                message: 'previous'
            }, _.changeSlide);
            _.$nextArrow.off('click.slick').on('click.slick', {
                message: 'next'
            }, _.changeSlide);
        }
    };

    Slick.prototype.initDotEvents = function () {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);
        }

        if (_.options.dots === true && _.options.pauseOnDotsHover === true) {

            $('li', _.$dots).on('mouseenter.slick', $.proxy(_.interrupt, _, true)).on('mouseleave.slick', $.proxy(_.interrupt, _, false));
        }
    };

    Slick.prototype.initSlideEvents = function () {

        var _ = this;

        if (_.options.pauseOnHover) {

            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));
        }
    };

    Slick.prototype.initializeEvents = function () {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();
        _.initSlideEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);
    };

    Slick.prototype.initUI = function () {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();
        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();
        }
    };

    Slick.prototype.keyHandler = function (event) {

        var _ = this;
        //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
            if (event.keyCode === 37 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'next' : 'previous'
                    }
                });
            } else if (event.keyCode === 39 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'previous' : 'next'
                    }
                });
            }
        }
    };

    Slick.prototype.lazyLoad = function () {

        var _ = this,
            loadRange,
            cloneRange,
            rangeStart,
            rangeEnd;

        function loadImages(imagesScope) {

            $('img[data-lazy]', imagesScope).each(function () {

                var image = $(this),
                    imageSource = $(this).attr('data-lazy'),
                    imageToLoad = document.createElement('img');

                imageToLoad.onload = function () {

                    image.animate({ opacity: 0 }, 100, function () {
                        image.attr('src', imageSource).animate({ opacity: 1 }, 200, function () {
                            image.removeAttr('data-lazy').removeClass('slick-loading');
                        });
                        _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                    });
                };

                imageToLoad.onerror = function () {

                    image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

                    _.$slider.trigger('lazyLoadError', [_, image, imageSource]);
                };

                imageToLoad.src = imageSource;
            });
        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
            if (_.options.fade === true) {
                if (rangeStart > 0) rangeStart--;
                if (rangeEnd <= _.slideCount) rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);
        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }
    };

    Slick.prototype.loadSlider = function () {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }
    };

    Slick.prototype.next = Slick.prototype.slickNext = function () {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });
    };

    Slick.prototype.orientationChange = function () {

        var _ = this;

        _.checkResponsive();
        _.setPosition();
    };

    Slick.prototype.pause = Slick.prototype.slickPause = function () {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;
    };

    Slick.prototype.play = Slick.prototype.slickPlay = function () {

        var _ = this;

        _.autoPlay();
        _.options.autoplay = true;
        _.paused = false;
        _.focussed = false;
        _.interrupted = false;
    };

    Slick.prototype.postSlide = function (index) {

        var _ = this;

        if (!_.unslicked) {

            _.$slider.trigger('afterChange', [_, index]);

            _.animating = false;

            _.setPosition();

            _.swipeLeft = null;

            if (_.options.autoplay) {
                _.autoPlay();
            }

            if (_.options.accessibility === true) {
                _.initADA();
            }
        }
    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function () {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });
    };

    Slick.prototype.preventDefault = function (event) {

        event.preventDefault();
    };

    Slick.prototype.progressiveLazyLoad = function (tryCount) {

        tryCount = tryCount || 1;

        var _ = this,
            $imgsToLoad = $('img[data-lazy]', _.$slider),
            image,
            imageSource,
            imageToLoad;

        if ($imgsToLoad.length) {

            image = $imgsToLoad.first();
            imageSource = image.attr('data-lazy');
            imageToLoad = document.createElement('img');

            imageToLoad.onload = function () {

                image.attr('src', imageSource).removeAttr('data-lazy').removeClass('slick-loading');

                if (_.options.adaptiveHeight === true) {
                    _.setPosition();
                }

                _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                _.progressiveLazyLoad();
            };

            imageToLoad.onerror = function () {

                if (tryCount < 3) {

                    /**
                     * try to load the image 3 times,
                     * leave a slight delay so we don't get
                     * servers blocking the request.
                     */
                    setTimeout(function () {
                        _.progressiveLazyLoad(tryCount + 1);
                    }, 500);
                } else {

                    image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

                    _.$slider.trigger('lazyLoadError', [_, image, imageSource]);

                    _.progressiveLazyLoad();
                }
            };

            imageToLoad.src = imageSource;
        } else {

            _.$slider.trigger('allImagesLoaded', [_]);
        }
    };

    Slick.prototype.refresh = function (initializing) {

        var _ = this,
            currentSlide,
            lastVisibleIndex;

        lastVisibleIndex = _.slideCount - _.options.slidesToShow;

        // in non-infinite sliders, we don't want to go past the
        // last visible index.
        if (!_.options.infinite && _.currentSlide > lastVisibleIndex) {
            _.currentSlide = lastVisibleIndex;
        }

        // if less slides than to show, go to start.
        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        currentSlide = _.currentSlide;

        _.destroy(true);

        $.extend(_, _.initials, { currentSlide: currentSlide });

        _.init();

        if (!initializing) {

            _.changeSlide({
                data: {
                    message: 'index',
                    index: currentSlide
                }
            }, false);
        }
    };

    Slick.prototype.registerBreakpoints = function () {

        var _ = this,
            breakpoint,
            currentBreakpoint,
            l,
            responsiveSettings = _.options.responsive || null;

        if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {

            _.respondTo = _.options.respondTo || 'window';

            for (breakpoint in responsiveSettings) {

                l = _.breakpoints.length - 1;
                currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                if (responsiveSettings.hasOwnProperty(breakpoint)) {

                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    while (l >= 0) {
                        if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {
                            _.breakpoints.splice(l, 1);
                        }
                        l--;
                    }

                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;
                }
            }

            _.breakpoints.sort(function (a, b) {
                return _.options.mobileFirst ? a - b : b - a;
            });
        }
    };

    Slick.prototype.reinit = function () {

        var _ = this;

        _.$slides = _.$slideTrack.children(_.options.slide).addClass('slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.registerBreakpoints();

        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.cleanUpSlideEvents();
        _.initSlideEvents();

        _.checkResponsive(false, true);

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        _.setPosition();
        _.focusHandler();

        _.paused = !_.options.autoplay;
        _.autoPlay();

        _.$slider.trigger('reInit', [_]);
    };

    Slick.prototype.resize = function () {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function () {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                if (!_.unslicked) {
                    _.setPosition();
                }
            }, 50);
        }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function (index, removeBefore, removeAll) {

        var _ = this;

        if (typeof index === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();
    };

    Slick.prototype.setCSS = function (position) {

        var _ = this,
            positionProps = {},
            x,
            y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }
    };

    Slick.prototype.setDimensions = function () {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: '0px ' + _.options.centerPadding
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: _.options.centerPadding + ' 0px'
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();

        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children('.slick-slide').length));
        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);
    };

    Slick.prototype.setFade = function () {

        var _ = this,
            targetLeft;

        _.$slides.each(function (index, element) {
            targetLeft = _.slideWidth * index * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });
    };

    Slick.prototype.setHeight = function () {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }
    };

    Slick.prototype.setOption = Slick.prototype.slickSetOption = function () {

        /**
         * accepts arguments in format of:
         *
         *  - for changing a single option's value:
         *     .slick("setOption", option, value, refresh )
         *
         *  - for changing a set of responsive options:
         *     .slick("setOption", 'responsive', [{}, ...], refresh )
         *
         *  - for updating multiple values at once (not responsive)
         *     .slick("setOption", { 'option': value, ... }, refresh )
         */

        var _ = this,
            l,
            item,
            option,
            value,
            refresh = false,
            type;

        if ($.type(arguments[0]) === 'object') {

            option = arguments[0];
            refresh = arguments[1];
            type = 'multiple';
        } else if ($.type(arguments[0]) === 'string') {

            option = arguments[0];
            value = arguments[1];
            refresh = arguments[2];

            if (arguments[0] === 'responsive' && $.type(arguments[1]) === 'array') {

                type = 'responsive';
            } else if (typeof arguments[1] !== 'undefined') {

                type = 'single';
            }
        }

        if (type === 'single') {

            _.options[option] = value;
        } else if (type === 'multiple') {

            $.each(option, function (opt, val) {

                _.options[opt] = val;
            });
        } else if (type === 'responsive') {

            for (item in value) {

                if ($.type(_.options.responsive) !== 'array') {

                    _.options.responsive = [value[item]];
                } else {

                    l = _.options.responsive.length - 1;

                    // loop through the responsive object and splice out duplicates.
                    while (l >= 0) {

                        if (_.options.responsive[l].breakpoint === value[item].breakpoint) {

                            _.options.responsive.splice(l, 1);
                        }

                        l--;
                    }

                    _.options.responsive.push(value[item]);
                }
            }
        }

        if (refresh) {

            _.unload();
            _.reinit();
        }
    };

    Slick.prototype.setPosition = function () {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);
    };

    Slick.prototype.setProps = function () {

        var _ = this,
            bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined || bodyStyle.MozTransition !== undefined || bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if (_.options.fade) {
            if (typeof _.options.zIndex === 'number') {
                if (_.options.zIndex < 3) {
                    _.options.zIndex = 3;
                }
            } else {
                _.options.zIndex = _.defaults.zIndex;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined) _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = _.options.useTransform && _.animType !== null && _.animType !== false;
    };

    Slick.prototype.setSlideClasses = function (index) {

        var _ = this,
            centerOffset,
            allSlides,
            indexOffset,
            remainder;

        allSlides = _.$slider.find('.slick-slide').removeClass('slick-active slick-center slick-current').attr('aria-hidden', 'true');

        _.$slides.eq(index).addClass('slick-current');

        if (_.options.centerMode === true) {

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) {

                    _.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass('slick-active').attr('aria-hidden', 'false');
                } else {

                    indexOffset = _.options.slidesToShow + index;
                    allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass('slick-active').attr('aria-hidden', 'false');
                }

                if (index === 0) {

                    allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slick-center');
                } else if (index === _.slideCount - 1) {

                    allSlides.eq(_.options.slidesToShow).addClass('slick-center');
                }
            }

            _.$slides.eq(index).addClass('slick-center');
        } else {

            if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) {

                _.$slides.slice(index, index + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
            } else if (allSlides.length <= _.options.slidesToShow) {

                allSlides.addClass('slick-active').attr('aria-hidden', 'false');
            } else {

                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                if (_.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow) {

                    allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass('slick-active').attr('aria-hidden', 'false');
                } else {

                    allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
                }
            }
        }

        if (_.options.lazyLoad === 'ondemand') {
            _.lazyLoad();
        }
    };

    Slick.prototype.setupInfinite = function () {

        var _ = this,
            i,
            slideIndex,
            infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function () {
                    $(this).attr('id', '');
                });
            }
        }
    };

    Slick.prototype.interrupt = function (toggle) {

        var _ = this;

        if (!toggle) {
            _.autoPlay();
        }
        _.interrupted = toggle;
    };

    Slick.prototype.selectHandler = function (event) {

        var _ = this;

        var targetElement = $(event.target).is('.slick-slide') ? $(event.target) : $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));

        if (!index) index = 0;

        if (_.slideCount <= _.options.slidesToShow) {

            _.setSlideClasses(index);
            _.asNavFor(index);
            return;
        }

        _.slideHandler(index);
    };

    Slick.prototype.slideHandler = function (index, sync, dontAnimate) {

        var targetSlide,
            animSlide,
            oldSlide,
            slideLeft,
            targetLeft = null,
            _ = this,
            navTarget;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function () {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > _.slideCount - _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function () {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if (_.options.autoplay) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - _.slideCount % _.options.slidesToScroll;
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        if (_.options.asNavFor) {

            navTarget = _.getNavTarget();
            navTarget = navTarget.slick('getSlick');

            if (navTarget.slideCount <= navTarget.options.slidesToShow) {
                navTarget.setSlideClasses(_.currentSlide);
            }
        }

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {

                _.fadeSlideOut(oldSlide);

                _.fadeSlide(animSlide, function () {
                    _.postSlide(animSlide);
                });
            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true) {
            _.animateSlide(targetLeft, function () {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }
    };

    Slick.prototype.startLoad = function () {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();
        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();
        }

        _.$slider.addClass('slick-loading');
    };

    Slick.prototype.swipeDirection = function () {

        var xDist,
            yDist,
            r,
            swipeAngle,
            _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if (swipeAngle <= 45 && swipeAngle >= 0) {
            return _.options.rtl === false ? 'left' : 'right';
        }
        if (swipeAngle <= 360 && swipeAngle >= 315) {
            return _.options.rtl === false ? 'left' : 'right';
        }
        if (swipeAngle >= 135 && swipeAngle <= 225) {
            return _.options.rtl === false ? 'right' : 'left';
        }
        if (_.options.verticalSwiping === true) {
            if (swipeAngle >= 35 && swipeAngle <= 135) {
                return 'down';
            } else {
                return 'up';
            }
        }

        return 'vertical';
    };

    Slick.prototype.swipeEnd = function (event) {

        var _ = this,
            slideCount,
            direction;

        _.dragging = false;
        _.interrupted = false;
        _.shouldClick = _.touchObject.swipeLength > 10 ? false : true;

        if (_.touchObject.curX === undefined) {
            return false;
        }

        if (_.touchObject.edgeHit === true) {
            _.$slider.trigger('edge', [_, _.swipeDirection()]);
        }

        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {

            direction = _.swipeDirection();

            switch (direction) {

                case 'left':
                case 'down':

                    slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();

                    _.currentDirection = 0;

                    break;

                case 'right':
                case 'up':

                    slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();

                    _.currentDirection = 1;

                    break;

                default:

            }

            if (direction != 'vertical') {

                _.slideHandler(slideCount);
                _.touchObject = {};
                _.$slider.trigger('swipe', [_, direction]);
            }
        } else {

            if (_.touchObject.startX !== _.touchObject.curX) {

                _.slideHandler(_.currentSlide);
                _.touchObject = {};
            }
        }
    };

    Slick.prototype.swipeHandler = function (event) {

        var _ = this;

        if (_.options.swipe === false || 'ontouchend' in document && _.options.swipe === false) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ? event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options.touchThreshold;
        }

        switch (event.data.action) {

            case 'start':
                _.swipeStart(event);
                break;

            case 'move':
                _.swipeMove(event);
                break;

            case 'end':
                _.swipeEnd(event);
                break;

        }
    };

    Slick.prototype.swipeMove = function (event) {

        var _ = this,
            edgeWasHit = false,
            curLeft,
            swipeDirection,
            swipeLength,
            positionOffset,
            touches;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));
        }

        swipeDirection = _.swipeDirection();

        if (swipeDirection === 'vertical') {
            return;
        }

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }

        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if (_.currentSlide === 0 && swipeDirection === 'right' || _.currentSlide >= _.getDotCount() && swipeDirection === 'left') {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + swipeLength * (_.$list.height() / _.listWidth) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);
    };

    Slick.prototype.swipeStart = function (event) {

        var _ = this,
            touches;

        _.interrupted = true;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;
    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function () {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();
        }
    };

    Slick.prototype.unload = function () {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.remove();
        }

        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.remove();
        }

        _.$slides.removeClass('slick-slide slick-active slick-visible slick-current').attr('aria-hidden', 'true').css('width', '');
    };

    Slick.prototype.unslick = function (fromBreakpoint) {

        var _ = this;
        _.$slider.trigger('unslick', [_, fromBreakpoint]);
        _.destroy();
    };

    Slick.prototype.updateArrows = function () {

        var _ = this,
            centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow && !_.options.infinite) {

            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            if (_.currentSlide === 0) {

                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            }
        }
    };

    Slick.prototype.updateDots = function () {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots.find('li').removeClass('slick-active').attr('aria-hidden', 'true');

            _.$dots.find('li').eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass('slick-active').attr('aria-hidden', 'false');
        }
    };

    Slick.prototype.visibility = function () {

        var _ = this;

        if (_.options.autoplay) {

            if (document[_.hidden]) {

                _.interrupted = true;
            } else {

                _.interrupted = false;
            }
        }
    };

    $.fn.slick = function () {
        var _ = this,
            opt = arguments[0],
            args = Array.prototype.slice.call(arguments, 1),
            l = _.length,
            i,
            ret;
        for (i = 0; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined') _[i].slick = new Slick(_[i], opt);else ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined') return ret;
        }
        return _;
    };
});
;"use strict";

/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.6.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
!function (a) {
  "use strict";
  "function" == typeof define && define.amd ? define(["jquery"], a) : "undefined" != typeof exports ? module.exports = a(require("jquery")) : a(jQuery);
}(function (a) {
  "use strict";
  var b = window.Slick || {};b = function () {
    function c(c, d) {
      var f,
          e = this;e.defaults = { accessibility: !0, adaptiveHeight: !1, appendArrows: a(c), appendDots: a(c), arrows: !0, asNavFor: null, prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>', nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>', autoplay: !1, autoplaySpeed: 3e3, centerMode: !1, centerPadding: "50px", cssEase: "ease", customPaging: function (b, c) {
          return a('<button type="button" data-role="none" role="button" tabindex="0" />').text(c + 1);
        }, dots: !1, dotsClass: "slick-dots", draggable: !0, easing: "linear", edgeFriction: .35, fade: !1, focusOnSelect: !1, infinite: !0, initialSlide: 0, lazyLoad: "ondemand", mobileFirst: !1, pauseOnHover: !0, pauseOnFocus: !0, pauseOnDotsHover: !1, respondTo: "window", responsive: null, rows: 1, rtl: !1, slide: "", slidesPerRow: 1, slidesToShow: 1, slidesToScroll: 1, speed: 500, swipe: !0, swipeToSlide: !1, touchMove: !0, touchThreshold: 5, useCSS: !0, useTransform: !0, variableWidth: !1, vertical: !1, verticalSwiping: !1, waitForAnimate: !0, zIndex: 1e3 }, e.initials = { animating: !1, dragging: !1, autoPlayTimer: null, currentDirection: 0, currentLeft: null, currentSlide: 0, direction: 1, $dots: null, listWidth: null, listHeight: null, loadIndex: 0, $nextArrow: null, $prevArrow: null, slideCount: null, slideWidth: null, $slideTrack: null, $slides: null, sliding: !1, slideOffset: 0, swipeLeft: null, $list: null, touchObject: {}, transformsEnabled: !1, unslicked: !1 }, a.extend(e, e.initials), e.activeBreakpoint = null, e.animType = null, e.animProp = null, e.breakpoints = [], e.breakpointSettings = [], e.cssTransitions = !1, e.focussed = !1, e.interrupted = !1, e.hidden = "hidden", e.paused = !0, e.positionProp = null, e.respondTo = null, e.rowCount = 1, e.shouldClick = !0, e.$slider = a(c), e.$slidesCache = null, e.transformType = null, e.transitionType = null, e.visibilityChange = "visibilitychange", e.windowWidth = 0, e.windowTimer = null, f = a(c).data("slick") || {}, e.options = a.extend({}, e.defaults, d, f), e.currentSlide = e.options.initialSlide, e.originalSettings = e.options, "undefined" != typeof document.mozHidden ? (e.hidden = "mozHidden", e.visibilityChange = "mozvisibilitychange") : "undefined" != typeof document.webkitHidden && (e.hidden = "webkitHidden", e.visibilityChange = "webkitvisibilitychange"), e.autoPlay = a.proxy(e.autoPlay, e), e.autoPlayClear = a.proxy(e.autoPlayClear, e), e.autoPlayIterator = a.proxy(e.autoPlayIterator, e), e.changeSlide = a.proxy(e.changeSlide, e), e.clickHandler = a.proxy(e.clickHandler, e), e.selectHandler = a.proxy(e.selectHandler, e), e.setPosition = a.proxy(e.setPosition, e), e.swipeHandler = a.proxy(e.swipeHandler, e), e.dragHandler = a.proxy(e.dragHandler, e), e.keyHandler = a.proxy(e.keyHandler, e), e.instanceUid = b++, e.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, e.registerBreakpoints(), e.init(!0);
    }var b = 0;return c;
  }(), b.prototype.activateADA = function () {
    var a = this;a.$slideTrack.find(".slick-active").attr({ "aria-hidden": "false" }).find("a, input, button, select").attr({ tabindex: "0" });
  }, b.prototype.addSlide = b.prototype.slickAdd = function (b, c, d) {
    var e = this;if ("boolean" == typeof c) d = c, c = null;else if (0 > c || c >= e.slideCount) return !1;e.unload(), "number" == typeof c ? 0 === c && 0 === e.$slides.length ? a(b).appendTo(e.$slideTrack) : d ? a(b).insertBefore(e.$slides.eq(c)) : a(b).insertAfter(e.$slides.eq(c)) : d === !0 ? a(b).prependTo(e.$slideTrack) : a(b).appendTo(e.$slideTrack), e.$slides = e.$slideTrack.children(this.options.slide), e.$slideTrack.children(this.options.slide).detach(), e.$slideTrack.append(e.$slides), e.$slides.each(function (b, c) {
      a(c).attr("data-slick-index", b);
    }), e.$slidesCache = e.$slides, e.reinit();
  }, b.prototype.animateHeight = function () {
    var a = this;if (1 === a.options.slidesToShow && a.options.adaptiveHeight === !0 && a.options.vertical === !1) {
      var b = a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.animate({ height: b }, a.options.speed);
    }
  }, b.prototype.animateSlide = function (b, c) {
    var d = {},
        e = this;e.animateHeight(), e.options.rtl === !0 && e.options.vertical === !1 && (b = -b), e.transformsEnabled === !1 ? e.options.vertical === !1 ? e.$slideTrack.animate({ left: b }, e.options.speed, e.options.easing, c) : e.$slideTrack.animate({ top: b }, e.options.speed, e.options.easing, c) : e.cssTransitions === !1 ? (e.options.rtl === !0 && (e.currentLeft = -e.currentLeft), a({ animStart: e.currentLeft }).animate({ animStart: b }, { duration: e.options.speed, easing: e.options.easing, step: function (a) {
        a = Math.ceil(a), e.options.vertical === !1 ? (d[e.animType] = "translate(" + a + "px, 0px)", e.$slideTrack.css(d)) : (d[e.animType] = "translate(0px," + a + "px)", e.$slideTrack.css(d));
      }, complete: function () {
        c && c.call();
      } })) : (e.applyTransition(), b = Math.ceil(b), e.options.vertical === !1 ? d[e.animType] = "translate3d(" + b + "px, 0px, 0px)" : d[e.animType] = "translate3d(0px," + b + "px, 0px)", e.$slideTrack.css(d), c && setTimeout(function () {
      e.disableTransition(), c.call();
    }, e.options.speed));
  }, b.prototype.getNavTarget = function () {
    var b = this,
        c = b.options.asNavFor;return c && null !== c && (c = a(c).not(b.$slider)), c;
  }, b.prototype.asNavFor = function (b) {
    var c = this,
        d = c.getNavTarget();null !== d && "object" == typeof d && d.each(function () {
      var c = a(this).slick("getSlick");c.unslicked || c.slideHandler(b, !0);
    });
  }, b.prototype.applyTransition = function (a) {
    var b = this,
        c = {};b.options.fade === !1 ? c[b.transitionType] = b.transformType + " " + b.options.speed + "ms " + b.options.cssEase : c[b.transitionType] = "opacity " + b.options.speed + "ms " + b.options.cssEase, b.options.fade === !1 ? b.$slideTrack.css(c) : b.$slides.eq(a).css(c);
  }, b.prototype.autoPlay = function () {
    var a = this;a.autoPlayClear(), a.slideCount > a.options.slidesToShow && (a.autoPlayTimer = setInterval(a.autoPlayIterator, a.options.autoplaySpeed));
  }, b.prototype.autoPlayClear = function () {
    var a = this;a.autoPlayTimer && clearInterval(a.autoPlayTimer);
  }, b.prototype.autoPlayIterator = function () {
    var a = this,
        b = a.currentSlide + a.options.slidesToScroll;a.paused || a.interrupted || a.focussed || (a.options.infinite === !1 && (1 === a.direction && a.currentSlide + 1 === a.slideCount - 1 ? a.direction = 0 : 0 === a.direction && (b = a.currentSlide - a.options.slidesToScroll, a.currentSlide - 1 === 0 && (a.direction = 1))), a.slideHandler(b));
  }, b.prototype.buildArrows = function () {
    var b = this;b.options.arrows === !0 && (b.$prevArrow = a(b.options.prevArrow).addClass("slick-arrow"), b.$nextArrow = a(b.options.nextArrow).addClass("slick-arrow"), b.slideCount > b.options.slidesToShow ? (b.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), b.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), b.htmlExpr.test(b.options.prevArrow) && b.$prevArrow.prependTo(b.options.appendArrows), b.htmlExpr.test(b.options.nextArrow) && b.$nextArrow.appendTo(b.options.appendArrows), b.options.infinite !== !0 && b.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : b.$prevArrow.add(b.$nextArrow).addClass("slick-hidden").attr({ "aria-disabled": "true", tabindex: "-1" }));
  }, b.prototype.buildDots = function () {
    var c,
        d,
        b = this;if (b.options.dots === !0 && b.slideCount > b.options.slidesToShow) {
      for (b.$slider.addClass("slick-dotted"), d = a("<ul />").addClass(b.options.dotsClass), c = 0; c <= b.getDotCount(); c += 1) {
        d.append(a("<li />").append(b.options.customPaging.call(this, b, c)));
      }b.$dots = d.appendTo(b.options.appendDots), b.$dots.find("li").first().addClass("slick-active").attr("aria-hidden", "false");
    }
  }, b.prototype.buildOut = function () {
    var b = this;b.$slides = b.$slider.children(b.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), b.slideCount = b.$slides.length, b.$slides.each(function (b, c) {
      a(c).attr("data-slick-index", b).data("originalStyling", a(c).attr("style") || "");
    }), b.$slider.addClass("slick-slider"), b.$slideTrack = 0 === b.slideCount ? a('<div class="slick-track"/>').appendTo(b.$slider) : b.$slides.wrapAll('<div class="slick-track"/>').parent(), b.$list = b.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent(), b.$slideTrack.css("opacity", 0), (b.options.centerMode === !0 || b.options.swipeToSlide === !0) && (b.options.slidesToScroll = 1), a("img[data-lazy]", b.$slider).not("[src]").addClass("slick-loading"), b.setupInfinite(), b.buildArrows(), b.buildDots(), b.updateDots(), b.setSlideClasses("number" == typeof b.currentSlide ? b.currentSlide : 0), b.options.draggable === !0 && b.$list.addClass("draggable");
  }, b.prototype.buildRows = function () {
    var b,
        c,
        d,
        e,
        f,
        g,
        h,
        a = this;if (e = document.createDocumentFragment(), g = a.$slider.children(), a.options.rows > 1) {
      for (h = a.options.slidesPerRow * a.options.rows, f = Math.ceil(g.length / h), b = 0; f > b; b++) {
        var i = document.createElement("div");for (c = 0; c < a.options.rows; c++) {
          var j = document.createElement("div");for (d = 0; d < a.options.slidesPerRow; d++) {
            var k = b * h + (c * a.options.slidesPerRow + d);g.get(k) && j.appendChild(g.get(k));
          }i.appendChild(j);
        }e.appendChild(i);
      }a.$slider.empty().append(e), a.$slider.children().children().children().css({ width: 100 / a.options.slidesPerRow + "%", display: "inline-block" });
    }
  }, b.prototype.checkResponsive = function (b, c) {
    var e,
        f,
        g,
        d = this,
        h = !1,
        i = d.$slider.width(),
        j = window.innerWidth || a(window).width();if ("window" === d.respondTo ? g = j : "slider" === d.respondTo ? g = i : "min" === d.respondTo && (g = Math.min(j, i)), d.options.responsive && d.options.responsive.length && null !== d.options.responsive) {
      f = null;for (e in d.breakpoints) {
        d.breakpoints.hasOwnProperty(e) && (d.originalSettings.mobileFirst === !1 ? g < d.breakpoints[e] && (f = d.breakpoints[e]) : g > d.breakpoints[e] && (f = d.breakpoints[e]));
      }null !== f ? null !== d.activeBreakpoint ? (f !== d.activeBreakpoint || c) && (d.activeBreakpoint = f, "unslick" === d.breakpointSettings[f] ? d.unslick(f) : (d.options = a.extend({}, d.originalSettings, d.breakpointSettings[f]), b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b)), h = f) : (d.activeBreakpoint = f, "unslick" === d.breakpointSettings[f] ? d.unslick(f) : (d.options = a.extend({}, d.originalSettings, d.breakpointSettings[f]), b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b)), h = f) : null !== d.activeBreakpoint && (d.activeBreakpoint = null, d.options = d.originalSettings, b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b), h = f), b || h === !1 || d.$slider.trigger("breakpoint", [d, h]);
    }
  }, b.prototype.changeSlide = function (b, c) {
    var f,
        g,
        h,
        d = this,
        e = a(b.currentTarget);switch (e.is("a") && b.preventDefault(), e.is("li") || (e = e.closest("li")), h = d.slideCount % d.options.slidesToScroll !== 0, f = h ? 0 : (d.slideCount - d.currentSlide) % d.options.slidesToScroll, b.data.message) {case "previous":
        g = 0 === f ? d.options.slidesToScroll : d.options.slidesToShow - f, d.slideCount > d.options.slidesToShow && d.slideHandler(d.currentSlide - g, !1, c);break;case "next":
        g = 0 === f ? d.options.slidesToScroll : f, d.slideCount > d.options.slidesToShow && d.slideHandler(d.currentSlide + g, !1, c);break;case "index":
        var i = 0 === b.data.index ? 0 : b.data.index || e.index() * d.options.slidesToScroll;d.slideHandler(d.checkNavigable(i), !1, c), e.children().trigger("focus");break;default:
        return;}
  }, b.prototype.checkNavigable = function (a) {
    var c,
        d,
        b = this;if (c = b.getNavigableIndexes(), d = 0, a > c[c.length - 1]) a = c[c.length - 1];else for (var e in c) {
      if (a < c[e]) {
        a = d;break;
      }d = c[e];
    }return a;
  }, b.prototype.cleanUpEvents = function () {
    var b = this;b.options.dots && null !== b.$dots && a("li", b.$dots).off("click.slick", b.changeSlide).off("mouseenter.slick", a.proxy(b.interrupt, b, !0)).off("mouseleave.slick", a.proxy(b.interrupt, b, !1)), b.$slider.off("focus.slick blur.slick"), b.options.arrows === !0 && b.slideCount > b.options.slidesToShow && (b.$prevArrow && b.$prevArrow.off("click.slick", b.changeSlide), b.$nextArrow && b.$nextArrow.off("click.slick", b.changeSlide)), b.$list.off("touchstart.slick mousedown.slick", b.swipeHandler), b.$list.off("touchmove.slick mousemove.slick", b.swipeHandler), b.$list.off("touchend.slick mouseup.slick", b.swipeHandler), b.$list.off("touchcancel.slick mouseleave.slick", b.swipeHandler), b.$list.off("click.slick", b.clickHandler), a(document).off(b.visibilityChange, b.visibility), b.cleanUpSlideEvents(), b.options.accessibility === !0 && b.$list.off("keydown.slick", b.keyHandler), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().off("click.slick", b.selectHandler), a(window).off("orientationchange.slick.slick-" + b.instanceUid, b.orientationChange), a(window).off("resize.slick.slick-" + b.instanceUid, b.resize), a("[draggable!=true]", b.$slideTrack).off("dragstart", b.preventDefault), a(window).off("load.slick.slick-" + b.instanceUid, b.setPosition), a(document).off("ready.slick.slick-" + b.instanceUid, b.setPosition);
  }, b.prototype.cleanUpSlideEvents = function () {
    var b = this;b.$list.off("mouseenter.slick", a.proxy(b.interrupt, b, !0)), b.$list.off("mouseleave.slick", a.proxy(b.interrupt, b, !1));
  }, b.prototype.cleanUpRows = function () {
    var b,
        a = this;a.options.rows > 1 && (b = a.$slides.children().children(), b.removeAttr("style"), a.$slider.empty().append(b));
  }, b.prototype.clickHandler = function (a) {
    var b = this;b.shouldClick === !1 && (a.stopImmediatePropagation(), a.stopPropagation(), a.preventDefault());
  }, b.prototype.destroy = function (b) {
    var c = this;c.autoPlayClear(), c.touchObject = {}, c.cleanUpEvents(), a(".slick-cloned", c.$slider).detach(), c.$dots && c.$dots.remove(), c.$prevArrow && c.$prevArrow.length && (c.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), c.htmlExpr.test(c.options.prevArrow) && c.$prevArrow.remove()), c.$nextArrow && c.$nextArrow.length && (c.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), c.htmlExpr.test(c.options.nextArrow) && c.$nextArrow.remove()), c.$slides && (c.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function () {
      a(this).attr("style", a(this).data("originalStyling"));
    }), c.$slideTrack.children(this.options.slide).detach(), c.$slideTrack.detach(), c.$list.detach(), c.$slider.append(c.$slides)), c.cleanUpRows(), c.$slider.removeClass("slick-slider"), c.$slider.removeClass("slick-initialized"), c.$slider.removeClass("slick-dotted"), c.unslicked = !0, b || c.$slider.trigger("destroy", [c]);
  }, b.prototype.disableTransition = function (a) {
    var b = this,
        c = {};c[b.transitionType] = "", b.options.fade === !1 ? b.$slideTrack.css(c) : b.$slides.eq(a).css(c);
  }, b.prototype.fadeSlide = function (a, b) {
    var c = this;c.cssTransitions === !1 ? (c.$slides.eq(a).css({ zIndex: c.options.zIndex }), c.$slides.eq(a).animate({ opacity: 1 }, c.options.speed, c.options.easing, b)) : (c.applyTransition(a), c.$slides.eq(a).css({ opacity: 1, zIndex: c.options.zIndex }), b && setTimeout(function () {
      c.disableTransition(a), b.call();
    }, c.options.speed));
  }, b.prototype.fadeSlideOut = function (a) {
    var b = this;b.cssTransitions === !1 ? b.$slides.eq(a).animate({ opacity: 0, zIndex: b.options.zIndex - 2 }, b.options.speed, b.options.easing) : (b.applyTransition(a), b.$slides.eq(a).css({ opacity: 0, zIndex: b.options.zIndex - 2 }));
  }, b.prototype.filterSlides = b.prototype.slickFilter = function (a) {
    var b = this;null !== a && (b.$slidesCache = b.$slides, b.unload(), b.$slideTrack.children(this.options.slide).detach(), b.$slidesCache.filter(a).appendTo(b.$slideTrack), b.reinit());
  }, b.prototype.focusHandler = function () {
    var b = this;b.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*:not(.slick-arrow)", function (c) {
      c.stopImmediatePropagation();var d = a(this);setTimeout(function () {
        b.options.pauseOnFocus && (b.focussed = d.is(":focus"), b.autoPlay());
      }, 0);
    });
  }, b.prototype.getCurrent = b.prototype.slickCurrentSlide = function () {
    var a = this;return a.currentSlide;
  }, b.prototype.getDotCount = function () {
    var a = this,
        b = 0,
        c = 0,
        d = 0;if (a.options.infinite === !0) for (; b < a.slideCount;) {
      ++d, b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
    } else if (a.options.centerMode === !0) d = a.slideCount;else if (a.options.asNavFor) for (; b < a.slideCount;) {
      ++d, b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
    } else d = 1 + Math.ceil((a.slideCount - a.options.slidesToShow) / a.options.slidesToScroll);return d - 1;
  }, b.prototype.getLeft = function (a) {
    var c,
        d,
        f,
        b = this,
        e = 0;return b.slideOffset = 0, d = b.$slides.first().outerHeight(!0), b.options.infinite === !0 ? (b.slideCount > b.options.slidesToShow && (b.slideOffset = b.slideWidth * b.options.slidesToShow * -1, e = d * b.options.slidesToShow * -1), b.slideCount % b.options.slidesToScroll !== 0 && a + b.options.slidesToScroll > b.slideCount && b.slideCount > b.options.slidesToShow && (a > b.slideCount ? (b.slideOffset = (b.options.slidesToShow - (a - b.slideCount)) * b.slideWidth * -1, e = (b.options.slidesToShow - (a - b.slideCount)) * d * -1) : (b.slideOffset = b.slideCount % b.options.slidesToScroll * b.slideWidth * -1, e = b.slideCount % b.options.slidesToScroll * d * -1))) : a + b.options.slidesToShow > b.slideCount && (b.slideOffset = (a + b.options.slidesToShow - b.slideCount) * b.slideWidth, e = (a + b.options.slidesToShow - b.slideCount) * d), b.slideCount <= b.options.slidesToShow && (b.slideOffset = 0, e = 0), b.options.centerMode === !0 && b.options.infinite === !0 ? b.slideOffset += b.slideWidth * Math.floor(b.options.slidesToShow / 2) - b.slideWidth : b.options.centerMode === !0 && (b.slideOffset = 0, b.slideOffset += b.slideWidth * Math.floor(b.options.slidesToShow / 2)), c = b.options.vertical === !1 ? a * b.slideWidth * -1 + b.slideOffset : a * d * -1 + e, b.options.variableWidth === !0 && (f = b.slideCount <= b.options.slidesToShow || b.options.infinite === !1 ? b.$slideTrack.children(".slick-slide").eq(a) : b.$slideTrack.children(".slick-slide").eq(a + b.options.slidesToShow), c = b.options.rtl === !0 ? f[0] ? -1 * (b.$slideTrack.width() - f[0].offsetLeft - f.width()) : 0 : f[0] ? -1 * f[0].offsetLeft : 0, b.options.centerMode === !0 && (f = b.slideCount <= b.options.slidesToShow || b.options.infinite === !1 ? b.$slideTrack.children(".slick-slide").eq(a) : b.$slideTrack.children(".slick-slide").eq(a + b.options.slidesToShow + 1), c = b.options.rtl === !0 ? f[0] ? -1 * (b.$slideTrack.width() - f[0].offsetLeft - f.width()) : 0 : f[0] ? -1 * f[0].offsetLeft : 0, c += (b.$list.width() - f.outerWidth()) / 2)), c;
  }, b.prototype.getOption = b.prototype.slickGetOption = function (a) {
    var b = this;return b.options[a];
  }, b.prototype.getNavigableIndexes = function () {
    var e,
        a = this,
        b = 0,
        c = 0,
        d = [];for (a.options.infinite === !1 ? e = a.slideCount : (b = -1 * a.options.slidesToScroll, c = -1 * a.options.slidesToScroll, e = 2 * a.slideCount); e > b;) {
      d.push(b), b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
    }return d;
  }, b.prototype.getSlick = function () {
    return this;
  }, b.prototype.getSlideCount = function () {
    var c,
        d,
        e,
        b = this;return e = b.options.centerMode === !0 ? b.slideWidth * Math.floor(b.options.slidesToShow / 2) : 0, b.options.swipeToSlide === !0 ? (b.$slideTrack.find(".slick-slide").each(function (c, f) {
      return f.offsetLeft - e + a(f).outerWidth() / 2 > -1 * b.swipeLeft ? (d = f, !1) : void 0;
    }), c = Math.abs(a(d).attr("data-slick-index") - b.currentSlide) || 1) : b.options.slidesToScroll;
  }, b.prototype.goTo = b.prototype.slickGoTo = function (a, b) {
    var c = this;c.changeSlide({ data: { message: "index", index: parseInt(a) } }, b);
  }, b.prototype.init = function (b) {
    var c = this;a(c.$slider).hasClass("slick-initialized") || (a(c.$slider).addClass("slick-initialized"), c.buildRows(), c.buildOut(), c.setProps(), c.startLoad(), c.loadSlider(), c.initializeEvents(), c.updateArrows(), c.updateDots(), c.checkResponsive(!0), c.focusHandler()), b && c.$slider.trigger("init", [c]), c.options.accessibility === !0 && c.initADA(), c.options.autoplay && (c.paused = !1, c.autoPlay());
  }, b.prototype.initADA = function () {
    var b = this;b.$slides.add(b.$slideTrack.find(".slick-cloned")).attr({ "aria-hidden": "true", tabindex: "-1" }).find("a, input, button, select").attr({ tabindex: "-1" }), b.$slideTrack.attr("role", "listbox"), b.$slides.not(b.$slideTrack.find(".slick-cloned")).each(function (c) {
      a(this).attr({ role: "option", "aria-describedby": "slick-slide" + b.instanceUid + c });
    }), null !== b.$dots && b.$dots.attr("role", "tablist").find("li").each(function (c) {
      a(this).attr({ role: "presentation", "aria-selected": "false", "aria-controls": "navigation" + b.instanceUid + c, id: "slick-slide" + b.instanceUid + c });
    }).first().attr("aria-selected", "true").end().find("button").attr("role", "button").end().closest("div").attr("role", "toolbar"), b.activateADA();
  }, b.prototype.initArrowEvents = function () {
    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.off("click.slick").on("click.slick", { message: "previous" }, a.changeSlide), a.$nextArrow.off("click.slick").on("click.slick", { message: "next" }, a.changeSlide));
  }, b.prototype.initDotEvents = function () {
    var b = this;b.options.dots === !0 && b.slideCount > b.options.slidesToShow && a("li", b.$dots).on("click.slick", { message: "index" }, b.changeSlide), b.options.dots === !0 && b.options.pauseOnDotsHover === !0 && a("li", b.$dots).on("mouseenter.slick", a.proxy(b.interrupt, b, !0)).on("mouseleave.slick", a.proxy(b.interrupt, b, !1));
  }, b.prototype.initSlideEvents = function () {
    var b = this;b.options.pauseOnHover && (b.$list.on("mouseenter.slick", a.proxy(b.interrupt, b, !0)), b.$list.on("mouseleave.slick", a.proxy(b.interrupt, b, !1)));
  }, b.prototype.initializeEvents = function () {
    var b = this;b.initArrowEvents(), b.initDotEvents(), b.initSlideEvents(), b.$list.on("touchstart.slick mousedown.slick", { action: "start" }, b.swipeHandler), b.$list.on("touchmove.slick mousemove.slick", { action: "move" }, b.swipeHandler), b.$list.on("touchend.slick mouseup.slick", { action: "end" }, b.swipeHandler), b.$list.on("touchcancel.slick mouseleave.slick", { action: "end" }, b.swipeHandler), b.$list.on("click.slick", b.clickHandler), a(document).on(b.visibilityChange, a.proxy(b.visibility, b)), b.options.accessibility === !0 && b.$list.on("keydown.slick", b.keyHandler), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().on("click.slick", b.selectHandler), a(window).on("orientationchange.slick.slick-" + b.instanceUid, a.proxy(b.orientationChange, b)), a(window).on("resize.slick.slick-" + b.instanceUid, a.proxy(b.resize, b)), a("[draggable!=true]", b.$slideTrack).on("dragstart", b.preventDefault), a(window).on("load.slick.slick-" + b.instanceUid, b.setPosition), a(document).on("ready.slick.slick-" + b.instanceUid, b.setPosition);
  }, b.prototype.initUI = function () {
    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.show(), a.$nextArrow.show()), a.options.dots === !0 && a.slideCount > a.options.slidesToShow && a.$dots.show();
  }, b.prototype.keyHandler = function (a) {
    var b = this;a.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === a.keyCode && b.options.accessibility === !0 ? b.changeSlide({ data: { message: b.options.rtl === !0 ? "next" : "previous" } }) : 39 === a.keyCode && b.options.accessibility === !0 && b.changeSlide({ data: { message: b.options.rtl === !0 ? "previous" : "next" } }));
  }, b.prototype.lazyLoad = function () {
    function g(c) {
      a("img[data-lazy]", c).each(function () {
        var c = a(this),
            d = a(this).attr("data-lazy"),
            e = document.createElement("img");e.onload = function () {
          c.animate({ opacity: 0 }, 100, function () {
            c.attr("src", d).animate({ opacity: 1 }, 200, function () {
              c.removeAttr("data-lazy").removeClass("slick-loading");
            }), b.$slider.trigger("lazyLoaded", [b, c, d]);
          });
        }, e.onerror = function () {
          c.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), b.$slider.trigger("lazyLoadError", [b, c, d]);
        }, e.src = d;
      });
    }var c,
        d,
        e,
        f,
        b = this;b.options.centerMode === !0 ? b.options.infinite === !0 ? (e = b.currentSlide + (b.options.slidesToShow / 2 + 1), f = e + b.options.slidesToShow + 2) : (e = Math.max(0, b.currentSlide - (b.options.slidesToShow / 2 + 1)), f = 2 + (b.options.slidesToShow / 2 + 1) + b.currentSlide) : (e = b.options.infinite ? b.options.slidesToShow + b.currentSlide : b.currentSlide, f = Math.ceil(e + b.options.slidesToShow), b.options.fade === !0 && (e > 0 && e--, f <= b.slideCount && f++)), c = b.$slider.find(".slick-slide").slice(e, f), g(c), b.slideCount <= b.options.slidesToShow ? (d = b.$slider.find(".slick-slide"), g(d)) : b.currentSlide >= b.slideCount - b.options.slidesToShow ? (d = b.$slider.find(".slick-cloned").slice(0, b.options.slidesToShow), g(d)) : 0 === b.currentSlide && (d = b.$slider.find(".slick-cloned").slice(-1 * b.options.slidesToShow), g(d));
  }, b.prototype.loadSlider = function () {
    var a = this;a.setPosition(), a.$slideTrack.css({ opacity: 1 }), a.$slider.removeClass("slick-loading"), a.initUI(), "progressive" === a.options.lazyLoad && a.progressiveLazyLoad();
  }, b.prototype.next = b.prototype.slickNext = function () {
    var a = this;a.changeSlide({ data: { message: "next" } });
  }, b.prototype.orientationChange = function () {
    var a = this;a.checkResponsive(), a.setPosition();
  }, b.prototype.pause = b.prototype.slickPause = function () {
    var a = this;a.autoPlayClear(), a.paused = !0;
  }, b.prototype.play = b.prototype.slickPlay = function () {
    var a = this;a.autoPlay(), a.options.autoplay = !0, a.paused = !1, a.focussed = !1, a.interrupted = !1;
  }, b.prototype.postSlide = function (a) {
    var b = this;b.unslicked || (b.$slider.trigger("afterChange", [b, a]), b.animating = !1, b.setPosition(), b.swipeLeft = null, b.options.autoplay && b.autoPlay(), b.options.accessibility === !0 && b.initADA());
  }, b.prototype.prev = b.prototype.slickPrev = function () {
    var a = this;a.changeSlide({ data: { message: "previous" } });
  }, b.prototype.preventDefault = function (a) {
    a.preventDefault();
  }, b.prototype.progressiveLazyLoad = function (b) {
    b = b || 1;var e,
        f,
        g,
        c = this,
        d = a("img[data-lazy]", c.$slider);d.length ? (e = d.first(), f = e.attr("data-lazy"), g = document.createElement("img"), g.onload = function () {
      e.attr("src", f).removeAttr("data-lazy").removeClass("slick-loading"), c.options.adaptiveHeight === !0 && c.setPosition(), c.$slider.trigger("lazyLoaded", [c, e, f]), c.progressiveLazyLoad();
    }, g.onerror = function () {
      3 > b ? setTimeout(function () {
        c.progressiveLazyLoad(b + 1);
      }, 500) : (e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), c.$slider.trigger("lazyLoadError", [c, e, f]), c.progressiveLazyLoad());
    }, g.src = f) : c.$slider.trigger("allImagesLoaded", [c]);
  }, b.prototype.refresh = function (b) {
    var d,
        e,
        c = this;e = c.slideCount - c.options.slidesToShow, !c.options.infinite && c.currentSlide > e && (c.currentSlide = e), c.slideCount <= c.options.slidesToShow && (c.currentSlide = 0), d = c.currentSlide, c.destroy(!0), a.extend(c, c.initials, { currentSlide: d }), c.init(), b || c.changeSlide({ data: { message: "index", index: d } }, !1);
  }, b.prototype.registerBreakpoints = function () {
    var c,
        d,
        e,
        b = this,
        f = b.options.responsive || null;if ("array" === a.type(f) && f.length) {
      b.respondTo = b.options.respondTo || "window";for (c in f) {
        if (e = b.breakpoints.length - 1, d = f[c].breakpoint, f.hasOwnProperty(c)) {
          for (; e >= 0;) {
            b.breakpoints[e] && b.breakpoints[e] === d && b.breakpoints.splice(e, 1), e--;
          }b.breakpoints.push(d), b.breakpointSettings[d] = f[c].settings;
        }
      }b.breakpoints.sort(function (a, c) {
        return b.options.mobileFirst ? a - c : c - a;
      });
    }
  }, b.prototype.reinit = function () {
    var b = this;b.$slides = b.$slideTrack.children(b.options.slide).addClass("slick-slide"), b.slideCount = b.$slides.length, b.currentSlide >= b.slideCount && 0 !== b.currentSlide && (b.currentSlide = b.currentSlide - b.options.slidesToScroll), b.slideCount <= b.options.slidesToShow && (b.currentSlide = 0), b.registerBreakpoints(), b.setProps(), b.setupInfinite(), b.buildArrows(), b.updateArrows(), b.initArrowEvents(), b.buildDots(), b.updateDots(), b.initDotEvents(), b.cleanUpSlideEvents(), b.initSlideEvents(), b.checkResponsive(!1, !0), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().on("click.slick", b.selectHandler), b.setSlideClasses("number" == typeof b.currentSlide ? b.currentSlide : 0), b.setPosition(), b.focusHandler(), b.paused = !b.options.autoplay, b.autoPlay(), b.$slider.trigger("reInit", [b]);
  }, b.prototype.resize = function () {
    var b = this;a(window).width() !== b.windowWidth && (clearTimeout(b.windowDelay), b.windowDelay = window.setTimeout(function () {
      b.windowWidth = a(window).width(), b.checkResponsive(), b.unslicked || b.setPosition();
    }, 50));
  }, b.prototype.removeSlide = b.prototype.slickRemove = function (a, b, c) {
    var d = this;return "boolean" == typeof a ? (b = a, a = b === !0 ? 0 : d.slideCount - 1) : a = b === !0 ? --a : a, d.slideCount < 1 || 0 > a || a > d.slideCount - 1 ? !1 : (d.unload(), c === !0 ? d.$slideTrack.children().remove() : d.$slideTrack.children(this.options.slide).eq(a).remove(), d.$slides = d.$slideTrack.children(this.options.slide), d.$slideTrack.children(this.options.slide).detach(), d.$slideTrack.append(d.$slides), d.$slidesCache = d.$slides, void d.reinit());
  }, b.prototype.setCSS = function (a) {
    var d,
        e,
        b = this,
        c = {};b.options.rtl === !0 && (a = -a), d = "left" == b.positionProp ? Math.ceil(a) + "px" : "0px", e = "top" == b.positionProp ? Math.ceil(a) + "px" : "0px", c[b.positionProp] = a, b.transformsEnabled === !1 ? b.$slideTrack.css(c) : (c = {}, b.cssTransitions === !1 ? (c[b.animType] = "translate(" + d + ", " + e + ")", b.$slideTrack.css(c)) : (c[b.animType] = "translate3d(" + d + ", " + e + ", 0px)", b.$slideTrack.css(c)));
  }, b.prototype.setDimensions = function () {
    var a = this;a.options.vertical === !1 ? a.options.centerMode === !0 && a.$list.css({ padding: "0px " + a.options.centerPadding }) : (a.$list.height(a.$slides.first().outerHeight(!0) * a.options.slidesToShow), a.options.centerMode === !0 && a.$list.css({ padding: a.options.centerPadding + " 0px" })), a.listWidth = a.$list.width(), a.listHeight = a.$list.height(), a.options.vertical === !1 && a.options.variableWidth === !1 ? (a.slideWidth = Math.ceil(a.listWidth / a.options.slidesToShow), a.$slideTrack.width(Math.ceil(a.slideWidth * a.$slideTrack.children(".slick-slide").length))) : a.options.variableWidth === !0 ? a.$slideTrack.width(5e3 * a.slideCount) : (a.slideWidth = Math.ceil(a.listWidth), a.$slideTrack.height(Math.ceil(a.$slides.first().outerHeight(!0) * a.$slideTrack.children(".slick-slide").length)));var b = a.$slides.first().outerWidth(!0) - a.$slides.first().width();a.options.variableWidth === !1 && a.$slideTrack.children(".slick-slide").width(a.slideWidth - b);
  }, b.prototype.setFade = function () {
    var c,
        b = this;b.$slides.each(function (d, e) {
      c = b.slideWidth * d * -1, b.options.rtl === !0 ? a(e).css({ position: "relative", right: c, top: 0, zIndex: b.options.zIndex - 2, opacity: 0 }) : a(e).css({ position: "relative", left: c, top: 0, zIndex: b.options.zIndex - 2, opacity: 0 });
    }), b.$slides.eq(b.currentSlide).css({ zIndex: b.options.zIndex - 1, opacity: 1 });
  }, b.prototype.setHeight = function () {
    var a = this;if (1 === a.options.slidesToShow && a.options.adaptiveHeight === !0 && a.options.vertical === !1) {
      var b = a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.css("height", b);
    }
  }, b.prototype.setOption = b.prototype.slickSetOption = function () {
    var c,
        d,
        e,
        f,
        h,
        b = this,
        g = !1;if ("object" === a.type(arguments[0]) ? (e = arguments[0], g = arguments[1], h = "multiple") : "string" === a.type(arguments[0]) && (e = arguments[0], f = arguments[1], g = arguments[2], "responsive" === arguments[0] && "array" === a.type(arguments[1]) ? h = "responsive" : "undefined" != typeof arguments[1] && (h = "single")), "single" === h) b.options[e] = f;else if ("multiple" === h) a.each(e, function (a, c) {
      b.options[a] = c;
    });else if ("responsive" === h) for (d in f) {
      if ("array" !== a.type(b.options.responsive)) b.options.responsive = [f[d]];else {
        for (c = b.options.responsive.length - 1; c >= 0;) {
          b.options.responsive[c].breakpoint === f[d].breakpoint && b.options.responsive.splice(c, 1), c--;
        }b.options.responsive.push(f[d]);
      }
    }g && (b.unload(), b.reinit());
  }, b.prototype.setPosition = function () {
    var a = this;a.setDimensions(), a.setHeight(), a.options.fade === !1 ? a.setCSS(a.getLeft(a.currentSlide)) : a.setFade(), a.$slider.trigger("setPosition", [a]);
  }, b.prototype.setProps = function () {
    var a = this,
        b = document.body.style;a.positionProp = a.options.vertical === !0 ? "top" : "left", "top" === a.positionProp ? a.$slider.addClass("slick-vertical") : a.$slider.removeClass("slick-vertical"), (void 0 !== b.WebkitTransition || void 0 !== b.MozTransition || void 0 !== b.msTransition) && a.options.useCSS === !0 && (a.cssTransitions = !0), a.options.fade && ("number" == typeof a.options.zIndex ? a.options.zIndex < 3 && (a.options.zIndex = 3) : a.options.zIndex = a.defaults.zIndex), void 0 !== b.OTransform && (a.animType = "OTransform", a.transformType = "-o-transform", a.transitionType = "OTransition", void 0 === b.perspectiveProperty && void 0 === b.webkitPerspective && (a.animType = !1)), void 0 !== b.MozTransform && (a.animType = "MozTransform", a.transformType = "-moz-transform", a.transitionType = "MozTransition", void 0 === b.perspectiveProperty && void 0 === b.MozPerspective && (a.animType = !1)), void 0 !== b.webkitTransform && (a.animType = "webkitTransform", a.transformType = "-webkit-transform", a.transitionType = "webkitTransition", void 0 === b.perspectiveProperty && void 0 === b.webkitPerspective && (a.animType = !1)), void 0 !== b.msTransform && (a.animType = "msTransform", a.transformType = "-ms-transform", a.transitionType = "msTransition", void 0 === b.msTransform && (a.animType = !1)), void 0 !== b.transform && a.animType !== !1 && (a.animType = "transform", a.transformType = "transform", a.transitionType = "transition"), a.transformsEnabled = a.options.useTransform && null !== a.animType && a.animType !== !1;
  }, b.prototype.setSlideClasses = function (a) {
    var c,
        d,
        e,
        f,
        b = this;d = b.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), b.$slides.eq(a).addClass("slick-current"), b.options.centerMode === !0 ? (c = Math.floor(b.options.slidesToShow / 2), b.options.infinite === !0 && (a >= c && a <= b.slideCount - 1 - c ? b.$slides.slice(a - c, a + c + 1).addClass("slick-active").attr("aria-hidden", "false") : (e = b.options.slidesToShow + a, d.slice(e - c + 1, e + c + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === a ? d.eq(d.length - 1 - b.options.slidesToShow).addClass("slick-center") : a === b.slideCount - 1 && d.eq(b.options.slidesToShow).addClass("slick-center")), b.$slides.eq(a).addClass("slick-center")) : a >= 0 && a <= b.slideCount - b.options.slidesToShow ? b.$slides.slice(a, a + b.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : d.length <= b.options.slidesToShow ? d.addClass("slick-active").attr("aria-hidden", "false") : (f = b.slideCount % b.options.slidesToShow, e = b.options.infinite === !0 ? b.options.slidesToShow + a : a, b.options.slidesToShow == b.options.slidesToScroll && b.slideCount - a < b.options.slidesToShow ? d.slice(e - (b.options.slidesToShow - f), e + f).addClass("slick-active").attr("aria-hidden", "false") : d.slice(e, e + b.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false")), "ondemand" === b.options.lazyLoad && b.lazyLoad();
  }, b.prototype.setupInfinite = function () {
    var c,
        d,
        e,
        b = this;if (b.options.fade === !0 && (b.options.centerMode = !1), b.options.infinite === !0 && b.options.fade === !1 && (d = null, b.slideCount > b.options.slidesToShow)) {
      for (e = b.options.centerMode === !0 ? b.options.slidesToShow + 1 : b.options.slidesToShow, c = b.slideCount; c > b.slideCount - e; c -= 1) {
        d = c - 1, a(b.$slides[d]).clone(!0).attr("id", "").attr("data-slick-index", d - b.slideCount).prependTo(b.$slideTrack).addClass("slick-cloned");
      }for (c = 0; e > c; c += 1) {
        d = c, a(b.$slides[d]).clone(!0).attr("id", "").attr("data-slick-index", d + b.slideCount).appendTo(b.$slideTrack).addClass("slick-cloned");
      }b.$slideTrack.find(".slick-cloned").find("[id]").each(function () {
        a(this).attr("id", "");
      });
    }
  }, b.prototype.interrupt = function (a) {
    var b = this;a || b.autoPlay(), b.interrupted = a;
  }, b.prototype.selectHandler = function (b) {
    var c = this,
        d = a(b.target).is(".slick-slide") ? a(b.target) : a(b.target).parents(".slick-slide"),
        e = parseInt(d.attr("data-slick-index"));return e || (e = 0), c.slideCount <= c.options.slidesToShow ? (c.setSlideClasses(e), void c.asNavFor(e)) : void c.slideHandler(e);
  }, b.prototype.slideHandler = function (a, b, c) {
    var d,
        e,
        f,
        g,
        j,
        h = null,
        i = this;return b = b || !1, i.animating === !0 && i.options.waitForAnimate === !0 || i.options.fade === !0 && i.currentSlide === a || i.slideCount <= i.options.slidesToShow ? void 0 : (b === !1 && i.asNavFor(a), d = a, h = i.getLeft(d), g = i.getLeft(i.currentSlide), i.currentLeft = null === i.swipeLeft ? g : i.swipeLeft, i.options.infinite === !1 && i.options.centerMode === !1 && (0 > a || a > i.getDotCount() * i.options.slidesToScroll) ? void (i.options.fade === !1 && (d = i.currentSlide, c !== !0 ? i.animateSlide(g, function () {
      i.postSlide(d);
    }) : i.postSlide(d))) : i.options.infinite === !1 && i.options.centerMode === !0 && (0 > a || a > i.slideCount - i.options.slidesToScroll) ? void (i.options.fade === !1 && (d = i.currentSlide, c !== !0 ? i.animateSlide(g, function () {
      i.postSlide(d);
    }) : i.postSlide(d))) : (i.options.autoplay && clearInterval(i.autoPlayTimer), e = 0 > d ? i.slideCount % i.options.slidesToScroll !== 0 ? i.slideCount - i.slideCount % i.options.slidesToScroll : i.slideCount + d : d >= i.slideCount ? i.slideCount % i.options.slidesToScroll !== 0 ? 0 : d - i.slideCount : d, i.animating = !0, i.$slider.trigger("beforeChange", [i, i.currentSlide, e]), f = i.currentSlide, i.currentSlide = e, i.setSlideClasses(i.currentSlide), i.options.asNavFor && (j = i.getNavTarget(), j = j.slick("getSlick"), j.slideCount <= j.options.slidesToShow && j.setSlideClasses(i.currentSlide)), i.updateDots(), i.updateArrows(), i.options.fade === !0 ? (c !== !0 ? (i.fadeSlideOut(f), i.fadeSlide(e, function () {
      i.postSlide(e);
    })) : i.postSlide(e), void i.animateHeight()) : void (c !== !0 ? i.animateSlide(h, function () {
      i.postSlide(e);
    }) : i.postSlide(e))));
  }, b.prototype.startLoad = function () {
    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.hide(), a.$nextArrow.hide()), a.options.dots === !0 && a.slideCount > a.options.slidesToShow && a.$dots.hide(), a.$slider.addClass("slick-loading");
  }, b.prototype.swipeDirection = function () {
    var a,
        b,
        c,
        d,
        e = this;return a = e.touchObject.startX - e.touchObject.curX, b = e.touchObject.startY - e.touchObject.curY, c = Math.atan2(b, a), d = Math.round(180 * c / Math.PI), 0 > d && (d = 360 - Math.abs(d)), 45 >= d && d >= 0 ? e.options.rtl === !1 ? "left" : "right" : 360 >= d && d >= 315 ? e.options.rtl === !1 ? "left" : "right" : d >= 135 && 225 >= d ? e.options.rtl === !1 ? "right" : "left" : e.options.verticalSwiping === !0 ? d >= 35 && 135 >= d ? "down" : "up" : "vertical";
  }, b.prototype.swipeEnd = function (a) {
    var c,
        d,
        b = this;if (b.dragging = !1, b.interrupted = !1, b.shouldClick = b.touchObject.swipeLength > 10 ? !1 : !0, void 0 === b.touchObject.curX) return !1;if (b.touchObject.edgeHit === !0 && b.$slider.trigger("edge", [b, b.swipeDirection()]), b.touchObject.swipeLength >= b.touchObject.minSwipe) {
      switch (d = b.swipeDirection()) {case "left":case "down":
          c = b.options.swipeToSlide ? b.checkNavigable(b.currentSlide + b.getSlideCount()) : b.currentSlide + b.getSlideCount(), b.currentDirection = 0;break;case "right":case "up":
          c = b.options.swipeToSlide ? b.checkNavigable(b.currentSlide - b.getSlideCount()) : b.currentSlide - b.getSlideCount(), b.currentDirection = 1;}"vertical" != d && (b.slideHandler(c), b.touchObject = {}, b.$slider.trigger("swipe", [b, d]));
    } else b.touchObject.startX !== b.touchObject.curX && (b.slideHandler(b.currentSlide), b.touchObject = {});
  }, b.prototype.swipeHandler = function (a) {
    var b = this;if (!(b.options.swipe === !1 || "ontouchend" in document && b.options.swipe === !1 || b.options.draggable === !1 && -1 !== a.type.indexOf("mouse"))) switch (b.touchObject.fingerCount = a.originalEvent && void 0 !== a.originalEvent.touches ? a.originalEvent.touches.length : 1, b.touchObject.minSwipe = b.listWidth / b.options.touchThreshold, b.options.verticalSwiping === !0 && (b.touchObject.minSwipe = b.listHeight / b.options.touchThreshold), a.data.action) {case "start":
        b.swipeStart(a);break;case "move":
        b.swipeMove(a);break;case "end":
        b.swipeEnd(a);}
  }, b.prototype.swipeMove = function (a) {
    var d,
        e,
        f,
        g,
        h,
        b = this;return h = void 0 !== a.originalEvent ? a.originalEvent.touches : null, !b.dragging || h && 1 !== h.length ? !1 : (d = b.getLeft(b.currentSlide), b.touchObject.curX = void 0 !== h ? h[0].pageX : a.clientX, b.touchObject.curY = void 0 !== h ? h[0].pageY : a.clientY, b.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(b.touchObject.curX - b.touchObject.startX, 2))), b.options.verticalSwiping === !0 && (b.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(b.touchObject.curY - b.touchObject.startY, 2)))), e = b.swipeDirection(), "vertical" !== e ? (void 0 !== a.originalEvent && b.touchObject.swipeLength > 4 && a.preventDefault(), g = (b.options.rtl === !1 ? 1 : -1) * (b.touchObject.curX > b.touchObject.startX ? 1 : -1), b.options.verticalSwiping === !0 && (g = b.touchObject.curY > b.touchObject.startY ? 1 : -1), f = b.touchObject.swipeLength, b.touchObject.edgeHit = !1, b.options.infinite === !1 && (0 === b.currentSlide && "right" === e || b.currentSlide >= b.getDotCount() && "left" === e) && (f = b.touchObject.swipeLength * b.options.edgeFriction, b.touchObject.edgeHit = !0), b.options.vertical === !1 ? b.swipeLeft = d + f * g : b.swipeLeft = d + f * (b.$list.height() / b.listWidth) * g, b.options.verticalSwiping === !0 && (b.swipeLeft = d + f * g), b.options.fade === !0 || b.options.touchMove === !1 ? !1 : b.animating === !0 ? (b.swipeLeft = null, !1) : void b.setCSS(b.swipeLeft)) : void 0);
  }, b.prototype.swipeStart = function (a) {
    var c,
        b = this;return b.interrupted = !0, 1 !== b.touchObject.fingerCount || b.slideCount <= b.options.slidesToShow ? (b.touchObject = {}, !1) : (void 0 !== a.originalEvent && void 0 !== a.originalEvent.touches && (c = a.originalEvent.touches[0]), b.touchObject.startX = b.touchObject.curX = void 0 !== c ? c.pageX : a.clientX, b.touchObject.startY = b.touchObject.curY = void 0 !== c ? c.pageY : a.clientY, void (b.dragging = !0));
  }, b.prototype.unfilterSlides = b.prototype.slickUnfilter = function () {
    var a = this;null !== a.$slidesCache && (a.unload(), a.$slideTrack.children(this.options.slide).detach(), a.$slidesCache.appendTo(a.$slideTrack), a.reinit());
  }, b.prototype.unload = function () {
    var b = this;a(".slick-cloned", b.$slider).remove(), b.$dots && b.$dots.remove(), b.$prevArrow && b.htmlExpr.test(b.options.prevArrow) && b.$prevArrow.remove(), b.$nextArrow && b.htmlExpr.test(b.options.nextArrow) && b.$nextArrow.remove(), b.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "");
  }, b.prototype.unslick = function (a) {
    var b = this;b.$slider.trigger("unslick", [b, a]), b.destroy();
  }, b.prototype.updateArrows = function () {
    var b,
        a = this;b = Math.floor(a.options.slidesToShow / 2), a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && !a.options.infinite && (a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === a.currentSlide ? (a.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : a.currentSlide >= a.slideCount - a.options.slidesToShow && a.options.centerMode === !1 ? (a.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : a.currentSlide >= a.slideCount - 1 && a.options.centerMode === !0 && (a.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")));
  }, b.prototype.updateDots = function () {
    var a = this;null !== a.$dots && (a.$dots.find("li").removeClass("slick-active").attr("aria-hidden", "true"), a.$dots.find("li").eq(Math.floor(a.currentSlide / a.options.slidesToScroll)).addClass("slick-active").attr("aria-hidden", "false"));
  }, b.prototype.visibility = function () {
    var a = this;a.options.autoplay && (document[a.hidden] ? a.interrupted = !0 : a.interrupted = !1);
  }, a.fn.slick = function () {
    var f,
        g,
        a = this,
        c = arguments[0],
        d = Array.prototype.slice.call(arguments, 1),
        e = a.length;for (f = 0; e > f; f++) {
      if ("object" == typeof c || "undefined" == typeof c ? a[f].slick = new b(a[f], c) : g = a[f].slick[c].apply(a[f].slick, d), "undefined" != typeof g) return g;
    }return a;
  };
});
;"use strict";

/*! purl v2.3.1 | MIT */
(function (factory) {
  if (typeof define === "function" && define.amd) {
    define(factory);
  } else {
    window.purl = factory();
  }
})(function () {
  var tag2attr = { a: "href", img: "src", form: "action", base: "href", script: "src", iframe: "src", link: "href" },
      key = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "fragment"],
      aliases = { anchor: "fragment" },
      parser = { strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ },
      isint = /^[0-9]+$/;function parseUri(url, strictMode) {
    var str = decodeURI(url),
        res = parser[strictMode || false ? "strict" : "loose"].exec(str),
        uri = { attr: {}, param: {}, seg: {} },
        i = 14;while (i--) {
      uri.attr[key[i]] = res[i] || "";
    }uri.param["query"] = parseString(uri.attr["query"]);uri.param["fragment"] = parseString(uri.attr["fragment"]);uri.seg["path"] = uri.attr.path.replace(/^\/+|\/+$/g, "").split("/");uri.seg["fragment"] = uri.attr.fragment.replace(/^\/+|\/+$/g, "").split("/");uri.attr["base"] = uri.attr.host ? (uri.attr.protocol ? uri.attr.protocol + "://" + uri.attr.host : uri.attr.host) + (uri.attr.port ? ":" + uri.attr.port : "") : "";return uri;
  }function getAttrName(elm) {
    var tn = elm.tagName;if (typeof tn !== "undefined") return tag2attr[tn.toLowerCase()];return tn;
  }function promote(parent, key) {
    if (parent[key].length === 0) return parent[key] = {};var t = {};for (var i in parent[key]) {
      t[i] = parent[key][i];
    }parent[key] = t;return t;
  }function parse(parts, parent, key, val) {
    var part = parts.shift();if (!part) {
      if (isArray(parent[key])) {
        parent[key].push(val);
      } else if ("object" == typeof parent[key]) {
        parent[key] = val;
      } else if ("undefined" == typeof parent[key]) {
        parent[key] = val;
      } else {
        parent[key] = [parent[key], val];
      }
    } else {
      var obj = parent[key] = parent[key] || [];if ("]" == part) {
        if (isArray(obj)) {
          if ("" !== val) obj.push(val);
        } else if ("object" == typeof obj) {
          obj[keys(obj).length] = val;
        } else {
          obj = parent[key] = [parent[key], val];
        }
      } else if (~part.indexOf("]")) {
        part = part.substr(0, part.length - 1);if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);parse(parts, obj, part, val);
      } else {
        if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);parse(parts, obj, part, val);
      }
    }
  }function merge(parent, key, val) {
    if (~key.indexOf("]")) {
      var parts = key.split("[");parse(parts, parent, "base", val);
    } else {
      if (!isint.test(key) && isArray(parent.base)) {
        var t = {};for (var k in parent.base) {
          t[k] = parent.base[k];
        }parent.base = t;
      }if (key !== "") {
        set(parent.base, key, val);
      }
    }return parent;
  }function parseString(str) {
    return reduce(String(str).split(/&|;/), function (ret, pair) {
      try {
        pair = decodeURIComponent(pair.replace(/\+/g, " "));
      } catch (e) {}var eql = pair.indexOf("="),
          brace = lastBraceInKey(pair),
          key = pair.substr(0, brace || eql),
          val = pair.substr(brace || eql, pair.length);val = val.substr(val.indexOf("=") + 1, val.length);if (key === "") {
        key = pair;val = "";
      }return merge(ret, key, val);
    }, { base: {} }).base;
  }function set(obj, key, val) {
    var v = obj[key];if (typeof v === "undefined") {
      obj[key] = val;
    } else if (isArray(v)) {
      v.push(val);
    } else {
      obj[key] = [v, val];
    }
  }function lastBraceInKey(str) {
    var len = str.length,
        brace,
        c;for (var i = 0; i < len; ++i) {
      c = str[i];if ("]" == c) brace = false;if ("[" == c) brace = true;if ("=" == c && !brace) return i;
    }
  }function reduce(obj, accumulator) {
    var i = 0,
        l = obj.length >> 0,
        curr = arguments[2];while (i < l) {
      if (i in obj) curr = accumulator.call(undefined, curr, obj[i], i, obj);++i;
    }return curr;
  }function isArray(vArg) {
    return Object.prototype.toString.call(vArg) === "[object Array]";
  }function keys(obj) {
    var key_array = [];for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) key_array.push(prop);
    }return key_array;
  }function purl(url, strictMode) {
    if (arguments.length === 1 && url === true) {
      strictMode = true;url = undefined;
    }strictMode = strictMode || false;url = url || window.location.toString();return { data: parseUri(url, strictMode), attr: function (attr) {
        attr = aliases[attr] || attr;return typeof attr !== "undefined" ? this.data.attr[attr] : this.data.attr;
      }, param: function (param) {
        return typeof param !== "undefined" ? this.data.param.query[param] : this.data.param.query;
      }, fparam: function (param) {
        return typeof param !== "undefined" ? this.data.param.fragment[param] : this.data.param.fragment;
      }, segment: function (seg) {
        if (typeof seg === "undefined") {
          return this.data.seg.path;
        } else {
          seg = seg < 0 ? this.data.seg.path.length + seg : seg - 1;return this.data.seg.path[seg];
        }
      }, fsegment: function (seg) {
        if (typeof seg === "undefined") {
          return this.data.seg.fragment;
        } else {
          seg = seg < 0 ? this.data.seg.fragment.length + seg : seg - 1;return this.data.seg.fragment[seg];
        }
      } };
  }purl.jQuery = function ($) {
    if ($ != null) {
      $.fn.url = function (strictMode) {
        var url = "";if (this.length) {
          url = $(this).attr(getAttrName(this[0])) || "";
        }return purl(url, strictMode);
      };$.url = purl;
    }
  };purl.jQuery(window.jQuery);return purl;
});
;"use strict";

/*
 Sticky-kit v1.1.2 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
*/
(function () {
  var b, f;b = this.jQuery || window.jQuery;f = b(window);b.fn.stick_in_parent = function (d) {
    var A, w, J, n, B, K, p, q, k, E, t;null == d && (d = {});t = d.sticky_class;B = d.inner_scrolling;E = d.recalc_every;k = d.parent;q = d.offset_top;p = d.spacer;w = d.bottoming;null == q && (q = 0);null == k && (k = void 0);null == B && (B = !0);null == t && (t = "is_stuck");A = b(document);null == w && (w = !0);J = function (a, d, n, C, F, u, r, G) {
      var v, H, m, D, I, c, g, x, y, z, h, l;if (!a.data("sticky_kit")) {
        a.data("sticky_kit", !0);I = A.height();g = a.parent();null != k && (g = g.closest(k));
        if (!g.length) throw "failed to find stick parent";v = m = !1;(h = null != p ? p && a.closest(p) : b("<div />")) && h.css("position", a.css("position"));x = function () {
          var c, f, e;if (!G && (I = A.height(), c = parseInt(g.css("border-top-width"), 10), f = parseInt(g.css("padding-top"), 10), d = parseInt(g.css("padding-bottom"), 10), n = g.offset().top + c + f, C = g.height(), m && (v = m = !1, null == p && (a.insertAfter(h), h.detach()), a.css({ position: "", top: "", width: "", bottom: "" }).removeClass(t), e = !0), F = a.offset().top - (parseInt(a.css("margin-top"), 10) || 0) - q, u = a.outerHeight(!0), r = a.css("float"), h && h.css({ width: a.outerWidth(!0), height: u, display: a.css("display"), "vertical-align": a.css("vertical-align"), "float": r }), e)) return l();
        };x();if (u !== C) return D = void 0, c = q, z = E, l = function () {
          var b, l, e, k;if (!G && (e = !1, null != z && (--z, 0 >= z && (z = E, x(), e = !0)), e || A.height() === I || x(), e = f.scrollTop(), null != D && (l = e - D), D = e, m ? (w && (k = e + u + c > C + n, v && !k && (v = !1, a.css({ position: "fixed", bottom: "", top: c }).trigger("sticky_kit:unbottom"))), e < F && (m = !1, c = q, null == p && ("left" !== r && "right" !== r || a.insertAfter(h), h.detach()), b = { position: "", width: "", top: "" }, a.css(b).removeClass(t).trigger("sticky_kit:unstick")), B && (b = f.height(), u + q > b && !v && (c -= l, c = Math.max(b - u, c), c = Math.min(q, c), m && a.css({ top: c + "px" })))) : e > F && (m = !0, b = { position: "fixed", top: c }, b.width = "border-box" === a.css("box-sizing") ? a.outerWidth() + "px" : a.width() + "px", a.css(b).addClass(t), null == p && (a.after(h), "left" !== r && "right" !== r || h.append(a)), a.trigger("sticky_kit:stick")), m && w && (null == k && (k = e + u + c > C + n), !v && k))) return v = !0, "static" === g.css("position") && g.css({ position: "relative" }), a.css({ position: "absolute", bottom: d, top: "auto" }).trigger("sticky_kit:bottom");
        }, y = function () {
          x();return l();
        }, H = function () {
          G = !0;f.off("touchmove", l);f.off("scroll", l);f.off("resize", y);b(document.body).off("sticky_kit:recalc", y);a.off("sticky_kit:detach", H);a.removeData("sticky_kit");a.css({ position: "", bottom: "", top: "", width: "" });g.position("position", "");if (m) return null == p && ("left" !== r && "right" !== r || a.insertAfter(h), h.remove()), a.removeClass(t);
        }, f.on("touchmove", l), f.on("scroll", l), f.on("resize", y), b(document.body).on("sticky_kit:recalc", y), a.on("sticky_kit:detach", H), setTimeout(l, 0);
      }
    };n = 0;for (K = this.length; n < K; n++) {
      d = this[n], J(b(d));
    }return this;
  };
}).call(this);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndoYXQtaW5wdXQuanMiLCJmb3VuZGF0aW9uLmNvcmUuanMiLCJmb3VuZGF0aW9uLnV0aWwuYm94LmpzIiwiZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzIiwiZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanMiLCJmb3VuZGF0aW9uLnV0aWwubW90aW9uLmpzIiwiZm91bmRhdGlvbi51dGlsLm5lc3QuanMiLCJmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlci5qcyIsImZvdW5kYXRpb24udXRpbC50b3VjaC5qcyIsImZvdW5kYXRpb24udXRpbC50cmlnZ2Vycy5qcyIsImZvdW5kYXRpb24uYWJpZGUuanMiLCJmb3VuZGF0aW9uLmFjY29yZGlvbi5qcyIsImZvdW5kYXRpb24uYWNjb3JkaW9uTWVudS5qcyIsImZvdW5kYXRpb24uZHJpbGxkb3duLmpzIiwiZm91bmRhdGlvbi5kcm9wZG93bi5qcyIsImZvdW5kYXRpb24uZHJvcGRvd25NZW51LmpzIiwiZm91bmRhdGlvbi5lcXVhbGl6ZXIuanMiLCJmb3VuZGF0aW9uLmludGVyY2hhbmdlLmpzIiwiZm91bmRhdGlvbi5tYWdlbGxhbi5qcyIsImZvdW5kYXRpb24ub2ZmY2FudmFzLmpzIiwiZm91bmRhdGlvbi5vcmJpdC5qcyIsImZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnUuanMiLCJmb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGUuanMiLCJmb3VuZGF0aW9uLnJldmVhbC5qcyIsImZvdW5kYXRpb24uc2xpZGVyLmpzIiwiZm91bmRhdGlvbi5zdGlja3kuanMiLCJmb3VuZGF0aW9uLnRhYnMuanMiLCJmb3VuZGF0aW9uLnRvZ2dsZXIuanMiLCJmb3VuZGF0aW9uLnRvb2x0aXAuanMiLCJtb3Rpb24tdWkuanMiLCJzbmFwLnN2Zy5qcyIsInNjcm9sbHJldmVhbC5qcyIsImFwcGxpY2F0aW9uLmpzIiwiYnItY29va2llcy5qcyIsImV4cGFuZGVyLmpzIiwiZmxleC12aWRlby5qcyIsImhvbWVwYWdlLWFuaW1hdGlvbnMuanMiLCJpbml0LWZvdW5kYXRpb24uanMiLCJpbnNpZ2h0LmpzIiwiam95cmlkZS1kZW1vLmpzIiwibGF3eWVycy5qcyIsIm5hdi5qcyIsIm9mZkNhbnZhcy5qcyIsInBlb3BsZS5qcyIsInNsaWNrLXNsaWRlci5qcyIsInN0aWNreWZvb3Rlci5qcyIsInN0aWNreS1raXQuanMiLCJiYWNrc3RyZXRjaC5taW4uanMiLCJzbGljay5qcyIsInNsaWNrLm1pbi5qcyIsInB1cmwuanMiXSwibmFtZXMiOlsid2luZG93Iiwid2hhdElucHV0IiwiYWN0aXZlS2V5cyIsImJvZHkiLCJidWZmZXIiLCJjdXJyZW50SW5wdXQiLCJub25UeXBpbmdJbnB1dHMiLCJtb3VzZVdoZWVsIiwiZGV0ZWN0V2hlZWwiLCJpZ25vcmVNYXAiLCJpbnB1dE1hcCIsImlucHV0VHlwZXMiLCJrZXlNYXAiLCJwb2ludGVyTWFwIiwidGltZXIiLCJldmVudEJ1ZmZlciIsImNsZWFyVGltZXIiLCJzZXRJbnB1dCIsImV2ZW50Iiwic2V0VGltZW91dCIsImJ1ZmZlcmVkRXZlbnQiLCJ1bkJ1ZmZlcmVkRXZlbnQiLCJjbGVhclRpbWVvdXQiLCJldmVudEtleSIsImtleSIsInZhbHVlIiwidHlwZSIsInBvaW50ZXJUeXBlIiwiZXZlbnRUYXJnZXQiLCJ0YXJnZXQiLCJldmVudFRhcmdldE5vZGUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZXZlbnRUYXJnZXRUeXBlIiwiZ2V0QXR0cmlidXRlIiwiaGFzQXR0cmlidXRlIiwiaW5kZXhPZiIsInN3aXRjaElucHV0IiwibG9nS2V5cyIsInN0cmluZyIsInNldEF0dHJpYnV0ZSIsInB1c2giLCJrZXlDb2RlIiwid2hpY2giLCJzcmNFbGVtZW50IiwidW5Mb2dLZXlzIiwiYXJyYXlQb3MiLCJzcGxpY2UiLCJiaW5kRXZlbnRzIiwiZG9jdW1lbnQiLCJQb2ludGVyRXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiTVNQb2ludGVyRXZlbnQiLCJjcmVhdGVFbGVtZW50Iiwib25tb3VzZXdoZWVsIiwidW5kZWZpbmVkIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJhc2siLCJrZXlzIiwidHlwZXMiLCJzZXQiLCIkIiwiRk9VTkRBVElPTl9WRVJTSU9OIiwiRm91bmRhdGlvbiIsInZlcnNpb24iLCJfcGx1Z2lucyIsIl91dWlkcyIsInJ0bCIsImF0dHIiLCJwbHVnaW4iLCJuYW1lIiwiY2xhc3NOYW1lIiwiZnVuY3Rpb25OYW1lIiwiYXR0ck5hbWUiLCJoeXBoZW5hdGUiLCJyZWdpc3RlclBsdWdpbiIsInBsdWdpbk5hbWUiLCJjb25zdHJ1Y3RvciIsInV1aWQiLCJHZXRZb0RpZ2l0cyIsIiRlbGVtZW50IiwiZGF0YSIsInRyaWdnZXIiLCJ1bnJlZ2lzdGVyUGx1Z2luIiwicmVtb3ZlQXR0ciIsInJlbW92ZURhdGEiLCJwcm9wIiwicmVJbml0IiwicGx1Z2lucyIsImlzSlEiLCJlYWNoIiwiX2luaXQiLCJfdGhpcyIsImZucyIsInBsZ3MiLCJmb3JFYWNoIiwicCIsImZvdW5kYXRpb24iLCJPYmplY3QiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJsZW5ndGgiLCJuYW1lc3BhY2UiLCJNYXRoIiwicm91bmQiLCJwb3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwicmVmbG93IiwiZWxlbSIsImkiLCIkZWxlbSIsImZpbmQiLCJhZGRCYWNrIiwiJGVsIiwib3B0cyIsIndhcm4iLCJ0aGluZyIsInNwbGl0IiwiZSIsIm9wdCIsIm1hcCIsImVsIiwidHJpbSIsInBhcnNlVmFsdWUiLCJlciIsImdldEZuTmFtZSIsInRyYW5zaXRpb25lbmQiLCJ0cmFuc2l0aW9ucyIsImVuZCIsInQiLCJzdHlsZSIsInRyaWdnZXJIYW5kbGVyIiwidXRpbCIsInRocm90dGxlIiwiZnVuYyIsImRlbGF5IiwiY29udGV4dCIsImFyZ3MiLCJhcmd1bWVudHMiLCJhcHBseSIsIm1ldGhvZCIsIiRtZXRhIiwiJG5vSlMiLCJhcHBlbmRUbyIsImhlYWQiLCJyZW1vdmVDbGFzcyIsIk1lZGlhUXVlcnkiLCJjYWxsIiwicGx1Z0NsYXNzIiwiUmVmZXJlbmNlRXJyb3IiLCJUeXBlRXJyb3IiLCJmbiIsIkRhdGUiLCJub3ciLCJnZXRUaW1lIiwidmVuZG9ycyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInZwIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibGFzdFRpbWUiLCJjYWxsYmFjayIsIm5leHRUaW1lIiwibWF4IiwicGVyZm9ybWFuY2UiLCJzdGFydCIsIkZ1bmN0aW9uIiwiYmluZCIsIm9UaGlzIiwiYUFyZ3MiLCJmVG9CaW5kIiwiZk5PUCIsImZCb3VuZCIsImNvbmNhdCIsImZ1bmNOYW1lUmVnZXgiLCJyZXN1bHRzIiwiZXhlYyIsInN0ciIsImlzTmFOIiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJqUXVlcnkiLCJCb3giLCJJbU5vdFRvdWNoaW5nWW91IiwiR2V0RGltZW5zaW9ucyIsIkdldE9mZnNldHMiLCJlbGVtZW50IiwicGFyZW50IiwibHJPbmx5IiwidGJPbmx5IiwiZWxlRGltcyIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsInBhckRpbXMiLCJvZmZzZXQiLCJoZWlnaHQiLCJ3aWR0aCIsIndpbmRvd0RpbXMiLCJhbGxEaXJzIiwiRXJyb3IiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicGFyUmVjdCIsInBhcmVudE5vZGUiLCJ3aW5SZWN0Iiwid2luWSIsInBhZ2VZT2Zmc2V0Iiwid2luWCIsInBhZ2VYT2Zmc2V0IiwicGFyZW50RGltcyIsImFuY2hvciIsInBvc2l0aW9uIiwidk9mZnNldCIsImhPZmZzZXQiLCJpc092ZXJmbG93IiwiJGVsZURpbXMiLCIkYW5jaG9yRGltcyIsImtleUNvZGVzIiwiY29tbWFuZHMiLCJLZXlib2FyZCIsImdldEtleUNvZGVzIiwicGFyc2VLZXkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b1VwcGVyQ2FzZSIsInNoaWZ0S2V5IiwiY3RybEtleSIsImFsdEtleSIsImhhbmRsZUtleSIsImNvbXBvbmVudCIsImZ1bmN0aW9ucyIsImNvbW1hbmRMaXN0IiwiY21kcyIsImNvbW1hbmQiLCJsdHIiLCJleHRlbmQiLCJyZXR1cm5WYWx1ZSIsImhhbmRsZWQiLCJ1bmhhbmRsZWQiLCJmaW5kRm9jdXNhYmxlIiwiZmlsdGVyIiwiaXMiLCJyZWdpc3RlciIsImNvbXBvbmVudE5hbWUiLCJrY3MiLCJrIiwia2MiLCJkZWZhdWx0UXVlcmllcyIsImxhbmRzY2FwZSIsInBvcnRyYWl0IiwicmV0aW5hIiwicXVlcmllcyIsImN1cnJlbnQiLCJzZWxmIiwiZXh0cmFjdGVkU3R5bGVzIiwiY3NzIiwibmFtZWRRdWVyaWVzIiwicGFyc2VTdHlsZVRvT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJfZ2V0Q3VycmVudFNpemUiLCJfd2F0Y2hlciIsImF0TGVhc3QiLCJzaXplIiwicXVlcnkiLCJnZXQiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsIm1hdGNoZWQiLCJvbiIsIm5ld1NpemUiLCJjdXJyZW50U2l6ZSIsInN0eWxlTWVkaWEiLCJtZWRpYSIsInNjcmlwdCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5mbyIsImlkIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1cnJlbnRTdHlsZSIsIm1hdGNoTWVkaXVtIiwidGV4dCIsInN0eWxlU2hlZXQiLCJjc3NUZXh0IiwidGV4dENvbnRlbnQiLCJzdHlsZU9iamVjdCIsInJlZHVjZSIsInJldCIsInBhcmFtIiwicGFydHMiLCJ2YWwiLCJkZWNvZGVVUklDb21wb25lbnQiLCJpc0FycmF5IiwiaW5pdENsYXNzZXMiLCJhY3RpdmVDbGFzc2VzIiwiTW90aW9uIiwiYW5pbWF0ZUluIiwiYW5pbWF0aW9uIiwiY2IiLCJhbmltYXRlIiwiYW5pbWF0ZU91dCIsIk1vdmUiLCJkdXJhdGlvbiIsImFuaW0iLCJwcm9nIiwibW92ZSIsInRzIiwiaXNJbiIsImVxIiwiaW5pdENsYXNzIiwiYWN0aXZlQ2xhc3MiLCJyZXNldCIsImFkZENsYXNzIiwic2hvdyIsIm9mZnNldFdpZHRoIiwib25lIiwiZmluaXNoIiwiaGlkZSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIk5lc3QiLCJGZWF0aGVyIiwibWVudSIsIml0ZW1zIiwic3ViTWVudUNsYXNzIiwic3ViSXRlbUNsYXNzIiwiaGFzU3ViQ2xhc3MiLCIkaXRlbSIsIiRzdWIiLCJjaGlsZHJlbiIsIkJ1cm4iLCJUaW1lciIsIm9wdGlvbnMiLCJuYW1lU3BhY2UiLCJyZW1haW4iLCJpc1BhdXNlZCIsInJlc3RhcnQiLCJpbmZpbml0ZSIsInBhdXNlIiwib25JbWFnZXNMb2FkZWQiLCJpbWFnZXMiLCJ1bmxvYWRlZCIsImNvbXBsZXRlIiwic2luZ2xlSW1hZ2VMb2FkZWQiLCJuYXR1cmFsV2lkdGgiLCJzcG90U3dpcGUiLCJlbmFibGVkIiwiZG9jdW1lbnRFbGVtZW50IiwicHJldmVudERlZmF1bHQiLCJtb3ZlVGhyZXNob2xkIiwidGltZVRocmVzaG9sZCIsInN0YXJ0UG9zWCIsInN0YXJ0UG9zWSIsInN0YXJ0VGltZSIsImVsYXBzZWRUaW1lIiwiaXNNb3ZpbmciLCJvblRvdWNoRW5kIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uVG91Y2hNb3ZlIiwieCIsInRvdWNoZXMiLCJwYWdlWCIsInkiLCJwYWdlWSIsImR4IiwiZHkiLCJkaXIiLCJhYnMiLCJvblRvdWNoU3RhcnQiLCJpbml0IiwidGVhcmRvd24iLCJzcGVjaWFsIiwic3dpcGUiLCJzZXR1cCIsIm5vb3AiLCJhZGRUb3VjaCIsImhhbmRsZVRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJmaXJzdCIsImV2ZW50VHlwZXMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJzaW11bGF0ZWRFdmVudCIsIk1vdXNlRXZlbnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJNdXRhdGlvbk9ic2VydmVyIiwicHJlZml4ZXMiLCJ0cmlnZ2VycyIsInN0b3BQcm9wYWdhdGlvbiIsImZhZGVPdXQiLCJsb2FkIiwiY2hlY2tMaXN0ZW5lcnMiLCJldmVudHNMaXN0ZW5lciIsInJlc2l6ZUxpc3RlbmVyIiwic2Nyb2xsTGlzdGVuZXIiLCJjbG9zZW1lTGlzdGVuZXIiLCJ5ZXRpQm94ZXMiLCJwbHVnTmFtZXMiLCJsaXN0ZW5lcnMiLCJqb2luIiwib2ZmIiwicGx1Z2luSWQiLCJub3QiLCJkZWJvdW5jZSIsIiRub2RlcyIsIm5vZGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24iLCJtdXRhdGlvblJlY29yZHNMaXN0IiwiJHRhcmdldCIsImVsZW1lbnRPYnNlcnZlciIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsInN1YnRyZWUiLCJhdHRyaWJ1dGVGaWx0ZXIiLCJJSGVhcllvdSIsIkFiaWRlIiwiZGVmYXVsdHMiLCIkaW5wdXRzIiwiX2V2ZW50cyIsInJlc2V0Rm9ybSIsInZhbGlkYXRlRm9ybSIsInZhbGlkYXRlT24iLCJ2YWxpZGF0ZUlucHV0IiwibGl2ZVZhbGlkYXRlIiwiaXNHb29kIiwiY2hlY2tlZCIsIiRlcnJvciIsInNpYmxpbmdzIiwiZm9ybUVycm9yU2VsZWN0b3IiLCIkbGFiZWwiLCJjbG9zZXN0IiwiJGVscyIsImxhYmVscyIsImZpbmRMYWJlbCIsIiRmb3JtRXJyb3IiLCJmaW5kRm9ybUVycm9yIiwibGFiZWxFcnJvckNsYXNzIiwiZm9ybUVycm9yQ2xhc3MiLCJpbnB1dEVycm9yQ2xhc3MiLCJncm91cE5hbWUiLCIkbGFiZWxzIiwiZmluZFJhZGlvTGFiZWxzIiwiJGZvcm1FcnJvcnMiLCJyZW1vdmVSYWRpb0Vycm9yQ2xhc3NlcyIsImNsZWFyUmVxdWlyZSIsInJlcXVpcmVkQ2hlY2siLCJ2YWxpZGF0ZWQiLCJjdXN0b21WYWxpZGF0b3IiLCJ2YWxpZGF0b3IiLCJlcXVhbFRvIiwidmFsaWRhdGVSYWRpbyIsInZhbGlkYXRlVGV4dCIsIm1hdGNoVmFsaWRhdGlvbiIsInZhbGlkYXRvcnMiLCJnb29kVG9HbyIsIm1lc3NhZ2UiLCJhY2MiLCJub0Vycm9yIiwicGF0dGVybiIsImlucHV0VGV4dCIsInZhbGlkIiwicGF0dGVybnMiLCJSZWdFeHAiLCIkZ3JvdXAiLCJyZXF1aXJlZCIsImNsZWFyIiwidiIsIiRmb3JtIiwicmVtb3ZlRXJyb3JDbGFzc2VzIiwiYWxwaGEiLCJhbHBoYV9udW1lcmljIiwiaW50ZWdlciIsIm51bWJlciIsImNhcmQiLCJjdnYiLCJlbWFpbCIsInVybCIsImRvbWFpbiIsImRhdGV0aW1lIiwiZGF0ZSIsInRpbWUiLCJkYXRlSVNPIiwibW9udGhfZGF5X3llYXIiLCJkYXlfbW9udGhfeWVhciIsImNvbG9yIiwiQWNjb3JkaW9uIiwiJHRhYnMiLCJpZHgiLCIkY29udGVudCIsImxpbmtJZCIsIiRpbml0QWN0aXZlIiwiZG93biIsIiR0YWJDb250ZW50IiwiaGFzQ2xhc3MiLCJhbGxvd0FsbENsb3NlZCIsInVwIiwidG9nZ2xlIiwibmV4dCIsIiRhIiwiZm9jdXMiLCJtdWx0aUV4cGFuZCIsInByZXZpb3VzIiwicHJldiIsImZpcnN0VGltZSIsIiRjdXJyZW50QWN0aXZlIiwic2xpZGVEb3duIiwic2xpZGVTcGVlZCIsIiRhdW50cyIsImNhbkNsb3NlIiwic2xpZGVVcCIsInN0b3AiLCJBY2NvcmRpb25NZW51IiwibXVsdGlPcGVuIiwiJG1lbnVMaW5rcyIsInN1YklkIiwiaXNBY3RpdmUiLCJpbml0UGFuZXMiLCIkc3VibWVudSIsIiRlbGVtZW50cyIsIiRwcmV2RWxlbWVudCIsIiRuZXh0RWxlbWVudCIsIm1pbiIsInBhcmVudHMiLCJvcGVuIiwiY2xvc2UiLCJjbG9zZUFsbCIsImhpZGVBbGwiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwYXJlbnRzVW50aWwiLCJhZGQiLCIkbWVudXMiLCJEcmlsbGRvd24iLCIkc3VibWVudUFuY2hvcnMiLCIkc3VibWVudXMiLCIkbWVudUl0ZW1zIiwiX3ByZXBhcmVNZW51IiwiX2tleWJvYXJkRXZlbnRzIiwiJGxpbmsiLCJwYXJlbnRMaW5rIiwiY2xvbmUiLCJwcmVwZW5kVG8iLCJ3cmFwIiwiJG1lbnUiLCIkYmFjayIsInByZXBlbmQiLCJiYWNrQnV0dG9uIiwiX2JhY2siLCIkd3JhcHBlciIsIndyYXBwZXIiLCJfZ2V0TWF4RGltcyIsIl9zaG93IiwiY2xvc2VPbkNsaWNrIiwiJGJvZHkiLCJjb250YWlucyIsIl9oaWRlQWxsIiwiX2hpZGUiLCJibHVyIiwicmVzdWx0IiwibnVtT2ZFbGVtcyIsInVud3JhcCIsInJlbW92ZSIsIkRyb3Bkb3duIiwiJGlkIiwiJGFuY2hvciIsInBvc2l0aW9uQ2xhc3MiLCJnZXRQb3NpdGlvbkNsYXNzIiwiY291bnRlciIsInVzZWRQb3NpdGlvbnMiLCJ2ZXJ0aWNhbFBvc2l0aW9uIiwibWF0Y2giLCJob3Jpem9udGFsUG9zaXRpb24iLCJjbGFzc0NoYW5nZWQiLCJkaXJlY3Rpb24iLCJfcmVwb3NpdGlvbiIsIl9zZXRQb3NpdGlvbiIsImhvdmVyIiwidGltZW91dCIsImhvdmVyRGVsYXkiLCJob3ZlclBhbmUiLCJ2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMiLCJ0YWJfZm9yd2FyZCIsInRyYXBGb2N1cyIsInRhYl9iYWNrd2FyZCIsImF1dG9Gb2N1cyIsIiRmb2N1c2FibGUiLCJfYWRkQm9keUhhbmRsZXIiLCJjdXJQb3NpdGlvbkNsYXNzIiwiRHJvcGRvd25NZW51Iiwic3VicyIsInZlcnRpY2FsQ2xhc3MiLCJyaWdodENsYXNzIiwiYWxpZ25tZW50IiwiY2hhbmdlZCIsImhhc1RvdWNoIiwib250b3VjaHN0YXJ0IiwicGFyQ2xhc3MiLCJoYW5kbGVDbGlja0ZuIiwiaGFzU3ViIiwiaGFzQ2xpY2tlZCIsImNsaWNrT3BlbiIsImZvcmNlRm9sbG93IiwiZGlzYWJsZUhvdmVyIiwiYXV0b2Nsb3NlIiwiY2xvc2luZ1RpbWUiLCJpc1RhYiIsImluZGV4IiwibmV4dFNpYmxpbmciLCJwcmV2U2libGluZyIsIm9wZW5TdWIiLCJjbG9zZVN1YiIsIiRzaWJzIiwib2xkQ2xhc3MiLCIkcGFyZW50TGkiLCIkdG9DbG9zZSIsInNvbWV0aGluZ1RvQ2xvc2UiLCJFcXVhbGl6ZXIiLCJlcUlkIiwiJHdhdGNoZWQiLCJoYXNOZXN0ZWQiLCJpc05lc3RlZCIsImlzT24iLCJfYmluZEhhbmRsZXIiLCJvblJlc2l6ZU1lQm91bmQiLCJfb25SZXNpemVNZSIsIm9uUG9zdEVxdWFsaXplZEJvdW5kIiwiX29uUG9zdEVxdWFsaXplZCIsImltZ3MiLCJ0b29TbWFsbCIsImVxdWFsaXplT24iLCJfY2hlY2tNUSIsIl9yZWZsb3ciLCJfcGF1c2VFdmVudHMiLCJlcXVhbGl6ZU9uU3RhY2siLCJfaXNTdGFja2VkIiwiZXF1YWxpemVCeVJvdyIsImdldEhlaWdodHNCeVJvdyIsImFwcGx5SGVpZ2h0QnlSb3ciLCJnZXRIZWlnaHRzIiwiYXBwbHlIZWlnaHQiLCJoZWlnaHRzIiwibGVuIiwib2Zmc2V0SGVpZ2h0IiwibGFzdEVsVG9wT2Zmc2V0IiwiZ3JvdXBzIiwiZ3JvdXAiLCJlbE9mZnNldFRvcCIsImoiLCJsbiIsImdyb3Vwc0lMZW5ndGgiLCJsZW5KIiwiSW50ZXJjaGFuZ2UiLCJydWxlcyIsImN1cnJlbnRQYXRoIiwiX2FkZEJyZWFrcG9pbnRzIiwiX2dlbmVyYXRlUnVsZXMiLCJydWxlIiwicGF0aCIsIlNQRUNJQUxfUVVFUklFUyIsInJ1bGVzTGlzdCIsInJlc3BvbnNlIiwiaHRtbCIsIk1hZ2VsbGFuIiwiJHRhcmdldHMiLCIkbGlua3MiLCIkYWN0aXZlIiwic2Nyb2xsUG9zIiwicGFyc2VJbnQiLCJwb2ludHMiLCJ3aW5IZWlnaHQiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImRvY0hlaWdodCIsInNjcm9sbEhlaWdodCIsIiR0YXIiLCJwdCIsInRocmVzaG9sZCIsInRhcmdldFBvaW50IiwiYW5pbWF0aW9uRHVyYXRpb24iLCJlYXNpbmciLCJhbmltYXRpb25FYXNpbmciLCJkZWVwTGlua2luZyIsImxvY2F0aW9uIiwiaGFzaCIsInNjcm9sbFRvTG9jIiwiY2FsY1BvaW50cyIsIl91cGRhdGVBY3RpdmUiLCJhcnJpdmFsIiwibG9jIiwiYmFyT2Zmc2V0Iiwic2Nyb2xsVG9wIiwid2luUG9zIiwiY3VySWR4IiwiaXNEb3duIiwiY3VyVmlzaWJsZSIsImhpc3RvcnkiLCJwdXNoU3RhdGUiLCJPZmZDYW52YXMiLCIkbGFzdFRyaWdnZXIiLCIkdHJpZ2dlcnMiLCIkZXhpdGVyIiwiZXhpdGVyIiwiYXBwZW5kIiwiaXNSZXZlYWxlZCIsInJldmVhbENsYXNzIiwicmV2ZWFsT24iLCJfc2V0TVFDaGVja2VyIiwidHJhbnNpdGlvblRpbWUiLCJfaGFuZGxlS2V5Ym9hcmQiLCJyZXZlYWwiLCIkY2xvc2VyIiwiZm9yY2VUb3AiLCJfdHJhcEZvY3VzIiwiZm9jdXNhYmxlIiwibGFzdCIsImtleWNvZGUiLCJPcmJpdCIsImNvbnRhaW5lckNsYXNzIiwiJHNsaWRlcyIsInNsaWRlQ2xhc3MiLCIkaW1hZ2VzIiwiaW5pdEFjdGl2ZSIsInVzZU1VSSIsIl9wcmVwYXJlRm9yT3JiaXQiLCJidWxsZXRzIiwiX2xvYWRCdWxsZXRzIiwiYXV0b1BsYXkiLCJnZW9TeW5jIiwiYWNjZXNzaWJsZSIsIiRidWxsZXRzIiwiYm94T2ZCdWxsZXRzIiwidGltZXJEZWxheSIsImNoYW5nZVNsaWRlIiwiX3NldFdyYXBwZXJIZWlnaHQiLCJfc2V0U2xpZGVIZWlnaHQiLCJ0ZW1wIiwicGF1c2VPbkhvdmVyIiwibmF2QnV0dG9ucyIsIiRjb250cm9scyIsIm5leHRDbGFzcyIsInByZXZDbGFzcyIsIiRzbGlkZSIsImlzTFRSIiwiY2hvc2VuU2xpZGUiLCIkY3VyU2xpZGUiLCIkZmlyc3RTbGlkZSIsIiRsYXN0U2xpZGUiLCJkaXJJbiIsImRpck91dCIsIiRuZXdTbGlkZSIsImluZmluaXRlV3JhcCIsIl91cGRhdGVCdWxsZXRzIiwiJG9sZEJ1bGxldCIsInNwYW4iLCJkZXRhY2giLCIkbmV3QnVsbGV0IiwiYW5pbUluRnJvbVJpZ2h0IiwiYW5pbU91dFRvUmlnaHQiLCJhbmltSW5Gcm9tTGVmdCIsImFuaW1PdXRUb0xlZnQiLCJSZXNwb25zaXZlTWVudSIsImN1cnJlbnRNcSIsImN1cnJlbnRQbHVnaW4iLCJydWxlc1RyZWUiLCJydWxlU2l6ZSIsInJ1bGVQbHVnaW4iLCJNZW51UGx1Z2lucyIsImlzRW1wdHlPYmplY3QiLCJfY2hlY2tNZWRpYVF1ZXJpZXMiLCJtYXRjaGVkTXEiLCJjc3NDbGFzcyIsImRlc3Ryb3kiLCJkcm9wZG93biIsImRyaWxsZG93biIsImFjY29yZGlvbiIsIlJlc3BvbnNpdmVUb2dnbGUiLCJ0YXJnZXRJRCIsIiR0YXJnZXRNZW51IiwiJHRvZ2dsZXIiLCJfdXBkYXRlIiwiX3VwZGF0ZU1xSGFuZGxlciIsInRvZ2dsZU1lbnUiLCJoaWRlRm9yIiwiUmV2ZWFsIiwiY2FjaGVkIiwibXEiLCJpc01vYmlsZSIsIm1vYmlsZVNuaWZmIiwiZnVsbFNjcmVlbiIsIm92ZXJsYXkiLCIkb3ZlcmxheSIsIl9tYWtlT3ZlcmxheSIsImRlZXBMaW5rIiwib3V0ZXJXaWR0aCIsIm91dGVySGVpZ2h0IiwibWFyZ2luIiwiX3VwZGF0ZVBvc2l0aW9uIiwiX2hhbmRsZVN0YXRlIiwibXVsdGlwbGVPcGVuZWQiLCJhbmltYXRpb25JbiIsImFmdGVyQW5pbWF0aW9uRm9jdXMiLCJsb2ciLCJmb2N1c2FibGVFbGVtZW50cyIsInNob3dEZWxheSIsIm9yaWdpbmFsU2Nyb2xsUG9zIiwiX2V4dHJhSGFuZGxlcnMiLCJjbG9zZU9uRXNjIiwiYW5pbWF0aW9uT3V0IiwiZmluaXNoVXAiLCJoaWRlRGVsYXkiLCJyZXNldE9uQ2xvc2UiLCJyZXBsYWNlU3RhdGUiLCJ0aXRsZSIsInBhdGhuYW1lIiwiYnRtT2Zmc2V0UGN0IiwiaVBob25lU25pZmYiLCJhbmRyb2lkU25pZmYiLCJTbGlkZXIiLCJpbnB1dHMiLCJoYW5kbGVzIiwiJGhhbmRsZSIsIiRpbnB1dCIsIiRmaWxsIiwidmVydGljYWwiLCJpc0RibCIsImRpc2FibGVkIiwiZGlzYWJsZWRDbGFzcyIsImJpbmRpbmciLCJfc2V0SW5pdEF0dHIiLCJkb3VibGVTaWRlZCIsIiRoYW5kbGUyIiwiJGlucHV0MiIsIl9zZXRIYW5kbGVQb3MiLCJpbml0aWFsU3RhcnQiLCJpbml0aWFsRW5kIiwiJGhuZGwiLCJub0ludmVydCIsImgyVmFsIiwic3RlcCIsImgxVmFsIiwidmVydCIsImhPclciLCJsT3JUIiwiaGFuZGxlRGltIiwiZWxlbURpbSIsInBjdE9mQmFyIiwicGVyY2VudCIsInRvRml4ZWQiLCJweFRvTW92ZSIsIm1vdmVtZW50IiwiZGVjaW1hbCIsIl9zZXRWYWx1ZXMiLCJpc0xlZnRIbmRsIiwiZGltIiwiaGFuZGxlUGN0IiwiaGFuZGxlUG9zIiwibW92ZVRpbWUiLCJjaGFuZ2VkRGVsYXkiLCJoYXNWYWwiLCJldmVudE9mZnNldCIsImhhbGZPZkhhbmRsZSIsImJhckRpbSIsIndpbmRvd1Njcm9sbCIsInNjcm9sbExlZnQiLCJlbGVtT2Zmc2V0IiwiZXZlbnRGcm9tQmFyIiwiYmFyWFkiLCJvZmZzZXRQY3QiLCJfYWRqdXN0VmFsdWUiLCJmaXJzdEhuZGxQb3MiLCJhYnNQb3NpdGlvbiIsInNlY25kSG5kbFBvcyIsImRpdiIsInByZXZfdmFsIiwibmV4dF92YWwiLCJjdXJIYW5kbGUiLCJfaGFuZGxlRXZlbnQiLCJjbGlja1NlbGVjdCIsImRyYWdnYWJsZSIsImN1cnJlbnRUYXJnZXQiLCJfJGhhbmRsZSIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJkZWNyZWFzZSIsImluY3JlYXNlIiwiZGVjcmVhc2VfZmFzdCIsImluY3JlYXNlX2Zhc3QiLCJpbnZlcnRWZXJ0aWNhbCIsImZyYWMiLCJudW0iLCJjbGlja1BvcyIsIlN0aWNreSIsIiRwYXJlbnQiLCJ3YXNXcmFwcGVkIiwiJGNvbnRhaW5lciIsImNvbnRhaW5lciIsIndyYXBJbm5lciIsInN0aWNreUNsYXNzIiwic2Nyb2xsQ291bnQiLCJjaGVja0V2ZXJ5IiwiaXNTdHVjayIsIl9wYXJzZVBvaW50cyIsIl9zZXRTaXplcyIsIl9jYWxjIiwicmV2ZXJzZSIsInRvcEFuY2hvciIsImJ0bSIsImJ0bUFuY2hvciIsInB0cyIsImJyZWFrcyIsInBsYWNlIiwiY2FuU3RpY2siLCJfcGF1c2VMaXN0ZW5lcnMiLCJjaGVja1NpemVzIiwic2Nyb2xsIiwiX3JlbW92ZVN0aWNreSIsInRvcFBvaW50IiwiYm90dG9tUG9pbnQiLCJfc2V0U3RpY2t5Iiwic3RpY2tUbyIsIm1yZ24iLCJub3RTdHVja1RvIiwiaXNUb3AiLCJzdGlja1RvVG9wIiwiYW5jaG9yUHQiLCJhbmNob3JIZWlnaHQiLCJlbGVtSGVpZ2h0IiwidG9wT3JCb3R0b20iLCJzdGlja3lPbiIsIm5ld0VsZW1XaWR0aCIsImNvbXAiLCJwZG5nIiwibmV3Q29udGFpbmVySGVpZ2h0IiwiY29udGFpbmVySGVpZ2h0IiwiX3NldEJyZWFrUG9pbnRzIiwibVRvcCIsImVtQ2FsYyIsIm1hcmdpblRvcCIsIm1CdG0iLCJtYXJnaW5Cb3R0b20iLCJlbSIsImZvbnRTaXplIiwiVGFicyIsIiR0YWJUaXRsZXMiLCJsaW5rQ2xhc3MiLCJtYXRjaEhlaWdodCIsIl9zZXRIZWlnaHQiLCJfYWRkS2V5SGFuZGxlciIsIl9hZGRDbGlja0hhbmRsZXIiLCJfc2V0SGVpZ2h0TXFIYW5kbGVyIiwiX2hhbmRsZVRhYkNoYW5nZSIsIiRmaXJzdFRhYiIsIiRsYXN0VGFiIiwid3JhcE9uS2V5cyIsIiR0YWJMaW5rIiwiJHRhcmdldENvbnRlbnQiLCIkb2xkVGFiIiwiaWRTdHIiLCJwYW5lbENsYXNzIiwicGFuZWwiLCJjaGVja0NsYXNzIiwiVG9nZ2xlciIsImlucHV0IiwidG9nZ2xlQ2xhc3MiLCJfdXBkYXRlQVJJQSIsIlRvb2x0aXAiLCJpc0NsaWNrIiwiZWxlbUlkIiwiX2dldFBvc2l0aW9uQ2xhc3MiLCJ0aXBUZXh0IiwidGVtcGxhdGUiLCJfYnVpbGRUZW1wbGF0ZSIsInRyaWdnZXJDbGFzcyIsInRlbXBsYXRlQ2xhc3NlcyIsInRvb2x0aXBDbGFzcyIsIiR0ZW1wbGF0ZSIsIiR0aXBEaW1zIiwic2hvd09uIiwiZmFkZUluIiwiZmFkZUluRHVyYXRpb24iLCJmYWRlT3V0RHVyYXRpb24iLCJpc0ZvY3VzIiwiZGlzYWJsZUZvclRvdWNoIiwidG91Y2hDbG9zZVRleHQiLCJlbmRFdmVudCIsIk1vdGlvblVJIiwiZ2xvYiIsImhhcyIsInNlcGFyYXRvciIsImNvbWFzZXBhcmF0b3IiLCJ3aWxkY2FyZCIsImZ1biIsIm51bXNvcnQiLCJhIiwiYiIsImN1cnJlbnRfZXZlbnQiLCJldmVudHMiLCJuIiwiZmlyc3REZWZpbmVkIiwiaWkiLCJsYXN0RGVmaW5lZCIsImV2ZSIsInNjb3BlIiwib2xkc3RvcCIsInoiLCJmIiwibCIsImluZGV4ZWQiLCJxdWV1ZSIsIm91dCIsImNlIiwiZXJyb3JzIiwiekluZGV4Iiwic29ydCIsIm5hbWVzIiwiaXRlbSIsImpqIiwibmVzIiwiZXMiLCJleGlzdCIsImF0dHJzIiwibnQiLCJzdWJuYW1lIiwibnRzIiwidW5iaW5kIiwiY3VyIiwiZnVuY3MiLCJvbmNlIiwiZjIiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIiwiYW1kIiwiZmFjdG9yeSIsInJlcXVpcmUiLCJtaW5hIiwiYW5pbWF0aW9ucyIsInJlcXVlc3RBbmltRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpZGdlbiIsImlkcHJlZml4IiwiSUQiLCJkaWZmIiwiQSIsIkIiLCJyZXMiLCJkaWYiLCJiYiIsInN0YSIsInMiLCJkcyIsImR1ciIsInNwZWVkIiwic3BkIiwic3RvcGl0IiwidXBkYXRlIiwicGRpZiIsInJlc3VtZSIsImZyYW1lIiwibGluZWFyIiwic3RhdHVzIiwiZ2V0QnlJZCIsImVhc2VvdXQiLCJlYXNlaW4iLCJlYXNlaW5vdXQiLCJxIiwiUSIsInNxcnQiLCJYIiwiWSIsImJhY2tpbiIsImJhY2tvdXQiLCJlbGFzdGljIiwic2luIiwiUEkiLCJib3VuY2UiLCJTbmFwIiwicm9vdCIsInciLCJoIiwibm9kZVR5cGUiLCJFbGVtZW50IiwiZG9jIiwicXVlcnlTZWxlY3RvciIsIlBhcGVyIiwiXyIsIndpbiIsIlN0ciIsInRvRmxvYXQiLCJ0b0ludCIsIm1hdGgiLCJtbWF4IiwibW1pbiIsIkUiLCJTIiwib2JqZWN0VG9TdHJpbmciLCJJU1VSTCIsImNvbG91clJlZ0V4cCIsImJlemllcnJnIiwicmVVUkxWYWx1ZSIsIndoaXRlc3BhY2UiLCJjb21tYVNwYWNlcyIsImhzcmciLCJocyIsInJnIiwicGF0aENvbW1hbmQiLCJ0Q29tbWFuZCIsInBhdGhWYWx1ZXMiLCJ4bGluayIsInhtbG5zIiwiaHViIiwiVVJMIiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVDb21tZW50Iiwic3Vic3RyaW5nIiwiZ2V0QXR0cmlidXRlTlMiLCJub2RlVmFsdWUiLCJzZXRBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsImdldEF0dHJzIiwibmFtZXNwYWNlVVJJIiwibyIsImlzRmluaXRlIiwiZm9ybWF0IiwidG9rZW5SZWdleCIsIm9iak5vdGF0aW9uUmVnZXgiLCJyZXBsYWNlciIsImFsbCIsIm9iaiIsInF1b3RlIiwicXVvdGVkTmFtZSIsImlzRnVuYyIsInJlcHVzaCIsImFycmF5IiwiY2FjaGVyIiwicG9zdHByb2Nlc3NvciIsIm5ld2YiLCJhcmciLCJjYWNoZSIsImNvdW50Iiwic2hpZnQiLCJhbmdsZSIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsImF0YW4yIiwicmFkIiwiZGVnIiwieF95IiwieF95X3dfaCIsInRhbiIsImNvcyIsImFzaW4iLCJhY29zIiwiYXRhbiIsImxlbjIiLCJjbG9zZXN0UG9pbnQiLCJkaXN0YW5jZTIiLCJwYXRoTm9kZSIsIm5vZGUiLCJwYXRoTGVuZ3RoIiwiZ2V0VG90YWxMZW5ndGgiLCJwcmVjaXNpb24iLCJwYXRoU2VnTGlzdCIsIm51bWJlck9mSXRlbXMiLCJiZXN0IiwiYmVzdExlbmd0aCIsImJlc3REaXN0YW5jZSIsIkluZmluaXR5Iiwic2NhbiIsInNjYW5MZW5ndGgiLCJzY2FuRGlzdGFuY2UiLCJnZXRQb2ludEF0TGVuZ3RoIiwiYmVmb3JlIiwiYWZ0ZXIiLCJiZWZvcmVMZW5ndGgiLCJhZnRlckxlbmd0aCIsImJlZm9yZURpc3RhbmNlIiwiYWZ0ZXJEaXN0YW5jZSIsImRpc3RhbmNlIiwic25hcFRvIiwidmFsdWVzIiwidG9sZXJhbmNlIiwicmVtIiwiZ2V0UkdCIiwiY29sb3VyIiwiciIsImciLCJoZXgiLCJyZ2J0b1N0cmluZyIsImNoYXJBdCIsInRvSGV4IiwicmVkIiwiZ3JlZW4iLCJibHVlIiwib3BhY2l0eSIsInJnYiIsImhzYjJyZ2IiLCJoc2wycmdiIiwiaHNiIiwiaHNsIiwiZGVmYXVsdFZpZXciLCJnZXRQcm9wZXJ0eVZhbHVlIiwiaHNidG9TdHJpbmciLCJoc2x0b1N0cmluZyIsInByZXBhcmVSR0IiLCJjbHIiLCJwYWNrYWdlUkdCIiwicmdiMmhzbCIsInJnYjJoc2IiLCJSIiwiRyIsIkMiLCJIIiwiViIsIkwiLCJNIiwibSIsInBhcnNlUGF0aFN0cmluZyIsInBhdGhTdHJpbmciLCJwdGgiLCJhcnIiLCJwYXJhbUNvdW50cyIsImMiLCJ1IiwicGFyYW1zIiwicGFyc2VUcmFuc2Zvcm1TdHJpbmciLCJUU3RyaW5nIiwic3ZnVHJhbnNmb3JtMnN0cmluZyIsInRzdHIiLCJyZ1RyYW5zZm9ybSIsInRyYW5zZm9ybTJtYXRyaXgiLCJiYm94IiwidGRhdGEiLCJNYXRyaXgiLCJ0bGVuIiwiYWJzb2x1dGUiLCJpbnZlciIsImludmVydCIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInNjYWxlIiwiX3VuaXQycHgiLCJ1bml0MnB4IiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJhZG93biIsImJ1cCIsImdldFNvbWVEZWZzIiwib3duZXJTVkdFbGVtZW50Iiwic2VsZWN0IiwicGRlZnMiLCJkZWZzIiwibWFrZSIsImdldFNvbWVTVkciLCJzdmciLCJtZ3IiLCJmaWxsIiwiYXBwZW5kQ2hpbGQiLCJnZXRXIiwiZ2V0QkJveCIsImdldEgiLCJuYW0iLCJyZW1vdmVDaGlsZCIsInNlbGVjdEFsbCIsIm5vZGVsaXN0IiwiYWRkMmdyb3VwIiwibGlzdCIsImNoaWxkTm9kZXMiLCJzZXRJbnRlcnZhbCIsInNuYXAiLCJwYXBlciIsInRhZ05hbWUiLCJhbmltcyIsInRyYW5zZm9ybSIsIm1hc2siLCJzeW1ib2wiLCJqc29uIiwiYXR0IiwicGFyc2UiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZnVsbCIsImlubmVySFRNTCIsImZpcnN0Q2hpbGQiLCJGcmFnbWVudCIsImZyYWciLCJmcmFnbWVudCIsImRlc2MiLCJwcm90byIsIm93bmVyRG9jdW1lbnQiLCJkb20iLCJjb250ZW50RG9jdW1lbnQiLCJjaCIsImpzb25GaWxsZXIiLCJ0b0pTT04iLCJsYXN0SW5kZXhPZiIsImxldHRlciIsImNzc0F0dHIiLCJhamF4IiwicG9zdERhdGEiLCJyZXEiLCJYTUxIdHRwUmVxdWVzdCIsInBkIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2V0UmVxdWVzdEhlYWRlciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzZW5kIiwicmVzcG9uc2VUZXh0IiwiZ2V0T2Zmc2V0IiwiYm94IiwiZG9jRWxlbSIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJnZXRFbGVtZW50QnlQb2ludCIsImNhbnZhcyIsImVsZW1lbnRGcm9tUG9pbnQiLCJvcGVyYSIsInNvIiwic3IiLCJjcmVhdGVTVkdSZWN0IiwiaGl0cyIsImdldEludGVyc2VjdGlvbkxpc3QiLCJlbHByb3RvIiwiaXNXaXRob3V0VHJhbnNmb3JtIiwicmVtb3ZlZCIsImxvY2FsTWF0cml4Iiwib3JpZ2luYWwiLCJocmVmIiwiZ2V0RWxlbWVudEJ5SWQiLCJwYXRoZmluZGVyIiwiZGVmbHQiLCJiYm94d3QiLCJyZWFsUGF0aCIsIm1hdHJpeCIsInByb3BTdHJpbmciLCJleHRyYWN0VHJhbnNmb3JtIiwiZG9SZXR1cm4iLCJwYXBhIiwiZ2xvYmFsIiwiZ2V0Q1RNIiwibG9jYWwiLCJtcyIsImxvY2FsU3RyaW5nIiwidG9UcmFuc2Zvcm1TdHJpbmciLCJnbG9iYWxNYXRyaXgiLCJ0b3RhbE1hdHJpeCIsImRpZmZNYXRyaXgiLCJ0b3RhbCIsImdyYWRpZW50VHJhbnNmb3JtIiwicGF0dGVyblRyYW5zZm9ybSIsIml0IiwiaW5zZXJ0QWZ0ZXIiLCJhc1BYIiwidXNlIiwiZml4aWRzIiwiZWxzIiwiaWRzIiwidXNlcyIsInVybHRlc3QiLCJsaW5rdGVzdCIsIm9sZGlkIiwib2xkIiwiZnMiLCJjbG9uZU5vZGUiLCJ0b0RlZnMiLCJ0b1BhdHRlcm4iLCJwYXR0ZXJuVW5pdHMiLCJ2aWV3Qm94IiwibWFya2VyIiwicmVmWCIsInJlZlkiLCJjeCIsImN5IiwibWFya2VyV2lkdGgiLCJtYXJrZXJIZWlnaHQiLCJvcmllbnQiLCJmcm9tIiwidG8iLCJBbmltYXRpb24iLCJpbkFuaW0iLCJfYXR0cnMiLCJfY2FsbGJhY2siLCJjdXJTdGF0dXMiLCJzZXR0ZXIiLCJma2V5cyIsInRrZXlzIiwiZXF1YWwiLCJlbGRhdGEiLCJvdXRlclNWRyIsImlubmVyU1ZHIiwiY2hsZCIsInRvRGF0YVVSTCIsImJ0b2EiLCJjb250ZW50cyIsInVuZXNjYXBlIiwiZCIsIm1hdHJpeHByb3RvIiwibWUiLCJub3JtIiwibm9ybWFsaXplIiwibWFnIiwiZGV0ZXJtaW5hbnQiLCJyb3ciLCJzY2FsZXgiLCJzaGVhciIsInNjYWxleSIsImlzU2ltcGxlIiwiaXNTdXBlclNpbXBsZSIsIm5vUm90YXRpb24iLCJzaG9ydGVyIiwiY2xpcEl0IiwiY2xpcCIsImZpbGxTdHJva2UiLCJncmFkIiwiZ3JhZGllbnQiLCJncmFkcmciLCJwYXJzZUdyYWQiLCJ0b2tlbnMiLCJzdG9wcyIsInRvQWJzb2x1dGUiLCJ0eHQiLCJiYXNlVmFsIiwidmIiLCJyeCIsInJ5IiwidHAiLCJ0ZXh0UGF0aCIsInR1bmVyIiwiY2h1bmsiLCJ0dW5lZCIsInNldEZvbnRTaXplIiwiZ2V0dGVyIiwidGV4dEV4dHJhY3QiLCJjaGkiLCJnZXRGb250U2l6ZSIsInJnTm90U3BhY2UiLCJyZ0JhZFNwYWNlIiwicmdUcmltIiwiY2xhc3NlcyIsImN1ckNsYXNzZXMiLCJwb3MiLCJjbGF6eiIsImZpbmFsVmFsdWUiLCJmbGFnIiwib3BlcmF0b3JzIiwicmVVbml0IiwicmVBZGRvbiIsImdldE51bWJlciIsImdldFVuaXQiLCJ1bml0IiwicGx1cyIsImV2bnQiLCJhdHIiLCJhVW5pdCIsIm9wIiwiYnBsdXMiLCJjaXJjbGUiLCJwcmVsb2FkIiwib25lcnJvciIsInNyYyIsImltZyIsIm9ubG9hZCIsImltYWdlIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsImVsbGlwc2UiLCJ2YngiLCJ2YnkiLCJ2YnciLCJ2YmgiLCJwdHJuIiwidngiLCJ2eSIsInZ3IiwidmgiLCJsaW5lIiwicG9seWxpbmUiLCJwb2x5Z29uIiwiR3N0b3BzIiwiR2FkZFN0b3AiLCJHZ2V0QkJveCIsInVuc2hpZnQiLCJncmFkaWVudExpbmVhciIsImdyYWRpZW50UmFkaWFsIiwiZ3JhZGllbnRVbml0cyIsInNlZWQiLCJhZGRTdG9wIiwiZngiLCJmeSIsInAycyIsInBhdGhzIiwicHMiLCJzbGVlcCIsInIxIiwicjIiLCJyMCIsInJlY3RQYXRoIiwicGF0aENsb25lIiwicGF0aEFycmF5IiwiZ2V0UG9pbnRBdFNlZ21lbnRMZW5ndGgiLCJwMXgiLCJwMXkiLCJjMXgiLCJjMXkiLCJjMngiLCJjMnkiLCJwMngiLCJwMnkiLCJiZXpsZW4iLCJmaW5kRG90c0F0U2VnbWVudCIsImdldFRvdExlbiIsImdldExlbmd0aEZhY3RvcnkiLCJpc3RvdGFsIiwic3VicGF0aCIsIk8iLCJvbmx5c3RhcnQiLCJwYXRoMmN1cnZlIiwic3AiLCJzdWJwYXRocyIsInBvaW50IiwiZ2V0U3VicGF0aHNBdExlbmd0aCIsInQxIiwidDEzIiwidDEyIiwidDIiLCJ0MyIsIm14IiwibXkiLCJueCIsIm55IiwiYXgiLCJheSIsImJlemllckJCb3giLCJjdXJ2ZURpbSIsImlzUG9pbnRJbnNpZGVCQm94IiwiaXNCQm94SW50ZXJzZWN0IiwiYmJveDEiLCJiYm94MiIsImJhc2UzIiwicDEiLCJwMiIsInAzIiwicDQiLCJ4NCIsInk0IiwiejIiLCJUdmFsdWVzIiwiQ3ZhbHVlcyIsInN1bSIsImN0IiwieGJhc2UiLCJ5YmFzZSIsImNvbWIiLCJsbCIsImludGVyc2VjdCIsImRlbm9taW5hdG9yIiwicHgiLCJweSIsInB4MiIsInB5MiIsImludGVyIiwiYmV6MSIsImJlejIiLCJpbnRlckhlbHBlciIsImludGVyQ291bnQiLCJqdXN0Q291bnQiLCJsMSIsImwyIiwibjEiLCJuMiIsImRvdHMxIiwiZG90czIiLCJ4eSIsImRpIiwiZGkxIiwiZGoiLCJkajEiLCJjaSIsImNqIiwicGF0aEludGVyc2VjdGlvbiIsInBhdGgxIiwicGF0aDIiLCJpbnRlclBhdGhIZWxwZXIiLCJwYXRoSW50ZXJzZWN0aW9uTnVtYmVyIiwieDFtIiwieTFtIiwieDJtIiwieTJtIiwicGkiLCJwaiIsImludHIiLCJrayIsInNlZ21lbnQxIiwic2VnbWVudDIiLCJpc1BvaW50SW5zaWRlUGF0aCIsInBhdGhCQm94IiwieG1pbiIsInltaW4iLCJ4bWF4IiwieW1heCIsImVsbGlwc2VQYXRoIiwiZ2V0UGF0aCIsInBhdGhUb1JlbGF0aXZlIiwibG93ZXJDYXNlIiwicmVsIiwicGEiLCJwYXRoVG9BYnNvbHV0ZSIsInBhMCIsImNyeiIsImRvdHMiLCJwb3AiLCJjYXRtdWxsUm9tMmJlemllciIsImwyYyIsInEyYyIsIl8xMyIsIl8yMyIsImEyYyIsImxhcmdlX2FyY19mbGFnIiwic3dlZXBfZmxhZyIsInJlY3Vyc2l2ZSIsIl8xMjAiLCJyeDIiLCJyeTIiLCJmMSIsImRmIiwiZjJvbGQiLCJ4Mm9sZCIsInkyb2xkIiwiYzEiLCJzMSIsImMyIiwiczIiLCJoeCIsImh5IiwibTEiLCJtMiIsIm0zIiwibTQiLCJuZXdyZXMiLCJmaW5kRG90QXRTZWdtZW50IiwieDAiLCJ5MCIsInR2YWx1ZXMiLCJib3VuZHMiLCJiMmFjIiwic3FydGIyYWMiLCJqbGVuIiwibXQiLCJjdXJ2ZSIsImJ4IiwiYnkiLCJxeCIsInF5IiwiYXR0cnMyIiwicHJvY2Vzc1BhdGgiLCJwY29tIiwiVCIsImZpeEFyYyIsInBwIiwicGNvbXMxIiwicGNvbXMyIiwiZml4TSIsImExIiwiYTIiLCJwZmlyc3QiLCJzZWciLCJzZWcyIiwic2VnbGVuIiwic2VnMmxlbiIsIm1hcFBhdGgiLCJwYXRoaSIsImNycCIsImlMZW4iLCJnZXRTdWJwYXRoIiwiaW5zaWRlIiwiZm91bmQiLCJpbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3Rpb25OdW1iZXIiLCJpc1BvaW50SW5zaWRlIiwidG9SZWxhdGl2ZSIsInRvQ3ViaWMiLCJTZXQiLCJiaW5kaW5ncyIsInNldHByb3RvIiwidGhpc0FyZyIsImJlZ2luIiwiaGFuZGxlciIsImNhbGxiYWNrZXIiLCJhbmFtZSIsInVuYm91bmQiLCJpbnNlcnRpb24iLCJ0YWlsIiwidG9kZWwiLCJhcmdsZW4iLCJleGNsdWRlIiwic3Ryb2tlIiwiZ2V0RW1wdHkiLCJlcXVhbGlzZVRyYW5zZm9ybSIsIm1heGxlbmd0aCIsInR0MSIsInR0MiIsInBhdGgyYXJyYXkiLCJnZXRWaWV3Qm94IiwiZ2V0Q29sb3VyIiwiaXNOdW1lcmljIiwiYXJyYXlFcXVhbCIsImFycjEiLCJhcnIyIiwiTnVtYmVyIiwiYlVuaXQiLCJzdXBwb3J0c1RvdWNoIiwidG91Y2hNYXAiLCJtb3VzZWRvd24iLCJtb3VzZW1vdmUiLCJtb3VzZXVwIiwiZ2V0U2Nyb2xsIiwicHJldmVudFRvdWNoIiwib3JpZ2luYWxFdmVudCIsImNhbmNlbEJ1YmJsZSIsInN0b3BUb3VjaCIsImFkZEV2ZW50IiwicmVhbE5hbWUiLCJzY3JvbGxZIiwic2Nyb2xsWCIsInRhcmdldFRvdWNoZXMiLCJvbGRlIiwiZHJhZyIsImRyYWdNb3ZlIiwiZHJhZ2kiLCJ0b3VjaCIsImlkZW50aWZpZXIiLCJfZHJhZyIsImRpc3BsYXkiLCJtb3ZlX3Njb3BlIiwiZHJhZ1VwIiwidW5tb3VzZW1vdmUiLCJ1bm1vdXNldXAiLCJlbmRfc2NvcGUiLCJzdGFydF9zY29wZSIsImV2ZW50TmFtZSIsImZfaW4iLCJmX291dCIsInNjb3BlX2luIiwic2NvcGVfb3V0IiwibW91c2VvdmVyIiwibW91c2VvdXQiLCJ1bmhvdmVyIiwidW5tb3VzZW92ZXIiLCJ1bm1vdXNlb3V0Iiwib25tb3ZlIiwib25zdGFydCIsIm9uZW5kIiwib3JpZ1RyYW5zZm9ybSIsInVuZHJhZyIsInVubW91c2Vkb3duIiwicHByb3RvIiwicmd1cmwiLCJmaWxzdHIiLCJmaWx0ZXJVbml0cyIsImRlZiIsInNoYWRvdyIsImdyYXlzY2FsZSIsImFtb3VudCIsInNlcGlhIiwic2F0dXJhdGUiLCJodWVSb3RhdGUiLCJhbW91bnQyIiwiYnJpZ2h0bmVzcyIsImNvbnRyYXN0IiwiZmlyc3RMZXR0ZXIiLCJnZXRBbGlnbiIsIndheSIsImFsaWduIiwiX3JlcXVlc3RBbmltYXRpb25GcmFtZSIsIlNjcm9sbFJldmVhbCIsImNvbmZpZyIsImdldFByb3RvdHlwZU9mIiwidG9vbHMiLCJUb29scyIsImlzU3VwcG9ydGVkIiwiX3Jlc29sdmVDb250YWluZXIiLCJzdG9yZSIsImVsZW1lbnRzIiwiY29udGFpbmVycyIsInNlcXVlbmNlcyIsInVpZCIsImluaXRpYWxpemVkIiwib3JpZ2luIiwibW9iaWxlIiwidXNlRGVsYXkiLCJ2aWV3RmFjdG9yIiwidmlld09mZnNldCIsImJlZm9yZVJldmVhbCIsImRvbUVsIiwiYWZ0ZXJSZXZlYWwiLCJiZWZvcmVSZXNldCIsImFmdGVyUmVzZXQiLCJpbnRlcnZhbCIsInN5bmMiLCJzZXF1ZW5jZSIsInNlcXVlbmNlSWQiLCJfZ2V0UmV2ZWFsRWxlbWVudHMiLCJfbmV4dFVpZCIsImVsZW1JZHMiLCJhY3RpdmUiLCJzZWVuIiwicmV2ZWFsaW5nIiwiX2NvbmZpZ3VyZSIsIl9zdHlsZSIsIl91cGRhdGVTdG9yZSIsInN0eWxlcyIsImlubGluZSIsImluaXRpYWwiLCJfcmVjb3JkIiwiaW5pdFRpbWVvdXQiLCJyZWNvcmQiLCJpc05vZGUiLCJpc05vZGVMaXN0IiwiZXh0ZW5kQ2xvbmUiLCJheGlzIiwiY29tcHV0ZWQiLCJ0cmFuc2l0aW9uIiwiaW5zdGFudCIsIl9nZW5lcmF0ZVRyYW5zaXRpb24iLCJkZWxheWVkIiwiX2dlbmVyYXRlVHJhbnNmb3JtIiwiY3NzRGlzdGFuY2UiLCJzdWJzdHIiLCJfYW5pbWF0ZSIsIl9oYW5kbGVyIiwiX3NldEFjdGl2ZVNlcXVlbmNlcyIsImZvck93biIsIl9pc0VsZW1WaXNpYmxlIiwiX3Nob3VsZFVzZURlbGF5IiwiX3Nob3VsZFJldmVhbCIsIl9xdWV1ZUNhbGxiYWNrIiwiX3F1ZXVlTmV4dEluU2VxdWVuY2UiLCJfc2hvdWxkUmVzZXQiLCJlbGFwc2VkIiwiYmxvY2tlZCIsInN0YXJ0ZWQiLCJjbG9jayIsIl9nZXRDb250YWluZXIiLCJjbGllbnRXaWR0aCIsIl9nZXRTY3JvbGxlZCIsIl9nZXRPZmZzZXQiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0UGFyZW50Iiwic2Nyb2xsZWQiLCJ2RiIsImVsZW1XaWR0aCIsImVsZW1Ub3AiLCJlbGVtTGVmdCIsImVsZW1Cb3R0b20iLCJlbGVtUmlnaHQiLCJjb25maXJtQm91bmRzIiwiaXNQb3NpdGlvbkZpeGVkIiwidmlld1RvcCIsInZpZXdMZWZ0Iiwidmlld0JvdHRvbSIsInZpZXdSaWdodCIsImlzT2JqZWN0Iiwib2JqZWN0IiwiTm9kZSIsInByb3RvdHlwZVRvU3RyaW5nIiwicmVnZXgiLCJOb2RlTGlzdCIsInByb3BlcnR5Iiwic291cmNlIiwiQlIiLCJhZGRMaXN0ZW5lcnMiLCJjbGljayIsInRyaWdnZXJJZCIsInNsaWRlVG9nZ2xlIiwiQlJfQ09PS0lFUyIsInZpc2l0RGl2ZXJzaXR5Iiwic2hvd0RpdmVyc2l0eU1vZGFsIiwib25Mb2FkIiwiY3JlYXRlQ29va2llIiwiZGF5cyIsInNldFRpbWUiLCJleHBpcmVzIiwidG9HTVRTdHJpbmciLCJjb29raWUiLCJyZWFkQ29va2llIiwibmFtZUVRIiwiY2EiLCJlcmFzZUNvb2tpZSIsInZpc2l0ZWREaXZlcnNpdHkiLCJkaXZlcnNpdHlNb2RhbCIsInJlYWR5IiwiRVhQQU5ERVIiLCJoaWRkZW5FeHBlcmllbmNlcyIsImhpZGRlbk1lbnVJdGVtcyIsImV4cGFuZGVyIiwiaGlkZGVuSm9iRGVzY3JpcHRvbiIsIklOU0lHSFRTIiwiY2hhbmdlIiwic2VsZWN0cyIsInF1ZXJ5U3RyaW5nQmFzZSIsInF1ZXJ5U3RyaW5nIiwiZmlsdGVycyIsInBhcmFtTmFtZSIsInBhcmFtVmFsdWUiLCJzZWxlY3RlZEdlb2dyYXBoeSIsInNlbGVjdGVkSW5kdXN0cnkiLCJzZWxlY3RlZFByYWN0aWNlIiwic2VsZWN0ZWRMYW5ndWFnZSIsInNlbGVjdGVkTG9jYXRpb25zIiwic2VsZWN0ZWRBZG1pc3Npb24iLCJzZWxlY3RlZEVkdWNhdGlvbiIsInNlbGVjdGVkS2V5d29yZCIsImdlb2dyYXBoeVNlbGVjdCIsImluZHVzdHJ5U2VsZWN0IiwicHJhY3RpY2VTZWxlY3QiLCJsYW5ndWFnZVNlbGVjdCIsImxvY2F0aW9uU2VsZWN0IiwiYWRtaXNzaW9uU2VsZWN0IiwiZWR1Y2F0aW9uU2VsZWN0Iiwia2V5d29yZElucHV0IiwiTE9DQVRJT05TRUFSQ0hFUiIsImRldGVjdENoYW5nZSIsImtleXdvcmQiLCJOQVYiLCJpbm5lcldpZHRoIiwiZGVza3RvcE1lbnUiLCJzY3JvbGxFdmVudHMiLCJQRU9QTEUiLCJsZXR0ZXJsTGlua0lubmVyV3JhcHBlcnMiLCJsZXR0ZXJBbmNob3IiLCJzZWxlY3RlZGxldHRlcmxMaW5rSW5uZXJXcmFwcGVyIiwicmV2ZWFsQWR2YW5jZWRTZWFyY2giLCJzdGlja3lTaWRlQmFyIiwiaGlkZUFkdmFuY2VkU2VhcmNoIiwiaGVhZGVySGVpZ2h0Iiwic3RpY2tfaW5fcGFyZW50Iiwib2Zmc2V0X3RvcCIsImhvbWVwYWdlIiwiaW5pdGlhbGl6ZVNsaWRlciIsImFuaW1hdGVTdmciLCJzdHJva2VXaWR0aCIsInNsaWNrIiwiY3VycmVudFNsaWRlIiwibmV4dFNsaWRlIiwic2xpZGUiLCJzbGlkZXNUb1Nob3ciLCJzbGlkZXNUb1Njcm9sbCIsImF1dG9wbGF5IiwiYXV0b3BsYXlTcGVlZCIsImFycm93cyIsImZhZGUiLCJwcmV2QXJyb3ciLCJuZXh0QXJyb3ciLCJmb290ZXIiLCJzdGlja3lGb290ZXIiLCJlbG0iLCJlbmFibGVfYm90dG9taW5nIiwiaW5uZXJfc2Nyb2xsaW5nIiwibWFudWFsX3NwYWNlciIsInBhcmVudF9zZWxlY3RvciIsInJlY2FsY19ldmVyeSIsInN0aWNreV9jbGFzcyIsInNwYWNlciIsImJvdHRvbWluZyIsInBhZGRpbmdfYm90dG9tIiwicGFyZW50X3RvcCIsInBhcmVudF9oZWlnaHQiLCJlbF9mbG9hdCIsImRldGFjaGVkIiwiYm90dG9tZWQiLCJmaXhlZCIsImxhc3RfcG9zIiwibGFzdF9zY3JvbGxfaGVpZ2h0IiwicmVjYWxjIiwicmVjYWxjX2FuZF90aWNrIiwicmVjYWxjX2NvdW50ZXIiLCJ0aWNrIiwiYm9yZGVyX3RvcCIsInBhZGRpbmdfdG9wIiwicmVzdG9yZSIsImRlbHRhIiwicmVjYWxjZWQiLCJ3aWxsX2JvdHRvbSIsIndpbl9oZWlnaHQiLCJiYWNrc3RyZXRjaCIsInNjcm9sbFRvIiwiZXhwciIsImNlbnRlcmVkWCIsImNlbnRlcmVkWSIsIm92ZXJmbG93IiwicGFkZGluZyIsImJvcmRlciIsIm1heEhlaWdodCIsIm1heFdpZHRoIiwiaXNCb2R5IiwiJHJvb3QiLCIkd3JhcCIsImJhY2tncm91bmQiLCJwcm94eSIsInJlc2l6ZSIsIiRpbWciLCJyZWxhdGVkVGFyZ2V0IiwiRXZlbnQiLCJjbGVhckludGVydmFsIiwicGF1c2VkIiwiY3ljbGUiLCJwbGF0Zm9ybSIsIm9wZXJhbWluaSIsIlNsaWNrIiwiaW5zdGFuY2VVaWQiLCJzZXR0aW5ncyIsImRhdGFTZXR0aW5ncyIsImFjY2Vzc2liaWxpdHkiLCJhZGFwdGl2ZUhlaWdodCIsImFwcGVuZEFycm93cyIsImFwcGVuZERvdHMiLCJhc05hdkZvciIsImNlbnRlck1vZGUiLCJjZW50ZXJQYWRkaW5nIiwiY3NzRWFzZSIsImN1c3RvbVBhZ2luZyIsInNsaWRlciIsImRvdHNDbGFzcyIsImVkZ2VGcmljdGlvbiIsImZvY3VzT25TZWxlY3QiLCJpbml0aWFsU2xpZGUiLCJsYXp5TG9hZCIsIm1vYmlsZUZpcnN0IiwicGF1c2VPbkZvY3VzIiwicGF1c2VPbkRvdHNIb3ZlciIsInJlc3BvbmRUbyIsInJlc3BvbnNpdmUiLCJyb3dzIiwic2xpZGVzUGVyUm93Iiwic3dpcGVUb1NsaWRlIiwidG91Y2hNb3ZlIiwidG91Y2hUaHJlc2hvbGQiLCJ1c2VDU1MiLCJ1c2VUcmFuc2Zvcm0iLCJ2YXJpYWJsZVdpZHRoIiwidmVydGljYWxTd2lwaW5nIiwid2FpdEZvckFuaW1hdGUiLCJpbml0aWFscyIsImFuaW1hdGluZyIsImRyYWdnaW5nIiwiYXV0b1BsYXlUaW1lciIsImN1cnJlbnREaXJlY3Rpb24iLCJjdXJyZW50TGVmdCIsIiRkb3RzIiwibGlzdFdpZHRoIiwibGlzdEhlaWdodCIsImxvYWRJbmRleCIsIiRuZXh0QXJyb3ciLCIkcHJldkFycm93Iiwic2xpZGVDb3VudCIsInNsaWRlV2lkdGgiLCIkc2xpZGVUcmFjayIsInNsaWRpbmciLCJzbGlkZU9mZnNldCIsInN3aXBlTGVmdCIsIiRsaXN0IiwidG91Y2hPYmplY3QiLCJ0cmFuc2Zvcm1zRW5hYmxlZCIsInVuc2xpY2tlZCIsImFjdGl2ZUJyZWFrcG9pbnQiLCJhbmltVHlwZSIsImFuaW1Qcm9wIiwiYnJlYWtwb2ludHMiLCJicmVha3BvaW50U2V0dGluZ3MiLCJjc3NUcmFuc2l0aW9ucyIsImZvY3Vzc2VkIiwiaW50ZXJydXB0ZWQiLCJoaWRkZW4iLCJwb3NpdGlvblByb3AiLCJyb3dDb3VudCIsInNob3VsZENsaWNrIiwiJHNsaWRlciIsIiRzbGlkZXNDYWNoZSIsInRyYW5zZm9ybVR5cGUiLCJ0cmFuc2l0aW9uVHlwZSIsInZpc2liaWxpdHlDaGFuZ2UiLCJ3aW5kb3dXaWR0aCIsIndpbmRvd1RpbWVyIiwib3JpZ2luYWxTZXR0aW5ncyIsIm1vekhpZGRlbiIsIndlYmtpdEhpZGRlbiIsImF1dG9QbGF5Q2xlYXIiLCJhdXRvUGxheUl0ZXJhdG9yIiwiY2xpY2tIYW5kbGVyIiwic2VsZWN0SGFuZGxlciIsInNldFBvc2l0aW9uIiwic3dpcGVIYW5kbGVyIiwiZHJhZ0hhbmRsZXIiLCJrZXlIYW5kbGVyIiwiaHRtbEV4cHIiLCJyZWdpc3RlckJyZWFrcG9pbnRzIiwiYWN0aXZhdGVBREEiLCJhZGRTbGlkZSIsInNsaWNrQWRkIiwibWFya3VwIiwiYWRkQmVmb3JlIiwidW5sb2FkIiwicmVpbml0IiwiYW5pbWF0ZUhlaWdodCIsInRhcmdldEhlaWdodCIsImFuaW1hdGVTbGlkZSIsInRhcmdldExlZnQiLCJhbmltUHJvcHMiLCJhbmltU3RhcnQiLCJjZWlsIiwiYXBwbHlUcmFuc2l0aW9uIiwiZGlzYWJsZVRyYW5zaXRpb24iLCJnZXROYXZUYXJnZXQiLCJzbGlkZUhhbmRsZXIiLCJzbGlkZVRvIiwiYnVpbGRBcnJvd3MiLCJidWlsZERvdHMiLCJkb3QiLCJnZXREb3RDb3VudCIsImJ1aWxkT3V0Iiwid3JhcEFsbCIsInNldHVwSW5maW5pdGUiLCJ1cGRhdGVEb3RzIiwic2V0U2xpZGVDbGFzc2VzIiwiYnVpbGRSb3dzIiwibmV3U2xpZGVzIiwibnVtT2ZTbGlkZXMiLCJvcmlnaW5hbFNsaWRlcyIsInNsaWRlc1BlclNlY3Rpb24iLCJlbXB0eSIsImNoZWNrUmVzcG9uc2l2ZSIsImZvcmNlVXBkYXRlIiwiYnJlYWtwb2ludCIsInRhcmdldEJyZWFrcG9pbnQiLCJyZXNwb25kVG9XaWR0aCIsInRyaWdnZXJCcmVha3BvaW50Iiwic2xpZGVyV2lkdGgiLCJ1bnNsaWNrIiwicmVmcmVzaCIsImRvbnRBbmltYXRlIiwiaW5kZXhPZmZzZXQiLCJ1bmV2ZW5PZmZzZXQiLCJjaGVja05hdmlnYWJsZSIsIm5hdmlnYWJsZXMiLCJwcmV2TmF2aWdhYmxlIiwiZ2V0TmF2aWdhYmxlSW5kZXhlcyIsImNsZWFuVXBFdmVudHMiLCJpbnRlcnJ1cHQiLCJ2aXNpYmlsaXR5IiwiY2xlYW5VcFNsaWRlRXZlbnRzIiwib3JpZW50YXRpb25DaGFuZ2UiLCJjbGVhblVwUm93cyIsImZhZGVTbGlkZSIsInNsaWRlSW5kZXgiLCJmYWRlU2xpZGVPdXQiLCJmaWx0ZXJTbGlkZXMiLCJzbGlja0ZpbHRlciIsImZvY3VzSGFuZGxlciIsIiRzZiIsImdldEN1cnJlbnQiLCJzbGlja0N1cnJlbnRTbGlkZSIsImJyZWFrUG9pbnQiLCJwYWdlclF0eSIsImdldExlZnQiLCJ2ZXJ0aWNhbEhlaWdodCIsInZlcnRpY2FsT2Zmc2V0IiwidGFyZ2V0U2xpZGUiLCJmbG9vciIsImdldE9wdGlvbiIsInNsaWNrR2V0T3B0aW9uIiwib3B0aW9uIiwiaW5kZXhlcyIsImdldFNsaWNrIiwiZ2V0U2xpZGVDb3VudCIsInNsaWRlc1RyYXZlcnNlZCIsInN3aXBlZFNsaWRlIiwiY2VudGVyT2Zmc2V0IiwiZ29UbyIsInNsaWNrR29UbyIsImNyZWF0aW9uIiwic2V0UHJvcHMiLCJzdGFydExvYWQiLCJsb2FkU2xpZGVyIiwiaW5pdGlhbGl6ZUV2ZW50cyIsInVwZGF0ZUFycm93cyIsImluaXRBREEiLCJpbml0QXJyb3dFdmVudHMiLCJpbml0RG90RXZlbnRzIiwiaW5pdFNsaWRlRXZlbnRzIiwiYWN0aW9uIiwiaW5pdFVJIiwibG9hZFJhbmdlIiwiY2xvbmVSYW5nZSIsInJhbmdlU3RhcnQiLCJyYW5nZUVuZCIsImxvYWRJbWFnZXMiLCJpbWFnZXNTY29wZSIsImltYWdlU291cmNlIiwiaW1hZ2VUb0xvYWQiLCJwcm9ncmVzc2l2ZUxhenlMb2FkIiwic2xpY2tOZXh0Iiwic2xpY2tQYXVzZSIsInBsYXkiLCJzbGlja1BsYXkiLCJwb3N0U2xpZGUiLCJzbGlja1ByZXYiLCJ0cnlDb3VudCIsIiRpbWdzVG9Mb2FkIiwiaW5pdGlhbGl6aW5nIiwibGFzdFZpc2libGVJbmRleCIsImN1cnJlbnRCcmVha3BvaW50IiwicmVzcG9uc2l2ZVNldHRpbmdzIiwid2luZG93RGVsYXkiLCJyZW1vdmVTbGlkZSIsInNsaWNrUmVtb3ZlIiwicmVtb3ZlQmVmb3JlIiwicmVtb3ZlQWxsIiwic2V0Q1NTIiwicG9zaXRpb25Qcm9wcyIsInNldERpbWVuc2lvbnMiLCJzZXRGYWRlIiwic2V0SGVpZ2h0Iiwic2V0T3B0aW9uIiwic2xpY2tTZXRPcHRpb24iLCJib2R5U3R5bGUiLCJXZWJraXRUcmFuc2l0aW9uIiwiTW96VHJhbnNpdGlvbiIsIm1zVHJhbnNpdGlvbiIsIk9UcmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZVByb3BlcnR5Iiwid2Via2l0UGVyc3BlY3RpdmUiLCJNb3pUcmFuc2Zvcm0iLCJNb3pQZXJzcGVjdGl2ZSIsIndlYmtpdFRyYW5zZm9ybSIsIm1zVHJhbnNmb3JtIiwiYWxsU2xpZGVzIiwicmVtYWluZGVyIiwiaW5maW5pdGVDb3VudCIsInRhcmdldEVsZW1lbnQiLCJhbmltU2xpZGUiLCJvbGRTbGlkZSIsInNsaWRlTGVmdCIsIm5hdlRhcmdldCIsInN3aXBlRGlyZWN0aW9uIiwieERpc3QiLCJ5RGlzdCIsInN3aXBlQW5nbGUiLCJzdGFydFgiLCJjdXJYIiwic3RhcnRZIiwiY3VyWSIsInN3aXBlRW5kIiwic3dpcGVMZW5ndGgiLCJlZGdlSGl0IiwibWluU3dpcGUiLCJmaW5nZXJDb3VudCIsInN3aXBlU3RhcnQiLCJzd2lwZU1vdmUiLCJlZGdlV2FzSGl0IiwiY3VyTGVmdCIsInBvc2l0aW9uT2Zmc2V0IiwidW5maWx0ZXJTbGlkZXMiLCJzbGlja1VuZmlsdGVyIiwiZnJvbUJyZWFrcG9pbnQiLCJ0YWJpbmRleCIsInJvbGUiLCJwdXJsIiwidGFnMmF0dHIiLCJmb3JtIiwiYmFzZSIsImlmcmFtZSIsImxpbmsiLCJhbGlhc2VzIiwicGFyc2VyIiwic3RyaWN0IiwibG9vc2UiLCJpc2ludCIsInBhcnNlVXJpIiwic3RyaWN0TW9kZSIsImRlY29kZVVSSSIsInVyaSIsInBhcnNlU3RyaW5nIiwiaG9zdCIsInByb3RvY29sIiwicG9ydCIsImdldEF0dHJOYW1lIiwidG4iLCJwcm9tb3RlIiwicGFydCIsIm1lcmdlIiwicGFpciIsImVxbCIsImJyYWNlIiwibGFzdEJyYWNlSW5LZXkiLCJhY2N1bXVsYXRvciIsImN1cnIiLCJ2QXJnIiwia2V5X2FycmF5IiwiZnBhcmFtIiwic2VnbWVudCIsImZzZWdtZW50IiwiSiIsIksiLCJGIiwiRCIsIkkiXSwibWFwcGluZ3MiOiI7O0FBQUFBLE9BQU9DLFNBQVAsR0FBb0IsWUFBVzs7QUFFN0I7O0FBRUE7Ozs7OztBQU1BOztBQUNBLE1BQUlDLGFBQWEsRUFBakI7O0FBRUE7QUFDQSxNQUFJQyxJQUFKOztBQUVBO0FBQ0EsTUFBSUMsU0FBUyxLQUFiOztBQUVBO0FBQ0EsTUFBSUMsZUFBZSxJQUFuQjs7QUFFQTtBQUNBLE1BQUlDLGtCQUFrQixDQUNwQixRQURvQixFQUVwQixVQUZvQixFQUdwQixNQUhvQixFQUlwQixPQUpvQixFQUtwQixPQUxvQixFQU1wQixPQU5vQixFQU9wQixRQVBvQixDQUF0Qjs7QUFVQTtBQUNBO0FBQ0EsTUFBSUMsYUFBYUMsYUFBakI7O0FBRUE7QUFDQTtBQUNBLE1BQUlDLFlBQVksQ0FDZCxFQURjLEVBQ1Y7QUFDSixJQUZjLEVBRVY7QUFDSixJQUhjLEVBR1Y7QUFDSixJQUpjLEVBSVY7QUFDSixJQUxjLENBS1Y7QUFMVSxHQUFoQjs7QUFRQTtBQUNBLE1BQUlDLFdBQVc7QUFDYixlQUFXLFVBREU7QUFFYixhQUFTLFVBRkk7QUFHYixpQkFBYSxPQUhBO0FBSWIsaUJBQWEsT0FKQTtBQUtiLHFCQUFpQixTQUxKO0FBTWIscUJBQWlCLFNBTko7QUFPYixtQkFBZSxTQVBGO0FBUWIsbUJBQWUsU0FSRjtBQVNiLGtCQUFjO0FBVEQsR0FBZjs7QUFZQTtBQUNBQSxXQUFTRixhQUFULElBQTBCLE9BQTFCOztBQUVBO0FBQ0EsTUFBSUcsYUFBYSxFQUFqQjs7QUFFQTtBQUNBLE1BQUlDLFNBQVM7QUFDWCxPQUFHLEtBRFE7QUFFWCxRQUFJLE9BRk87QUFHWCxRQUFJLE9BSE87QUFJWCxRQUFJ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QUF2RTtBQUF3RixTQUZqUSxFQUVrUXczQixFQUFFenVCLEVBQUYsQ0FBSyxXQUFMLEVBQWlCMHVCLENBQWpCLENBRmxRLEVBRXNSRCxFQUFFenVCLEVBQUYsQ0FBSyxRQUFMLEVBQWMwdUIsQ0FBZCxDQUZ0UixFQUV1U0QsRUFBRXp1QixFQUFGLENBQUssUUFBTCxFQUN2ZTZGLENBRHVlLENBRnZTLEVBRzdMaW9CLEVBQUVqOEIsU0FBUzlDLElBQVgsRUFBaUJpUixFQUFqQixDQUFvQixtQkFBcEIsRUFBd0M2RixDQUF4QyxDQUg2TCxFQUdsSmdvQixFQUFFN3RCLEVBQUYsQ0FBSyxtQkFBTCxFQUF5Qmc4QixDQUF6QixDQUhrSixFQUd0SGpzQyxXQUFXMitCLENBQVgsRUFBYSxDQUFiLENBSCtHO0FBRy9GO0FBQUMsS0FMK1AsQ0FLOVBULElBQUUsQ0FBRixDQUFJLEtBQUlneUMsSUFBRSxLQUFLOXFFLE1BQVgsRUFBa0I4NEIsSUFBRWd5QyxDQUFwQixFQUFzQmh5QyxHQUF0QjtBQUEwQnFaLFVBQUUsS0FBS3JaLENBQUwsQ0FBRixFQUFVK3hDLEVBQUVseUMsRUFBRXdaLENBQUYsQ0FBRixDQUFWO0FBQTFCLEtBQTRDLE9BQU8sSUFBUDtBQUFZLEdBTDNGO0FBSzRGLENBTHpKLEVBSzJKbnZDLElBTDNKLENBS2dLLElBTGhLIiwiZmlsZSI6ImZvdW5kYXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJ3aW5kb3cud2hhdElucHV0ID0gKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKlxuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAgIHZhcmlhYmxlc1xuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAqL1xuXG4gIC8vIGFycmF5IG9mIGFjdGl2ZWx5IHByZXNzZWQga2V5c1xuICB2YXIgYWN0aXZlS2V5cyA9IFtdO1xuXG4gIC8vIGNhY2hlIGRvY3VtZW50LmJvZHlcbiAgdmFyIGJvZHk7XG5cbiAgLy8gYm9vbGVhbjogdHJ1ZSBpZiB0b3VjaCBidWZmZXIgdGltZXIgaXMgcnVubmluZ1xuICB2YXIgYnVmZmVyID0gZmFsc2U7XG5cbiAgLy8gdGhlIGxhc3QgdXNlZCBpbnB1dCB0eXBlXG4gIHZhciBjdXJyZW50SW5wdXQgPSBudWxsO1xuXG4gIC8vIGBpbnB1dGAgdHlwZXMgdGhhdCBkb24ndCBhY2NlcHQgdGV4dFxuICB2YXIgbm9uVHlwaW5nSW5wdXRzID0gW1xuICAgICdidXR0b24nLFxuICAgICdjaGVja2JveCcsXG4gICAgJ2ZpbGUnLFxuICAgICdpbWFnZScsXG4gICAgJ3JhZGlvJyxcbiAgICAncmVzZXQnLFxuICAgICdzdWJtaXQnXG4gIF07XG5cbiAgLy8gZGV0ZWN0IHZlcnNpb24gb2YgbW91c2Ugd2hlZWwgZXZlbnQgdG8gdXNlXG4gIC8vIHZpYSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWxcbiAgdmFyIG1vdXNlV2hlZWwgPSBkZXRlY3RXaGVlbCgpO1xuXG4gIC8vIGxpc3Qgb2YgbW9kaWZpZXIga2V5cyBjb21tb25seSB1c2VkIHdpdGggdGhlIG1vdXNlIGFuZFxuICAvLyBjYW4gYmUgc2FmZWx5IGlnbm9yZWQgdG8gcHJldmVudCBmYWxzZSBrZXlib2FyZCBkZXRlY3Rpb25cbiAgdmFyIGlnbm9yZU1hcCA9IFtcbiAgICAxNiwgLy8gc2hpZnRcbiAgICAxNywgLy8gY29udHJvbFxuICAgIDE4LCAvLyBhbHRcbiAgICA5MSwgLy8gV2luZG93cyBrZXkgLyBsZWZ0IEFwcGxlIGNtZFxuICAgIDkzICAvLyBXaW5kb3dzIG1lbnUgLyByaWdodCBBcHBsZSBjbWRcbiAgXTtcblxuICAvLyBtYXBwaW5nIG9mIGV2ZW50cyB0byBpbnB1dCB0eXBlc1xuICB2YXIgaW5wdXRNYXAgPSB7XG4gICAgJ2tleWRvd24nOiAna2V5Ym9hcmQnLFxuICAgICdrZXl1cCc6ICdrZXlib2FyZCcsXG4gICAgJ21vdXNlZG93bic6ICdtb3VzZScsXG4gICAgJ21vdXNlbW92ZSc6ICdtb3VzZScsXG4gICAgJ01TUG9pbnRlckRvd24nOiAncG9pbnRlcicsXG4gICAgJ01TUG9pbnRlck1vdmUnOiAncG9pbnRlcicsXG4gICAgJ3BvaW50ZXJkb3duJzogJ3BvaW50ZXInLFxuICAgICdwb2ludGVybW92ZSc6ICdwb2ludGVyJyxcbiAgICAndG91Y2hzdGFydCc6ICd0b3VjaCdcbiAgfTtcblxuICAvLyBhZGQgY29ycmVjdCBtb3VzZSB3aGVlbCBldmVudCBtYXBwaW5nIHRvIGBpbnB1dE1hcGBcbiAgaW5wdXRNYXBbZGV0ZWN0V2hlZWwoKV0gPSAnbW91c2UnO1xuXG4gIC8vIGFycmF5IG9mIGFsbCB1c2VkIGlucHV0IHR5cGVzXG4gIHZhciBpbnB1dFR5cGVzID0gW107XG5cbiAgLy8gbWFwcGluZyBvZiBrZXkgY29kZXMgdG8gYSBjb21tb24gbmFtZVxuICB2YXIga2V5TWFwID0ge1xuICAgIDk6ICd0YWInLFxuICAgIDEzOiAnZW50ZXInLFxuICAgIDE2OiAnc2hpZnQnLFxuICAgIDI3OiAnZXNjJyxcbiAgICAzMjogJ3NwYWNlJyxcbiAgICAzNzogJ2xlZnQnLFxuICAgIDM4OiAndXAnLFxuICAgIDM5OiAncmlnaHQnLFxuICAgIDQwOiAnZG93bidcbiAgfTtcblxuICAvLyBtYXAgb2YgSUUgMTAgcG9pbnRlciBldmVudHNcbiAgdmFyIHBvaW50ZXJNYXAgPSB7XG4gICAgMjogJ3RvdWNoJyxcbiAgICAzOiAndG91Y2gnLCAvLyB0cmVhdCBwZW4gbGlrZSB0b3VjaFxuICAgIDQ6ICdtb3VzZSdcbiAgfTtcblxuICAvLyB0b3VjaCBidWZmZXIgdGltZXJcbiAgdmFyIHRpbWVyO1xuXG5cbiAgLypcbiAgICAtLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS1cbiAgKi9cblxuICAvLyBhbGxvd3MgZXZlbnRzIHRoYXQgYXJlIGFsc28gdHJpZ2dlcmVkIHRvIGJlIGZpbHRlcmVkIG91dCBmb3IgYHRvdWNoc3RhcnRgXG4gIGZ1bmN0aW9uIGV2ZW50QnVmZmVyKCkge1xuICAgIGNsZWFyVGltZXIoKTtcbiAgICBzZXRJbnB1dChldmVudCk7XG5cbiAgICBidWZmZXIgPSB0cnVlO1xuICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBidWZmZXIgPSBmYWxzZTtcbiAgICB9LCA2NTApO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyZWRFdmVudChldmVudCkge1xuICAgIGlmICghYnVmZmVyKSBzZXRJbnB1dChldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bkJ1ZmZlcmVkRXZlbnQoZXZlbnQpIHtcbiAgICBjbGVhclRpbWVyKCk7XG4gICAgc2V0SW5wdXQoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJUaW1lcigpIHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldElucHV0KGV2ZW50KSB7XG4gICAgdmFyIGV2ZW50S2V5ID0ga2V5KGV2ZW50KTtcbiAgICB2YXIgdmFsdWUgPSBpbnB1dE1hcFtldmVudC50eXBlXTtcbiAgICBpZiAodmFsdWUgPT09ICdwb2ludGVyJykgdmFsdWUgPSBwb2ludGVyVHlwZShldmVudCk7XG5cbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgdmFsdWUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZSBhbHJlYWR5IHNldFxuICAgIGlmIChjdXJyZW50SW5wdXQgIT09IHZhbHVlKSB7XG4gICAgICB2YXIgZXZlbnRUYXJnZXQgPSB0YXJnZXQoZXZlbnQpO1xuICAgICAgdmFyIGV2ZW50VGFyZ2V0Tm9kZSA9IGV2ZW50VGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgZXZlbnRUYXJnZXRUeXBlID0gKGV2ZW50VGFyZ2V0Tm9kZSA9PT0gJ2lucHV0JykgPyBldmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA6IG51bGw7XG5cbiAgICAgIGlmIChcbiAgICAgICAgKC8vIG9ubHkgaWYgdGhlIHVzZXIgZmxhZyB0byBhbGxvdyB0eXBpbmcgaW4gZm9ybSBmaWVsZHMgaXNuJ3Qgc2V0XG4gICAgICAgICFib2R5Lmhhc0F0dHJpYnV0ZSgnZGF0YS13aGF0aW5wdXQtZm9ybXR5cGluZycpICYmXG5cbiAgICAgICAgLy8gb25seSBpZiBjdXJyZW50SW5wdXQgaGFzIGEgdmFsdWVcbiAgICAgICAgY3VycmVudElucHV0ICYmXG5cbiAgICAgICAgLy8gb25seSBpZiB0aGUgaW5wdXQgaXMgYGtleWJvYXJkYFxuICAgICAgICB2YWx1ZSA9PT0gJ2tleWJvYXJkJyAmJlxuXG4gICAgICAgIC8vIG5vdCBpZiB0aGUga2V5IGlzIGBUQUJgXG4gICAgICAgIGtleU1hcFtldmVudEtleV0gIT09ICd0YWInICYmXG5cbiAgICAgICAgLy8gb25seSBpZiB0aGUgdGFyZ2V0IGlzIGEgZm9ybSBpbnB1dCB0aGF0IGFjY2VwdHMgdGV4dFxuICAgICAgICAoXG4gICAgICAgICAgIGV2ZW50VGFyZ2V0Tm9kZSA9PT0gJ3RleHRhcmVhJyB8fFxuICAgICAgICAgICBldmVudFRhcmdldE5vZGUgPT09ICdzZWxlY3QnIHx8XG4gICAgICAgICAgIChldmVudFRhcmdldE5vZGUgPT09ICdpbnB1dCcgJiYgbm9uVHlwaW5nSW5wdXRzLmluZGV4T2YoZXZlbnRUYXJnZXRUeXBlKSA8IDApXG4gICAgICAgICkpIHx8IChcbiAgICAgICAgICAvLyBpZ25vcmUgbW9kaWZpZXIga2V5c1xuICAgICAgICAgIGlnbm9yZU1hcC5pbmRleE9mKGV2ZW50S2V5KSA+IC0xXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICAvLyBpZ25vcmUga2V5Ym9hcmQgdHlwaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2hJbnB1dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAna2V5Ym9hcmQnKSBsb2dLZXlzKGV2ZW50S2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN3aXRjaElucHV0KHN0cmluZykge1xuICAgIGN1cnJlbnRJbnB1dCA9IHN0cmluZztcbiAgICBib2R5LnNldEF0dHJpYnV0ZSgnZGF0YS13aGF0aW5wdXQnLCBjdXJyZW50SW5wdXQpO1xuXG4gICAgaWYgKGlucHV0VHlwZXMuaW5kZXhPZihjdXJyZW50SW5wdXQpID09PSAtMSkgaW5wdXRUeXBlcy5wdXNoKGN1cnJlbnRJbnB1dCk7XG4gIH1cblxuICBmdW5jdGlvbiBrZXkoZXZlbnQpIHtcbiAgICByZXR1cm4gKGV2ZW50LmtleUNvZGUpID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LndoaWNoO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFyZ2V0KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnRlclR5cGUoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBvaW50ZXJNYXBbZXZlbnQucG9pbnRlclR5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGV2ZW50LnBvaW50ZXJUeXBlID09PSAncGVuJykgPyAndG91Y2gnIDogZXZlbnQucG9pbnRlclR5cGU7IC8vIHRyZWF0IHBlbiBsaWtlIHRvdWNoXG4gICAgfVxuICB9XG5cbiAgLy8ga2V5Ym9hcmQgbG9nZ2luZ1xuICBmdW5jdGlvbiBsb2dLZXlzKGV2ZW50S2V5KSB7XG4gICAgaWYgKGFjdGl2ZUtleXMuaW5kZXhPZihrZXlNYXBbZXZlbnRLZXldKSA9PT0gLTEgJiYga2V5TWFwW2V2ZW50S2V5XSkgYWN0aXZlS2V5cy5wdXNoKGtleU1hcFtldmVudEtleV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5Mb2dLZXlzKGV2ZW50KSB7XG4gICAgdmFyIGV2ZW50S2V5ID0ga2V5KGV2ZW50KTtcbiAgICB2YXIgYXJyYXlQb3MgPSBhY3RpdmVLZXlzLmluZGV4T2Yoa2V5TWFwW2V2ZW50S2V5XSk7XG5cbiAgICBpZiAoYXJyYXlQb3MgIT09IC0xKSBhY3RpdmVLZXlzLnNwbGljZShhcnJheVBvcywgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gICAgLy8gcG9pbnRlciBldmVudHMgKG1vdXNlLCBwZW4sIHRvdWNoKVxuICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgYnVmZmVyZWRFdmVudCk7XG4gICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgYnVmZmVyZWRFdmVudCk7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcbiAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyRG93bicsIGJ1ZmZlcmVkRXZlbnQpO1xuICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJNb3ZlJywgYnVmZmVyZWRFdmVudCk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gbW91c2UgZXZlbnRzXG4gICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGJ1ZmZlcmVkRXZlbnQpO1xuICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBidWZmZXJlZEV2ZW50KTtcblxuICAgICAgLy8gdG91Y2ggZXZlbnRzXG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGV2ZW50QnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtb3VzZSB3aGVlbFxuICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVdoZWVsLCBidWZmZXJlZEV2ZW50KTtcblxuICAgIC8vIGtleWJvYXJkIGV2ZW50c1xuICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHVuQnVmZmVyZWRFdmVudCk7XG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVuQnVmZmVyZWRFdmVudCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1bkxvZ0tleXMpO1xuICB9XG5cblxuICAvKlxuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAgIHV0aWxpdGllc1xuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAqL1xuXG4gIC8vIGRldGVjdCB2ZXJzaW9uIG9mIG1vdXNlIHdoZWVsIGV2ZW50IHRvIHVzZVxuICAvLyB2aWEgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsXG4gIGZ1bmN0aW9uIGRldGVjdFdoZWVsKCkge1xuICAgIHJldHVybiBtb3VzZVdoZWVsID0gJ29ud2hlZWwnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpID9cbiAgICAgICd3aGVlbCcgOiAvLyBNb2Rlcm4gYnJvd3NlcnMgc3VwcG9ydCBcIndoZWVsXCJcblxuICAgICAgZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAnbW91c2V3aGVlbCcgOiAvLyBXZWJraXQgYW5kIElFIHN1cHBvcnQgYXQgbGVhc3QgXCJtb3VzZXdoZWVsXCJcbiAgICAgICAgJ0RPTU1vdXNlU2Nyb2xsJzsgLy8gbGV0J3MgYXNzdW1lIHRoYXQgcmVtYWluaW5nIGJyb3dzZXJzIGFyZSBvbGRlciBGaXJlZm94XG4gIH1cblxuXG4gIC8qXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICAgaW5pdFxuXG4gICAgZG9uJ3Qgc3RhcnQgc2NyaXB0IHVubGVzcyBicm93c2VyIGN1dHMgdGhlIG11c3RhcmQsXG4gICAgYWxzbyBwYXNzZXMgaWYgcG9seWZpbGxzIGFyZSB1c2VkXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICovXG5cbiAgaWYgKFxuICAgICdhZGRFdmVudExpc3RlbmVyJyBpbiB3aW5kb3cgJiZcbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZlxuICApIHtcblxuICAgIC8vIGlmIHRoZSBkb20gaXMgYWxyZWFkeSByZWFkeSBhbHJlYWR5IChzY3JpcHQgd2FzIHBsYWNlZCBhdCBib3R0b20gb2YgPGJvZHk+KVxuICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICBiaW5kRXZlbnRzKCk7XG5cbiAgICAvLyBvdGhlcndpc2Ugd2FpdCBmb3IgdGhlIGRvbSB0byBsb2FkIChzY3JpcHQgd2FzIHBsYWNlZCBpbiB0aGUgPGhlYWQ+KVxuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgYmluZEV2ZW50cyk7XG4gICAgfVxuICB9XG5cblxuICAvKlxuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAgIGFwaVxuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAqL1xuXG4gIHJldHVybiB7XG5cbiAgICAvLyByZXR1cm5zIHN0cmluZzogdGhlIGN1cnJlbnQgaW5wdXQgdHlwZVxuICAgIGFzazogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50SW5wdXQ7IH0sXG5cbiAgICAvLyByZXR1cm5zIGFycmF5OiBjdXJyZW50bHkgcHJlc3NlZCBrZXlzXG4gICAga2V5czogZnVuY3Rpb24oKSB7IHJldHVybiBhY3RpdmVLZXlzOyB9LFxuXG4gICAgLy8gcmV0dXJucyBhcnJheTogYWxsIHRoZSBkZXRlY3RlZCBpbnB1dCB0eXBlc1xuICAgIHR5cGVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIGlucHV0VHlwZXM7IH0sXG5cbiAgICAvLyBhY2NlcHRzIHN0cmluZzogbWFudWFsbHkgc2V0IHRoZSBpbnB1dCB0eXBlXG4gICAgc2V0OiBzd2l0Y2hJbnB1dFxuICB9O1xuXG59KCkpO1xuIiwiIWZ1bmN0aW9uKCQpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBGT1VOREFUSU9OX1ZFUlNJT04gPSAnNi4yLjInO1xuXG4vLyBHbG9iYWwgRm91bmRhdGlvbiBvYmplY3Rcbi8vIFRoaXMgaXMgYXR0YWNoZWQgdG8gdGhlIHdpbmRvdywgb3IgdXNlZCBhcyBhIG1vZHVsZSBmb3IgQU1EL0Jyb3dzZXJpZnlcbnZhciBGb3VuZGF0aW9uID0ge1xuICB2ZXJzaW9uOiBGT1VOREFUSU9OX1ZFUlNJT04sXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBpbml0aWFsaXplZCBwbHVnaW5zLlxuICAgKi9cbiAgX3BsdWdpbnM6IHt9LFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgZ2VuZXJhdGVkIHVuaXF1ZSBpZHMgZm9yIHBsdWdpbiBpbnN0YW5jZXNcbiAgICovXG4gIF91dWlkczogW10sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGZvciBSVEwgc3VwcG9ydFxuICAgKi9cbiAgcnRsOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiAkKCdodG1sJykuYXR0cignZGlyJykgPT09ICdydGwnO1xuICB9LFxuICAvKipcbiAgICogRGVmaW5lcyBhIEZvdW5kYXRpb24gcGx1Z2luLCBhZGRpbmcgaXQgdG8gdGhlIGBGb3VuZGF0aW9uYCBuYW1lc3BhY2UgYW5kIHRoZSBsaXN0IG9mIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZSB3aGVuIHJlZmxvd2luZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcGx1Z2luLlxuICAgKi9cbiAgcGx1Z2luOiBmdW5jdGlvbihwbHVnaW4sIG5hbWUpIHtcbiAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIGFkZGluZyB0byBnbG9iYWwgRm91bmRhdGlvbiBvYmplY3RcbiAgICAvLyBFeGFtcGxlczogRm91bmRhdGlvbi5SZXZlYWwsIEZvdW5kYXRpb24uT2ZmQ2FudmFzXG4gICAgdmFyIGNsYXNzTmFtZSA9IChuYW1lIHx8IGZ1bmN0aW9uTmFtZShwbHVnaW4pKTtcbiAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIHN0b3JpbmcgdGhlIHBsdWdpbiwgYWxzbyB1c2VkIHRvIGNyZWF0ZSB0aGUgaWRlbnRpZnlpbmcgZGF0YSBhdHRyaWJ1dGUgZm9yIHRoZSBwbHVnaW5cbiAgICAvLyBFeGFtcGxlczogZGF0YS1yZXZlYWwsIGRhdGEtb2ZmLWNhbnZhc1xuICAgIHZhciBhdHRyTmFtZSAgPSBoeXBoZW5hdGUoY2xhc3NOYW1lKTtcblxuICAgIC8vIEFkZCB0byB0aGUgRm91bmRhdGlvbiBvYmplY3QgYW5kIHRoZSBwbHVnaW5zIGxpc3QgKGZvciByZWZsb3dpbmcpXG4gICAgdGhpcy5fcGx1Z2luc1thdHRyTmFtZV0gPSB0aGlzW2NsYXNzTmFtZV0gPSBwbHVnaW47XG4gIH0sXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogUG9wdWxhdGVzIHRoZSBfdXVpZHMgYXJyYXkgd2l0aCBwb2ludGVycyB0byBlYWNoIGluZGl2aWR1YWwgcGx1Z2luIGluc3RhbmNlLlxuICAgKiBBZGRzIHRoZSBgemZQbHVnaW5gIGRhdGEtYXR0cmlidXRlIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlZCBwbHVnaW5zIHRvIGFsbG93IHVzZSBvZiAkKHNlbGVjdG9yKS5mb3VuZGF0aW9uKG1ldGhvZCkgY2FsbHMuXG4gICAqIEFsc28gZmlyZXMgdGhlIGluaXRpYWxpemF0aW9uIGV2ZW50IGZvciBlYWNoIHBsdWdpbiwgY29uc29saWRhdGluZyByZXBldGl0aXZlIGNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBhbiBpbnN0YW5jZSBvZiBhIHBsdWdpbiwgdXN1YWxseSBgdGhpc2AgaW4gY29udGV4dC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLCBwYXNzZWQgYXMgYSBjYW1lbENhc2VkIHN0cmluZy5cbiAgICogQGZpcmVzIFBsdWdpbiNpbml0XG4gICAqL1xuICByZWdpc3RlclBsdWdpbjogZnVuY3Rpb24ocGx1Z2luLCBuYW1lKXtcbiAgICB2YXIgcGx1Z2luTmFtZSA9IG5hbWUgPyBoeXBoZW5hdGUobmFtZSkgOiBmdW5jdGlvbk5hbWUocGx1Z2luLmNvbnN0cnVjdG9yKS50b0xvd2VyQ2FzZSgpO1xuICAgIHBsdWdpbi51dWlkID0gdGhpcy5HZXRZb0RpZ2l0cyg2LCBwbHVnaW5OYW1lKTtcblxuICAgIGlmKCFwbHVnaW4uJGVsZW1lbnQuYXR0cihgZGF0YS0ke3BsdWdpbk5hbWV9YCkpeyBwbHVnaW4uJGVsZW1lbnQuYXR0cihgZGF0YS0ke3BsdWdpbk5hbWV9YCwgcGx1Z2luLnV1aWQpOyB9XG4gICAgaWYoIXBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpKXsgcGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJywgcGx1Z2luKTsgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgaW5pdGlhbGl6ZWQuXG4gICAgICAgICAgICogQGV2ZW50IFBsdWdpbiNpbml0XG4gICAgICAgICAgICovXG4gICAgcGx1Z2luLiRlbGVtZW50LnRyaWdnZXIoYGluaXQuemYuJHtwbHVnaW5OYW1lfWApO1xuXG4gICAgdGhpcy5fdXVpZHMucHVzaChwbHVnaW4udXVpZCk7XG5cbiAgICByZXR1cm47XG4gIH0sXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogUmVtb3ZlcyB0aGUgcGx1Z2lucyB1dWlkIGZyb20gdGhlIF91dWlkcyBhcnJheS5cbiAgICogUmVtb3ZlcyB0aGUgemZQbHVnaW4gZGF0YSBhdHRyaWJ1dGUsIGFzIHdlbGwgYXMgdGhlIGRhdGEtcGx1Z2luLW5hbWUgYXR0cmlidXRlLlxuICAgKiBBbHNvIGZpcmVzIHRoZSBkZXN0cm95ZWQgZXZlbnQgZm9yIHRoZSBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZXRpdGl2ZSBjb2RlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gYW4gaW5zdGFuY2Ugb2YgYSBwbHVnaW4sIHVzdWFsbHkgYHRoaXNgIGluIGNvbnRleHQuXG4gICAqIEBmaXJlcyBQbHVnaW4jZGVzdHJveWVkXG4gICAqL1xuICB1bnJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4pe1xuICAgIHZhciBwbHVnaW5OYW1lID0gaHlwaGVuYXRlKGZ1bmN0aW9uTmFtZShwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nKS5jb25zdHJ1Y3RvcikpO1xuXG4gICAgdGhpcy5fdXVpZHMuc3BsaWNlKHRoaXMuX3V1aWRzLmluZGV4T2YocGx1Z2luLnV1aWQpLCAxKTtcbiAgICBwbHVnaW4uJGVsZW1lbnQucmVtb3ZlQXR0cihgZGF0YS0ke3BsdWdpbk5hbWV9YCkucmVtb3ZlRGF0YSgnemZQbHVnaW4nKVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgYmVlbiBkZXN0cm95ZWQuXG4gICAgICAgICAgICogQGV2ZW50IFBsdWdpbiNkZXN0cm95ZWRcbiAgICAgICAgICAgKi9cbiAgICAgICAgICAudHJpZ2dlcihgZGVzdHJveWVkLnpmLiR7cGx1Z2luTmFtZX1gKTtcbiAgICBmb3IodmFyIHByb3AgaW4gcGx1Z2luKXtcbiAgICAgIHBsdWdpbltwcm9wXSA9IG51bGw7Ly9jbGVhbiB1cCBzY3JpcHQgdG8gcHJlcCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgIH1cbiAgICByZXR1cm47XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBDYXVzZXMgb25lIG9yIG1vcmUgYWN0aXZlIHBsdWdpbnMgdG8gcmUtaW5pdGlhbGl6ZSwgcmVzZXR0aW5nIGV2ZW50IGxpc3RlbmVycywgcmVjYWxjdWxhdGluZyBwb3NpdGlvbnMsIGV0Yy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBsdWdpbnMgLSBvcHRpb25hbCBzdHJpbmcgb2YgYW4gaW5kaXZpZHVhbCBwbHVnaW4ga2V5LCBhdHRhaW5lZCBieSBjYWxsaW5nIGAkKGVsZW1lbnQpLmRhdGEoJ3BsdWdpbk5hbWUnKWAsIG9yIHN0cmluZyBvZiBhIHBsdWdpbiBjbGFzcyBpLmUuIGAnZHJvcGRvd24nYFxuICAgKiBAZGVmYXVsdCBJZiBubyBhcmd1bWVudCBpcyBwYXNzZWQsIHJlZmxvdyBhbGwgY3VycmVudGx5IGFjdGl2ZSBwbHVnaW5zLlxuICAgKi9cbiAgIHJlSW5pdDogZnVuY3Rpb24ocGx1Z2lucyl7XG4gICAgIHZhciBpc0pRID0gcGx1Z2lucyBpbnN0YW5jZW9mICQ7XG4gICAgIHRyeXtcbiAgICAgICBpZihpc0pRKXtcbiAgICAgICAgIHBsdWdpbnMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAkKHRoaXMpLmRhdGEoJ3pmUGx1Z2luJykuX2luaXQoKTtcbiAgICAgICAgIH0pO1xuICAgICAgIH1lbHNle1xuICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgcGx1Z2lucyxcbiAgICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgIGZucyA9IHtcbiAgICAgICAgICAgJ29iamVjdCc6IGZ1bmN0aW9uKHBsZ3Mpe1xuICAgICAgICAgICAgIHBsZ3MuZm9yRWFjaChmdW5jdGlvbihwKXtcbiAgICAgICAgICAgICAgIHAgPSBoeXBoZW5hdGUocCk7XG4gICAgICAgICAgICAgICAkKCdbZGF0YS0nKyBwICsnXScpLmZvdW5kYXRpb24oJ19pbml0Jyk7XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgICdzdHJpbmcnOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgIHBsdWdpbnMgPSBoeXBoZW5hdGUocGx1Z2lucyk7XG4gICAgICAgICAgICAgJCgnW2RhdGEtJysgcGx1Z2lucyArJ10nKS5mb3VuZGF0aW9uKCdfaW5pdCcpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICAndW5kZWZpbmVkJzogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICB0aGlzWydvYmplY3QnXShPYmplY3Qua2V5cyhfdGhpcy5fcGx1Z2lucykpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9O1xuICAgICAgICAgZm5zW3R5cGVdKHBsdWdpbnMpO1xuICAgICAgIH1cbiAgICAgfWNhdGNoKGVycil7XG4gICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICB9ZmluYWxseXtcbiAgICAgICByZXR1cm4gcGx1Z2lucztcbiAgICAgfVxuICAgfSxcblxuICAvKipcbiAgICogcmV0dXJucyBhIHJhbmRvbSBiYXNlLTM2IHVpZCB3aXRoIG5hbWVzcGFjaW5nXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gbnVtYmVyIG9mIHJhbmRvbSBiYXNlLTM2IGRpZ2l0cyBkZXNpcmVkLiBJbmNyZWFzZSBmb3IgbW9yZSByYW5kb20gc3RyaW5ncy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIG5hbWUgb2YgcGx1Z2luIHRvIGJlIGluY29ycG9yYXRlZCBpbiB1aWQsIG9wdGlvbmFsLlxuICAgKiBAZGVmYXVsdCB7U3RyaW5nfSAnJyAtIGlmIG5vIHBsdWdpbiBuYW1lIGlzIHByb3ZpZGVkLCBub3RoaW5nIGlzIGFwcGVuZGVkIHRvIHRoZSB1aWQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdW5pcXVlIGlkXG4gICAqL1xuICBHZXRZb0RpZ2l0czogZnVuY3Rpb24obGVuZ3RoLCBuYW1lc3BhY2Upe1xuICAgIGxlbmd0aCA9IGxlbmd0aCB8fCA2O1xuICAgIHJldHVybiBNYXRoLnJvdW5kKChNYXRoLnBvdygzNiwgbGVuZ3RoICsgMSkgLSBNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMzYsIGxlbmd0aCkpKS50b1N0cmluZygzNikuc2xpY2UoMSkgKyAobmFtZXNwYWNlID8gYC0ke25hbWVzcGFjZX1gIDogJycpO1xuICB9LFxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBwbHVnaW5zIG9uIGFueSBlbGVtZW50cyB3aXRoaW4gYGVsZW1gIChhbmQgYGVsZW1gIGl0c2VsZikgdGhhdCBhcmVuJ3QgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgdG8gY2hlY2sgaW5zaWRlLiBBbHNvIGNoZWNrcyB0aGUgZWxlbWVudCBpdHNlbGYsIHVubGVzcyBpdCdzIHRoZSBgZG9jdW1lbnRgIG9iamVjdC5cbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBsdWdpbnMgLSBBIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplLiBMZWF2ZSB0aGlzIG91dCB0byBpbml0aWFsaXplIGV2ZXJ5dGhpbmcuXG4gICAqL1xuICByZWZsb3c6IGZ1bmN0aW9uKGVsZW0sIHBsdWdpbnMpIHtcblxuICAgIC8vIElmIHBsdWdpbnMgaXMgdW5kZWZpbmVkLCBqdXN0IGdyYWIgZXZlcnl0aGluZ1xuICAgIGlmICh0eXBlb2YgcGx1Z2lucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBsdWdpbnMgPSBPYmplY3Qua2V5cyh0aGlzLl9wbHVnaW5zKTtcbiAgICB9XG4gICAgLy8gSWYgcGx1Z2lucyBpcyBhIHN0cmluZywgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIG9uZSBpdGVtXG4gICAgZWxzZSBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwbHVnaW5zID0gW3BsdWdpbnNdO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBwbHVnaW5cbiAgICAkLmVhY2gocGx1Z2lucywgZnVuY3Rpb24oaSwgbmFtZSkge1xuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHBsdWdpblxuICAgICAgdmFyIHBsdWdpbiA9IF90aGlzLl9wbHVnaW5zW25hbWVdO1xuXG4gICAgICAvLyBMb2NhbGl6ZSB0aGUgc2VhcmNoIHRvIGFsbCBlbGVtZW50cyBpbnNpZGUgZWxlbSwgYXMgd2VsbCBhcyBlbGVtIGl0c2VsZiwgdW5sZXNzIGVsZW0gPT09IGRvY3VtZW50XG4gICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pLmZpbmQoJ1tkYXRhLScrbmFtZSsnXScpLmFkZEJhY2soJ1tkYXRhLScrbmFtZSsnXScpO1xuXG4gICAgICAvLyBGb3IgZWFjaCBwbHVnaW4gZm91bmQsIGluaXRpYWxpemUgaXRcbiAgICAgICRlbGVtLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciAkZWwgPSAkKHRoaXMpLFxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICAvLyBEb24ndCBkb3VibGUtZGlwIG9uIHBsdWdpbnNcbiAgICAgICAgaWYgKCRlbC5kYXRhKCd6ZlBsdWdpbicpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gaW5pdGlhbGl6ZSBcIituYW1lK1wiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZigkZWwuYXR0cignZGF0YS1vcHRpb25zJykpe1xuICAgICAgICAgIHZhciB0aGluZyA9ICRlbC5hdHRyKCdkYXRhLW9wdGlvbnMnKS5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24oZSwgaSl7XG4gICAgICAgICAgICB2YXIgb3B0ID0gZS5zcGxpdCgnOicpLm1hcChmdW5jdGlvbihlbCl7IHJldHVybiBlbC50cmltKCk7IH0pO1xuICAgICAgICAgICAgaWYob3B0WzBdKSBvcHRzW29wdFswXV0gPSBwYXJzZVZhbHVlKG9wdFsxXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5e1xuICAgICAgICAgICRlbC5kYXRhKCd6ZlBsdWdpbicsIG5ldyBwbHVnaW4oJCh0aGlzKSwgb3B0cykpO1xuICAgICAgICB9Y2F0Y2goZXIpe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXIpO1xuICAgICAgICB9ZmluYWxseXtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBnZXRGbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgdHJhbnNpdGlvbmVuZDogZnVuY3Rpb24oJGVsZW0pe1xuICAgIHZhciB0cmFuc2l0aW9ucyA9IHtcbiAgICAgICd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICAnTW96VHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgICdPVHJhbnNpdGlvbic6ICdvdHJhbnNpdGlvbmVuZCdcbiAgICB9O1xuICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIGVuZDtcblxuICAgIGZvciAodmFyIHQgaW4gdHJhbnNpdGlvbnMpe1xuICAgICAgaWYgKHR5cGVvZiBlbGVtLnN0eWxlW3RdICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIGVuZCA9IHRyYW5zaXRpb25zW3RdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihlbmQpe1xuICAgICAgcmV0dXJuIGVuZDtcbiAgICB9ZWxzZXtcbiAgICAgIGVuZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgJGVsZW0udHJpZ2dlckhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCBbJGVsZW1dKTtcbiAgICAgIH0sIDEpO1xuICAgICAgcmV0dXJuICd0cmFuc2l0aW9uZW5kJztcbiAgICB9XG4gIH1cbn07XG5cbkZvdW5kYXRpb24udXRpbCA9IHtcbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGZvciBhcHBseWluZyBhIGRlYm91bmNlIGVmZmVjdCB0byBhIGZ1bmN0aW9uIGNhbGwuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGF0IGVuZCBvZiB0aW1lb3V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkgLSBUaW1lIGluIG1zIHRvIGRlbGF5IHRoZSBjYWxsIG9mIGBmdW5jYC5cbiAgICogQHJldHVybnMgZnVuY3Rpb25cbiAgICovXG4gIHRocm90dGxlOiBmdW5jdGlvbiAoZnVuYywgZGVsYXkpIHtcbiAgICB2YXIgdGltZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgaWYgKHRpbWVyID09PSBudWxsKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vLyBUT0RPOiBjb25zaWRlciBub3QgbWFraW5nIHRoaXMgYSBqUXVlcnkgZnVuY3Rpb25cbi8vIFRPRE86IG5lZWQgd2F5IHRvIHJlZmxvdyB2cy4gcmUtaW5pdGlhbGl6ZVxuLyoqXG4gKiBUaGUgRm91bmRhdGlvbiBqUXVlcnkgbWV0aG9kLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IG1ldGhvZCAtIEFuIGFjdGlvbiB0byBwZXJmb3JtIG9uIHRoZSBjdXJyZW50IGpRdWVyeSBvYmplY3QuXG4gKi9cbnZhciBmb3VuZGF0aW9uID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIG1ldGhvZCxcbiAgICAgICRtZXRhID0gJCgnbWV0YS5mb3VuZGF0aW9uLW1xJyksXG4gICAgICAkbm9KUyA9ICQoJy5uby1qcycpO1xuXG4gIGlmKCEkbWV0YS5sZW5ndGgpe1xuICAgICQoJzxtZXRhIGNsYXNzPVwiZm91bmRhdGlvbi1tcVwiPicpLmFwcGVuZFRvKGRvY3VtZW50LmhlYWQpO1xuICB9XG4gIGlmKCRub0pTLmxlbmd0aCl7XG4gICAgJG5vSlMucmVtb3ZlQ2xhc3MoJ25vLWpzJyk7XG4gIH1cblxuICBpZih0eXBlID09PSAndW5kZWZpbmVkJyl7Ly9uZWVkcyB0byBpbml0aWFsaXplIHRoZSBGb3VuZGF0aW9uIG9iamVjdCwgb3IgYW4gaW5kaXZpZHVhbCBwbHVnaW4uXG4gICAgRm91bmRhdGlvbi5NZWRpYVF1ZXJ5Ll9pbml0KCk7XG4gICAgRm91bmRhdGlvbi5yZWZsb3codGhpcyk7XG4gIH1lbHNlIGlmKHR5cGUgPT09ICdzdHJpbmcnKXsvL2FuIGluZGl2aWR1YWwgbWV0aG9kIHRvIGludm9rZSBvbiBhIHBsdWdpbiBvciBncm91cCBvZiBwbHVnaW5zXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOy8vY29sbGVjdCBhbGwgdGhlIGFyZ3VtZW50cywgaWYgbmVjZXNzYXJ5XG4gICAgdmFyIHBsdWdDbGFzcyA9IHRoaXMuZGF0YSgnemZQbHVnaW4nKTsvL2RldGVybWluZSB0aGUgY2xhc3Mgb2YgcGx1Z2luXG5cbiAgICBpZihwbHVnQ2xhc3MgIT09IHVuZGVmaW5lZCAmJiBwbHVnQ2xhc3NbbWV0aG9kXSAhPT0gdW5kZWZpbmVkKXsvL21ha2Ugc3VyZSBib3RoIHRoZSBjbGFzcyBhbmQgbWV0aG9kIGV4aXN0XG4gICAgICBpZih0aGlzLmxlbmd0aCA9PT0gMSl7Ly9pZiB0aGVyZSdzIG9ubHkgb25lLCBjYWxsIGl0IGRpcmVjdGx5LlxuICAgICAgICAgIHBsdWdDbGFzc1ttZXRob2RdLmFwcGx5KHBsdWdDbGFzcywgYXJncyk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGksIGVsKXsvL290aGVyd2lzZSBsb29wIHRocm91Z2ggdGhlIGpRdWVyeSBjb2xsZWN0aW9uIGFuZCBpbnZva2UgdGhlIG1ldGhvZCBvbiBlYWNoXG4gICAgICAgICAgcGx1Z0NsYXNzW21ldGhvZF0uYXBwbHkoJChlbCkuZGF0YSgnemZQbHVnaW4nKSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1lbHNley8vZXJyb3IgZm9yIG5vIGNsYXNzIG9yIG5vIG1ldGhvZFxuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiV2UncmUgc29ycnksICdcIiArIG1ldGhvZCArIFwiJyBpcyBub3QgYW4gYXZhaWxhYmxlIG1ldGhvZCBmb3IgXCIgKyAocGx1Z0NsYXNzID8gZnVuY3Rpb25OYW1lKHBsdWdDbGFzcykgOiAndGhpcyBlbGVtZW50JykgKyAnLicpO1xuICAgIH1cbiAgfWVsc2V7Ly9lcnJvciBmb3IgaW52YWxpZCBhcmd1bWVudCB0eXBlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV2UncmUgc29ycnksICR7dHlwZX0gaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyLiBZb3UgbXVzdCB1c2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBtZXRob2QgeW91IHdpc2ggdG8gaW52b2tlLmApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxud2luZG93LkZvdW5kYXRpb24gPSBGb3VuZGF0aW9uO1xuJC5mbi5mb3VuZGF0aW9uID0gZm91bmRhdGlvbjtcblxuLy8gUG9seWZpbGwgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuKGZ1bmN0aW9uKCkge1xuICBpZiAoIURhdGUubm93IHx8ICF3aW5kb3cuRGF0ZS5ub3cpXG4gICAgd2luZG93LkRhdGUubm93ID0gRGF0ZS5ub3cgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuXG4gIHZhciB2ZW5kb3JzID0gWyd3ZWJraXQnLCAnbW96J107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsraSkge1xuICAgICAgdmFyIHZwID0gdmVuZG9yc1tpXTtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdnArJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gKHdpbmRvd1t2cCsnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93W3ZwKydDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSk7XG4gIH1cbiAgaWYgKC9pUChhZHxob25lfG9kKS4qT1MgNi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICB8fCAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBuZXh0VGltZSA9IE1hdGgubWF4KGxhc3RUaW1lICsgMTYsIG5vdyk7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhsYXN0VGltZSA9IG5leHRUaW1lKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFRpbWUgLSBub3cpO1xuICAgIH07XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2xlYXJUaW1lb3V0O1xuICB9XG4gIC8qKlxuICAgKiBQb2x5ZmlsbCBmb3IgcGVyZm9ybWFuY2Uubm93LCByZXF1aXJlZCBieSByQUZcbiAgICovXG4gIGlmKCF3aW5kb3cucGVyZm9ybWFuY2UgfHwgIXdpbmRvdy5wZXJmb3JtYW5jZS5ub3cpe1xuICAgIHdpbmRvdy5wZXJmb3JtYW5jZSA9IHtcbiAgICAgIHN0YXJ0OiBEYXRlLm5vdygpLFxuICAgICAgbm93OiBmdW5jdGlvbigpeyByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnQ7IH1cbiAgICB9O1xuICB9XG59KSgpO1xuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG9UaGlzKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDVcbiAgICAgIC8vIGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgfVxuXG4gICAgdmFyIGFBcmdzICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgZk5PUCAgICA9IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIGZCb3VuZCAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUFxuICAgICAgICAgICAgICAgICA/IHRoaXNcbiAgICAgICAgICAgICAgICAgOiBvVGhpcyxcbiAgICAgICAgICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcblxuICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xuICAgICAgLy8gbmF0aXZlIGZ1bmN0aW9ucyBkb24ndCBoYXZlIGEgcHJvdG90eXBlXG4gICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgIH1cbiAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcblxuICAgIHJldHVybiBmQm91bmQ7XG4gIH07XG59XG4vLyBQb2x5ZmlsbCB0byBnZXQgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbiBpbiBJRTlcbmZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmbikge1xuICBpZiAoRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmdW5jTmFtZVJlZ2V4ID0gL2Z1bmN0aW9uXFxzKFteKF17MSx9KVxcKC87XG4gICAgdmFyIHJlc3VsdHMgPSAoZnVuY05hbWVSZWdleCkuZXhlYygoZm4pLnRvU3RyaW5nKCkpO1xuICAgIHJldHVybiAocmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCA+IDEpID8gcmVzdWx0c1sxXS50cmltKCkgOiBcIlwiO1xuICB9XG4gIGVsc2UgaWYgKGZuLnByb3RvdHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZuLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlKHN0cil7XG4gIGlmKC90cnVlLy50ZXN0KHN0cikpIHJldHVybiB0cnVlO1xuICBlbHNlIGlmKC9mYWxzZS8udGVzdChzdHIpKSByZXR1cm4gZmFsc2U7XG4gIGVsc2UgaWYoIWlzTmFOKHN0ciAqIDEpKSByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuLy8gQ29udmVydCBQYXNjYWxDYXNlIHRvIGtlYmFiLWNhc2Vcbi8vIFRoYW5rIHlvdTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODk1NTU4MFxuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG59XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuRm91bmRhdGlvbi5Cb3ggPSB7XG4gIEltTm90VG91Y2hpbmdZb3U6IEltTm90VG91Y2hpbmdZb3UsXG4gIEdldERpbWVuc2lvbnM6IEdldERpbWVuc2lvbnMsXG4gIEdldE9mZnNldHM6IEdldE9mZnNldHNcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50IHRvIGEgY29udGFpbmVyIGFuZCBkZXRlcm1pbmVzIGNvbGxpc2lvbiBldmVudHMgd2l0aCBjb250YWluZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byB0ZXN0IGZvciBjb2xsaXNpb25zLlxuICogQHBhcmFtIHtqUXVlcnl9IHBhcmVudCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGFzIGJvdW5kaW5nIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbHJPbmx5IC0gc2V0IHRvIHRydWUgdG8gY2hlY2sgbGVmdCBhbmQgcmlnaHQgdmFsdWVzIG9ubHkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRiT25seSAtIHNldCB0byB0cnVlIHRvIGNoZWNrIHRvcCBhbmQgYm90dG9tIHZhbHVlcyBvbmx5LlxuICogQGRlZmF1bHQgaWYgbm8gcGFyZW50IG9iamVjdCBwYXNzZWQsIGRldGVjdHMgY29sbGlzaW9ucyB3aXRoIGB3aW5kb3dgLlxuICogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiBjb2xsaXNpb24gZnJlZSwgZmFsc2UgaWYgYSBjb2xsaXNpb24gaW4gYW55IGRpcmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gSW1Ob3RUb3VjaGluZ1lvdShlbGVtZW50LCBwYXJlbnQsIGxyT25seSwgdGJPbmx5KSB7XG4gIHZhciBlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcbiAgICAgIHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodDtcblxuICBpZiAocGFyZW50KSB7XG4gICAgdmFyIHBhckRpbXMgPSBHZXREaW1lbnNpb25zKHBhcmVudCk7XG5cbiAgICBib3R0b20gPSAoZWxlRGltcy5vZmZzZXQudG9wICsgZWxlRGltcy5oZWlnaHQgPD0gcGFyRGltcy5oZWlnaHQgKyBwYXJEaW1zLm9mZnNldC50b3ApO1xuICAgIHRvcCAgICA9IChlbGVEaW1zLm9mZnNldC50b3AgPj0gcGFyRGltcy5vZmZzZXQudG9wKTtcbiAgICBsZWZ0ICAgPSAoZWxlRGltcy5vZmZzZXQubGVmdCA+PSBwYXJEaW1zLm9mZnNldC5sZWZ0KTtcbiAgICByaWdodCAgPSAoZWxlRGltcy5vZmZzZXQubGVmdCArIGVsZURpbXMud2lkdGggPD0gcGFyRGltcy53aWR0aCArIHBhckRpbXMub2Zmc2V0LmxlZnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIGJvdHRvbSA9IChlbGVEaW1zLm9mZnNldC50b3AgKyBlbGVEaW1zLmhlaWdodCA8PSBlbGVEaW1zLndpbmRvd0RpbXMuaGVpZ2h0ICsgZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3ApO1xuICAgIHRvcCAgICA9IChlbGVEaW1zLm9mZnNldC50b3AgPj0gZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3ApO1xuICAgIGxlZnQgICA9IChlbGVEaW1zLm9mZnNldC5sZWZ0ID49IGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCk7XG4gICAgcmlnaHQgID0gKGVsZURpbXMub2Zmc2V0LmxlZnQgKyBlbGVEaW1zLndpZHRoIDw9IGVsZURpbXMud2luZG93RGltcy53aWR0aCk7XG4gIH1cblxuICB2YXIgYWxsRGlycyA9IFtib3R0b20sIHRvcCwgbGVmdCwgcmlnaHRdO1xuXG4gIGlmIChsck9ubHkpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgPT09IHRydWU7XG4gIH1cblxuICBpZiAodGJPbmx5KSB7XG4gICAgcmV0dXJuIHRvcCA9PT0gYm90dG9tID09PSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGFsbERpcnMuaW5kZXhPZihmYWxzZSkgPT09IC0xO1xufTtcblxuLyoqXG4gKiBVc2VzIG5hdGl2ZSBtZXRob2RzIHRvIHJldHVybiBhbiBvYmplY3Qgb2YgZGltZW5zaW9uIHZhbHVlcy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtqUXVlcnkgfHwgSFRNTH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3Qgb3IgRE9NIGVsZW1lbnQgZm9yIHdoaWNoIHRvIGdldCB0aGUgZGltZW5zaW9ucy4gQ2FuIGJlIGFueSBlbGVtZW50IG90aGVyIHRoYXQgZG9jdW1lbnQgb3Igd2luZG93LlxuICogQHJldHVybnMge09iamVjdH0gLSBuZXN0ZWQgb2JqZWN0IG9mIGludGVnZXIgcGl4ZWwgdmFsdWVzXG4gKiBUT0RPIC0gaWYgZWxlbWVudCBpcyB3aW5kb3csIHJldHVybiBvbmx5IHRob3NlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gR2V0RGltZW5zaW9ucyhlbGVtLCB0ZXN0KXtcbiAgZWxlbSA9IGVsZW0ubGVuZ3RoID8gZWxlbVswXSA6IGVsZW07XG5cbiAgaWYgKGVsZW0gPT09IHdpbmRvdyB8fCBlbGVtID09PSBkb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkknbSBzb3JyeSwgRGF2ZS4gSSdtIGFmcmFpZCBJIGNhbid0IGRvIHRoYXQuXCIpO1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgcGFyUmVjdCA9IGVsZW0ucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHdpblJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgd2luWSA9IHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgIHdpblggPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIG9mZnNldDoge1xuICAgICAgdG9wOiByZWN0LnRvcCArIHdpblksXG4gICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5YXG4gICAgfSxcbiAgICBwYXJlbnREaW1zOiB7XG4gICAgICB3aWR0aDogcGFyUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogcGFyUmVjdC5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHtcbiAgICAgICAgdG9wOiBwYXJSZWN0LnRvcCArIHdpblksXG4gICAgICAgIGxlZnQ6IHBhclJlY3QubGVmdCArIHdpblhcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpbmRvd0RpbXM6IHtcbiAgICAgIHdpZHRoOiB3aW5SZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5SZWN0LmhlaWdodCxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB0b3A6IHdpblksXG4gICAgICAgIGxlZnQ6IHdpblhcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB0b3AgYW5kIGxlZnQgaW50ZWdlciBwaXhlbCB2YWx1ZXMgZm9yIGR5bmFtaWNhbGx5IHJlbmRlcmVkIGVsZW1lbnRzLFxuICogc3VjaCBhczogVG9vbHRpcCwgUmV2ZWFsLCBhbmQgRHJvcGRvd25cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IGZvciB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICogQHBhcmFtIHtqUXVlcnl9IGFuY2hvciAtIGpRdWVyeSBvYmplY3QgZm9yIHRoZSBlbGVtZW50J3MgYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gYSBzdHJpbmcgcmVsYXRpbmcgdG8gdGhlIGRlc2lyZWQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsIHJlbGF0aXZlIHRvIGl0J3MgYW5jaG9yXG4gKiBAcGFyYW0ge051bWJlcn0gdk9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCB2ZXJ0aWNhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IGhPZmZzZXQgLSBpbnRlZ2VyIHBpeGVsIHZhbHVlIG9mIGRlc2lyZWQgaG9yaXpvbnRhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxuICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJmbG93IC0gaWYgYSBjb2xsaXNpb24gZXZlbnQgaXMgZGV0ZWN0ZWQsIHNldHMgdG8gdHJ1ZSB0byBkZWZhdWx0IHRoZSBlbGVtZW50IHRvIGZ1bGwgd2lkdGggLSBhbnkgZGVzaXJlZCBvZmZzZXQuXG4gKiBUT0RPIGFsdGVyL3Jld3JpdGUgdG8gd29yayB3aXRoIGBlbWAgdmFsdWVzIGFzIHdlbGwvaW5zdGVhZCBvZiBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gR2V0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsIHBvc2l0aW9uLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KSB7XG4gIHZhciAkZWxlRGltcyA9IEdldERpbWVuc2lvbnMoZWxlbWVudCksXG4gICAgICAkYW5jaG9yRGltcyA9IGFuY2hvciA/IEdldERpbWVuc2lvbnMoYW5jaG9yKSA6IG51bGw7XG5cbiAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAoRm91bmRhdGlvbi5ydGwoKSA/ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gJGVsZURpbXMud2lkdGggKyAkYW5jaG9yRGltcy53aWR0aCA6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0KSxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gKCRlbGVEaW1zLndpZHRoICsgaE9mZnNldCksXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcFxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCArIGhPZmZzZXQsXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcFxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAoJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAoJGFuY2hvckRpbXMud2lkdGggLyAyKSkgLSAoJGVsZURpbXMud2lkdGggLyAyKSxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXIgYm90dG9tJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGlzT3ZlcmZsb3cgPyBoT2Zmc2V0IDogKCgkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICgkYW5jaG9yRGltcy53aWR0aCAvIDIpKSAtICgkZWxlRGltcy53aWR0aCAvIDIpKSxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgJGFuY2hvckRpbXMuaGVpZ2h0ICsgdk9mZnNldFxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2VudGVyIGxlZnQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KSxcbiAgICAgICAgdG9wOiAoJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICgkYW5jaG9yRGltcy5oZWlnaHQgLyAyKSkgLSAoJGVsZURpbXMuaGVpZ2h0IC8gMilcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlciByaWdodCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldCArIDEsXG4gICAgICAgIHRvcDogKCRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAoJGFuY2hvckRpbXMuaGVpZ2h0IC8gMikpIC0gKCRlbGVEaW1zLmhlaWdodCAvIDIpXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogKCRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQgKyAoJGVsZURpbXMud2luZG93RGltcy53aWR0aCAvIDIpKSAtICgkZWxlRGltcy53aWR0aCAvIDIpLFxuICAgICAgICB0b3A6ICgkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgKyAoJGVsZURpbXMud2luZG93RGltcy5oZWlnaHQgLyAyKSkgLSAoJGVsZURpbXMuaGVpZ2h0IC8gMilcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JldmVhbCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAoJGVsZURpbXMud2luZG93RGltcy53aWR0aCAtICRlbGVEaW1zLndpZHRoKSAvIDIsXG4gICAgICAgIHRvcDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wICsgdk9mZnNldFxuICAgICAgfVxuICAgIGNhc2UgJ3JldmVhbCBmdWxsJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQsXG4gICAgICAgIHRvcDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0IGJvdHRvbSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICgkZWxlRGltcy53aWR0aCArIGhPZmZzZXQpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCArIGhPZmZzZXQgLSAkZWxlRGltcy53aWR0aCxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgJGFuY2hvckRpbXMuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IChGb3VuZGF0aW9uLnJ0bCgpID8gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAkZWxlRGltcy53aWR0aCArICRhbmNob3JEaW1zLndpZHRoIDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgKyB2T2Zmc2V0XG4gICAgICB9XG4gIH1cbn1cblxufShqUXVlcnkpO1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBUaGlzIHV0aWwgd2FzIGNyZWF0ZWQgYnkgTWFyaXVzIE9sYmVydHogKlxuICogUGxlYXNlIHRoYW5rIE1hcml1cyBvbiBHaXRIdWIgL293bGJlcnR6ICpcbiAqIG9yIHRoZSB3ZWIgaHR0cDovL3d3dy5tYXJpdXNvbGJlcnR6LmRlLyAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG5jb25zdCBrZXlDb2RlcyA9IHtcbiAgOTogJ1RBQicsXG4gIDEzOiAnRU5URVInLFxuICAyNzogJ0VTQ0FQRScsXG4gIDMyOiAnU1BBQ0UnLFxuICAzNzogJ0FSUk9XX0xFRlQnLFxuICAzODogJ0FSUk9XX1VQJyxcbiAgMzk6ICdBUlJPV19SSUdIVCcsXG4gIDQwOiAnQVJST1dfRE9XTidcbn1cblxudmFyIGNvbW1hbmRzID0ge31cblxudmFyIEtleWJvYXJkID0ge1xuICBrZXlzOiBnZXRLZXlDb2RlcyhrZXlDb2RlcyksXG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgKGtleWJvYXJkKSBldmVudCBhbmQgcmV0dXJucyBhIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgaXRzIGtleVxuICAgKiBDYW4gYmUgdXNlZCBsaWtlIEZvdW5kYXRpb24ucGFyc2VLZXkoZXZlbnQpID09PSBGb3VuZGF0aW9uLmtleXMuU1BBQ0VcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXG4gICAqIEByZXR1cm4gU3RyaW5nIGtleSAtIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGtleSBwcmVzc2VkXG4gICAqL1xuICBwYXJzZUtleShldmVudCkge1xuICAgIHZhciBrZXkgPSBrZXlDb2Rlc1tldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXSB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LndoaWNoKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChldmVudC5zaGlmdEtleSkga2V5ID0gYFNISUZUXyR7a2V5fWA7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIGtleSA9IGBDVFJMXyR7a2V5fWA7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkga2V5ID0gYEFMVF8ke2tleX1gO1xuICAgIHJldHVybiBrZXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIChrZXlib2FyZCkgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgLSBGb3VuZGF0aW9uIGNvbXBvbmVudCdzIG5hbWUsIGUuZy4gU2xpZGVyIG9yIFJldmVhbFxuICAgKiBAcGFyYW0ge09iamVjdHN9IGZ1bmN0aW9ucyAtIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHRoYXQgYXJlIHRvIGJlIGV4ZWN1dGVkXG4gICAqL1xuICBoYW5kbGVLZXkoZXZlbnQsIGNvbXBvbmVudCwgZnVuY3Rpb25zKSB7XG4gICAgdmFyIGNvbW1hbmRMaXN0ID0gY29tbWFuZHNbY29tcG9uZW50XSxcbiAgICAgIGtleUNvZGUgPSB0aGlzLnBhcnNlS2V5KGV2ZW50KSxcbiAgICAgIGNtZHMsXG4gICAgICBjb21tYW5kLFxuICAgICAgZm47XG5cbiAgICBpZiAoIWNvbW1hbmRMaXN0KSByZXR1cm4gY29uc29sZS53YXJuKCdDb21wb25lbnQgbm90IGRlZmluZWQhJyk7XG5cbiAgICBpZiAodHlwZW9mIGNvbW1hbmRMaXN0Lmx0ciA9PT0gJ3VuZGVmaW5lZCcpIHsgLy8gdGhpcyBjb21wb25lbnQgZG9lcyBub3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGx0ciBhbmQgcnRsXG4gICAgICAgIGNtZHMgPSBjb21tYW5kTGlzdDsgLy8gdXNlIHBsYWluIGxpc3RcbiAgICB9IGVsc2UgeyAvLyBtZXJnZSBsdHIgYW5kIHJ0bDogaWYgZG9jdW1lbnQgaXMgcnRsLCBydGwgb3ZlcndyaXRlcyBsdHIgYW5kIHZpY2UgdmVyc2FcbiAgICAgICAgaWYgKEZvdW5kYXRpb24ucnRsKCkpIGNtZHMgPSAkLmV4dGVuZCh7fSwgY29tbWFuZExpc3QubHRyLCBjb21tYW5kTGlzdC5ydGwpO1xuXG4gICAgICAgIGVsc2UgY21kcyA9ICQuZXh0ZW5kKHt9LCBjb21tYW5kTGlzdC5ydGwsIGNvbW1hbmRMaXN0Lmx0cik7XG4gICAgfVxuICAgIGNvbW1hbmQgPSBjbWRzW2tleUNvZGVdO1xuXG4gICAgZm4gPSBmdW5jdGlvbnNbY29tbWFuZF07XG4gICAgaWYgKGZuICYmIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBleGVjdXRlIGZ1bmN0aW9uICBpZiBleGlzdHNcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGZuLmFwcGx5KCk7XG4gICAgICBpZiAoZnVuY3Rpb25zLmhhbmRsZWQgfHwgdHlwZW9mIGZ1bmN0aW9ucy5oYW5kbGVkID09PSAnZnVuY3Rpb24nKSB7IC8vIGV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgaGFuZGxlZFxuICAgICAgICAgIGZ1bmN0aW9ucy5oYW5kbGVkKHJldHVyblZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZ1bmN0aW9ucy51bmhhbmRsZWQgfHwgdHlwZW9mIGZ1bmN0aW9ucy51bmhhbmRsZWQgPT09ICdmdW5jdGlvbicpIHsgLy8gZXhlY3V0ZSBmdW5jdGlvbiB3aGVuIGV2ZW50IHdhcyBub3QgaGFuZGxlZFxuICAgICAgICAgIGZ1bmN0aW9ucy51bmhhbmRsZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIHRoZSBnaXZlbiBgJGVsZW1lbnRgXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gc2VhcmNoIHdpdGhpblxuICAgKiBAcmV0dXJuIHtqUXVlcnl9ICRmb2N1c2FibGUgLSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiBgJGVsZW1lbnRgXG4gICAqL1xuICBmaW5kRm9jdXNhYmxlKCRlbGVtZW50KSB7XG4gICAgcmV0dXJuICRlbGVtZW50LmZpbmQoJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBidXR0b246bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdLCAqW2NvbnRlbnRlZGl0YWJsZV0nKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISQodGhpcykuaXMoJzp2aXNpYmxlJykgfHwgJCh0aGlzKS5hdHRyKCd0YWJpbmRleCcpIDwgMCkgeyByZXR1cm4gZmFsc2U7IH0gLy9vbmx5IGhhdmUgdmlzaWJsZSBlbGVtZW50cyBhbmQgdGhvc2UgdGhhdCBoYXZlIGEgdGFiaW5kZXggZ3JlYXRlciBvciBlcXVhbCAwXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29tcG9uZW50IG5hbWUgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IC0gRm91bmRhdGlvbiBjb21wb25lbnQsIGUuZy4gU2xpZGVyIG9yIFJldmVhbFxuICAgKiBAcmV0dXJuIFN0cmluZyBjb21wb25lbnROYW1lXG4gICAqL1xuXG4gIHJlZ2lzdGVyKGNvbXBvbmVudE5hbWUsIGNtZHMpIHtcbiAgICBjb21tYW5kc1tjb21wb25lbnROYW1lXSA9IGNtZHM7XG4gIH1cbn1cblxuLypcbiAqIENvbnN0YW50cyBmb3IgZWFzaWVyIGNvbXBhcmluZy5cbiAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxuICovXG5mdW5jdGlvbiBnZXRLZXlDb2RlcyhrY3MpIHtcbiAgdmFyIGsgPSB7fTtcbiAgZm9yICh2YXIga2MgaW4ga2NzKSBrW2tjc1trY11dID0ga2NzW2tjXTtcbiAgcmV0dXJuIGs7XG59XG5cbkZvdW5kYXRpb24uS2V5Ym9hcmQgPSBLZXlib2FyZDtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vLyBEZWZhdWx0IHNldCBvZiBtZWRpYSBxdWVyaWVzXG5jb25zdCBkZWZhdWx0UXVlcmllcyA9IHtcbiAgJ2RlZmF1bHQnIDogJ29ubHkgc2NyZWVuJyxcbiAgbGFuZHNjYXBlIDogJ29ubHkgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxuICBwb3J0cmFpdCA6ICdvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknLFxuICByZXRpbmEgOiAnb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMi8xKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpJ1xufTtcblxudmFyIE1lZGlhUXVlcnkgPSB7XG4gIHF1ZXJpZXM6IFtdLFxuXG4gIGN1cnJlbnQ6ICcnLFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbWVkaWEgcXVlcnkgaGVscGVyLCBieSBleHRyYWN0aW5nIHRoZSBicmVha3BvaW50IGxpc3QgZnJvbSB0aGUgQ1NTIGFuZCBhY3RpdmF0aW5nIHRoZSBicmVha3BvaW50IHdhdGNoZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBleHRyYWN0ZWRTdHlsZXMgPSAkKCcuZm91bmRhdGlvbi1tcScpLmNzcygnZm9udC1mYW1pbHknKTtcbiAgICB2YXIgbmFtZWRRdWVyaWVzO1xuXG4gICAgbmFtZWRRdWVyaWVzID0gcGFyc2VTdHlsZVRvT2JqZWN0KGV4dHJhY3RlZFN0eWxlcyk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZWRRdWVyaWVzKSB7XG4gICAgICBpZihuYW1lZFF1ZXJpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBzZWxmLnF1ZXJpZXMucHVzaCh7XG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIHZhbHVlOiBgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6ICR7bmFtZWRRdWVyaWVzW2tleV19KWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcblxuICAgIHRoaXMuX3dhdGNoZXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gaXMgYXQgbGVhc3QgYXMgd2lkZSBhcyBhIGJyZWFrcG9pbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGJyZWFrcG9pbnQgbWF0Y2hlcywgYGZhbHNlYCBpZiBpdCdzIHNtYWxsZXIuXG4gICAqL1xuICBhdExlYXN0KHNpemUpIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLmdldChzaXplKTtcblxuICAgIGlmIChxdWVyeSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KS5tYXRjaGVzO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgbWVkaWEgcXVlcnkgb2YgYSBicmVha3BvaW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGdldC5cbiAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSAtIFRoZSBtZWRpYSBxdWVyeSBvZiB0aGUgYnJlYWtwb2ludCwgb3IgYG51bGxgIGlmIHRoZSBicmVha3BvaW50IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBnZXQoc2l6ZSkge1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5xdWVyaWVzKSB7XG4gICAgICBpZih0aGlzLnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gcXVlcnkubmFtZSkgcmV0dXJuIHF1ZXJ5LnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgbmFtZSBieSB0ZXN0aW5nIGV2ZXJ5IGJyZWFrcG9pbnQgYW5kIHJldHVybmluZyB0aGUgbGFzdCBvbmUgdG8gbWF0Y2ggKHRoZSBiaWdnZXN0IG9uZSkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBOYW1lIG9mIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQuXG4gICAqL1xuICBfZ2V0Q3VycmVudFNpemUoKSB7XG4gICAgdmFyIG1hdGNoZWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xuXG4gICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocXVlcnkudmFsdWUpLm1hdGNoZXMpIHtcbiAgICAgICAgbWF0Y2hlZCA9IHF1ZXJ5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWF0Y2hlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBtYXRjaGVkLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBicmVha3BvaW50IHdhdGNoZXIsIHdoaWNoIGZpcmVzIGFuIGV2ZW50IG9uIHRoZSB3aW5kb3cgd2hlbmV2ZXIgdGhlIGJyZWFrcG9pbnQgY2hhbmdlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd2F0Y2hlcigpIHtcbiAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS56Zi5tZWRpYXF1ZXJ5JywgKCkgPT4ge1xuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLl9nZXRDdXJyZW50U2l6ZSgpLCBjdXJyZW50U2l6ZSA9IHRoaXMuY3VycmVudDtcblxuICAgICAgaWYgKG5ld1NpemUgIT09IGN1cnJlbnRTaXplKSB7XG4gICAgICAgIC8vIENoYW5nZSB0aGUgY3VycmVudCBtZWRpYSBxdWVyeVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXdTaXplO1xuXG4gICAgICAgIC8vIEJyb2FkY2FzdCB0aGUgbWVkaWEgcXVlcnkgY2hhbmdlIG9uIHRoZSB3aW5kb3dcbiAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIFtuZXdTaXplLCBjdXJyZW50U2l6ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5Gb3VuZGF0aW9uLk1lZGlhUXVlcnkgPSBNZWRpYVF1ZXJ5O1xuXG4vLyBtYXRjaE1lZGlhKCkgcG9seWZpbGwgLSBUZXN0IGEgQ1NTIG1lZGlhIHR5cGUvcXVlcnkgaW4gSlMuXG4vLyBBdXRob3JzICYgY29weXJpZ2h0IChjKSAyMDEyOiBTY290dCBKZWhsLCBQYXVsIElyaXNoLCBOaWNob2xhcyBaYWthcywgRGF2aWQgS25pZ2h0LiBEdWFsIE1JVC9CU0QgbGljZW5zZVxud2luZG93Lm1hdGNoTWVkaWEgfHwgKHdpbmRvdy5tYXRjaE1lZGlhID0gZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IG1hdGNoTWVkaXVtIGFwaSBzdWNoIGFzIElFIDkgYW5kIHdlYmtpdFxuICB2YXIgc3R5bGVNZWRpYSA9ICh3aW5kb3cuc3R5bGVNZWRpYSB8fCB3aW5kb3cubWVkaWEpO1xuXG4gIC8vIEZvciB0aG9zZSB0aGF0IGRvbid0IHN1cHBvcnQgbWF0Y2hNZWRpdW1cbiAgaWYgKCFzdHlsZU1lZGlhKSB7XG4gICAgdmFyIHN0eWxlICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpLFxuICAgIHNjcmlwdCAgICAgID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdLFxuICAgIGluZm8gICAgICAgID0gbnVsbDtcblxuICAgIHN0eWxlLnR5cGUgID0gJ3RleHQvY3NzJztcbiAgICBzdHlsZS5pZCAgICA9ICdtYXRjaG1lZGlhanMtdGVzdCc7XG5cbiAgICBzY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIHNjcmlwdCk7XG5cbiAgICAvLyAnc3R5bGUuY3VycmVudFN0eWxlJyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICd3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZScgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuICAgIGluZm8gPSAoJ2dldENvbXB1dGVkU3R5bGUnIGluIHdpbmRvdykgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3R5bGUsIG51bGwpIHx8IHN0eWxlLmN1cnJlbnRTdHlsZTtcblxuICAgIHN0eWxlTWVkaWEgPSB7XG4gICAgICBtYXRjaE1lZGl1bShtZWRpYSkge1xuICAgICAgICB2YXIgdGV4dCA9IGBAbWVkaWEgJHttZWRpYX17ICNtYXRjaG1lZGlhanMtdGVzdCB7IHdpZHRoOiAxcHg7IH0gfWA7XG5cbiAgICAgICAgLy8gJ3N0eWxlLnN0eWxlU2hlZXQnIGlzIHVzZWQgYnkgSUUgPD0gOCBhbmQgJ3N0eWxlLnRleHRDb250ZW50JyBmb3IgYWxsIG90aGVyIGJyb3dzZXJzXG4gICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXN0IGlmIG1lZGlhIHF1ZXJ5IGlzIHRydWUgb3IgZmFsc2VcbiAgICAgICAgcmV0dXJuIGluZm8ud2lkdGggPT09ICcxcHgnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihtZWRpYSkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaGVzOiBzdHlsZU1lZGlhLm1hdGNoTWVkaXVtKG1lZGlhIHx8ICdhbGwnKSxcbiAgICAgIG1lZGlhOiBtZWRpYSB8fCAnYWxsJ1xuICAgIH07XG4gIH1cbn0oKSk7XG5cbi8vIFRoYW5rIHlvdTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmdcbmZ1bmN0aW9uIHBhcnNlU3R5bGVUb09iamVjdChzdHIpIHtcbiAgdmFyIHN0eWxlT2JqZWN0ID0ge307XG5cbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG5cbiAgc3RyID0gc3RyLnRyaW0oKS5zbGljZSgxLCAtMSk7IC8vIGJyb3dzZXJzIHJlLXF1b3RlIHN0cmluZyBzdHlsZSB2YWx1ZXNcblxuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBzdHlsZU9iamVjdDtcbiAgfVxuXG4gIHN0eWxlT2JqZWN0ID0gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uKHJldCwgcGFyYW0pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBwYXJ0c1swXTtcbiAgICB2YXIgdmFsID0gcGFydHNbMV07XG4gICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XG5cbiAgICAvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuICAgIC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcbiAgICB2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuICAgIGlmICghcmV0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldFtrZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcbiAgICAgIHJldFtrZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG5cbkZvdW5kYXRpb24uTWVkaWFRdWVyeSA9IE1lZGlhUXVlcnk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBNb3Rpb24gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm1vdGlvblxuICovXG5cbmNvbnN0IGluaXRDbGFzc2VzICAgPSBbJ211aS1lbnRlcicsICdtdWktbGVhdmUnXTtcbmNvbnN0IGFjdGl2ZUNsYXNzZXMgPSBbJ211aS1lbnRlci1hY3RpdmUnLCAnbXVpLWxlYXZlLWFjdGl2ZSddO1xuXG5jb25zdCBNb3Rpb24gPSB7XG4gIGFuaW1hdGVJbjogZnVuY3Rpb24oZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICAgIGFuaW1hdGUodHJ1ZSwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYik7XG4gIH0sXG5cbiAgYW5pbWF0ZU91dDogZnVuY3Rpb24oZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICAgIGFuaW1hdGUoZmFsc2UsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIE1vdmUoZHVyYXRpb24sIGVsZW0sIGZuKXtcbiAgdmFyIGFuaW0sIHByb2csIHN0YXJ0ID0gbnVsbDtcbiAgLy8gY29uc29sZS5sb2coJ2NhbGxlZCcpO1xuXG4gIGZ1bmN0aW9uIG1vdmUodHMpe1xuICAgIGlmKCFzdGFydCkgc3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy8gY29uc29sZS5sb2coc3RhcnQsIHRzKTtcbiAgICBwcm9nID0gdHMgLSBzdGFydDtcbiAgICBmbi5hcHBseShlbGVtKTtcblxuICAgIGlmKHByb2cgPCBkdXJhdGlvbil7IGFuaW0gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdmUsIGVsZW0pOyB9XG4gICAgZWxzZXtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltKTtcbiAgICAgIGVsZW0udHJpZ2dlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSkudHJpZ2dlckhhbmRsZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pO1xuICAgIH1cbiAgfVxuICBhbmltID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtb3ZlKTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyBhbiBlbGVtZW50IGluIG9yIG91dCB1c2luZyBhIENTUyB0cmFuc2l0aW9uIGNsYXNzLlxuICogQGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0luIC0gRGVmaW5lcyBpZiB0aGUgYW5pbWF0aW9uIGlzIGluIG9yIG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9yIEhUTUwgb2JqZWN0IHRvIGFuaW1hdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gYW5pbWF0aW9uIC0gQ1NTIGNsYXNzIHRvIHVzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gQ2FsbGJhY2sgdG8gcnVuIHdoZW4gYW5pbWF0aW9uIGlzIGZpbmlzaGVkLlxuICovXG5mdW5jdGlvbiBhbmltYXRlKGlzSW4sIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcbiAgZWxlbWVudCA9ICQoZWxlbWVudCkuZXEoMCk7XG5cbiAgaWYgKCFlbGVtZW50Lmxlbmd0aCkgcmV0dXJuO1xuXG4gIHZhciBpbml0Q2xhc3MgPSBpc0luID8gaW5pdENsYXNzZXNbMF0gOiBpbml0Q2xhc3Nlc1sxXTtcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNJbiA/IGFjdGl2ZUNsYXNzZXNbMF0gOiBhY3RpdmVDbGFzc2VzWzFdO1xuXG4gIC8vIFNldCB1cCB0aGUgYW5pbWF0aW9uXG4gIHJlc2V0KCk7XG5cbiAgZWxlbWVudFxuICAgIC5hZGRDbGFzcyhhbmltYXRpb24pXG4gICAgLmNzcygndHJhbnNpdGlvbicsICdub25lJyk7XG5cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBlbGVtZW50LmFkZENsYXNzKGluaXRDbGFzcyk7XG4gICAgaWYgKGlzSW4pIGVsZW1lbnQuc2hvdygpO1xuICB9KTtcblxuICAvLyBTdGFydCB0aGUgYW5pbWF0aW9uXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgZWxlbWVudFswXS5vZmZzZXRXaWR0aDtcbiAgICBlbGVtZW50XG4gICAgICAuY3NzKCd0cmFuc2l0aW9uJywgJycpXG4gICAgICAuYWRkQ2xhc3MoYWN0aXZlQ2xhc3MpO1xuICB9KTtcblxuICAvLyBDbGVhbiB1cCB0aGUgYW5pbWF0aW9uIHdoZW4gaXQgZmluaXNoZXNcbiAgZWxlbWVudC5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKGVsZW1lbnQpLCBmaW5pc2gpO1xuXG4gIC8vIEhpZGVzIHRoZSBlbGVtZW50IChmb3Igb3V0IGFuaW1hdGlvbnMpLCByZXNldHMgdGhlIGVsZW1lbnQsIGFuZCBydW5zIGEgY2FsbGJhY2tcbiAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIGlmICghaXNJbikgZWxlbWVudC5oaWRlKCk7XG4gICAgcmVzZXQoKTtcbiAgICBpZiAoY2IpIGNiLmFwcGx5KGVsZW1lbnQpO1xuICB9XG5cbiAgLy8gUmVzZXRzIHRyYW5zaXRpb25zIGFuZCByZW1vdmVzIG1vdGlvbi1zcGVjaWZpYyBjbGFzc2VzXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGVsZW1lbnRbMF0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gMDtcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGAke2luaXRDbGFzc30gJHthY3RpdmVDbGFzc30gJHthbmltYXRpb259YCk7XG4gIH1cbn1cblxuRm91bmRhdGlvbi5Nb3ZlID0gTW92ZTtcbkZvdW5kYXRpb24uTW90aW9uID0gTW90aW9uO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbmNvbnN0IE5lc3QgPSB7XG4gIEZlYXRoZXIobWVudSwgdHlwZSA9ICd6ZicpIHtcbiAgICBtZW51LmF0dHIoJ3JvbGUnLCAnbWVudWJhcicpO1xuXG4gICAgdmFyIGl0ZW1zID0gbWVudS5maW5kKCdsaScpLmF0dHIoeydyb2xlJzogJ21lbnVpdGVtJ30pLFxuICAgICAgICBzdWJNZW51Q2xhc3MgPSBgaXMtJHt0eXBlfS1zdWJtZW51YCxcbiAgICAgICAgc3ViSXRlbUNsYXNzID0gYCR7c3ViTWVudUNsYXNzfS1pdGVtYCxcbiAgICAgICAgaGFzU3ViQ2xhc3MgPSBgaXMtJHt0eXBlfS1zdWJtZW51LXBhcmVudGA7XG5cbiAgICBtZW51LmZpbmQoJ2E6Zmlyc3QnKS5hdHRyKCd0YWJpbmRleCcsIDApO1xuXG4gICAgaXRlbXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkaXRlbSA9ICQodGhpcyksXG4gICAgICAgICAgJHN1YiA9ICRpdGVtLmNoaWxkcmVuKCd1bCcpO1xuXG4gICAgICBpZiAoJHN1Yi5sZW5ndGgpIHtcbiAgICAgICAgJGl0ZW1cbiAgICAgICAgICAuYWRkQ2xhc3MoaGFzU3ViQ2xhc3MpXG4gICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxuICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsJzogJGl0ZW0uY2hpbGRyZW4oJ2E6Zmlyc3QnKS50ZXh0KClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAkc3ViXG4gICAgICAgICAgLmFkZENsYXNzKGBzdWJtZW51ICR7c3ViTWVudUNsYXNzfWApXG4gICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgJ2RhdGEtc3VibWVudSc6ICcnLFxuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAgICdyb2xlJzogJ21lbnUnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgkaXRlbS5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKSB7XG4gICAgICAgICRpdGVtLmFkZENsYXNzKGBpcy1zdWJtZW51LWl0ZW0gJHtzdWJJdGVtQ2xhc3N9YCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH0sXG5cbiAgQnVybihtZW51LCB0eXBlKSB7XG4gICAgdmFyIGl0ZW1zID0gbWVudS5maW5kKCdsaScpLnJlbW92ZUF0dHIoJ3RhYmluZGV4JyksXG4gICAgICAgIHN1Yk1lbnVDbGFzcyA9IGBpcy0ke3R5cGV9LXN1Ym1lbnVgLFxuICAgICAgICBzdWJJdGVtQ2xhc3MgPSBgJHtzdWJNZW51Q2xhc3N9LWl0ZW1gLFxuICAgICAgICBoYXNTdWJDbGFzcyA9IGBpcy0ke3R5cGV9LXN1Ym1lbnUtcGFyZW50YDtcblxuICAgIG1lbnVcbiAgICAgIC5maW5kKCcqJylcbiAgICAgIC5yZW1vdmVDbGFzcyhgJHtzdWJNZW51Q2xhc3N9ICR7c3ViSXRlbUNsYXNzfSAke2hhc1N1YkNsYXNzfSBpcy1zdWJtZW51LWl0ZW0gc3VibWVudSBpcy1hY3RpdmVgKVxuICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtc3VibWVudScpLmNzcygnZGlzcGxheScsICcnKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCAgICAgIG1lbnUuZmluZCgnLicgKyBzdWJNZW51Q2xhc3MgKyAnLCAuJyArIHN1Ykl0ZW1DbGFzcyArICcsIC5oYXMtc3VibWVudSwgLmlzLXN1Ym1lbnUtaXRlbSwgLnN1Ym1lbnUsIFtkYXRhLXN1Ym1lbnVdJylcbiAgICAvLyAgICAgICAgICAgLnJlbW92ZUNsYXNzKHN1Yk1lbnVDbGFzcyArICcgJyArIHN1Ykl0ZW1DbGFzcyArICcgaGFzLXN1Ym1lbnUgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUnKVxuICAgIC8vICAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51JykpO1xuICAgIC8vIGl0ZW1zLmVhY2goZnVuY3Rpb24oKXtcbiAgICAvLyAgIHZhciAkaXRlbSA9ICQodGhpcyksXG4gICAgLy8gICAgICAgJHN1YiA9ICRpdGVtLmNoaWxkcmVuKCd1bCcpO1xuICAgIC8vICAgaWYoJGl0ZW0ucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCl7XG4gICAgLy8gICAgICRpdGVtLnJlbW92ZUNsYXNzKCdpcy1zdWJtZW51LWl0ZW0gJyArIHN1Ykl0ZW1DbGFzcyk7XG4gICAgLy8gICB9XG4gICAgLy8gICBpZigkc3ViLmxlbmd0aCl7XG4gICAgLy8gICAgICRpdGVtLnJlbW92ZUNsYXNzKCdoYXMtc3VibWVudScpO1xuICAgIC8vICAgICAkc3ViLnJlbW92ZUNsYXNzKCdzdWJtZW51ICcgKyBzdWJNZW51Q2xhc3MpLnJlbW92ZUF0dHIoJ2RhdGEtc3VibWVudScpO1xuICAgIC8vICAgfVxuICAgIC8vIH0pO1xuICB9XG59XG5cbkZvdW5kYXRpb24uTmVzdCA9IE5lc3Q7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuZnVuY3Rpb24gVGltZXIoZWxlbSwgb3B0aW9ucywgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiwvL29wdGlvbnMgaXMgYW4gb2JqZWN0IGZvciBlYXNpbHkgYWRkaW5nIGZlYXR1cmVzIGxhdGVyLlxuICAgICAgbmFtZVNwYWNlID0gT2JqZWN0LmtleXMoZWxlbS5kYXRhKCkpWzBdIHx8ICd0aW1lcicsXG4gICAgICByZW1haW4gPSAtMSxcbiAgICAgIHN0YXJ0LFxuICAgICAgdGltZXI7XG5cbiAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gIHRoaXMucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHJlbWFpbiA9IC0xO1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9XG5cbiAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAvLyBpZighZWxlbS5kYXRhKCdwYXVzZWQnKSl7IHJldHVybiBmYWxzZTsgfS8vbWF5YmUgaW1wbGVtZW50IHRoaXMgc2FuaXR5IGNoZWNrIGlmIHVzZWQgZm9yIG90aGVyIHRoaW5ncy5cbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHJlbWFpbiA9IHJlbWFpbiA8PSAwID8gZHVyYXRpb24gOiByZW1haW47XG4gICAgZWxlbS5kYXRhKCdwYXVzZWQnLCBmYWxzZSk7XG4gICAgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgaWYob3B0aW9ucy5pbmZpbml0ZSl7XG4gICAgICAgIF90aGlzLnJlc3RhcnQoKTsvL3JlcnVuIHRoZSB0aW1lci5cbiAgICAgIH1cbiAgICAgIGNiKCk7XG4gICAgfSwgcmVtYWluKTtcbiAgICBlbGVtLnRyaWdnZXIoYHRpbWVyc3RhcnQuemYuJHtuYW1lU3BhY2V9YCk7XG4gIH1cblxuICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgLy9pZihlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgZWxlbS5kYXRhKCdwYXVzZWQnLCB0cnVlKTtcbiAgICB2YXIgZW5kID0gRGF0ZS5ub3coKTtcbiAgICByZW1haW4gPSByZW1haW4gLSAoZW5kIC0gc3RhcnQpO1xuICAgIGVsZW0udHJpZ2dlcihgdGltZXJwYXVzZWQuemYuJHtuYW1lU3BhY2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSdW5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBpbWFnZXMgYXJlIGZ1bGx5IGxvYWRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZXMgLSBJbWFnZShzKSB0byBjaGVjayBpZiBsb2FkZWQuXG4gKiBAcGFyYW0ge0Z1bmN9IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGltYWdlIGlzIGZ1bGx5IGxvYWRlZC5cbiAqL1xuZnVuY3Rpb24gb25JbWFnZXNMb2FkZWQoaW1hZ2VzLCBjYWxsYmFjayl7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHVubG9hZGVkID0gaW1hZ2VzLmxlbmd0aDtcblxuICBpZiAodW5sb2FkZWQgPT09IDApIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgaW1hZ2VzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29tcGxldGUpIHtcbiAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLm5hdHVyYWxXaWR0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5uYXR1cmFsV2lkdGggPiAwKSB7XG4gICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICQodGhpcykub25lKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHNpbmdsZUltYWdlTG9hZGVkKCkge1xuICAgIHVubG9hZGVkLS07XG4gICAgaWYgKHVubG9hZGVkID09PSAwKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxufVxuXG5Gb3VuZGF0aW9uLlRpbWVyID0gVGltZXI7XG5Gb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkID0gb25JbWFnZXNMb2FkZWQ7XG5cbn0oalF1ZXJ5KTtcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vKipXb3JrIGluc3BpcmVkIGJ5IG11bHRpcGxlIGpxdWVyeSBzd2lwZSBwbHVnaW5zKipcbi8vKipEb25lIGJ5IFlvaGFpIEFyYXJhdCAqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbihmdW5jdGlvbigkKSB7XG5cbiAgJC5zcG90U3dpcGUgPSB7XG4gICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICBlbmFibGVkOiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuICAgIG1vdmVUaHJlc2hvbGQ6IDc1LFxuICAgIHRpbWVUaHJlc2hvbGQ6IDIwMFxuICB9O1xuXG4gIHZhciAgIHN0YXJ0UG9zWCxcbiAgICAgICAgc3RhcnRQb3NZLFxuICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgIGVsYXBzZWRUaW1lLFxuICAgICAgICBpc01vdmluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XG4gICAgLy8gIGFsZXJ0KHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcbiAgICBpc01vdmluZyA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSkge1xuICAgIGlmICgkLnNwb3RTd2lwZS5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICBpZihpc01vdmluZykge1xuICAgICAgdmFyIHggPSBlLnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICB2YXIgeSA9IGUudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgIHZhciBkeCA9IHN0YXJ0UG9zWCAtIHg7XG4gICAgICB2YXIgZHkgPSBzdGFydFBvc1kgLSB5O1xuICAgICAgdmFyIGRpcjtcbiAgICAgIGVsYXBzZWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWU7XG4gICAgICBpZihNYXRoLmFicyhkeCkgPj0gJC5zcG90U3dpcGUubW92ZVRocmVzaG9sZCAmJiBlbGFwc2VkVGltZSA8PSAkLnNwb3RTd2lwZS50aW1lVGhyZXNob2xkKSB7XG4gICAgICAgIGRpciA9IGR4ID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB9XG4gICAgICAvLyBlbHNlIGlmKE1hdGguYWJzKGR5KSA+PSAkLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkICYmIGVsYXBzZWRUaW1lIDw9ICQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQpIHtcbiAgICAgIC8vICAgZGlyID0gZHkgPiAwID8gJ2Rvd24nIDogJ3VwJztcbiAgICAgIC8vIH1cbiAgICAgIGlmKGRpcikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9uVG91Y2hFbmQuY2FsbCh0aGlzKTtcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdzd2lwZScsIGRpcikudHJpZ2dlcihgc3dpcGUke2Rpcn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgIHN0YXJ0UG9zWCA9IGUudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgIHN0YXJ0UG9zWSA9IGUudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgIGlzTW92aW5nID0gdHJ1ZTtcbiAgICAgIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlYXJkb3duKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCk7XG4gIH1cblxuICAkLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSB7IHNldHVwOiBpbml0IH07XG5cbiAgJC5lYWNoKFsnbGVmdCcsICd1cCcsICdkb3duJywgJ3JpZ2h0J10sIGZ1bmN0aW9uICgpIHtcbiAgICAkLmV2ZW50LnNwZWNpYWxbYHN3aXBlJHt0aGlzfWBdID0geyBzZXR1cDogZnVuY3Rpb24oKXtcbiAgICAgICQodGhpcykub24oJ3N3aXBlJywgJC5ub29wKTtcbiAgICB9IH07XG4gIH0pO1xufSkoalF1ZXJ5KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNZXRob2QgZm9yIGFkZGluZyBwc3VlZG8gZHJhZyBldmVudHMgdG8gZWxlbWVudHMgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiFmdW5jdGlvbigkKXtcbiAgJC5mbi5hZGRUb3VjaCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGksZWwpe1xuICAgICAgJChlbCkuYmluZCgndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vd2UgcGFzcyB0aGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0IGJlY2F1c2UgdGhlIGpRdWVyeSBldmVudFxuICAgICAgICAvL29iamVjdCBpcyBub3JtYWxpemVkIHRvIHczYyBzcGVjcyBhbmQgZG9lcyBub3QgcHJvdmlkZSB0aGUgVG91Y2hMaXN0XG4gICAgICAgIGhhbmRsZVRvdWNoKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGhhbmRsZVRvdWNoID0gZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgICBmaXJzdCA9IHRvdWNoZXNbMF0sXG4gICAgICAgICAgZXZlbnRUeXBlcyA9IHtcbiAgICAgICAgICAgIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuICAgICAgICAgICAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgIHRvdWNoZW5kOiAnbW91c2V1cCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHR5cGUgPSBldmVudFR5cGVzW2V2ZW50LnR5cGVdLFxuICAgICAgICAgIHNpbXVsYXRlZEV2ZW50XG4gICAgICAgIDtcblxuICAgICAgaWYoJ01vdXNlRXZlbnQnIGluIHdpbmRvdyAmJiB0eXBlb2Ygd2luZG93Lk1vdXNlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2ltdWxhdGVkRXZlbnQgPSBuZXcgd2luZG93Lk1vdXNlRXZlbnQodHlwZSwge1xuICAgICAgICAgICdidWJibGVzJzogdHJ1ZSxcbiAgICAgICAgICAnY2FuY2VsYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3NjcmVlblgnOiBmaXJzdC5zY3JlZW5YLFxuICAgICAgICAgICdzY3JlZW5ZJzogZmlyc3Quc2NyZWVuWSxcbiAgICAgICAgICAnY2xpZW50WCc6IGZpcnN0LmNsaWVudFgsXG4gICAgICAgICAgJ2NsaWVudFknOiBmaXJzdC5jbGllbnRZXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuICAgICAgICBzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudCh0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsIGZpcnN0LnNjcmVlblgsIGZpcnN0LnNjcmVlblksIGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLypsZWZ0Ki8sIG51bGwpO1xuICAgICAgfVxuICAgICAgZmlyc3QudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuICAgIH07XG4gIH07XG59KGpRdWVyeSk7XG5cblxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyoqRnJvbSB0aGUgalF1ZXJ5IE1vYmlsZSBMaWJyYXJ5Kipcbi8vKipuZWVkIHRvIHJlY3JlYXRlIGZ1bmN0aW9uYWxpdHkqKlxuLy8qKmFuZCB0cnkgdG8gaW1wcm92ZSBpZiBwb3NzaWJsZSoqXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuLyogUmVtb3ZpbmcgdGhlIGpRdWVyeSBmdW5jdGlvbiAqKioqXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuXHR2YXIgJGRvY3VtZW50ID0gJCggZG9jdW1lbnQgKSxcblx0XHQvLyBzdXBwb3J0VG91Y2ggPSAkLm1vYmlsZS5zdXBwb3J0LnRvdWNoLFxuXHRcdHRvdWNoU3RhcnRFdmVudCA9ICd0b3VjaHN0YXJ0Jy8vc3VwcG9ydFRvdWNoID8gXCJ0b3VjaHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiLFxuXHRcdHRvdWNoU3RvcEV2ZW50ID0gJ3RvdWNoZW5kJy8vc3VwcG9ydFRvdWNoID8gXCJ0b3VjaGVuZFwiIDogXCJtb3VzZXVwXCIsXG5cdFx0dG91Y2hNb3ZlRXZlbnQgPSAndG91Y2htb3ZlJy8vc3VwcG9ydFRvdWNoID8gXCJ0b3VjaG1vdmVcIiA6IFwibW91c2Vtb3ZlXCI7XG5cblx0Ly8gc2V0dXAgbmV3IGV2ZW50IHNob3J0Y3V0c1xuXHQkLmVhY2goICggXCJ0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCBcIiArXG5cdFx0XCJzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodFwiICkuc3BsaXQoIFwiIFwiICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdFx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0cmV0dXJuIGZuID8gdGhpcy5iaW5kKCBuYW1lLCBmbiApIDogdGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblxuXHRcdC8vIGpRdWVyeSA8IDEuOFxuXHRcdGlmICggJC5hdHRyRm4gKSB7XG5cdFx0XHQkLmF0dHJGblsgbmFtZSBdID0gdHJ1ZTtcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIHRyaWdnZXJDdXN0b21FdmVudCggb2JqLCBldmVudFR5cGUsIGV2ZW50LCBidWJibGUgKSB7XG5cdFx0dmFyIG9yaWdpbmFsVHlwZSA9IGV2ZW50LnR5cGU7XG5cdFx0ZXZlbnQudHlwZSA9IGV2ZW50VHlwZTtcblx0XHRpZiAoIGJ1YmJsZSApIHtcblx0XHRcdCQuZXZlbnQudHJpZ2dlciggZXZlbnQsIHVuZGVmaW5lZCwgb2JqICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQuZXZlbnQuZGlzcGF0Y2guY2FsbCggb2JqLCBldmVudCApO1xuXHRcdH1cblx0XHRldmVudC50eXBlID0gb3JpZ2luYWxUeXBlO1xuXHR9XG5cblx0Ly8gYWxzbyBoYW5kbGVzIHRhcGhvbGRcblxuXHQvLyBBbHNvIGhhbmRsZXMgc3dpcGVsZWZ0LCBzd2lwZXJpZ2h0XG5cdCQuZXZlbnQuc3BlY2lhbC5zd2lwZSA9IHtcblxuXHRcdC8vIE1vcmUgdGhhbiB0aGlzIGhvcml6b250YWwgZGlzcGxhY2VtZW50LCBhbmQgd2Ugd2lsbCBzdXBwcmVzcyBzY3JvbGxpbmcuXG5cdFx0c2Nyb2xsU3VwcmVzc2lvblRocmVzaG9sZDogMzAsXG5cblx0XHQvLyBNb3JlIHRpbWUgdGhhbiB0aGlzLCBhbmQgaXQgaXNuJ3QgYSBzd2lwZS5cblx0XHRkdXJhdGlvblRocmVzaG9sZDogMTAwMCxcblxuXHRcdC8vIFN3aXBlIGhvcml6b250YWwgZGlzcGxhY2VtZW50IG11c3QgYmUgbW9yZSB0aGFuIHRoaXMuXG5cdFx0aG9yaXpvbnRhbERpc3RhbmNlVGhyZXNob2xkOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+PSAyID8gMTUgOiAzMCxcblxuXHRcdC8vIFN3aXBlIHZlcnRpY2FsIGRpc3BsYWNlbWVudCBtdXN0IGJlIGxlc3MgdGhhbiB0aGlzLlxuXHRcdHZlcnRpY2FsRGlzdGFuY2VUaHJlc2hvbGQ6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID49IDIgPyAxNSA6IDMwLFxuXG5cdFx0Z2V0TG9jYXRpb246IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHR2YXIgd2luUGFnZVggPSB3aW5kb3cucGFnZVhPZmZzZXQsXG5cdFx0XHRcdHdpblBhZ2VZID0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuXHRcdFx0XHR4ID0gZXZlbnQuY2xpZW50WCxcblx0XHRcdFx0eSA9IGV2ZW50LmNsaWVudFk7XG5cblx0XHRcdGlmICggZXZlbnQucGFnZVkgPT09IDAgJiYgTWF0aC5mbG9vciggeSApID4gTWF0aC5mbG9vciggZXZlbnQucGFnZVkgKSB8fFxuXHRcdFx0XHRldmVudC5wYWdlWCA9PT0gMCAmJiBNYXRoLmZsb29yKCB4ICkgPiBNYXRoLmZsb29yKCBldmVudC5wYWdlWCApICkge1xuXG5cdFx0XHRcdC8vIGlPUzQgY2xpZW50WC9jbGllbnRZIGhhdmUgdGhlIHZhbHVlIHRoYXQgc2hvdWxkIGhhdmUgYmVlblxuXHRcdFx0XHQvLyBpbiBwYWdlWC9wYWdlWS4gV2hpbGUgcGFnZVgvcGFnZS8gaGF2ZSB0aGUgdmFsdWUgMFxuXHRcdFx0XHR4ID0geCAtIHdpblBhZ2VYO1xuXHRcdFx0XHR5ID0geSAtIHdpblBhZ2VZO1xuXHRcdFx0fSBlbHNlIGlmICggeSA8ICggZXZlbnQucGFnZVkgLSB3aW5QYWdlWSkgfHwgeCA8ICggZXZlbnQucGFnZVggLSB3aW5QYWdlWCApICkge1xuXG5cdFx0XHRcdC8vIFNvbWUgQW5kcm9pZCBicm93c2VycyBoYXZlIHRvdGFsbHkgYm9ndXMgdmFsdWVzIGZvciBjbGllbnRYL1lcblx0XHRcdFx0Ly8gd2hlbiBzY3JvbGxpbmcvem9vbWluZyBhIHBhZ2UuIERldGVjdGFibGUgc2luY2UgY2xpZW50WC9jbGllbnRZXG5cdFx0XHRcdC8vIHNob3VsZCBuZXZlciBiZSBzbWFsbGVyIHRoYW4gcGFnZVgvcGFnZVkgbWludXMgcGFnZSBzY3JvbGxcblx0XHRcdFx0eCA9IGV2ZW50LnBhZ2VYIC0gd2luUGFnZVg7XG5cdFx0XHRcdHkgPSBldmVudC5wYWdlWSAtIHdpblBhZ2VZO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiB5XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRzdGFydDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGRhdGEgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgP1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1sgMCBdIDogZXZlbnQsXG5cdFx0XHRcdGxvY2F0aW9uID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmdldExvY2F0aW9uKCBkYXRhICk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dGltZTogKCBuZXcgRGF0ZSgpICkuZ2V0VGltZSgpLFxuXHRcdFx0XHRcdFx0Y29vcmRzOiBbIGxvY2F0aW9uLngsIGxvY2F0aW9uLnkgXSxcblx0XHRcdFx0XHRcdG9yaWdpbjogJCggZXZlbnQudGFyZ2V0IClcblx0XHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRzdG9wOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgZGF0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyA/XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWyAwIF0gOiBldmVudCxcblx0XHRcdFx0bG9jYXRpb24gPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZ2V0TG9jYXRpb24oIGRhdGEgKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0aW1lOiAoIG5ldyBEYXRlKCkgKS5nZXRUaW1lKCksXG5cdFx0XHRcdFx0XHRjb29yZHM6IFsgbG9jYXRpb24ueCwgbG9jYXRpb24ueSBdXG5cdFx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0aGFuZGxlU3dpcGU6IGZ1bmN0aW9uKCBzdGFydCwgc3RvcCwgdGhpc09iamVjdCwgb3JpZ1RhcmdldCApIHtcblx0XHRcdGlmICggc3RvcC50aW1lIC0gc3RhcnQudGltZSA8ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5kdXJhdGlvblRocmVzaG9sZCAmJlxuXHRcdFx0XHRNYXRoLmFicyggc3RhcnQuY29vcmRzWyAwIF0gLSBzdG9wLmNvb3Jkc1sgMCBdICkgPiAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuaG9yaXpvbnRhbERpc3RhbmNlVGhyZXNob2xkICYmXG5cdFx0XHRcdE1hdGguYWJzKCBzdGFydC5jb29yZHNbIDEgXSAtIHN0b3AuY29vcmRzWyAxIF0gKSA8ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS52ZXJ0aWNhbERpc3RhbmNlVGhyZXNob2xkICkge1xuXHRcdFx0XHR2YXIgZGlyZWN0aW9uID0gc3RhcnQuY29vcmRzWzBdID4gc3RvcC5jb29yZHNbIDAgXSA/IFwic3dpcGVsZWZ0XCIgOiBcInN3aXBlcmlnaHRcIjtcblxuXHRcdFx0XHR0cmlnZ2VyQ3VzdG9tRXZlbnQoIHRoaXNPYmplY3QsIFwic3dpcGVcIiwgJC5FdmVudCggXCJzd2lwZVwiLCB7IHRhcmdldDogb3JpZ1RhcmdldCwgc3dpcGVzdGFydDogc3RhcnQsIHN3aXBlc3RvcDogc3RvcCB9KSwgdHJ1ZSApO1xuXHRcdFx0XHR0cmlnZ2VyQ3VzdG9tRXZlbnQoIHRoaXNPYmplY3QsIGRpcmVjdGlvbiwkLkV2ZW50KCBkaXJlY3Rpb24sIHsgdGFyZ2V0OiBvcmlnVGFyZ2V0LCBzd2lwZXN0YXJ0OiBzdGFydCwgc3dpcGVzdG9wOiBzdG9wIH0gKSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH0sXG5cblx0XHQvLyBUaGlzIHNlcnZlcyBhcyBhIGZsYWcgdG8gZW5zdXJlIHRoYXQgYXQgbW9zdCBvbmUgc3dpcGUgZXZlbnQgZXZlbnQgaXNcblx0XHQvLyBpbiB3b3JrIGF0IGFueSBnaXZlbiB0aW1lXG5cdFx0ZXZlbnRJblByb2dyZXNzOiBmYWxzZSxcblxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBldmVudHMsXG5cdFx0XHRcdHRoaXNPYmplY3QgPSB0aGlzLFxuXHRcdFx0XHQkdGhpcyA9ICQoIHRoaXNPYmplY3QgKSxcblx0XHRcdFx0Y29udGV4dCA9IHt9O1xuXG5cdFx0XHQvLyBSZXRyaWV2ZSB0aGUgZXZlbnRzIGRhdGEgZm9yIHRoaXMgZWxlbWVudCBhbmQgYWRkIHRoZSBzd2lwZSBjb250ZXh0XG5cdFx0XHRldmVudHMgPSAkLmRhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiICk7XG5cdFx0XHRpZiAoICFldmVudHMgKSB7XG5cdFx0XHRcdGV2ZW50cyA9IHsgbGVuZ3RoOiAwIH07XG5cdFx0XHRcdCQuZGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIsIGV2ZW50cyApO1xuXHRcdFx0fVxuXHRcdFx0ZXZlbnRzLmxlbmd0aCsrO1xuXHRcdFx0ZXZlbnRzLnN3aXBlID0gY29udGV4dDtcblxuXHRcdFx0Y29udGV4dC5zdGFydCA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBCYWlsIGlmIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvbiBhIHN3aXBlIGV2ZW50XG5cdFx0XHRcdGlmICggJC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9IHRydWU7XG5cblx0XHRcdFx0dmFyIHN0b3AsXG5cdFx0XHRcdFx0c3RhcnQgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc3RhcnQoIGV2ZW50ICksXG5cdFx0XHRcdFx0b3JpZ1RhcmdldCA9IGV2ZW50LnRhcmdldCxcblx0XHRcdFx0XHRlbWl0dGVkID0gZmFsc2U7XG5cblx0XHRcdFx0Y29udGV4dC5tb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXJ0IHx8IGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN0b3AgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc3RvcCggZXZlbnQgKTtcblx0XHRcdFx0XHRpZiAoICFlbWl0dGVkICkge1xuXHRcdFx0XHRcdFx0ZW1pdHRlZCA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5oYW5kbGVTd2lwZSggc3RhcnQsIHN0b3AsIHRoaXNPYmplY3QsIG9yaWdUYXJnZXQgKTtcblx0XHRcdFx0XHRcdGlmICggZW1pdHRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXNldCB0aGUgY29udGV4dCB0byBtYWtlIHdheSBmb3IgdGhlIG5leHQgc3dpcGUgZXZlbnRcblx0XHRcdFx0XHRcdFx0JC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBwcmV2ZW50IHNjcm9sbGluZ1xuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIHN0YXJ0LmNvb3Jkc1sgMCBdIC0gc3RvcC5jb29yZHNbIDAgXSApID4gJC5ldmVudC5zcGVjaWFsLnN3aXBlLnNjcm9sbFN1cHJlc3Npb25UaHJlc2hvbGQgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRjb250ZXh0LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGVtaXR0ZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHQvLyBSZXNldCB0aGUgY29udGV4dCB0byBtYWtlIHdheSBmb3IgdGhlIG5leHQgc3dpcGUgZXZlbnRcblx0XHRcdFx0XHRcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRcdCRkb2N1bWVudC5vZmYoIHRvdWNoTW92ZUV2ZW50LCBjb250ZXh0Lm1vdmUgKTtcblx0XHRcdFx0XHRcdGNvbnRleHQubW92ZSA9IG51bGw7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0JGRvY3VtZW50Lm9uKCB0b3VjaE1vdmVFdmVudCwgY29udGV4dC5tb3ZlIClcblx0XHRcdFx0XHQub25lKCB0b3VjaFN0b3BFdmVudCwgY29udGV4dC5zdG9wICk7XG5cdFx0XHR9O1xuXHRcdFx0JHRoaXMub24oIHRvdWNoU3RhcnRFdmVudCwgY29udGV4dC5zdGFydCApO1xuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZXZlbnRzLCBjb250ZXh0O1xuXG5cdFx0XHRldmVudHMgPSAkLmRhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiICk7XG5cdFx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdFx0Y29udGV4dCA9IGV2ZW50cy5zd2lwZTtcblx0XHRcdFx0ZGVsZXRlIGV2ZW50cy5zd2lwZTtcblx0XHRcdFx0ZXZlbnRzLmxlbmd0aC0tO1xuXHRcdFx0XHRpZiAoIGV2ZW50cy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0JC5yZW1vdmVEYXRhKCB0aGlzLCBcIm1vYmlsZS1ldmVudHNcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggY29udGV4dCApIHtcblx0XHRcdFx0aWYgKCBjb250ZXh0LnN0YXJ0ICkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5vZmYoIHRvdWNoU3RhcnRFdmVudCwgY29udGV4dC5zdGFydCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY29udGV4dC5tb3ZlICkge1xuXHRcdFx0XHRcdCRkb2N1bWVudC5vZmYoIHRvdWNoTW92ZUV2ZW50LCBjb250ZXh0Lm1vdmUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNvbnRleHQuc3RvcCApIHtcblx0XHRcdFx0XHQkZG9jdW1lbnQub2ZmKCB0b3VjaFN0b3BFdmVudCwgY29udGV4dC5zdG9wICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdCQuZWFjaCh7XG5cdFx0c3dpcGVsZWZ0OiBcInN3aXBlLmxlZnRcIixcblx0XHRzd2lwZXJpZ2h0OiBcInN3aXBlLnJpZ2h0XCJcblx0fSwgZnVuY3Rpb24oIGV2ZW50LCBzb3VyY2VFdmVudCApIHtcblxuXHRcdCQuZXZlbnQuc3BlY2lhbFsgZXZlbnQgXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmJpbmQoIHNvdXJjZUV2ZW50LCAkLm5vb3AgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS51bmJpbmQoIHNvdXJjZUV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59KSggalF1ZXJ5LCB0aGlzICk7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG5jb25zdCBNdXRhdGlvbk9ic2VydmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByZWZpeGVzID0gWydXZWJLaXQnLCAnTW96JywgJ08nLCAnTXMnLCAnJ107XG4gIGZvciAodmFyIGk9MDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGAke3ByZWZpeGVzW2ldfU11dGF0aW9uT2JzZXJ2ZXJgIGluIHdpbmRvdykge1xuICAgICAgcmV0dXJuIHdpbmRvd1tgJHtwcmVmaXhlc1tpXX1NdXRhdGlvbk9ic2VydmVyYF07XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn0oKSk7XG5cbmNvbnN0IHRyaWdnZXJzID0gKGVsLCB0eXBlKSA9PiB7XG4gIGVsLmRhdGEodHlwZSkuc3BsaXQoJyAnKS5mb3JFYWNoKGlkID0+IHtcbiAgICAkKGAjJHtpZH1gKVsgdHlwZSA9PT0gJ2Nsb3NlJyA/ICd0cmlnZ2VyJyA6ICd0cmlnZ2VySGFuZGxlciddKGAke3R5cGV9LnpmLnRyaWdnZXJgLCBbZWxdKTtcbiAgfSk7XG59O1xuLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1vcGVuXSB3aWxsIHJldmVhbCBhIHBsdWdpbiB0aGF0IHN1cHBvcnRzIGl0IHdoZW4gY2xpY2tlZC5cbiQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLW9wZW5dJywgZnVuY3Rpb24oKSB7XG4gIHRyaWdnZXJzKCQodGhpcyksICdvcGVuJyk7XG59KTtcblxuLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1jbG9zZV0gd2lsbCBjbG9zZSBhIHBsdWdpbiB0aGF0IHN1cHBvcnRzIGl0IHdoZW4gY2xpY2tlZC5cbi8vIElmIHVzZWQgd2l0aG91dCBhIHZhbHVlIG9uIFtkYXRhLWNsb3NlXSwgdGhlIGV2ZW50IHdpbGwgYnViYmxlLCBhbGxvd2luZyBpdCB0byBjbG9zZSBhIHBhcmVudCBjb21wb25lbnQuXG4kKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS1jbG9zZV0nLCBmdW5jdGlvbigpIHtcbiAgbGV0IGlkID0gJCh0aGlzKS5kYXRhKCdjbG9zZScpO1xuICBpZiAoaWQpIHtcbiAgICB0cmlnZ2VycygkKHRoaXMpLCAnY2xvc2UnKTtcbiAgfVxuICBlbHNlIHtcbiAgICAkKHRoaXMpLnRyaWdnZXIoJ2Nsb3NlLnpmLnRyaWdnZXInKTtcbiAgfVxufSk7XG5cbi8vIEVsZW1lbnRzIHdpdGggW2RhdGEtdG9nZ2xlXSB3aWxsIHRvZ2dsZSBhIHBsdWdpbiB0aGF0IHN1cHBvcnRzIGl0IHdoZW4gY2xpY2tlZC5cbiQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLXRvZ2dsZV0nLCBmdW5jdGlvbigpIHtcbiAgdHJpZ2dlcnMoJCh0aGlzKSwgJ3RvZ2dsZScpO1xufSk7XG5cbi8vIEVsZW1lbnRzIHdpdGggW2RhdGEtY2xvc2FibGVdIHdpbGwgcmVzcG9uZCB0byBjbG9zZS56Zi50cmlnZ2VyIGV2ZW50cy5cbiQoZG9jdW1lbnQpLm9uKCdjbG9zZS56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NhYmxlXScsIGZ1bmN0aW9uKGUpe1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICBsZXQgYW5pbWF0aW9uID0gJCh0aGlzKS5kYXRhKCdjbG9zYWJsZScpO1xuXG4gIGlmKGFuaW1hdGlvbiAhPT0gJycpe1xuICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQoJCh0aGlzKSwgYW5pbWF0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykudHJpZ2dlcignY2xvc2VkLnpmJyk7XG4gICAgfSk7XG4gIH1lbHNle1xuICAgICQodGhpcykuZmFkZU91dCgpLnRyaWdnZXIoJ2Nsb3NlZC56ZicpO1xuICB9XG59KTtcblxuJChkb2N1bWVudCkub24oJ2ZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyJywgJ1tkYXRhLXRvZ2dsZS1mb2N1c10nLCBmdW5jdGlvbigpIHtcbiAgbGV0IGlkID0gJCh0aGlzKS5kYXRhKCd0b2dnbGUtZm9jdXMnKTtcbiAgJChgIyR7aWR9YCkudHJpZ2dlckhhbmRsZXIoJ3RvZ2dsZS56Zi50cmlnZ2VyJywgWyQodGhpcyldKTtcbn0pO1xuXG4vKipcbiogRmlyZXMgb25jZSBhZnRlciBhbGwgb3RoZXIgc2NyaXB0cyBoYXZlIGxvYWRlZFxuKiBAZnVuY3Rpb25cbiogQHByaXZhdGVcbiovXG4kKHdpbmRvdykubG9hZCgoKSA9PiB7XG4gIGNoZWNrTGlzdGVuZXJzKCk7XG59KTtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcnMoKSB7XG4gIGV2ZW50c0xpc3RlbmVyKCk7XG4gIHJlc2l6ZUxpc3RlbmVyKCk7XG4gIHNjcm9sbExpc3RlbmVyKCk7XG4gIGNsb3NlbWVMaXN0ZW5lcigpO1xufVxuXG4vLyoqKioqKioqIG9ubHkgZmlyZXMgdGhpcyBmdW5jdGlvbiBvbmNlIG9uIGxvYWQsIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIHRvIHdhdGNoICoqKioqKioqXG5mdW5jdGlvbiBjbG9zZW1lTGlzdGVuZXIocGx1Z2luTmFtZSkge1xuICB2YXIgeWV0aUJveGVzID0gJCgnW2RhdGEteWV0aS1ib3hdJyksXG4gICAgICBwbHVnTmFtZXMgPSBbJ2Ryb3Bkb3duJywgJ3Rvb2x0aXAnLCAncmV2ZWFsJ107XG5cbiAgaWYocGx1Z2luTmFtZSl7XG4gICAgaWYodHlwZW9mIHBsdWdpbk5hbWUgPT09ICdzdHJpbmcnKXtcbiAgICAgIHBsdWdOYW1lcy5wdXNoKHBsdWdpbk5hbWUpO1xuICAgIH1lbHNlIGlmKHR5cGVvZiBwbHVnaW5OYW1lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGx1Z2luTmFtZVswXSA9PT0gJ3N0cmluZycpe1xuICAgICAgcGx1Z05hbWVzLmNvbmNhdChwbHVnaW5OYW1lKTtcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BsdWdpbiBuYW1lcyBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gIH1cbiAgaWYoeWV0aUJveGVzLmxlbmd0aCl7XG4gICAgbGV0IGxpc3RlbmVycyA9IHBsdWdOYW1lcy5tYXAoKG5hbWUpID0+IHtcbiAgICAgIHJldHVybiBgY2xvc2VtZS56Zi4ke25hbWV9YDtcbiAgICB9KS5qb2luKCcgJyk7XG5cbiAgICAkKHdpbmRvdykub2ZmKGxpc3RlbmVycykub24obGlzdGVuZXJzLCBmdW5jdGlvbihlLCBwbHVnaW5JZCl7XG4gICAgICBsZXQgcGx1Z2luID0gZS5uYW1lc3BhY2Uuc3BsaXQoJy4nKVswXTtcbiAgICAgIGxldCBwbHVnaW5zID0gJChgW2RhdGEtJHtwbHVnaW59XWApLm5vdChgW2RhdGEteWV0aS1ib3g9XCIke3BsdWdpbklkfVwiXWApO1xuXG4gICAgICBwbHVnaW5zLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IF90aGlzID0gJCh0aGlzKTtcblxuICAgICAgICBfdGhpcy50cmlnZ2VySGFuZGxlcignY2xvc2UuemYudHJpZ2dlcicsIFtfdGhpc10pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzaXplTGlzdGVuZXIoZGVib3VuY2Upe1xuICBsZXQgdGltZXIsXG4gICAgICAkbm9kZXMgPSAkKCdbZGF0YS1yZXNpemVdJyk7XG4gIGlmKCRub2Rlcy5sZW5ndGgpe1xuICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS56Zi50cmlnZ2VyJylcbiAgICAub24oJ3Jlc2l6ZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRpbWVyKSB7IGNsZWFyVGltZW91dCh0aW1lcik7IH1cblxuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgaWYoIU11dGF0aW9uT2JzZXJ2ZXIpey8vZmFsbGJhY2sgZm9yIElFIDlcbiAgICAgICAgICAkbm9kZXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSByZXNpemUgZXZlbnRcbiAgICAgICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXCJyZXNpemVcIik7XG4gICAgICB9LCBkZWJvdW5jZSB8fCAxMCk7Ly9kZWZhdWx0IHRpbWUgdG8gZW1pdCByZXNpemUgZXZlbnRcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxMaXN0ZW5lcihkZWJvdW5jZSl7XG4gIGxldCB0aW1lcixcbiAgICAgICRub2RlcyA9ICQoJ1tkYXRhLXNjcm9sbF0nKTtcbiAgaWYoJG5vZGVzLmxlbmd0aCl7XG4gICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLnpmLnRyaWdnZXInKVxuICAgIC5vbignc2Nyb2xsLnpmLnRyaWdnZXInLCBmdW5jdGlvbihlKXtcbiAgICAgIGlmKHRpbWVyKXsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfVxuXG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgICAgICBpZighTXV0YXRpb25PYnNlcnZlcil7Ly9mYWxsYmFjayBmb3IgSUUgOVxuICAgICAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKCdzY3JvbGxtZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy90cmlnZ2VyIGFsbCBsaXN0ZW5pbmcgZWxlbWVudHMgYW5kIHNpZ25hbCBhIHNjcm9sbCBldmVudFxuICAgICAgICAkbm9kZXMuYXR0cignZGF0YS1ldmVudHMnLCBcInNjcm9sbFwiKTtcbiAgICAgIH0sIGRlYm91bmNlIHx8IDEwKTsvL2RlZmF1bHQgdGltZSB0byBlbWl0IHNjcm9sbCBldmVudFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50c0xpc3RlbmVyKCkge1xuICBpZighTXV0YXRpb25PYnNlcnZlcil7IHJldHVybiBmYWxzZTsgfVxuICBsZXQgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1yZXNpemVdLCBbZGF0YS1zY3JvbGxdLCBbZGF0YS1tdXRhdGVdJyk7XG5cbiAgLy9lbGVtZW50IGNhbGxiYWNrXG4gIHZhciBsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uID0gZnVuY3Rpb24obXV0YXRpb25SZWNvcmRzTGlzdCkge1xuICAgIHZhciAkdGFyZ2V0ID0gJChtdXRhdGlvblJlY29yZHNMaXN0WzBdLnRhcmdldCk7XG4gICAgLy90cmlnZ2VyIHRoZSBldmVudCBoYW5kbGVyIGZvciB0aGUgZWxlbWVudCBkZXBlbmRpbmcgb24gdHlwZVxuICAgIHN3aXRjaCAoJHRhcmdldC5hdHRyKFwiZGF0YS1ldmVudHNcIikpIHtcblxuICAgICAgY2FzZSBcInJlc2l6ZVwiIDpcbiAgICAgICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBbJHRhcmdldF0pO1xuICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJzY3JvbGxcIiA6XG4gICAgICAkdGFyZ2V0LnRyaWdnZXJIYW5kbGVyKCdzY3JvbGxtZS56Zi50cmlnZ2VyJywgWyR0YXJnZXQsIHdpbmRvdy5wYWdlWU9mZnNldF0pO1xuICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIGNhc2UgXCJtdXRhdGVcIiA6XG4gICAgICAvLyBjb25zb2xlLmxvZygnbXV0YXRlJywgJHRhcmdldCk7XG4gICAgICAvLyAkdGFyZ2V0LnRyaWdnZXJIYW5kbGVyKCdtdXRhdGUuemYudHJpZ2dlcicpO1xuICAgICAgLy9cbiAgICAgIC8vIC8vbWFrZSBzdXJlIHdlIGRvbid0IGdldCBzdHVjayBpbiBhbiBpbmZpbml0ZSBsb29wIGZyb20gc2xvcHB5IGNvZGVpbmdcbiAgICAgIC8vIGlmICgkdGFyZ2V0LmluZGV4KCdbZGF0YS1tdXRhdGVdJykgPT0gJChcIltkYXRhLW11dGF0ZV1cIikubGVuZ3RoLTEpIHtcbiAgICAgIC8vICAgZG9tTXV0YXRpb25PYnNlcnZlcigpO1xuICAgICAgLy8gfVxuICAgICAgLy8gYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQgOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgLy9ub3RoaW5nXG4gICAgfVxuICB9XG5cbiAgaWYobm9kZXMubGVuZ3RoKXtcbiAgICAvL2ZvciBlYWNoIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBsaXN0ZW4gZm9yIHJlc2l6aW5nLCBzY3JvbGxpbmcsIChvciBjb21pbmcgc29vbiBtdXRhdGlvbikgYWRkIGEgc2luZ2xlIG9ic2VydmVyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbm9kZXMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgbGV0IGVsZW1lbnRPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24pO1xuICAgICAgZWxlbWVudE9ic2VydmVyLm9ic2VydmUobm9kZXNbaV0sIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiBmYWxzZSwgY2hhcmFjdGVyRGF0YTogZmFsc2UsIHN1YnRyZWU6ZmFsc2UsIGF0dHJpYnV0ZUZpbHRlcjpbXCJkYXRhLWV2ZW50c1wiXX0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gW1BIXVxuLy8gRm91bmRhdGlvbi5DaGVja1dhdGNoZXJzID0gY2hlY2tXYXRjaGVycztcbkZvdW5kYXRpb24uSUhlYXJZb3UgPSBjaGVja0xpc3RlbmVycztcbi8vIEZvdW5kYXRpb24uSVNlZVlvdSA9IHNjcm9sbExpc3RlbmVyO1xuLy8gRm91bmRhdGlvbi5JRmVlbFlvdSA9IGNsb3NlbWVMaXN0ZW5lcjtcblxufShqUXVlcnkpO1xuXG4vLyBmdW5jdGlvbiBkb21NdXRhdGlvbk9ic2VydmVyKGRlYm91bmNlKSB7XG4vLyAgIC8vICEhISBUaGlzIGlzIGNvbWluZyBzb29uIGFuZCBuZWVkcyBtb3JlIHdvcms7IG5vdCBhY3RpdmUgICEhISAvL1xuLy8gICB2YXIgdGltZXIsXG4vLyAgIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbXV0YXRlXScpO1xuLy8gICAvL1xuLy8gICBpZiAobm9kZXMubGVuZ3RoKSB7XG4vLyAgICAgLy8gdmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuLy8gICAgIC8vICAgdmFyIHByZWZpeGVzID0gWydXZWJLaXQnLCAnTW96JywgJ08nLCAnTXMnLCAnJ107XG4vLyAgICAgLy8gICBmb3IgKHZhciBpPTA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuLy8gICAgIC8vICAgICBpZiAocHJlZml4ZXNbaV0gKyAnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4vLyAgICAgLy8gICAgICAgcmV0dXJuIHdpbmRvd1twcmVmaXhlc1tpXSArICdNdXRhdGlvbk9ic2VydmVyJ107XG4vLyAgICAgLy8gICAgIH1cbi8vICAgICAvLyAgIH1cbi8vICAgICAvLyAgIHJldHVybiBmYWxzZTtcbi8vICAgICAvLyB9KCkpO1xuLy9cbi8vXG4vLyAgICAgLy9mb3IgdGhlIGJvZHksIHdlIG5lZWQgdG8gbGlzdGVuIGZvciBhbGwgY2hhbmdlcyBlZmZlY3RpbmcgdGhlIHN0eWxlIGFuZCBjbGFzcyBhdHRyaWJ1dGVzXG4vLyAgICAgdmFyIGJvZHlPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGJvZHlNdXRhdGlvbik7XG4vLyAgICAgYm9keU9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIGNoYXJhY3RlckRhdGE6IGZhbHNlLCBzdWJ0cmVlOnRydWUsIGF0dHJpYnV0ZUZpbHRlcjpbXCJzdHlsZVwiLCBcImNsYXNzXCJdfSk7XG4vL1xuLy9cbi8vICAgICAvL2JvZHkgY2FsbGJhY2tcbi8vICAgICBmdW5jdGlvbiBib2R5TXV0YXRpb24obXV0YXRlKSB7XG4vLyAgICAgICAvL3RyaWdnZXIgYWxsIGxpc3RlbmluZyBlbGVtZW50cyBhbmQgc2lnbmFsIGEgbXV0YXRpb24gZXZlbnRcbi8vICAgICAgIGlmICh0aW1lcikgeyBjbGVhclRpbWVvdXQodGltZXIpOyB9XG4vL1xuLy8gICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICBib2R5T2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuLy8gICAgICAgICAkKCdbZGF0YS1tdXRhdGVdJykuYXR0cignZGF0YS1ldmVudHMnLFwibXV0YXRlXCIpO1xuLy8gICAgICAgfSwgZGVib3VuY2UgfHwgMTUwKTtcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBBYmlkZSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWJpZGVcbiAqL1xuXG5jbGFzcyBBYmlkZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEFiaWRlLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIEFiaWRlI2luaXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zICA9ICQuZXh0ZW5kKHt9LCBBYmlkZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnQWJpZGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQWJpZGUgcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IEFiaWRlIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB0aGlzLiRpbnB1dHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0Jyk7XG5cbiAgICB0aGlzLl9ldmVudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIEFiaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V2ZW50cygpIHtcbiAgICB0aGlzLiRlbGVtZW50Lm9mZignLmFiaWRlJylcbiAgICAgIC5vbigncmVzZXQuemYuYWJpZGUnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVzZXRGb3JtKCk7XG4gICAgICB9KVxuICAgICAgLm9uKCdzdWJtaXQuemYuYWJpZGUnLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlRm9ybSgpO1xuICAgICAgfSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnZhbGlkYXRlT24gPT09ICdmaWVsZENoYW5nZScpIHtcbiAgICAgIHRoaXMuJGlucHV0c1xuICAgICAgICAub2ZmKCdjaGFuZ2UuemYuYWJpZGUnKVxuICAgICAgICAub24oJ2NoYW5nZS56Zi5hYmlkZScsIChlKSA9PiB7XG4gICAgICAgICAgdGhpcy52YWxpZGF0ZUlucHV0KCQoZS50YXJnZXQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5saXZlVmFsaWRhdGUpIHtcbiAgICAgIHRoaXMuJGlucHV0c1xuICAgICAgICAub2ZmKCdpbnB1dC56Zi5hYmlkZScpXG4gICAgICAgIC5vbignaW5wdXQuemYuYWJpZGUnLCAoZSkgPT4ge1xuICAgICAgICAgIHRoaXMudmFsaWRhdGVJbnB1dCgkKGUudGFyZ2V0KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBBYmlkZSB1cG9uIERPTSBjaGFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZWZsb3coKSB7XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIGZvcm0gZWxlbWVudCBoYXMgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBhbmQgaWYgaXQncyBjaGVja2VkIG9yIG5vdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XG4gICAqL1xuICByZXF1aXJlZENoZWNrKCRlbCkge1xuICAgIGlmICghJGVsLmF0dHIoJ3JlcXVpcmVkJykpIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIGlzR29vZCA9IHRydWU7XG5cbiAgICBzd2l0Y2ggKCRlbFswXS50eXBlKSB7XG4gICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgIGlzR29vZCA9ICRlbFswXS5jaGVja2VkO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGNhc2UgJ3NlbGVjdC1vbmUnOlxuICAgICAgY2FzZSAnc2VsZWN0LW11bHRpcGxlJzpcbiAgICAgICAgdmFyIG9wdCA9ICRlbC5maW5kKCdvcHRpb246c2VsZWN0ZWQnKTtcbiAgICAgICAgaWYgKCFvcHQubGVuZ3RoIHx8ICFvcHQudmFsKCkpIGlzR29vZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYoISRlbC52YWwoKSB8fCAhJGVsLnZhbCgpLmxlbmd0aCkgaXNHb29kID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzR29vZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlZCBvbiAkZWwsIGdldCB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIHNlbGVjdG9yIGluIHRoaXMgb3JkZXI6XG4gICAqIDEuIFRoZSBlbGVtZW50J3MgZGlyZWN0IHNpYmxpbmcoJ3MpLlxuICAgKiAzLiBUaGUgZWxlbWVudCdzIHBhcmVudCdzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBUaGlzIGFsbG93cyBmb3IgbXVsdGlwbGUgZm9ybSBlcnJvcnMgcGVyIGlucHV0LCB0aG91Z2ggaWYgbm9uZSBhcmUgZm91bmQsIG5vIGZvcm0gZXJyb3JzIHdpbGwgYmUgc2hvd24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHVzZSBhcyByZWZlcmVuY2UgdG8gZmluZCB0aGUgZm9ybSBlcnJvciBzZWxlY3Rvci5cbiAgICogQHJldHVybnMge09iamVjdH0galF1ZXJ5IG9iamVjdCB3aXRoIHRoZSBzZWxlY3Rvci5cbiAgICovXG4gIGZpbmRGb3JtRXJyb3IoJGVsKSB7XG4gICAgdmFyICRlcnJvciA9ICRlbC5zaWJsaW5ncyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO1xuXG4gICAgaWYgKCEkZXJyb3IubGVuZ3RoKSB7XG4gICAgICAkZXJyb3IgPSAkZWwucGFyZW50KCkuZmluZCh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiAkZXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCBlbGVtZW50IGluIHRoaXMgb3JkZXI6XG4gICAqIDIuIFRoZSA8bGFiZWw+IHdpdGggdGhlIGF0dHJpYnV0ZSBgW2Zvcj1cInNvbWVJbnB1dElkXCJdYFxuICAgKiAzLiBUaGUgYC5jbG9zZXN0KClgIDxsYWJlbD5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XG4gICAqL1xuICBmaW5kTGFiZWwoJGVsKSB7XG4gICAgdmFyIGlkID0gJGVsWzBdLmlkO1xuICAgIHZhciAkbGFiZWwgPSB0aGlzLiRlbGVtZW50LmZpbmQoYGxhYmVsW2Zvcj1cIiR7aWR9XCJdYCk7XG5cbiAgICBpZiAoISRsYWJlbC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAkZWwuY2xvc2VzdCgnbGFiZWwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJGxhYmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2V0IG9mIGxhYmVscyBhc3NvY2lhdGVkIHdpdGggYSBzZXQgb2YgcmFkaW8gZWxzIGluIHRoaXMgb3JkZXJcbiAgICogMi4gVGhlIDxsYWJlbD4gd2l0aCB0aGUgYXR0cmlidXRlIGBbZm9yPVwic29tZUlucHV0SWRcIl1gXG4gICAqIDMuIFRoZSBgLmNsb3Nlc3QoKWAgPGxhYmVsPlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcbiAgICovXG4gIGZpbmRSYWRpb0xhYmVscygkZWxzKSB7XG4gICAgdmFyIGxhYmVscyA9ICRlbHMubWFwKChpLCBlbCkgPT4ge1xuICAgICAgdmFyIGlkID0gZWwuaWQ7XG4gICAgICB2YXIgJGxhYmVsID0gdGhpcy4kZWxlbWVudC5maW5kKGBsYWJlbFtmb3I9XCIke2lkfVwiXWApO1xuXG4gICAgICBpZiAoISRsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgJGxhYmVsID0gJChlbCkuY2xvc2VzdCgnbGFiZWwnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAkbGFiZWxbMF07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gJChsYWJlbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIENTUyBlcnJvciBjbGFzcyBhcyBzcGVjaWZpZWQgYnkgdGhlIEFiaWRlIHNldHRpbmdzIHRvIHRoZSBsYWJlbCwgaW5wdXQsIGFuZCB0aGUgZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIGNsYXNzIHRvXG4gICAqL1xuICBhZGRFcnJvckNsYXNzZXMoJGVsKSB7XG4gICAgdmFyICRsYWJlbCA9IHRoaXMuZmluZExhYmVsKCRlbCk7XG4gICAgdmFyICRmb3JtRXJyb3IgPSB0aGlzLmZpbmRGb3JtRXJyb3IoJGVsKTtcblxuICAgIGlmICgkbGFiZWwubGVuZ3RoKSB7XG4gICAgICAkbGFiZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKCRmb3JtRXJyb3IubGVuZ3RoKSB7XG4gICAgICAkZm9ybUVycm9yLmFkZENsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyk7XG4gICAgfVxuXG4gICAgJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoJ2RhdGEtaW52YWxpZCcsICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgQ1NTIGVycm9yIGNsYXNzZXMgZXRjIGZyb20gYW4gZW50aXJlIHJhZGlvIGJ1dHRvbiBncm91cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lIC0gQSBzdHJpbmcgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWUgb2YgYSByYWRpbyBidXR0b24gZ3JvdXBcbiAgICpcbiAgICovXG5cbiAgcmVtb3ZlUmFkaW9FcnJvckNsYXNzZXMoZ3JvdXBOYW1lKSB7XG4gICAgdmFyICRlbHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoYDpyYWRpb1tuYW1lPVwiJHtncm91cE5hbWV9XCJdYCk7XG4gICAgdmFyICRsYWJlbHMgPSB0aGlzLmZpbmRSYWRpb0xhYmVscygkZWxzKTtcbiAgICB2YXIgJGZvcm1FcnJvcnMgPSB0aGlzLmZpbmRGb3JtRXJyb3IoJGVscyk7XG5cbiAgICBpZiAoJGxhYmVscy5sZW5ndGgpIHtcbiAgICAgICRsYWJlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKCRmb3JtRXJyb3JzLmxlbmd0aCkge1xuICAgICAgJGZvcm1FcnJvcnMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcbiAgICB9XG5cbiAgICAkZWxzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLnJlbW92ZUF0dHIoJ2RhdGEtaW52YWxpZCcpO1xuXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBDU1MgZXJyb3IgY2xhc3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBBYmlkZSBzZXR0aW5ncyBmcm9tIHRoZSBsYWJlbCwgaW5wdXQsIGFuZCB0aGUgZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byByZW1vdmUgdGhlIGNsYXNzIGZyb21cbiAgICovXG4gIHJlbW92ZUVycm9yQ2xhc3NlcygkZWwpIHtcbiAgICAvLyByYWRpb3MgbmVlZCB0byBjbGVhciBhbGwgb2YgdGhlIGVsc1xuICAgIGlmKCRlbFswXS50eXBlID09ICdyYWRpbycpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKCRlbC5hdHRyKCduYW1lJykpO1xuICAgIH1cblxuICAgIHZhciAkbGFiZWwgPSB0aGlzLmZpbmRMYWJlbCgkZWwpO1xuICAgIHZhciAkZm9ybUVycm9yID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbCk7XG5cbiAgICBpZiAoJGxhYmVsLmxlbmd0aCkge1xuICAgICAgJGxhYmVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO1xuICAgIH1cblxuICAgIGlmICgkZm9ybUVycm9yLmxlbmd0aCkge1xuICAgICAgJGZvcm1FcnJvci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xuICAgIH1cblxuICAgICRlbC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHb2VzIHRocm91Z2ggYSBmb3JtIHRvIGZpbmQgaW5wdXRzIGFuZCBwcm9jZWVkcyB0byB2YWxpZGF0ZSB0aGVtIGluIHdheXMgc3BlY2lmaWMgdG8gdGhlaXIgdHlwZVxuICAgKiBAZmlyZXMgQWJpZGUjaW52YWxpZFxuICAgKiBAZmlyZXMgQWJpZGUjdmFsaWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHZhbGlkYXRlLCBzaG91bGQgYmUgYW4gSFRNTCBpbnB1dFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZ29vZFRvR28gLSBJZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90LlxuICAgKi9cbiAgdmFsaWRhdGVJbnB1dCgkZWwpIHtcbiAgICB2YXIgY2xlYXJSZXF1aXJlID0gdGhpcy5yZXF1aXJlZENoZWNrKCRlbCksXG4gICAgICAgIHZhbGlkYXRlZCA9IGZhbHNlLFxuICAgICAgICBjdXN0b21WYWxpZGF0b3IgPSB0cnVlLFxuICAgICAgICB2YWxpZGF0b3IgPSAkZWwuYXR0cignZGF0YS12YWxpZGF0b3InKSxcbiAgICAgICAgZXF1YWxUbyA9IHRydWU7XG5cbiAgICAvLyBkb24ndCB2YWxpZGF0ZSBpZ25vcmVkIGlucHV0cyBvciBoaWRkZW4gaW5wdXRzXG4gICAgaWYgKCRlbC5pcygnW2RhdGEtYWJpZGUtaWdub3JlXScpIHx8ICRlbC5pcygnW3R5cGU9XCJoaWRkZW5cIl0nKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3dpdGNoICgkZWxbMF0udHlwZSkge1xuICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICB2YWxpZGF0ZWQgPSB0aGlzLnZhbGlkYXRlUmFkaW8oJGVsLmF0dHIoJ25hbWUnKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgIHZhbGlkYXRlZCA9IGNsZWFyUmVxdWlyZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICdzZWxlY3Qtb25lJzpcbiAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XG4gICAgICAgIHZhbGlkYXRlZCA9IGNsZWFyUmVxdWlyZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhbGlkYXRlZCA9IHRoaXMudmFsaWRhdGVUZXh0KCRlbCk7XG4gICAgfVxuXG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgY3VzdG9tVmFsaWRhdG9yID0gdGhpcy5tYXRjaFZhbGlkYXRpb24oJGVsLCB2YWxpZGF0b3IsICRlbC5hdHRyKCdyZXF1aXJlZCcpKTtcbiAgICB9XG5cbiAgICBpZiAoJGVsLmF0dHIoJ2RhdGEtZXF1YWx0bycpKSB7XG4gICAgICBlcXVhbFRvID0gdGhpcy5vcHRpb25zLnZhbGlkYXRvcnMuZXF1YWxUbygkZWwpO1xuICAgIH1cblxuXG4gICAgdmFyIGdvb2RUb0dvID0gW2NsZWFyUmVxdWlyZSwgdmFsaWRhdGVkLCBjdXN0b21WYWxpZGF0b3IsIGVxdWFsVG9dLmluZGV4T2YoZmFsc2UpID09PSAtMTtcbiAgICB2YXIgbWVzc2FnZSA9IChnb29kVG9HbyA/ICd2YWxpZCcgOiAnaW52YWxpZCcpICsgJy56Zi5hYmlkZSc7XG5cbiAgICB0aGlzW2dvb2RUb0dvID8gJ3JlbW92ZUVycm9yQ2xhc3NlcycgOiAnYWRkRXJyb3JDbGFzc2VzJ10oJGVsKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGlucHV0IGlzIGRvbmUgY2hlY2tpbmcgZm9yIHZhbGlkYXRpb24uIEV2ZW50IHRyaWdnZXIgaXMgZWl0aGVyIGB2YWxpZC56Zi5hYmlkZWAgb3IgYGludmFsaWQuemYuYWJpZGVgXG4gICAgICogVHJpZ2dlciBpbmNsdWRlcyB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIGlucHV0LlxuICAgICAqIEBldmVudCBBYmlkZSN2YWxpZFxuICAgICAqIEBldmVudCBBYmlkZSNpbnZhbGlkXG4gICAgICovXG4gICAgJGVsLnRyaWdnZXIobWVzc2FnZSwgWyRlbF0pO1xuXG4gICAgcmV0dXJuIGdvb2RUb0dvO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvZXMgdGhyb3VnaCBhIGZvcm0gYW5kIGlmIHRoZXJlIGFyZSBhbnkgaW52YWxpZCBpbnB1dHMsIGl0IHdpbGwgZGlzcGxheSB0aGUgZm9ybSBlcnJvciBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBub0Vycm9yIC0gdHJ1ZSBpZiBubyBlcnJvcnMgd2VyZSBkZXRlY3RlZC4uLlxuICAgKiBAZmlyZXMgQWJpZGUjZm9ybXZhbGlkXG4gICAqIEBmaXJlcyBBYmlkZSNmb3JtaW52YWxpZFxuICAgKi9cbiAgdmFsaWRhdGVGb3JtKCkge1xuICAgIHZhciBhY2MgPSBbXTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy4kaW5wdXRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBhY2MucHVzaChfdGhpcy52YWxpZGF0ZUlucHV0KCQodGhpcykpKTtcbiAgICB9KTtcblxuICAgIHZhciBub0Vycm9yID0gYWNjLmluZGV4T2YoZmFsc2UpID09PSAtMTtcblxuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJykuY3NzKCdkaXNwbGF5JywgKG5vRXJyb3IgPyAnbm9uZScgOiAnYmxvY2snKSk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBmb3JtIGlzIGZpbmlzaGVkIHZhbGlkYXRpbmcuIEV2ZW50IHRyaWdnZXIgaXMgZWl0aGVyIGBmb3JtdmFsaWQuemYuYWJpZGVgIG9yIGBmb3JtaW52YWxpZC56Zi5hYmlkZWAuXG4gICAgICogVHJpZ2dlciBpbmNsdWRlcyB0aGUgZWxlbWVudCBvZiB0aGUgZm9ybS5cbiAgICAgKiBAZXZlbnQgQWJpZGUjZm9ybXZhbGlkXG4gICAgICogQGV2ZW50IEFiaWRlI2Zvcm1pbnZhbGlkXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKChub0Vycm9yID8gJ2Zvcm12YWxpZCcgOiAnZm9ybWludmFsaWQnKSArICcuemYuYWJpZGUnLCBbdGhpcy4kZWxlbWVudF0pO1xuXG4gICAgcmV0dXJuIG5vRXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIGEgbm90IGEgdGV4dCBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB0aGUgcGF0dGVybiBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZS4gSWYgbm8gbWF0Y2hpbmcgcGF0dGVybiBpcyBmb3VuZCwgcmV0dXJucyB0cnVlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byB2YWxpZGF0ZSwgc2hvdWxkIGJlIGEgdGV4dCBpbnB1dCBIVE1MIGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gLSBzdHJpbmcgdmFsdWUgb2Ygb25lIG9mIHRoZSBSZWdFeCBwYXR0ZXJucyBpbiBBYmlkZS5vcHRpb25zLnBhdHRlcm5zXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgdGhlIGlucHV0IHZhbHVlIG1hdGNoZXMgdGhlIHBhdHRlcm4gc3BlY2lmaWVkXG4gICAqL1xuICB2YWxpZGF0ZVRleHQoJGVsLCBwYXR0ZXJuKSB7XG4gICAgLy8gQSBwYXR0ZXJuIGNhbiBiZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBiZSBpbmZlcmVkIGZyb20gdGhlIGlucHV0J3MgXCJwYXR0ZXJuXCIgYXR0cmlidXRlLCBvciBpdCdzIFwidHlwZVwiIGF0dHJpYnV0ZVxuICAgIHBhdHRlcm4gPSAocGF0dGVybiB8fCAkZWwuYXR0cigncGF0dGVybicpIHx8ICRlbC5hdHRyKCd0eXBlJykpO1xuICAgIHZhciBpbnB1dFRleHQgPSAkZWwudmFsKCk7XG4gICAgdmFyIHZhbGlkID0gZmFsc2U7XG5cbiAgICBpZiAoaW5wdXRUZXh0Lmxlbmd0aCkge1xuICAgICAgLy8gSWYgdGhlIHBhdHRlcm4gYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50IGlzIGluIEFiaWRlJ3MgbGlzdCBvZiBwYXR0ZXJucywgdGhlbiB0ZXN0IHRoYXQgcmVnZXhwXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhdHRlcm5zLmhhc093blByb3BlcnR5KHBhdHRlcm4pKSB7XG4gICAgICAgIHZhbGlkID0gdGhpcy5vcHRpb25zLnBhdHRlcm5zW3BhdHRlcm5dLnRlc3QoaW5wdXRUZXh0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBwYXR0ZXJuIG5hbWUgaXNuJ3QgYWxzbyB0aGUgdHlwZSBhdHRyaWJ1dGUgb2YgdGhlIGZpZWxkLCB0aGVuIHRlc3QgaXQgYXMgYSByZWdleHBcbiAgICAgIGVsc2UgaWYgKHBhdHRlcm4gIT09ICRlbC5hdHRyKCd0eXBlJykpIHtcbiAgICAgICAgdmFsaWQgPSBuZXcgUmVnRXhwKHBhdHRlcm4pLnRlc3QoaW5wdXRUZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFuIGVtcHR5IGZpZWxkIGlzIHZhbGlkIGlmIGl0J3Mgbm90IHJlcXVpcmVkXG4gICAgZWxzZSBpZiAoISRlbC5wcm9wKCdyZXF1aXJlZCcpKSB7XG4gICAgICB2YWxpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkO1xuICAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3IgYSBub3QgYSByYWRpbyBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBpdCBpcyByZXF1aXJlZCBhbmQgc2VsZWN0ZWQuIEFsdGhvdWdoIHRoZSBmdW5jdGlvbiB0YXJnZXRzIGEgc2luZ2xlIGA8aW5wdXQ+YCwgaXQgdmFsaWRhdGVzIGJ5IGNoZWNraW5nIHRoZSBgcmVxdWlyZWRgIGFuZCBgY2hlY2tlZGAgcHJvcGVydGllcyBvZiBhbGwgcmFkaW8gYnV0dG9ucyBpbiBpdHMgZ3JvdXAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgLSBBIHN0cmluZyB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZSBvZiBhIHJhZGlvIGJ1dHRvbiBncm91cFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0IGxlYXN0IG9uZSByYWRpbyBpbnB1dCBoYXMgYmVlbiBzZWxlY3RlZCAoaWYgaXQncyByZXF1aXJlZClcbiAgICovXG4gIHZhbGlkYXRlUmFkaW8oZ3JvdXBOYW1lKSB7XG4gICAgLy8gSWYgYXQgbGVhc3Qgb25lIHJhZGlvIGluIHRoZSBncm91cCBoYXMgdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlLCB0aGUgZ3JvdXAgaXMgY29uc2lkZXJlZCByZXF1aXJlZFxuICAgIC8vIFBlciBXM0Mgc3BlYywgYWxsIHJhZGlvIGJ1dHRvbnMgaW4gYSBncm91cCBzaG91bGQgaGF2ZSBgcmVxdWlyZWRgLCBidXQgd2UncmUgYmVpbmcgbmljZVxuICAgIHZhciAkZ3JvdXAgPSB0aGlzLiRlbGVtZW50LmZpbmQoYDpyYWRpb1tuYW1lPVwiJHtncm91cE5hbWV9XCJdYCk7XG4gICAgdmFyIHZhbGlkID0gZmFsc2UsIHJlcXVpcmVkID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgdGhlIGdyb3VwIHRvIGJlIHJlcXVpcmVkLCBhdCBsZWFzdCBvbmUgcmFkaW8gbmVlZHMgdG8gYmUgcmVxdWlyZWRcbiAgICAkZ3JvdXAuZWFjaCgoaSwgZSkgPT4ge1xuICAgICAgaWYgKCQoZSkuYXR0cigncmVxdWlyZWQnKSkge1xuICAgICAgICByZXF1aXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoIXJlcXVpcmVkKSB2YWxpZD10cnVlO1xuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgLy8gRm9yIHRoZSBncm91cCB0byBiZSB2YWxpZCwgYXQgbGVhc3Qgb25lIHJhZGlvIG5lZWRzIHRvIGJlIGNoZWNrZWRcbiAgICAgICRncm91cC5lYWNoKChpLCBlKSA9PiB7XG4gICAgICAgIGlmICgkKGUpLnByb3AoJ2NoZWNrZWQnKSkge1xuICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiB2YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGEgc2VsZWN0ZWQgaW5wdXQgcGFzc2VzIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uIE11bHRpcGxlIHZhbGlkYXRpb25zIGNhbiBiZSB1c2VkLCBpZiBwYXNzZWQgdG8gdGhlIGVsZW1lbnQgd2l0aCBgZGF0YS12YWxpZGF0b3I9XCJmb28gYmFyIGJhelwiYCBpbiBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbGlkYXRvcnMgLSBhIHN0cmluZyBvZiBmdW5jdGlvbiBuYW1lcyBtYXRjaGluZyBmdW5jdGlvbnMgaW4gdGhlIEFiaWRlLm9wdGlvbnMudmFsaWRhdG9ycyBvYmplY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVxdWlyZWQgLSBzZWxmIGV4cGxhbmF0b3J5P1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHZhbGlkYXRpb25zIHBhc3NlZC5cbiAgICovXG4gIG1hdGNoVmFsaWRhdGlvbigkZWwsIHZhbGlkYXRvcnMsIHJlcXVpcmVkKSB7XG4gICAgcmVxdWlyZWQgPSByZXF1aXJlZCA/IHRydWUgOiBmYWxzZTtcblxuICAgIHZhciBjbGVhciA9IHZhbGlkYXRvcnMuc3BsaXQoJyAnKS5tYXAoKHYpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsaWRhdG9yc1t2XSgkZWwsIHJlcXVpcmVkLCAkZWwucGFyZW50KCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjbGVhci5pbmRleE9mKGZhbHNlKSA9PT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIGZvcm0gaW5wdXRzIGFuZCBzdHlsZXNcbiAgICogQGZpcmVzIEFiaWRlI2Zvcm1yZXNldFxuICAgKi9cbiAgcmVzZXRGb3JtKCkge1xuICAgIHZhciAkZm9ybSA9IHRoaXMuJGVsZW1lbnQsXG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAkKGAuJHtvcHRzLmxhYmVsRXJyb3JDbGFzc31gLCAkZm9ybSkubm90KCdzbWFsbCcpLnJlbW92ZUNsYXNzKG9wdHMubGFiZWxFcnJvckNsYXNzKTtcbiAgICAkKGAuJHtvcHRzLmlucHV0RXJyb3JDbGFzc31gLCAkZm9ybSkubm90KCdzbWFsbCcpLnJlbW92ZUNsYXNzKG9wdHMuaW5wdXRFcnJvckNsYXNzKTtcbiAgICAkKGAke29wdHMuZm9ybUVycm9yU2VsZWN0b3J9LiR7b3B0cy5mb3JtRXJyb3JDbGFzc31gKS5yZW1vdmVDbGFzcyhvcHRzLmZvcm1FcnJvckNsYXNzKTtcbiAgICAkZm9ybS5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICQoJzppbnB1dCcsICRmb3JtKS5ub3QoJzpidXR0b24sIDpzdWJtaXQsIDpyZXNldCwgOmhpZGRlbiwgOnJhZGlvLCA6Y2hlY2tib3gsIFtkYXRhLWFiaWRlLWlnbm9yZV0nKS52YWwoJycpLnJlbW92ZUF0dHIoJ2RhdGEtaW52YWxpZCcpO1xuICAgICQoJzppbnB1dDpyYWRpbycsICRmb3JtKS5ub3QoJ1tkYXRhLWFiaWRlLWlnbm9yZV0nKS5wcm9wKCdjaGVja2VkJyxmYWxzZSkucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7XG4gICAgJCgnOmlucHV0OmNoZWNrYm94JywgJGZvcm0pLm5vdCgnW2RhdGEtYWJpZGUtaWdub3JlXScpLnByb3AoJ2NoZWNrZWQnLGZhbHNlKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBmb3JtIGhhcyBiZWVuIHJlc2V0LlxuICAgICAqIEBldmVudCBBYmlkZSNmb3JtcmVzZXRcbiAgICAgKi9cbiAgICAkZm9ybS50cmlnZ2VyKCdmb3JtcmVzZXQuemYuYWJpZGUnLCBbJGZvcm1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBBYmlkZS5cbiAgICogUmVtb3ZlcyBlcnJvciBzdHlsZXMgYW5kIGNsYXNzZXMgZnJvbSBlbGVtZW50cywgd2l0aG91dCByZXNldHRpbmcgdGhlaXIgdmFsdWVzLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vZmYoJy5hYmlkZScpXG4gICAgICAuZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJylcbiAgICAgICAgLmNzcygnZGlzcGxheScsICdub25lJyk7XG5cbiAgICB0aGlzLiRpbnB1dHNcbiAgICAgIC5vZmYoJy5hYmlkZScpXG4gICAgICAuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlRXJyb3JDbGFzc2VzKCQodGhpcykpO1xuICAgICAgfSk7XG5cbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cbiAqL1xuQWJpZGUuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBldmVudCB0byB2YWxpZGF0ZSBpbnB1dHMuIENoZWNrYm94ZXMgYW5kIHJhZGlvcyB2YWxpZGF0ZSBpbW1lZGlhdGVseS5cbiAgICogUmVtb3ZlIG9yIGNoYW5nZSB0aGlzIHZhbHVlIGZvciBtYW51YWwgdmFsaWRhdGlvbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnZmllbGRDaGFuZ2UnXG4gICAqL1xuICB2YWxpZGF0ZU9uOiAnZmllbGRDaGFuZ2UnLFxuXG4gIC8qKlxuICAgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIGlucHV0IGxhYmVscyBvbiBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnaXMtaW52YWxpZC1sYWJlbCdcbiAgICovXG4gIGxhYmVsRXJyb3JDbGFzczogJ2lzLWludmFsaWQtbGFiZWwnLFxuXG4gIC8qKlxuICAgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIGlucHV0cyBvbiBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnaXMtaW52YWxpZC1pbnB1dCdcbiAgICovXG4gIGlucHV0RXJyb3JDbGFzczogJ2lzLWludmFsaWQtaW5wdXQnLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBzZWxlY3RvciB0byB1c2UgdG8gdGFyZ2V0IEZvcm0gRXJyb3JzIGZvciBzaG93L2hpZGUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJy5mb3JtLWVycm9yJ1xuICAgKi9cbiAgZm9ybUVycm9yU2VsZWN0b3I6ICcuZm9ybS1lcnJvcicsXG5cbiAgLyoqXG4gICAqIENsYXNzIGFkZGVkIHRvIEZvcm0gRXJyb3JzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdpcy12aXNpYmxlJ1xuICAgKi9cbiAgZm9ybUVycm9yQ2xhc3M6ICdpcy12aXNpYmxlJyxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgdG8gdmFsaWRhdGUgdGV4dCBpbnB1dHMgb24gYW55IHZhbHVlIGNoYW5nZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgbGl2ZVZhbGlkYXRlOiBmYWxzZSxcblxuICBwYXR0ZXJuczoge1xuICAgIGFscGhhIDogL15bYS16QS1aXSskLyxcbiAgICBhbHBoYV9udW1lcmljIDogL15bYS16QS1aMC05XSskLyxcbiAgICBpbnRlZ2VyIDogL15bLStdP1xcZCskLyxcbiAgICBudW1iZXIgOiAvXlstK10/XFxkKig/OltcXC5cXCxdXFxkKyk/JC8sXG5cbiAgICAvLyBhbWV4LCB2aXNhLCBkaW5lcnNcbiAgICBjYXJkIDogL14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18Nig/OjAxMXw1WzAtOV1bMC05XSlbMC05XXsxMn18M1s0N11bMC05XXsxM318Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fCg/OjIxMzF8MTgwMHwzNVxcZHszfSlcXGR7MTF9KSQvLFxuICAgIGN2diA6IC9eKFswLTldKXszLDR9JC8sXG5cbiAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9zdGF0ZXMtb2YtdGhlLXR5cGUtYXR0cmlidXRlLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3NcbiAgICBlbWFpbCA6IC9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyQvLFxuXG4gICAgdXJsIDogL14oaHR0cHM/fGZ0cHxmaWxlfHNzaCk6XFwvXFwvKCgoKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDopKkApPygoKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKSl8KCgoW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpBLVpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpBLVpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16QS1aXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16QS1aXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuPykoOlxcZCopPykoXFwvKCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSsoXFwvKChbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKikqKT8pPyhcXD8oKChbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFtcXHVFMDAwLVxcdUY4RkZdfFxcL3xcXD8pKik/KFxcIygoKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8XFwvfFxcPykqKT8kLyxcbiAgICAvLyBhYmMuZGVcbiAgICBkb21haW4gOiAvXihbYS16QS1aMC05XShbYS16QS1aMC05XFwtXXswLDYxfVthLXpBLVowLTldKT9cXC4pK1thLXpBLVpdezIsOH0kLyxcblxuICAgIGRhdGV0aW1lIDogL14oWzAtMl1bMC05XXszfSlcXC0oWzAtMV1bMC05XSlcXC0oWzAtM11bMC05XSlUKFswLTVdWzAtOV0pXFw6KFswLTVdWzAtOV0pXFw6KFswLTVdWzAtOV0pKFp8KFtcXC1cXCtdKFswLTFdWzAtOV0pXFw6MDApKSQvLFxuICAgIC8vIFlZWVktTU0tRERcbiAgICBkYXRlIDogLyg/OjE5fDIwKVswLTldezJ9LSg/Oig/OjBbMS05XXwxWzAtMl0pLSg/OjBbMS05XXwxWzAtOV18MlswLTldKXwoPzooPyEwMikoPzowWzEtOV18MVswLTJdKS0oPzozMCkpfCg/Oig/OjBbMTM1NzhdfDFbMDJdKS0zMSkpJC8sXG4gICAgLy8gSEg6TU06U1NcbiAgICB0aW1lIDogL14oMFswLTldfDFbMC05XXwyWzAtM10pKDpbMC01XVswLTldKXsyfSQvLFxuICAgIGRhdGVJU08gOiAvXlxcZHs0fVtcXC9cXC1dXFxkezEsMn1bXFwvXFwtXVxcZHsxLDJ9JC8sXG4gICAgLy8gTU0vREQvWVlZWVxuICAgIG1vbnRoX2RheV95ZWFyIDogL14oMFsxLTldfDFbMDEyXSlbLSBcXC8uXSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcLy5dXFxkezR9JC8sXG4gICAgLy8gREQvTU0vWVlZWVxuICAgIGRheV9tb250aF95ZWFyIDogL14oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlbLSBcXC8uXSgwWzEtOV18MVswMTJdKVstIFxcLy5dXFxkezR9JC8sXG5cbiAgICAvLyAjRkZGIG9yICNGRkZGRkZcbiAgICBjb2xvciA6IC9eIz8oW2EtZkEtRjAtOV17Nn18W2EtZkEtRjAtOV17M30pJC9cbiAgfSxcblxuICAvKipcbiAgICogT3B0aW9uYWwgdmFsaWRhdGlvbiBmdW5jdGlvbnMgdG8gYmUgdXNlZC4gYGVxdWFsVG9gIGJlaW5nIHRoZSBvbmx5IGRlZmF1bHQgaW5jbHVkZWQgZnVuY3Rpb24uXG4gICAqIEZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIG9ubHkgYSBib29sZWFuIGlmIHRoZSBpbnB1dCBpcyB2YWxpZCBvciBub3QuIEZ1bmN0aW9ucyBhcmUgZ2l2ZW4gdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gICAqIGVsIDogVGhlIGpRdWVyeSBlbGVtZW50IHRvIHZhbGlkYXRlLlxuICAgKiByZXF1aXJlZCA6IEJvb2xlYW4gdmFsdWUgb2YgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBiZSBwcmVzZW50IG9yIG5vdC5cbiAgICogcGFyZW50IDogVGhlIGRpcmVjdCBwYXJlbnQgb2YgdGhlIGlucHV0LlxuICAgKiBAb3B0aW9uXG4gICAqL1xuICB2YWxpZGF0b3JzOiB7XG4gICAgZXF1YWxUbzogZnVuY3Rpb24gKGVsLCByZXF1aXJlZCwgcGFyZW50KSB7XG4gICAgICByZXR1cm4gJChgIyR7ZWwuYXR0cignZGF0YS1lcXVhbHRvJyl9YCkudmFsKCkgPT09IGVsLnZhbCgpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oQWJpZGUsICdBYmlkZScpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogQWNjb3JkaW9uIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5hY2NvcmRpb25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gKi9cblxuY2xhc3MgQWNjb3JkaW9uIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIEFjY29yZGlvbiNpbml0XG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGEgcGxhaW4gb2JqZWN0IHdpdGggc2V0dGluZ3MgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWNjb3JkaW9uLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdBY2NvcmRpb24nKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdBY2NvcmRpb24nLCB7XG4gICAgICAnRU5URVInOiAndG9nZ2xlJyxcbiAgICAgICdTUEFDRSc6ICd0b2dnbGUnLFxuICAgICAgJ0FSUk9XX0RPV04nOiAnbmV4dCcsXG4gICAgICAnQVJST1dfVVAnOiAncHJldmlvdXMnXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGFjY29yZGlvbiBieSBhbmltYXRpbmcgdGhlIHByZXNldCBhY3RpdmUgcGFuZShzKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHRoaXMuJGVsZW1lbnQuYXR0cigncm9sZScsICd0YWJsaXN0Jyk7XG4gICAgdGhpcy4kdGFicyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJ2xpLCBbZGF0YS1hY2NvcmRpb24taXRlbV0nKTtcblxuICAgIHRoaXMuJHRhYnMuZWFjaChmdW5jdGlvbihpZHgsIGVsKSB7XG4gICAgICB2YXIgJGVsID0gJChlbCksXG4gICAgICAgICAgJGNvbnRlbnQgPSAkZWwuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpLFxuICAgICAgICAgIGlkID0gJGNvbnRlbnRbMF0uaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnYWNjb3JkaW9uJyksXG4gICAgICAgICAgbGlua0lkID0gZWwuaWQgfHwgYCR7aWR9LWxhYmVsYDtcblxuICAgICAgJGVsLmZpbmQoJ2E6Zmlyc3QnKS5hdHRyKHtcbiAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBpZCxcbiAgICAgICAgJ3JvbGUnOiAndGFiJyxcbiAgICAgICAgJ2lkJzogbGlua0lkLFxuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlLFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgJGNvbnRlbnQuYXR0cih7J3JvbGUnOiAndGFicGFuZWwnLCAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkLCAnYXJpYS1oaWRkZW4nOiB0cnVlLCAnaWQnOiBpZH0pO1xuICAgIH0pO1xuICAgIHZhciAkaW5pdEFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjdGl2ZScpLmNoaWxkcmVuKCdbZGF0YS10YWItY29udGVudF0nKTtcbiAgICBpZigkaW5pdEFjdGl2ZS5sZW5ndGgpe1xuICAgICAgdGhpcy5kb3duKCRpbml0QWN0aXZlLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRzKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSBhY2NvcmRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpO1xuICAgICAgdmFyICR0YWJDb250ZW50ID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuICAgICAgaWYgKCR0YWJDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAkZWxlbS5jaGlsZHJlbignYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uIGtleWRvd24uemYuYWNjb3JkaW9uJylcbiAgICAgICAgICAgICAgIC5vbignY2xpY2suemYuYWNjb3JkaW9uJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyAkKHRoaXMpLmNoaWxkcmVuKCdhJykub24oJ2NsaWNrLnpmLmFjY29yZGlvbicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKCRlbGVtLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xuICAgICAgICAgICAgaWYoX3RoaXMub3B0aW9ucy5hbGxvd0FsbENsb3NlZCB8fCAkZWxlbS5zaWJsaW5ncygpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSl7XG4gICAgICAgICAgICAgIF90aGlzLnVwKCR0YWJDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5kb3duKCR0YWJDb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKCdrZXlkb3duLnpmLmFjY29yZGlvbicsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdBY2NvcmRpb24nLCB7XG4gICAgICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJHRhYkNvbnRlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgJGEgPSAkZWxlbS5uZXh0KCkuZmluZCgnYScpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCkge1xuICAgICAgICAgICAgICAgICRhLnRyaWdnZXIoJ2NsaWNrLnpmLmFjY29yZGlvbicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciAkYSA9ICRlbGVtLnByZXYoKS5maW5kKCdhJykuZm9jdXMoKTtcbiAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kKSB7XG4gICAgICAgICAgICAgICAgJGEudHJpZ2dlcignY2xpY2suemYuYWNjb3JkaW9uJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHNlbGVjdGVkIGNvbnRlbnQgcGFuZSdzIG9wZW4vY2xvc2Ugc3RhdGUuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0galF1ZXJ5IG9iamVjdCBvZiB0aGUgcGFuZSB0byB0b2dnbGUuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgdG9nZ2xlKCR0YXJnZXQpIHtcbiAgICBpZigkdGFyZ2V0LnBhcmVudCgpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xuICAgICAgaWYodGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkIHx8ICR0YXJnZXQucGFyZW50KCkuc2libGluZ3MoKS5oYXNDbGFzcygnaXMtYWN0aXZlJykpe1xuICAgICAgICB0aGlzLnVwKCR0YXJnZXQpO1xuICAgICAgfSBlbHNlIHsgcmV0dXJuOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG93bigkdGFyZ2V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGFjY29yZGlvbiB0YWIgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHBhbmUgdG8gb3Blbi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBmaXJzdFRpbWUgLSBmbGFnIHRvIGRldGVybWluZSBpZiByZWZsb3cgc2hvdWxkIGhhcHBlbi5cbiAgICogQGZpcmVzIEFjY29yZGlvbiNkb3duXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgZG93bigkdGFyZ2V0LCBmaXJzdFRpbWUpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCAmJiAhZmlyc3RUaW1lKSB7XG4gICAgICB2YXIgJGN1cnJlbnRBY3RpdmUgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuICAgICAgaWYoJGN1cnJlbnRBY3RpdmUubGVuZ3RoKXtcbiAgICAgICAgdGhpcy51cCgkY3VycmVudEFjdGl2ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJHRhcmdldFxuICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpXG4gICAgICAucGFyZW50KCdbZGF0YS10YWItY29udGVudF0nKVxuICAgICAgLmFkZEJhY2soKVxuICAgICAgLnBhcmVudCgpLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAgICR0YXJnZXQuc2xpZGVEb3duKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCAoKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHRhYiBpcyBkb25lIG9wZW5pbmcuXG4gICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uI2Rvd25cbiAgICAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdkb3duLnpmLmFjY29yZGlvbicsIFskdGFyZ2V0XSk7XG4gICAgfSk7XG5cbiAgICAkKGAjJHskdGFyZ2V0LmF0dHIoJ2FyaWEtbGFiZWxsZWRieScpfWApLmF0dHIoe1xuICAgICAgJ2FyaWEtZXhwYW5kZWQnOiB0cnVlLFxuICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSB0YWIgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHRhYiB0byBjbG9zZS5cbiAgICogQGZpcmVzIEFjY29yZGlvbiN1cFxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIHVwKCR0YXJnZXQpIHtcbiAgICB2YXIgJGF1bnRzID0gJHRhcmdldC5wYXJlbnQoKS5zaWJsaW5ncygpLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGNhbkNsb3NlID0gdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kID8gJGF1bnRzLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSA6ICR0YXJnZXQucGFyZW50KCkuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXG4gICAgaWYoIXRoaXMub3B0aW9ucy5hbGxvd0FsbENsb3NlZCAmJiAhY2FuQ2xvc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGb3VuZGF0aW9uLk1vdmUodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsICR0YXJnZXQsIGZ1bmN0aW9uKCl7XG4gICAgICAkdGFyZ2V0LnNsaWRlVXAoX3RoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB0YWIgaXMgZG9uZSBjb2xsYXBzaW5nIHVwLlxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uI3VwXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cC56Zi5hY2NvcmRpb24nLCBbJHRhcmdldF0pO1xuICAgICAgfSk7XG4gICAgLy8gfSk7XG5cbiAgICAkdGFyZ2V0LmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSlcbiAgICAgICAgICAgLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAgICQoYCMkeyR0YXJnZXQuYXR0cignYXJpYS1sYWJlbGxlZGJ5Jyl9YCkuYXR0cih7XG4gICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICdhcmlhLXNlbGVjdGVkJzogZmFsc2VcbiAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFuIGFjY29yZGlvbi5cbiAgICogQGZpcmVzIEFjY29yZGlvbiNkZXN0cm95ZWRcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtdGFiLWNvbnRlbnRdJykuc3RvcCh0cnVlKS5zbGlkZVVwKDApLmNzcygnZGlzcGxheScsICcnKTtcbiAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2EnKS5vZmYoJy56Zi5hY2NvcmRpb24nKTtcblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5BY2NvcmRpb24uZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0byBhbmltYXRlIHRoZSBvcGVuaW5nIG9mIGFuIGFjY29yZGlvbiBwYW5lLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDI1MFxuICAgKi9cbiAgc2xpZGVTcGVlZDogMjUwLFxuICAvKipcbiAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBoYXZlIG11bHRpcGxlIG9wZW4gcGFuZXMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIG11bHRpRXhwYW5kOiBmYWxzZSxcbiAgLyoqXG4gICAqIEFsbG93IHRoZSBhY2NvcmRpb24gdG8gY2xvc2UgYWxsIHBhbmVzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBhbGxvd0FsbENsb3NlZDogZmFsc2Vcbn07XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihBY2NvcmRpb24sICdBY2NvcmRpb24nKTtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIEFjY29yZGlvbk1lbnUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmFjY29yZGlvbk1lbnVcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcbiAqL1xuXG5jbGFzcyBBY2NvcmRpb25NZW51IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAqIEBjbGFzc1xuICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSNpbml0XG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWNjb3JkaW9uTWVudS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCwgJ2FjY29yZGlvbicpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnQWNjb3JkaW9uTWVudScpO1xuICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ0FjY29yZGlvbk1lbnUnLCB7XG4gICAgICAnRU5URVInOiAndG9nZ2xlJyxcbiAgICAgICdTUEFDRSc6ICd0b2dnbGUnLFxuICAgICAgJ0FSUk9XX1JJR0hUJzogJ29wZW4nLFxuICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcbiAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxuICAgICAgJ0FSUk9XX0xFRlQnOiAnY2xvc2UnLFxuICAgICAgJ0VTQ0FQRSc6ICdjbG9zZUFsbCcsXG4gICAgICAnVEFCJzogJ2Rvd24nLFxuICAgICAgJ1NISUZUX1RBQic6ICd1cCdcbiAgICB9KTtcbiAgfVxuXG5cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGFjY29yZGlvbiBtZW51IGJ5IGhpZGluZyBhbGwgbmVzdGVkIG1lbnVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpLm5vdCgnLmlzLWFjdGl2ZScpLnNsaWRlVXAoMCk7Ly8uZmluZCgnYScpLmNzcygncGFkZGluZy1sZWZ0JywgJzFyZW0nKTtcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgJ3JvbGUnOiAndGFibGlzdCcsXG4gICAgICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiB0aGlzLm9wdGlvbnMubXVsdGlPcGVuXG4gICAgfSk7XG5cbiAgICB0aGlzLiRtZW51TGlua3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKTtcbiAgICB0aGlzLiRtZW51TGlua3MuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyIGxpbmtJZCA9IHRoaXMuaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnYWNjLW1lbnUtbGluaycpLFxuICAgICAgICAgICRlbGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAkc3ViID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyksXG4gICAgICAgICAgc3ViSWQgPSAkc3ViWzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ2FjYy1tZW51JyksXG4gICAgICAgICAgaXNBY3RpdmUgPSAkc3ViLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAgICRlbGVtLmF0dHIoe1xuICAgICAgICAnYXJpYS1jb250cm9scyc6IHN1YklkLFxuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGlzQWN0aXZlLFxuICAgICAgICAncm9sZSc6ICd0YWInLFxuICAgICAgICAnaWQnOiBsaW5rSWRcbiAgICAgIH0pO1xuICAgICAgJHN1Yi5hdHRyKHtcbiAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGxpbmtJZCxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogIWlzQWN0aXZlLFxuICAgICAgICAncm9sZSc6ICd0YWJwYW5lbCcsXG4gICAgICAgICdpZCc6IHN1YklkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgaW5pdFBhbmVzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJyk7XG4gICAgaWYoaW5pdFBhbmVzLmxlbmd0aCl7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaW5pdFBhbmVzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgX3RoaXMuZG93bigkKHRoaXMpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIG1lbnUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkc3VibWVudSA9ICQodGhpcykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7XG5cbiAgICAgIGlmICgkc3VibWVudS5sZW5ndGgpIHtcbiAgICAgICAgJCh0aGlzKS5jaGlsZHJlbignYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uTWVudScpLm9uKCdjbGljay56Zi5hY2NvcmRpb25NZW51JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIF90aGlzLnRvZ2dsZSgkc3VibWVudSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLm9uKCdrZXlkb3duLnpmLmFjY29yZGlvbm1lbnUnLCBmdW5jdGlvbihlKXtcbiAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyksXG4gICAgICAgICAgJGVsZW1lbnRzID0gJGVsZW1lbnQucGFyZW50KCd1bCcpLmNoaWxkcmVuKCdsaScpLFxuICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAkbmV4dEVsZW1lbnQsXG4gICAgICAgICAgJHRhcmdldCA9ICRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpO1xuXG4gICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpLTEpKS5maW5kKCdhJykuZmlyc3QoKTtcbiAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSsxLCAkZWxlbWVudHMubGVuZ3RoLTEpKS5maW5kKCdhJykuZmlyc3QoKTtcblxuICAgICAgICAgIGlmICgkKHRoaXMpLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XTp2aXNpYmxlJykubGVuZ3RoKSB7IC8vIGhhcyBvcGVuIHN1YiBtZW51XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5maW5kKCdsaTpmaXJzdC1jaGlsZCcpLmZpbmQoJ2EnKS5maXJzdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnOmZpcnN0LWNoaWxkJykpIHsgLy8gaXMgZmlyc3QgZWxlbWVudCBvZiBzdWIgbWVudVxuICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJHByZXZFbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XTp2aXNpYmxlJykubGVuZ3RoKSB7IC8vIGlmIHByZXZpb3VzIGVsZW1lbnQgaGFzIG9wZW4gc3ViIG1lbnVcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRwcmV2RWxlbWVudC5maW5kKCdsaTpsYXN0LWNoaWxkJykuZmluZCgnYScpLmZpcnN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCc6bGFzdC1jaGlsZCcpKSB7IC8vIGlzIGxhc3QgZWxlbWVudCBvZiBzdWIgbWVudVxuICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLm5leHQoJ2xpJykuZmluZCgnYScpLmZpcnN0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdBY2NvcmRpb25NZW51Jywge1xuICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoJHRhcmdldC5pcygnOmhpZGRlbicpKSB7XG4gICAgICAgICAgICBfdGhpcy5kb3duKCR0YXJnZXQpO1xuICAgICAgICAgICAgJHRhcmdldC5maW5kKCdsaScpLmZpcnN0KCkuZmluZCgnYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoJHRhcmdldC5sZW5ndGggJiYgISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkgeyAvLyBjbG9zZSBhY3RpdmUgc3ViIG9mIHRoaXMgaXRlbVxuICAgICAgICAgICAgX3RoaXMudXAoJHRhcmdldCk7XG4gICAgICAgICAgfSBlbHNlIGlmICgkZWxlbWVudC5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKSB7IC8vIGNsb3NlIGN1cnJlbnRseSBvcGVuIHN1YlxuICAgICAgICAgICAgX3RoaXMudXAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpKTtcbiAgICAgICAgICAgICRlbGVtZW50LnBhcmVudHMoJ2xpJykuZmlyc3QoKS5maW5kKCdhJykuZmlyc3QoKS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRwcmV2RWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKS5mb2N1cygpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkbmV4dEVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAtMSkuZm9jdXMoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpcy50b2dnbGUoJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2VBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLmhpZGVBbGwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24ocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7Ly8uYXR0cigndGFiaW5kZXgnLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgYWxsIHBhbmVzIG9mIHRoZSBtZW51LlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGhpZGVBbGwoKSB7XG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpLnNsaWRlVXAodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2Ugc3RhdGUgb2YgYSBzdWJtZW51LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSB0aGUgc3VibWVudSB0byB0b2dnbGVcbiAgICovXG4gIHRvZ2dsZSgkdGFyZ2V0KXtcbiAgICBpZighJHRhcmdldC5pcygnOmFuaW1hdGVkJykpIHtcbiAgICAgIGlmICghJHRhcmdldC5pcygnOmhpZGRlbicpKSB7XG4gICAgICAgIHRoaXMudXAoJHRhcmdldCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5kb3duKCR0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gU3ViLW1lbnUgdG8gb3Blbi5cbiAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjZG93blxuICAgKi9cbiAgZG93bigkdGFyZ2V0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmKCF0aGlzLm9wdGlvbnMubXVsdGlPcGVuKSB7XG4gICAgICB0aGlzLnVwKHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjdGl2ZScpLm5vdCgkdGFyZ2V0LnBhcmVudHNVbnRpbCh0aGlzLiRlbGVtZW50KS5hZGQoJHRhcmdldCkpKTtcbiAgICB9XG5cbiAgICAkdGFyZ2V0LmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKHsnYXJpYS1oaWRkZW4nOiBmYWxzZX0pXG4gICAgICAucGFyZW50KCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50JykuYXR0cih7J2FyaWEtZXhwYW5kZWQnOiB0cnVlfSk7XG5cbiAgICAgIC8vRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCAkdGFyZ2V0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgJHRhcmdldC5zbGlkZURvd24oX3RoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBkb25lIG9wZW5pbmcuXG4gICAgICAgICAgICogQGV2ZW50IEFjY29yZGlvbk1lbnUjZG93blxuICAgICAgICAgICAqL1xuICAgICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Rvd24uemYuYWNjb3JkaW9uTWVudScsIFskdGFyZ2V0XSk7XG4gICAgICAgIH0pO1xuICAgICAgLy99KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHN1Yi1tZW51IGRlZmluZWQgYnkgYCR0YXJnZXRgLiBBbGwgc3ViLW1lbnVzIGluc2lkZSB0aGUgdGFyZ2V0IHdpbGwgYmUgY2xvc2VkIGFzIHdlbGwuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gU3ViLW1lbnUgdG8gY2xvc2UuXG4gICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I3VwXG4gICAqL1xuICB1cCgkdGFyZ2V0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvL0ZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgJHRhcmdldCwgZnVuY3Rpb24oKXtcbiAgICAgICR0YXJnZXQuc2xpZGVVcChfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZG9uZSBjb2xsYXBzaW5nIHVwLlxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSN1cFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcigndXAuemYuYWNjb3JkaW9uTWVudScsIFskdGFyZ2V0XSk7XG4gICAgICB9KTtcbiAgICAvL30pO1xuXG4gICAgdmFyICRtZW51cyA9ICR0YXJnZXQuZmluZCgnW2RhdGEtc3VibWVudV0nKS5zbGlkZVVwKDApLmFkZEJhY2soKS5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgJG1lbnVzLnBhcmVudCgnLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudCcpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYWNjb3JkaW9uIG1lbnUuXG4gICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2Rlc3Ryb3llZFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykuc2xpZGVEb3duKDApLmNzcygnZGlzcGxheScsICcnKTtcbiAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2EnKS5vZmYoJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnKTtcblxuICAgIEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsICdhY2NvcmRpb24nKTtcbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cbn1cblxuQWNjb3JkaW9uTWVudS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYSBzdWJtZW51IGluIG1zLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDI1MFxuICAgKi9cbiAgc2xpZGVTcGVlZDogMjUwLFxuICAvKipcbiAgICogQWxsb3cgdGhlIG1lbnUgdG8gaGF2ZSBtdWx0aXBsZSBvcGVuIHBhbmVzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIG11bHRpT3BlbjogdHJ1ZVxufTtcblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKEFjY29yZGlvbk1lbnUsICdBY2NvcmRpb25NZW51Jyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBEcmlsbGRvd24gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyaWxsZG93blxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxuICovXG5cbmNsYXNzIERyaWxsZG93biB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgZHJpbGxkb3duIG1lbnUuXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbiBtZW51LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIERyaWxsZG93bi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCwgJ2RyaWxsZG93bicpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnRHJpbGxkb3duJyk7XG4gICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignRHJpbGxkb3duJywge1xuICAgICAgJ0VOVEVSJzogJ29wZW4nLFxuICAgICAgJ1NQQUNFJzogJ29wZW4nLFxuICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxuICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcbiAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxuICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnLFxuICAgICAgJ0VTQ0FQRSc6ICdjbG9zZScsXG4gICAgICAnVEFCJzogJ2Rvd24nLFxuICAgICAgJ1NISUZUX1RBQic6ICd1cCdcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZHJpbGxkb3duIGJ5IGNyZWF0aW5nIGpRdWVyeSBjb2xsZWN0aW9ucyBvZiBlbGVtZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdGhpcy4kc3VibWVudUFuY2hvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpLmNoaWxkcmVuKCdhJyk7XG4gICAgdGhpcy4kc3VibWVudXMgPSB0aGlzLiRzdWJtZW51QW5jaG9ycy5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7XG4gICAgdGhpcy4kbWVudUl0ZW1zID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaScpLm5vdCgnLmpzLWRyaWxsZG93bi1iYWNrJykuYXR0cigncm9sZScsICdtZW51aXRlbScpLmZpbmQoJ2EnKTtcblxuICAgIHRoaXMuX3ByZXBhcmVNZW51KCk7XG5cbiAgICB0aGlzLl9rZXlib2FyZEV2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHByZXBhcmVzIGRyaWxsZG93biBtZW51IGJ5IHNldHRpbmcgYXR0cmlidXRlcyB0byBsaW5rcyBhbmQgZWxlbWVudHNcbiAgICogc2V0cyBhIG1pbiBoZWlnaHQgdG8gcHJldmVudCBjb250ZW50IGp1bXBpbmdcbiAgICogd3JhcHMgdGhlIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgd3JhcHBlZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIF9wcmVwYXJlTWVudSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIGlmKCF0aGlzLm9wdGlvbnMuaG9sZE9wZW4pe1xuICAgIC8vICAgdGhpcy5fbWVudUxpbmtFdmVudHMoKTtcbiAgICAvLyB9XG4gICAgdGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyICRsaW5rID0gJCh0aGlzKTtcbiAgICAgIHZhciAkc3ViID0gJGxpbmsucGFyZW50KCk7XG4gICAgICBpZihfdGhpcy5vcHRpb25zLnBhcmVudExpbmspe1xuICAgICAgICAkbGluay5jbG9uZSgpLnByZXBlbmRUbygkc3ViLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpKS53cmFwKCc8bGkgY2xhc3M9XCJpcy1zdWJtZW51LXBhcmVudC1pdGVtIGlzLXN1Ym1lbnUtaXRlbSBpcy1kcmlsbGRvd24tc3VibWVudS1pdGVtXCIgcm9sZT1cIm1lbnUtaXRlbVwiPjwvbGk+Jyk7XG4gICAgICB9XG4gICAgICAkbGluay5kYXRhKCdzYXZlZEhyZWYnLCAkbGluay5hdHRyKCdocmVmJykpLnJlbW92ZUF0dHIoJ2hyZWYnKTtcbiAgICAgICRsaW5rLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpXG4gICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAgICd0YWJpbmRleCc6IDAsXG4gICAgICAgICAgICAncm9sZSc6ICdtZW51J1xuICAgICAgICAgIH0pO1xuICAgICAgX3RoaXMuX2V2ZW50cygkbGluayk7XG4gICAgfSk7XG4gICAgdGhpcy4kc3VibWVudXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyICRtZW51ID0gJCh0aGlzKSxcbiAgICAgICAgICAkYmFjayA9ICRtZW51LmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjaycpO1xuICAgICAgaWYoISRiYWNrLmxlbmd0aCl7XG4gICAgICAgICRtZW51LnByZXBlbmQoX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9iYWNrKCRtZW51KTtcbiAgICB9KTtcbiAgICBpZighdGhpcy4kZWxlbWVudC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtZHJpbGxkb3duJykpe1xuICAgICAgdGhpcy4kd3JhcHBlciA9ICQodGhpcy5vcHRpb25zLndyYXBwZXIpLmFkZENsYXNzKCdpcy1kcmlsbGRvd24nKTtcbiAgICAgIHRoaXMuJHdyYXBwZXIgPSB0aGlzLiRlbGVtZW50LndyYXAodGhpcy4kd3JhcHBlcikucGFyZW50KCkuY3NzKHRoaXMuX2dldE1heERpbXMoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gZWxlbWVudHMgaW4gdGhlIG1lbnUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBtZW51IGl0ZW0gdG8gYWRkIGhhbmRsZXJzIHRvLlxuICAgKi9cbiAgX2V2ZW50cygkZWxlbSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAkZWxlbS5vZmYoJ2NsaWNrLnpmLmRyaWxsZG93bicpXG4gICAgLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbihlKXtcbiAgICAgIGlmKCQoZS50YXJnZXQpLnBhcmVudHNVbnRpbCgndWwnLCAnbGknKS5oYXNDbGFzcygnaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50Jykpe1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQpe1xuICAgICAgLy8gICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyB9XG4gICAgICBfdGhpcy5fc2hvdygkZWxlbS5wYXJlbnQoJ2xpJykpO1xuXG4gICAgICBpZihfdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayl7XG4gICAgICAgIHZhciAkYm9keSA9ICQoJ2JvZHknKTtcbiAgICAgICAgJGJvZHkub2ZmKCcuemYuZHJpbGxkb3duJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwgJC5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSwgZS50YXJnZXQpKSB7IHJldHVybjsgfVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBfdGhpcy5faGlkZUFsbCgpO1xuICAgICAgICAgICRib2R5Lm9mZignLnpmLmRyaWxsZG93bicpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGtleWRvd24gZXZlbnQgbGlzdGVuZXIgdG8gYGxpYCdzIGluIHRoZSBtZW51LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2tleWJvYXJkRXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLiRtZW51SXRlbXMuYWRkKHRoaXMuJGVsZW1lbnQuZmluZCgnLmpzLWRyaWxsZG93bi1iYWNrID4gYScpKS5vbigna2V5ZG93bi56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbihlKXtcblxuICAgICAgdmFyICRlbGVtZW50ID0gJCh0aGlzKSxcbiAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLmNoaWxkcmVuKCdsaScpLmNoaWxkcmVuKCdhJyksXG4gICAgICAgICAgJHByZXZFbGVtZW50LFxuICAgICAgICAgICRuZXh0RWxlbWVudDtcblxuICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBpZiAoJCh0aGlzKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaS0xKSk7XG4gICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkrMSwgJGVsZW1lbnRzLmxlbmd0aC0xKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ0RyaWxsZG93bicsIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCRlbGVtZW50LmlzKF90aGlzLiRzdWJtZW51QW5jaG9ycykpIHtcbiAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50LnBhcmVudCgnbGknKSk7XG4gICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbWVudCksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5maW5kKCd1bCBsaSBhJykuZmlsdGVyKF90aGlzLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmV2aW91czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKSk7XG4gICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpLmNoaWxkcmVuKCdhJykuZmlyc3QoKS5mb2N1cygpO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkcHJldkVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJG5leHRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5fYmFjaygpO1xuICAgICAgICAgIC8vX3RoaXMuJG1lbnVJdGVtcy5maXJzdCgpLmZvY3VzKCk7IC8vIGZvY3VzIHRvIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCEkZWxlbWVudC5pcyhfdGhpcy4kbWVudUl0ZW1zKSkgeyAvLyBub3QgbWVudSBpdGVtIG1lYW5zIGJhY2sgYnV0dG9uXG4gICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpKTtcbiAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbWVudCksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ2EnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmICgkZWxlbWVudC5pcyhfdGhpcy4kc3VibWVudUFuY2hvcnMpKSB7XG4gICAgICAgICAgICBfdGhpcy5fc2hvdygkZWxlbWVudC5wYXJlbnQoJ2xpJykpO1xuICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW1lbnQpLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykuZmluZCgndWwgbGkgYScpLmZpbHRlcihfdGhpcy4kbWVudUl0ZW1zKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pOyAvLyBlbmQga2V5Ym9hcmRBY2Nlc3NcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgYWxsIG9wZW4gZWxlbWVudHMsIGFuZCByZXR1cm5zIHRvIHJvb3QgbWVudS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBEcmlsbGRvd24jY2xvc2VkXG4gICAqL1xuICBfaGlkZUFsbCgpIHtcbiAgICB2YXIgJGVsZW0gPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1kcmlsbGRvd24tc3VibWVudS5pcy1hY3RpdmUnKS5hZGRDbGFzcygnaXMtY2xvc2luZycpO1xuICAgICRlbGVtLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW0pLCBmdW5jdGlvbihlKXtcbiAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZycpO1xuICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBmdWxseSBjbG9zZWQuXG4gICAgICAgICAqIEBldmVudCBEcmlsbGRvd24jY2xvc2VkXG4gICAgICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VkLnpmLmRyaWxsZG93bicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgZm9yIGVhY2ggYGJhY2tgIGJ1dHRvbiwgYW5kIGNsb3NlcyBvcGVuIG1lbnVzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIERyaWxsZG93biNiYWNrXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IHN1Yi1tZW51IHRvIGFkZCBgYmFja2AgZXZlbnQuXG4gICAqL1xuICBfYmFjaygkZWxlbSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgJGVsZW0ub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKTtcbiAgICAkZWxlbS5jaGlsZHJlbignLmpzLWRyaWxsZG93bi1iYWNrJylcbiAgICAgIC5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdtb3VzZXVwIG9uIGJhY2snKTtcbiAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW0pO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lciB0byBtZW51IGl0ZW1zIHcvbyBzdWJtZW51cyB0byBjbG9zZSBvcGVuIG1lbnVzIG9uIGNsaWNrLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tZW51TGlua0V2ZW50cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuJG1lbnVJdGVtcy5ub3QoJy5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQnKVxuICAgICAgICAub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKVxuICAgICAgICAub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIC8vIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgX3RoaXMuX2hpZGVBbGwoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIGEgc3VibWVudS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBEcmlsbGRvd24jb3BlblxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBlbGVtZW50IHdpdGggYSBzdWJtZW51IHRvIG9wZW4sIGkuZS4gdGhlIGBsaWAgdGFnLlxuICAgKi9cbiAgX3Nob3coJGVsZW0pIHtcbiAgICAkZWxlbS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgc3VibWVudSBoYXMgb3BlbmVkLlxuICAgICAqIEBldmVudCBEcmlsbGRvd24jb3BlblxuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb3Blbi56Zi5kcmlsbGRvd24nLCBbJGVsZW1dKTtcbiAgfTtcblxuICAvKipcbiAgICogSGlkZXMgYSBzdWJtZW51XG4gICAqIEBmdW5jdGlvblxuICAgKiBAZmlyZXMgRHJpbGxkb3duI2hpZGVcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGN1cnJlbnQgc3ViLW1lbnUgdG8gaGlkZSwgaS5lLiB0aGUgYHVsYCB0YWcuXG4gICAqL1xuICBfaGlkZSgkZWxlbSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgJGVsZW0uYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKVxuICAgICAgICAgLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW0pLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcnKTtcbiAgICAgICAgICAgJGVsZW0uYmx1cigpO1xuICAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgc3VibWVudSBoYXMgY2xvc2VkLlxuICAgICAqIEBldmVudCBEcmlsbGRvd24jaGlkZVxuICAgICAqL1xuICAgICRlbGVtLnRyaWdnZXIoJ2hpZGUuemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgbmVzdGVkIG1lbnVzIHRvIGNhbGN1bGF0ZSB0aGUgbWluLWhlaWdodCwgYW5kIG1heC13aWR0aCBmb3IgdGhlIG1lbnUuXG4gICAqIFByZXZlbnRzIGNvbnRlbnQganVtcGluZy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TWF4RGltcygpIHtcbiAgICB2YXIgbWF4ID0gMCwgcmVzdWx0ID0ge307XG4gICAgdGhpcy4kc3VibWVudXMuYWRkKHRoaXMuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciBudW1PZkVsZW1zID0gJCh0aGlzKS5jaGlsZHJlbignbGknKS5sZW5ndGg7XG4gICAgICBtYXggPSBudW1PZkVsZW1zID4gbWF4ID8gbnVtT2ZFbGVtcyA6IG1heDtcbiAgICB9KTtcblxuICAgIHJlc3VsdFsnbWluLWhlaWdodCddID0gYCR7bWF4ICogdGhpcy4kbWVudUl0ZW1zWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodH1weGA7XG4gICAgcmVzdWx0WydtYXgtd2lkdGgnXSA9IGAke3RoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGh9cHhgO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgRHJpbGxkb3duIE1lbnVcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2hpZGVBbGwoKTtcbiAgICBGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XG4gICAgdGhpcy4kZWxlbWVudC51bndyYXAoKVxuICAgICAgICAgICAgICAgICAuZmluZCgnLmpzLWRyaWxsZG93bi1iYWNrLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbScpLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgIC5lbmQoKS5maW5kKCcuaXMtYWN0aXZlLCAuaXMtY2xvc2luZywgLmlzLWRyaWxsZG93bi1zdWJtZW51JykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nIGlzLWRyaWxsZG93bi1zdWJtZW51JylcbiAgICAgICAgICAgICAgICAgLmVuZCgpLmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4gdGFiaW5kZXggcm9sZScpO1xuICAgIHRoaXMuJHN1Ym1lbnVBbmNob3JzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAkKHRoaXMpLm9mZignLnpmLmRyaWxsZG93bicpO1xuICAgIH0pO1xuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciAkbGluayA9ICQodGhpcyk7XG4gICAgICBpZigkbGluay5kYXRhKCdzYXZlZEhyZWYnKSl7XG4gICAgICAgICRsaW5rLmF0dHIoJ2hyZWYnLCAkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkucmVtb3ZlRGF0YSgnc2F2ZWRIcmVmJyk7XG4gICAgICB9ZWxzZXsgcmV0dXJuOyB9XG4gICAgfSk7XG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9O1xufVxuXG5EcmlsbGRvd24uZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBNYXJrdXAgdXNlZCBmb3IgSlMgZ2VuZXJhdGVkIGJhY2sgYnV0dG9uLiBQcmVwZW5kZWQgdG8gc3VibWVudSBsaXN0cyBhbmQgZGVsZXRlZCBvbiBgZGVzdHJveWAgbWV0aG9kLCAnanMtZHJpbGxkb3duLWJhY2snIGNsYXNzIHJlcXVpcmVkLiBSZW1vdmUgdGhlIGJhY2tzbGFzaCAoYFxcYCkgaWYgY29weSBhbmQgcGFzdGluZy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnPFxcbGk+PFxcYT5CYWNrPFxcL2E+PFxcL2xpPidcbiAgICovXG4gIGJhY2tCdXR0b246ICc8bGkgY2xhc3M9XCJqcy1kcmlsbGRvd24tYmFja1wiPjxhIHRhYmluZGV4PVwiMFwiPkJhY2s8L2E+PC9saT4nLFxuICAvKipcbiAgICogTWFya3VwIHVzZWQgdG8gd3JhcCBkcmlsbGRvd24gbWVudS4gVXNlIGEgY2xhc3MgbmFtZSBmb3IgaW5kZXBlbmRlbnQgc3R5bGluZzsgdGhlIEpTIGFwcGxpZWQgY2xhc3M6IGBpcy1kcmlsbGRvd25gIGlzIHJlcXVpcmVkLiBSZW1vdmUgdGhlIGJhY2tzbGFzaCAoYFxcYCkgaWYgY29weSBhbmQgcGFzdGluZy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnPFxcZGl2IGNsYXNzPVwiaXMtZHJpbGxkb3duXCI+PFxcL2Rpdj4nXG4gICAqL1xuICB3cmFwcGVyOiAnPGRpdj48L2Rpdj4nLFxuICAvKipcbiAgICogQWRkcyB0aGUgcGFyZW50IGxpbmsgdG8gdGhlIHN1Ym1lbnUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIHBhcmVudExpbms6IGZhbHNlLFxuICAvKipcbiAgICogQWxsb3cgdGhlIG1lbnUgdG8gcmV0dXJuIHRvIHJvb3QgbGlzdCBvbiBib2R5IGNsaWNrLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBjbG9zZU9uQ2xpY2s6IGZhbHNlXG4gIC8vIGhvbGRPcGVuOiBmYWxzZVxufTtcblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKERyaWxsZG93biwgJ0RyaWxsZG93bicpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogRHJvcGRvd24gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICovXG5cbmNsYXNzIERyb3Bkb3duIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcm9wZG93bi5cbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93bi5cbiAgICogICAgICAgIE9iamVjdCBzaG91bGQgYmUgb2YgdGhlIGRyb3Bkb3duIHBhbmVsLCByYXRoZXIgdGhhbiBpdHMgYW5jaG9yLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIERyb3Bkb3duLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnRHJvcGRvd24nKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdEcm9wZG93bicsIHtcbiAgICAgICdFTlRFUic6ICdvcGVuJyxcbiAgICAgICdTUEFDRSc6ICdvcGVuJyxcbiAgICAgICdFU0NBUEUnOiAnY2xvc2UnLFxuICAgICAgJ1RBQic6ICd0YWJfZm9yd2FyZCcsXG4gICAgICAnU0hJRlRfVEFCJzogJ3RhYl9iYWNrd2FyZCdcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luIGJ5IHNldHRpbmcvY2hlY2tpbmcgb3B0aW9ucyBhbmQgYXR0cmlidXRlcywgYWRkaW5nIGhlbHBlciB2YXJpYWJsZXMsIGFuZCBzYXZpbmcgdGhlIGFuY2hvci5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgJGlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xuXG4gICAgdGhpcy4kYW5jaG9yID0gJChgW2RhdGEtdG9nZ2xlPVwiJHskaWR9XCJdYCkgfHwgJChgW2RhdGEtb3Blbj1cIiR7JGlkfVwiXWApO1xuICAgIHRoaXMuJGFuY2hvci5hdHRyKHtcbiAgICAgICdhcmlhLWNvbnRyb2xzJzogJGlkLFxuICAgICAgJ2RhdGEtaXMtZm9jdXMnOiBmYWxzZSxcbiAgICAgICdkYXRhLXlldGktYm94JzogJGlkLFxuICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxuICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZVxuXG4gICAgfSk7XG5cbiAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcyA9IHRoaXMuZ2V0UG9zaXRpb25DbGFzcygpO1xuICAgIHRoaXMuY291bnRlciA9IDQ7XG4gICAgdGhpcy51c2VkUG9zaXRpb25zID0gW107XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcbiAgICAgICdkYXRhLXlldGktYm94JzogJGlkLFxuICAgICAgJ2RhdGEtcmVzaXplJzogJGlkLFxuICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IHRoaXMuJGFuY2hvclswXS5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdkZC1hbmNob3InKVxuICAgIH0pO1xuICAgIHRoaXMuX2V2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgY3VycmVudCBvcmllbnRhdGlvbiBvZiBkcm9wZG93biBwYW5lLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge1N0cmluZ30gcG9zaXRpb24gLSBzdHJpbmcgdmFsdWUgb2YgYSBwb3NpdGlvbiBjbGFzcy5cbiAgICovXG4gIGdldFBvc2l0aW9uQ2xhc3MoKSB7XG4gICAgdmFyIHZlcnRpY2FsUG9zaXRpb24gPSB0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbSkvZyk7XG4gICAgICAgIHZlcnRpY2FsUG9zaXRpb24gPSB2ZXJ0aWNhbFBvc2l0aW9uID8gdmVydGljYWxQb3NpdGlvblswXSA6ICcnO1xuICAgIHZhciBob3Jpem9udGFsUG9zaXRpb24gPSAvZmxvYXQtKFxcUyspXFxzLy5leGVjKHRoaXMuJGFuY2hvclswXS5jbGFzc05hbWUpO1xuICAgICAgICBob3Jpem9udGFsUG9zaXRpb24gPSBob3Jpem9udGFsUG9zaXRpb24gPyBob3Jpem9udGFsUG9zaXRpb25bMV0gOiAnJztcbiAgICB2YXIgcG9zaXRpb24gPSBob3Jpem9udGFsUG9zaXRpb24gPyBob3Jpem9udGFsUG9zaXRpb24gKyAnICcgKyB2ZXJ0aWNhbFBvc2l0aW9uIDogdmVydGljYWxQb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogQWRqdXN0cyB0aGUgZHJvcGRvd24gcGFuZXMgb3JpZW50YXRpb24gYnkgYWRkaW5nL3JlbW92aW5nIHBvc2l0aW9uaW5nIGNsYXNzZXMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbiBjbGFzcyB0byByZW1vdmUuXG4gICAqL1xuICBfcmVwb3NpdGlvbihwb3NpdGlvbikge1xuICAgIHRoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uID8gcG9zaXRpb24gOiAnYm90dG9tJyk7XG4gICAgLy9kZWZhdWx0LCB0cnkgc3dpdGNoaW5nIHRvIG9wcG9zaXRlIHNpZGVcbiAgICBpZighcG9zaXRpb24gJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCd0b3AnKSA8IDApKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ3RvcCcpO1xuICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAndG9wJyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgfWVsc2UgaWYocG9zaXRpb24gPT09ICdsZWZ0JyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3JpZ2h0JykgPCAwKSl7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKVxuICAgICAgICAgIC5hZGRDbGFzcygncmlnaHQnKTtcbiAgICB9ZWxzZSBpZihwb3NpdGlvbiA9PT0gJ3JpZ2h0JyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA8IDApKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pXG4gICAgICAgICAgLmFkZENsYXNzKCdsZWZ0Jyk7XG4gICAgfVxuXG4gICAgLy9pZiBkZWZhdWx0IGNoYW5nZSBkaWRuJ3Qgd29yaywgdHJ5IGJvdHRvbSBvciBsZWZ0IGZpcnN0XG4gICAgZWxzZSBpZighcG9zaXRpb24gJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCd0b3AnKSA+IC0xKSAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA8IDApKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2xlZnQnKTtcbiAgICB9ZWxzZSBpZihwb3NpdGlvbiA9PT0gJ3RvcCcgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA+IC0xKSAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA8IDApKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pXG4gICAgICAgICAgLmFkZENsYXNzKCdsZWZ0Jyk7XG4gICAgfWVsc2UgaWYocG9zaXRpb24gPT09ICdsZWZ0JyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3JpZ2h0JykgPiAtMSkgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA8IDApKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAncmlnaHQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpID4gLTEpICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJykgPCAwKSl7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgLy9pZiBub3RoaW5nIGNsZWFyZWQsIHNldCB0byBib3R0b21cbiAgICBlbHNle1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgfVxuICAgIHRoaXMuY2xhc3NDaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLmNvdW50ZXItLTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgdGhlIGRyb3Bkb3duIHBhbmUsIGNoZWNrcyBmb3IgY29sbGlzaW9ucy5cbiAgICogUmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmIGlmIGEgY29sbGlzaW9uIGlzIGRldGVjdGVkLCB3aXRoIGEgbmV3IHBvc2l0aW9uIGNsYXNzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRQb3NpdGlvbigpIHtcbiAgICBpZih0aGlzLiRhbmNob3IuYXR0cignYXJpYS1leHBhbmRlZCcpID09PSAnZmFsc2UnKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbkNsYXNzKCksXG4gICAgICAgICRlbGVEaW1zID0gRm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLiRlbGVtZW50KSxcbiAgICAgICAgJGFuY2hvckRpbXMgPSBGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGFuY2hvciksXG4gICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgZGlyZWN0aW9uID0gKHBvc2l0aW9uID09PSAnbGVmdCcgPyAnbGVmdCcgOiAoKHBvc2l0aW9uID09PSAncmlnaHQnKSA/ICdsZWZ0JyA6ICd0b3AnKSksXG4gICAgICAgIHBhcmFtID0gKGRpcmVjdGlvbiA9PT0gJ3RvcCcpID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxuICAgICAgICBvZmZzZXQgPSAocGFyYW0gPT09ICdoZWlnaHQnKSA/IHRoaXMub3B0aW9ucy52T2Zmc2V0IDogdGhpcy5vcHRpb25zLmhPZmZzZXQ7XG5cblxuXG4gICAgaWYoKCRlbGVEaW1zLndpZHRoID49ICRlbGVEaW1zLndpbmRvd0RpbXMud2lkdGgpIHx8ICghdGhpcy5jb3VudGVyICYmICFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMuJGVsZW1lbnQpKSl7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMuJGVsZW1lbnQsIHRoaXMuJGFuY2hvciwgJ2NlbnRlciBib3R0b20nLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQsIHRydWUpKS5jc3Moe1xuICAgICAgICAnd2lkdGgnOiAkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC0gKHRoaXMub3B0aW9ucy5oT2Zmc2V0ICogMiksXG4gICAgICAgICdoZWlnaHQnOiAnYXV0bydcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbGFzc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCwgdGhpcy4kYW5jaG9yLCBwb3NpdGlvbiwgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7XG5cbiAgICB3aGlsZSghRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50LCBmYWxzZSwgdHJ1ZSkgJiYgdGhpcy5jb3VudGVyKXtcbiAgICAgIHRoaXMuX3JlcG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgdGhpcy5fc2V0UG9zaXRpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGVsZW1lbnQgdXRpbGl6aW5nIHRoZSB0cmlnZ2VycyB1dGlsaXR5IGxpYnJhcnkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V2ZW50cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuJGVsZW1lbnQub24oe1xuICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmNsb3NlLmJpbmQodGhpcyksXG4gICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxuICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9zZXRQb3NpdGlvbi5iaW5kKHRoaXMpXG4gICAgfSk7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuaG92ZXIpe1xuICAgICAgdGhpcy4kYW5jaG9yLm9mZignbW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJylcbiAgICAgICAgICAub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd24nLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgX3RoaXMub3BlbigpO1xuICAgICAgICAgICAgICBfdGhpcy4kYW5jaG9yLmRhdGEoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xuICAgICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xuICAgICAgICAgIH0pO1xuICAgICAgaWYodGhpcy5vcHRpb25zLmhvdmVyUGFuZSl7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd24nKVxuICAgICAgICAgICAgLm9uKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd24nLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy4kYW5jaG9yLmRhdGEoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuJGFuY2hvci5hZGQodGhpcy4kZWxlbWVudCkub24oJ2tleWRvd24uemYuZHJvcGRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIHZhciAkdGFyZ2V0ID0gJCh0aGlzKSxcbiAgICAgICAgdmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKF90aGlzLiRlbGVtZW50KTtcblxuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ0Ryb3Bkb3duJywge1xuICAgICAgICB0YWJfZm9yd2FyZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKF90aGlzLiRlbGVtZW50LmZpbmQoJzpmb2N1cycpLmlzKHZpc2libGVGb2N1c2FibGVFbGVtZW50cy5lcSgtMSkpKSB7IC8vIGxlZnQgbW9kYWwgZG93bndhcmRzLCBzZXR0aW5nIGZvY3VzIHRvIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnRyYXBGb2N1cykgeyAvLyBpZiBmb2N1cyBzaGFsbCBiZSB0cmFwcGVkXG4gICAgICAgICAgICAgIHZpc2libGVGb2N1c2FibGVFbGVtZW50cy5lcSgwKS5mb2N1cygpO1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpZiBmb2N1cyBpcyBub3QgdHJhcHBlZCwgY2xvc2UgZHJvcGRvd24gb24gZm9jdXMgb3V0XG4gICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0YWJfYmFja3dhcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5maW5kKCc6Zm9jdXMnKS5pcyh2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMuZXEoMCkpIHx8IF90aGlzLiRlbGVtZW50LmlzKCc6Zm9jdXMnKSkgeyAvLyBsZWZ0IG1vZGFsIHVwd2FyZHMsIHNldHRpbmcgZm9jdXMgdG8gbGFzdCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy50cmFwRm9jdXMpIHsgLy8gaWYgZm9jdXMgc2hhbGwgYmUgdHJhcHBlZFxuICAgICAgICAgICAgICB2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGlmIGZvY3VzIGlzIG5vdCB0cmFwcGVkLCBjbG9zZSBkcm9wZG93biBvbiBmb2N1cyBvdXRcbiAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICgkdGFyZ2V0LmlzKF90aGlzLiRhbmNob3IpKSB7XG4gICAgICAgICAgICBfdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKS5mb2N1cygpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgX3RoaXMuJGFuY2hvci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGJvZHkgdG8gY2xvc2UgYW55IGRyb3Bkb3ducyBvbiBhIGNsaWNrLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hZGRCb2R5SGFuZGxlcigpIHtcbiAgICAgdmFyICRib2R5ID0gJChkb2N1bWVudC5ib2R5KS5ub3QodGhpcy4kZWxlbWVudCksXG4gICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICRib2R5Lm9mZignY2xpY2suemYuZHJvcGRvd24nKVxuICAgICAgICAgIC5vbignY2xpY2suemYuZHJvcGRvd24nLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIGlmKF90aGlzLiRhbmNob3IuaXMoZS50YXJnZXQpIHx8IF90aGlzLiRhbmNob3IuZmluZChlLnRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKF90aGlzLiRlbGVtZW50LmZpbmQoZS50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgJGJvZHkub2ZmKCdjbGljay56Zi5kcm9wZG93bicpO1xuICAgICAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBkcm9wZG93biBwYW5lLCBhbmQgZmlyZXMgYSBidWJibGluZyBldmVudCB0byBjbG9zZSBvdGhlciBkcm9wZG93bnMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAZmlyZXMgRHJvcGRvd24jY2xvc2VtZVxuICAgKiBAZmlyZXMgRHJvcGRvd24jc2hvd1xuICAgKi9cbiAgb3BlbigpIHtcbiAgICAvLyB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHRvIGNsb3NlIG90aGVyIG9wZW4gZHJvcGRvd25zXG4gICAgICogQGV2ZW50IERyb3Bkb3duI2Nsb3NlbWVcbiAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYuZHJvcGRvd24nLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO1xuICAgIHRoaXMuJGFuY2hvci5hZGRDbGFzcygnaG92ZXInKVxuICAgICAgICAuYXR0cih7J2FyaWEtZXhwYW5kZWQnOiB0cnVlfSk7XG4gICAgLy8gdGhpcy4kZWxlbWVudC8qLnNob3coKSovO1xuICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XG4gICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnaXMtb3BlbicpXG4gICAgICAgIC5hdHRyKHsnYXJpYS1oaWRkZW4nOiBmYWxzZX0pO1xuXG4gICAgaWYodGhpcy5vcHRpb25zLmF1dG9Gb2N1cyl7XG4gICAgICB2YXIgJGZvY3VzYWJsZSA9IEZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KTtcbiAgICAgIGlmKCRmb2N1c2FibGUubGVuZ3RoKXtcbiAgICAgICAgJGZvY3VzYWJsZS5lcSgwKS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2speyB0aGlzLl9hZGRCb2R5SGFuZGxlcigpOyB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyBvbmNlIHRoZSBkcm9wZG93biBpcyB2aXNpYmxlLlxuICAgICAqIEBldmVudCBEcm9wZG93biNzaG93XG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzaG93LnpmLmRyb3Bkb3duJywgW3RoaXMuJGVsZW1lbnRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG9wZW4gZHJvcGRvd24gcGFuZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBEcm9wZG93biNoaWRlXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICBpZighdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtb3BlbicpXG4gICAgICAgIC5hdHRyKHsnYXJpYS1oaWRkZW4nOiB0cnVlfSk7XG5cbiAgICB0aGlzLiRhbmNob3IucmVtb3ZlQ2xhc3MoJ2hvdmVyJylcbiAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG5cbiAgICBpZih0aGlzLmNsYXNzQ2hhbmdlZCl7XG4gICAgICB2YXIgY3VyUG9zaXRpb25DbGFzcyA9IHRoaXMuZ2V0UG9zaXRpb25DbGFzcygpO1xuICAgICAgaWYoY3VyUG9zaXRpb25DbGFzcyl7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoY3VyUG9zaXRpb25DbGFzcyk7XG4gICAgICB9XG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzKVxuICAgICAgICAgIC8qLmhpZGUoKSovLmNzcyh7aGVpZ2h0OiAnJywgd2lkdGg6ICcnfSk7XG4gICAgICB0aGlzLmNsYXNzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb3VudGVyID0gNDtcbiAgICAgIHRoaXMudXNlZFBvc2l0aW9ucy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYuZHJvcGRvd24nLCBbdGhpcy4kZWxlbWVudF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGRyb3Bkb3duIHBhbmUncyB2aXNpYmlsaXR5LlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICBpZih0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpe1xuICAgICAgaWYodGhpcy4kYW5jaG9yLmRhdGEoJ2hvdmVyJykpIHJldHVybjtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgZHJvcGRvd24uXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXInKS5oaWRlKCk7XG4gICAgdGhpcy4kYW5jaG9yLm9mZignLnpmLmRyb3Bkb3duJyk7XG5cbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cbn1cblxuRHJvcGRvd24uZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAyNTBcbiAgICovXG4gIGhvdmVyRGVsYXk6IDI1MCxcbiAgLyoqXG4gICAqIEFsbG93IHN1Ym1lbnVzIHRvIG9wZW4gb24gaG92ZXIgZXZlbnRzXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGhvdmVyOiBmYWxzZSxcbiAgLyoqXG4gICAqIERvbid0IGNsb3NlIGRyb3Bkb3duIHdoZW4gaG92ZXJpbmcgb3ZlciBkcm9wZG93biBwYW5lXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgaG92ZXJQYW5lOiBmYWxzZSxcbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgYmV0d2VlbiB0aGUgZHJvcGRvd24gcGFuZSBhbmQgdGhlIHRyaWdnZXJpbmcgZWxlbWVudCBvbiBvcGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDFcbiAgICovXG4gIHZPZmZzZXQ6IDEsXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIGRyb3Bkb3duIHBhbmUgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgb24gb3Blbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAxXG4gICAqL1xuICBoT2Zmc2V0OiAxLFxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byBhZGp1c3Qgb3BlbiBwb3NpdGlvbi4gSlMgd2lsbCB0ZXN0IGFuZCBmaWxsIHRoaXMgaW4uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3RvcCdcbiAgICovXG4gIHBvc2l0aW9uQ2xhc3M6ICcnLFxuICAvKipcbiAgICogQWxsb3cgdGhlIHBsdWdpbiB0byB0cmFwIGZvY3VzIHRvIHRoZSBkcm9wZG93biBwYW5lIGlmIG9wZW5lZCB3aXRoIGtleWJvYXJkIGNvbW1hbmRzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICB0cmFwRm9jdXM6IGZhbHNlLFxuICAvKipcbiAgICogQWxsb3cgdGhlIHBsdWdpbiB0byBzZXQgZm9jdXMgdG8gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgcGFuZSwgcmVnYXJkbGVzcyBvZiBtZXRob2Qgb2Ygb3BlbmluZy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBhdXRvRm9jdXM6IGZhbHNlLFxuICAvKipcbiAgICogQWxsb3dzIGEgY2xpY2sgb24gdGhlIGJvZHkgdG8gY2xvc2UgdGhlIGRyb3Bkb3duLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBjbG9zZU9uQ2xpY2s6IGZhbHNlXG59XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihEcm9wZG93biwgJ0Ryb3Bkb3duJyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBEcm9wZG93bk1lbnUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duLW1lbnVcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcbiAqL1xuXG5jbGFzcyBEcm9wZG93bk1lbnUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBEcm9wZG93bk1lbnUuXG4gICAqIEBjbGFzc1xuICAgKiBAZmlyZXMgRHJvcGRvd25NZW51I2luaXRcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhIGRyb3Bkb3duIG1lbnUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRHJvcGRvd25NZW51LmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICBGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdEcm9wZG93bk1lbnUnKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdEcm9wZG93bk1lbnUnLCB7XG4gICAgICAnRU5URVInOiAnb3BlbicsXG4gICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXG4gICAgICAnQVJST1dfVVAnOiAndXAnLFxuICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXG4gICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cycsXG4gICAgICAnRVNDQVBFJzogJ2Nsb3NlJ1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4sIGFuZCBjYWxscyBfcHJlcGFyZU1lbnVcbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgc3VicyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTtcbiAgICB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKS5hZGRDbGFzcygnZmlyc3Qtc3ViJyk7XG5cbiAgICB0aGlzLiRtZW51SXRlbXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tyb2xlPVwibWVudWl0ZW1cIl0nKTtcbiAgICB0aGlzLiR0YWJzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbignW3JvbGU9XCJtZW51aXRlbVwiXScpO1xuICAgIHRoaXMuJHRhYnMuZmluZCgndWwuaXMtZHJvcGRvd24tc3VibWVudScpLmFkZENsYXNzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbENsYXNzKTtcblxuICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5yaWdodENsYXNzKSB8fCB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAncmlnaHQnIHx8IEZvdW5kYXRpb24ucnRsKCkgfHwgdGhpcy4kZWxlbWVudC5wYXJlbnRzKCcudG9wLWJhci1yaWdodCcpLmlzKCcqJykpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPSAncmlnaHQnO1xuICAgICAgc3Vicy5hZGRDbGFzcygnb3BlbnMtbGVmdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJzLmFkZENsYXNzKCdvcGVucy1yaWdodCcpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ldmVudHMoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIGVsZW1lbnRzIHdpdGhpbiB0aGUgbWVudVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIF9ldmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgaGFzVG91Y2ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgKHR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0ICE9PSAndW5kZWZpbmVkJyksXG4gICAgICAgIHBhckNsYXNzID0gJ2lzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JztcblxuICAgIC8vIHVzZWQgZm9yIG9uQ2xpY2sgYW5kIGluIHRoZSBrZXlib2FyZCBoYW5kbGVyc1xuICAgIHZhciBoYW5kbGVDbGlja0ZuID0gZnVuY3Rpb24oZSkge1xuICAgICAgdmFyICRlbGVtID0gJChlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsIGAuJHtwYXJDbGFzc31gKSxcbiAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyksXG4gICAgICAgICAgaGFzQ2xpY2tlZCA9ICRlbGVtLmF0dHIoJ2RhdGEtaXMtY2xpY2snKSA9PT0gJ3RydWUnLFxuICAgICAgICAgICRzdWIgPSAkZWxlbS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKTtcblxuICAgICAgaWYgKGhhc1N1Yikge1xuICAgICAgICBpZiAoaGFzQ2xpY2tlZCkge1xuICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgfHwgKCFfdGhpcy5vcHRpb25zLmNsaWNrT3BlbiAmJiAhaGFzVG91Y2gpIHx8IChfdGhpcy5vcHRpb25zLmZvcmNlRm9sbG93ICYmIGhhc1RvdWNoKSkgeyByZXR1cm47IH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpKTtcbiAgICAgICAgICAkZWxlbS5hZGQoJGVsZW0ucGFyZW50c1VudGlsKF90aGlzLiRlbGVtZW50LCBgLiR7cGFyQ2xhc3N9YCkpLmF0dHIoJ2RhdGEtaXMtY2xpY2snLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgcmV0dXJuOyB9XG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY2xpY2tPcGVuIHx8IGhhc1RvdWNoKSB7XG4gICAgICB0aGlzLiRtZW51SXRlbXMub24oJ2NsaWNrLnpmLmRyb3Bkb3dubWVudSB0b3VjaHN0YXJ0LnpmLmRyb3Bkb3dubWVudScsIGhhbmRsZUNsaWNrRm4pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcikge1xuICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3dubWVudScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyICRlbGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGhhc1N1YiA9ICRlbGVtLmhhc0NsYXNzKHBhckNsYXNzKTtcblxuICAgICAgICBpZiAoaGFzU3ViKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmRlbGF5KTtcbiAgICAgICAgICBfdGhpcy5kZWxheSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy5fc2hvdygkZWxlbS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKSk7XG4gICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO1xuICAgICAgICBpZiAoaGFzU3ViICYmIF90aGlzLm9wdGlvbnMuYXV0b2Nsb3NlKSB7XG4gICAgICAgICAgaWYgKCRlbGVtLmF0dHIoJ2RhdGEtaXMtY2xpY2snKSA9PT0gJ3RydWUnICYmIF90aGlzLm9wdGlvbnMuY2xpY2tPcGVuKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmRlbGF5KTtcbiAgICAgICAgICBfdGhpcy5kZWxheSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XG4gICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5jbG9zaW5nVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLiRtZW51SXRlbXMub24oJ2tleWRvd24uemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyICRlbGVtZW50ID0gJChlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsICdbcm9sZT1cIm1lbnVpdGVtXCJdJyksXG4gICAgICAgICAgaXNUYWIgPSBfdGhpcy4kdGFicy5pbmRleCgkZWxlbWVudCkgPiAtMSxcbiAgICAgICAgICAkZWxlbWVudHMgPSBpc1RhYiA/IF90aGlzLiR0YWJzIDogJGVsZW1lbnQuc2libGluZ3MoJ2xpJykuYWRkKCRlbGVtZW50KSxcbiAgICAgICAgICAkcHJldkVsZW1lbnQsXG4gICAgICAgICAgJG5leHRFbGVtZW50O1xuXG4gICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShpLTEpO1xuICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50cy5lcShpKzEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBuZXh0U2libGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoISRlbGVtZW50LmlzKCc6bGFzdC1jaGlsZCcpKSB7XG4gICAgICAgICAgJG5leHRFbGVtZW50LmNoaWxkcmVuKCdhOmZpcnN0JykuZm9jdXMoKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHByZXZTaWJsaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRwcmV2RWxlbWVudC5jaGlsZHJlbignYTpmaXJzdCcpLmZvY3VzKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sIG9wZW5TdWIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICRzdWIgPSAkZWxlbWVudC5jaGlsZHJlbigndWwuaXMtZHJvcGRvd24tc3VibWVudScpO1xuICAgICAgICBpZiAoJHN1Yi5sZW5ndGgpIHtcbiAgICAgICAgICBfdGhpcy5fc2hvdygkc3ViKTtcbiAgICAgICAgICAkZWxlbWVudC5maW5kKCdsaSA+IGE6Zmlyc3QnKS5mb2N1cygpO1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHsgcmV0dXJuOyB9XG4gICAgICB9LCBjbG9zZVN1YiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2lmICgkZWxlbWVudC5pcygnOmZpcnN0LWNoaWxkJykpIHtcbiAgICAgICAgdmFyIGNsb3NlID0gJGVsZW1lbnQucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKTtcbiAgICAgICAgY2xvc2UuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO1xuICAgICAgICBfdGhpcy5faGlkZShjbG9zZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy99XG4gICAgICB9O1xuICAgICAgdmFyIGZ1bmN0aW9ucyA9IHtcbiAgICAgICAgb3Blbjogb3BlblN1YixcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLl9oaWRlKF90aGlzLiRlbGVtZW50KTtcbiAgICAgICAgICBfdGhpcy4kbWVudUl0ZW1zLmZpbmQoJ2E6Zmlyc3QnKS5mb2N1cygpOyAvLyBmb2N1cyB0byBmaXJzdCBlbGVtZW50XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoaXNUYWIpIHtcbiAgICAgICAgaWYgKF90aGlzLiRlbGVtZW50Lmhhc0NsYXNzKF90aGlzLm9wdGlvbnMudmVydGljYWxDbGFzcykpIHsgLy8gdmVydGljYWwgbWVudVxuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnKSB7IC8vIGxlZnQgYWxpZ25lZFxuICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIG5leHQ6IG9wZW5TdWIsXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBjbG9zZVN1YlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gcmlnaHQgYWxpZ25lZFxuICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIG5leHQ6IGNsb3NlU3ViLFxuICAgICAgICAgICAgICBwcmV2aW91czogb3BlblN1YlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBob3Jpem9udGFsIG1lbnVcbiAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcbiAgICAgICAgICAgIG5leHQ6IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgcHJldmlvdXM6IHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgZG93bjogb3BlblN1YixcbiAgICAgICAgICAgIHVwOiBjbG9zZVN1YlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyAvLyBub3QgdGFicyAtPiBvbmUgc3ViXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnKSB7IC8vIGxlZnQgYWxpZ25lZFxuICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgbmV4dDogb3BlblN1YixcbiAgICAgICAgICAgIHByZXZpb3VzOiBjbG9zZVN1YixcbiAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHJpZ2h0IGFsaWduZWRcbiAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcbiAgICAgICAgICAgIG5leHQ6IGNsb3NlU3ViLFxuICAgICAgICAgICAgcHJldmlvdXM6IG9wZW5TdWIsXG4gICAgICAgICAgICBkb3duOiBuZXh0U2libGluZyxcbiAgICAgICAgICAgIHVwOiBwcmV2U2libGluZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnRHJvcGRvd25NZW51JywgZnVuY3Rpb25zKTtcblxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgYm9keSB0byBjbG9zZSBhbnkgZHJvcGRvd25zIG9uIGEgY2xpY2suXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZEJvZHlIYW5kbGVyKCkge1xuICAgIHZhciAkYm9keSA9ICQoZG9jdW1lbnQuYm9keSksXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAkYm9keS5vZmYoJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScpXG4gICAgICAgICAub24oJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgdmFyICRsaW5rID0gX3RoaXMuJGVsZW1lbnQuZmluZChlLnRhcmdldCk7XG4gICAgICAgICAgIGlmICgkbGluay5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgX3RoaXMuX2hpZGUoKTtcbiAgICAgICAgICAgJGJvZHkub2ZmKCdtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnUnKTtcbiAgICAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIGEgZHJvcGRvd24gcGFuZSwgYW5kIGNoZWNrcyBmb3IgY29sbGlzaW9ucyBmaXJzdC5cbiAgICogQHBhcmFtIHtqUXVlcnl9ICRzdWIgLSB1bCBlbGVtZW50IHRoYXQgaXMgYSBzdWJtZW51IHRvIHNob3dcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBmaXJlcyBEcm9wZG93bk1lbnUjc2hvd1xuICAgKi9cbiAgX3Nob3coJHN1Yikge1xuICAgIHZhciBpZHggPSB0aGlzLiR0YWJzLmluZGV4KHRoaXMuJHRhYnMuZmlsdGVyKGZ1bmN0aW9uKGksIGVsKSB7XG4gICAgICByZXR1cm4gJChlbCkuZmluZCgkc3ViKS5sZW5ndGggPiAwO1xuICAgIH0pKTtcbiAgICB2YXIgJHNpYnMgPSAkc3ViLnBhcmVudCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5zaWJsaW5ncygnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTtcbiAgICB0aGlzLl9oaWRlKCRzaWJzLCBpZHgpO1xuICAgICRzdWIuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpLmFkZENsYXNzKCdqcy1kcm9wZG93bi1hY3RpdmUnKS5hdHRyKHsnYXJpYS1oaWRkZW4nOiBmYWxzZX0pXG4gICAgICAgIC5wYXJlbnQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpXG4gICAgICAgIC5hdHRyKHsnYXJpYS1leHBhbmRlZCc6IHRydWV9KTtcbiAgICB2YXIgY2xlYXIgPSBGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KCRzdWIsIG51bGwsIHRydWUpO1xuICAgIGlmICghY2xlYXIpIHtcbiAgICAgIHZhciBvbGRDbGFzcyA9IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdsZWZ0JyA/ICctcmlnaHQnIDogJy1sZWZ0JyxcbiAgICAgICAgICAkcGFyZW50TGkgPSAkc3ViLnBhcmVudCgnLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Jyk7XG4gICAgICAkcGFyZW50TGkucmVtb3ZlQ2xhc3MoYG9wZW5zJHtvbGRDbGFzc31gKS5hZGRDbGFzcyhgb3BlbnMtJHt0aGlzLm9wdGlvbnMuYWxpZ25tZW50fWApO1xuICAgICAgY2xlYXIgPSBGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KCRzdWIsIG51bGwsIHRydWUpO1xuICAgICAgaWYgKCFjbGVhcikge1xuICAgICAgICAkcGFyZW50TGkucmVtb3ZlQ2xhc3MoYG9wZW5zLSR7dGhpcy5vcHRpb25zLmFsaWdubWVudH1gKS5hZGRDbGFzcygnb3BlbnMtaW5uZXInKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgICRzdWIuY3NzKCd2aXNpYmlsaXR5JywgJycpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7IHRoaXMuX2FkZEJvZHlIYW5kbGVyKCk7IH1cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBuZXcgZHJvcGRvd24gcGFuZSBpcyB2aXNpYmxlLlxuICAgICAqIEBldmVudCBEcm9wZG93bk1lbnUjc2hvd1xuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2hvdy56Zi5kcm9wZG93bm1lbnUnLCBbJHN1Yl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIGEgc2luZ2xlLCBjdXJyZW50bHkgb3BlbiBkcm9wZG93biBwYW5lLCBpZiBwYXNzZWQgYSBwYXJhbWV0ZXIsIG90aGVyd2lzZSwgaGlkZXMgZXZlcnl0aGluZy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gaGlkZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gaW5kZXggb2YgdGhlICR0YWJzIGNvbGxlY3Rpb24gdG8gaGlkZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hpZGUoJGVsZW0sIGlkeCkge1xuICAgIHZhciAkdG9DbG9zZTtcbiAgICBpZiAoJGVsZW0gJiYgJGVsZW0ubGVuZ3RoKSB7XG4gICAgICAkdG9DbG9zZSA9ICRlbGVtO1xuICAgIH0gZWxzZSBpZiAoaWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICR0b0Nsb3NlID0gdGhpcy4kdGFicy5ub3QoZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgcmV0dXJuIGkgPT09IGlkeDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICR0b0Nsb3NlID0gdGhpcy4kZWxlbWVudDtcbiAgICB9XG4gICAgdmFyIHNvbWV0aGluZ1RvQ2xvc2UgPSAkdG9DbG9zZS5oYXNDbGFzcygnaXMtYWN0aXZlJykgfHwgJHRvQ2xvc2UuZmluZCgnLmlzLWFjdGl2ZScpLmxlbmd0aCA+IDA7XG5cbiAgICBpZiAoc29tZXRoaW5nVG9DbG9zZSkge1xuICAgICAgJHRvQ2xvc2UuZmluZCgnbGkuaXMtYWN0aXZlJykuYWRkKCR0b0Nsb3NlKS5hdHRyKHtcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcbiAgICAgICAgJ2RhdGEtaXMtY2xpY2snOiBmYWxzZVxuICAgICAgfSkucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXG4gICAgICAkdG9DbG9zZS5maW5kKCd1bC5qcy1kcm9wZG93bi1hY3RpdmUnKS5hdHRyKHtcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZVxuICAgICAgfSkucmVtb3ZlQ2xhc3MoJ2pzLWRyb3Bkb3duLWFjdGl2ZScpO1xuXG4gICAgICBpZiAodGhpcy5jaGFuZ2VkIHx8ICR0b0Nsb3NlLmZpbmQoJ29wZW5zLWlubmVyJykubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvbGRDbGFzcyA9IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdsZWZ0JyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuYWRkKCR0b0Nsb3NlKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhgb3BlbnMtaW5uZXIgb3BlbnMtJHt0aGlzLm9wdGlvbnMuYWxpZ25tZW50fWApXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKGBvcGVucy0ke29sZENsYXNzfWApO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgb3BlbiBtZW51cyBhcmUgY2xvc2VkLlxuICAgICAgICogQGV2ZW50IERyb3Bkb3duTWVudSNoaWRlXG4gICAgICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi5kcm9wZG93bm1lbnUnLCBbJHRvQ2xvc2VdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIHBsdWdpbi5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuJG1lbnVJdGVtcy5vZmYoJy56Zi5kcm9wZG93bm1lbnUnKS5yZW1vdmVBdHRyKCdkYXRhLWlzLWNsaWNrJylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdpcy1yaWdodC1hcnJvdyBpcy1sZWZ0LWFycm93IGlzLWRvd24tYXJyb3cgb3BlbnMtcmlnaHQgb3BlbnMtbGVmdCBvcGVucy1pbm5lcicpO1xuICAgICQoZG9jdW1lbnQuYm9keSkub2ZmKCcuemYuZHJvcGRvd25tZW51Jyk7XG4gICAgRm91bmRhdGlvbi5OZXN0LkJ1cm4odGhpcy4kZWxlbWVudCwgJ2Ryb3Bkb3duJyk7XG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gKi9cbkRyb3Bkb3duTWVudS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIERpc2FsbG93cyBob3ZlciBldmVudHMgZnJvbSBvcGVuaW5nIHN1Ym1lbnVzXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGRpc2FibGVIb3ZlcjogZmFsc2UsXG4gIC8qKlxuICAgKiBBbGxvdyBhIHN1Ym1lbnUgdG8gYXV0b21hdGljYWxseSBjbG9zZSBvbiBhIG1vdXNlbGVhdmUgZXZlbnQsIGlmIG5vdCBjbGlja2VkIG9wZW4uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgYXV0b2Nsb3NlOiB0cnVlLFxuICAvKipcbiAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgb3BlbmluZyBhIHN1Ym1lbnUgb24gaG92ZXIgZXZlbnQuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgNTBcbiAgICovXG4gIGhvdmVyRGVsYXk6IDUwLFxuICAvKipcbiAgICogQWxsb3cgYSBzdWJtZW51IHRvIG9wZW4vcmVtYWluIG9wZW4gb24gcGFyZW50IGNsaWNrIGV2ZW50LiBBbGxvd3MgY3Vyc29yIHRvIG1vdmUgYXdheSBmcm9tIG1lbnUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgY2xpY2tPcGVuOiBmYWxzZSxcbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGNsb3NpbmcgYSBzdWJtZW51IG9uIGEgbW91c2VsZWF2ZSBldmVudC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSA1MDBcbiAgICovXG5cbiAgY2xvc2luZ1RpbWU6IDIwMCxcbiAgLyoqXG4gICAqIFBvc2l0aW9uIG9mIHRoZSBtZW51IHJlbGF0aXZlIHRvIHdoYXQgZGlyZWN0aW9uIHRoZSBzdWJtZW51cyBzaG91bGQgb3Blbi4gSGFuZGxlZCBieSBKUy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnbGVmdCdcbiAgICovXG4gIGFsaWdubWVudDogJ2xlZnQnLFxuICAvKipcbiAgICogQWxsb3cgY2xpY2tzIG9uIHRoZSBib2R5IHRvIGNsb3NlIGFueSBvcGVuIHN1Ym1lbnVzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGNsb3NlT25DbGljazogdHJ1ZSxcbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdmVydGljYWwgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgdmVydGljYWxgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAndmVydGljYWwnXG4gICAqL1xuICB2ZXJ0aWNhbENsYXNzOiAndmVydGljYWwnLFxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byByaWdodC1zaWRlIG9yaWVudGVkIG1lbnVzLCBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgYGFsaWduLXJpZ2h0YC4gVXBkYXRlIHRoaXMgaWYgdXNpbmcgeW91ciBvd24gY2xhc3MuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ2FsaWduLXJpZ2h0J1xuICAgKi9cbiAgcmlnaHRDbGFzczogJ2FsaWduLXJpZ2h0JyxcbiAgLyoqXG4gICAqIEJvb2xlYW4gdG8gZm9yY2Ugb3ZlcmlkZSB0aGUgY2xpY2tpbmcgb2YgbGlua3MgdG8gcGVyZm9ybSBkZWZhdWx0IGFjdGlvbiwgb24gc2Vjb25kIHRvdWNoIGV2ZW50IGZvciBtb2JpbGUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGZvcmNlRm9sbG93OiB0cnVlXG59O1xuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oRHJvcGRvd25NZW51LCAnRHJvcGRvd25NZW51Jyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBFcXVhbGl6ZXIgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmVxdWFsaXplclxuICovXG5cbmNsYXNzIEVxdWFsaXplciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEVxdWFsaXplci5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBFcXVhbGl6ZXIjaW5pdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKXtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgID0gJC5leHRlbmQoe30sIEVxdWFsaXplci5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnRXF1YWxpemVyJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIEVxdWFsaXplciBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgZXFJZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1lcXVhbGl6ZXInKSB8fCAnJztcbiAgICB2YXIgJHdhdGNoZWQgPSB0aGlzLiRlbGVtZW50LmZpbmQoYFtkYXRhLWVxdWFsaXplci13YXRjaD1cIiR7ZXFJZH1cIl1gKTtcblxuICAgIHRoaXMuJHdhdGNoZWQgPSAkd2F0Y2hlZC5sZW5ndGggPyAkd2F0Y2hlZCA6IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyLXdhdGNoXScpO1xuICAgIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1yZXNpemUnLCAoZXFJZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdlcScpKSk7XG5cbiAgICB0aGlzLmhhc05lc3RlZCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyXScpLmxlbmd0aCA+IDA7XG4gICAgdGhpcy5pc05lc3RlZCA9IHRoaXMuJGVsZW1lbnQucGFyZW50c1VudGlsKGRvY3VtZW50LmJvZHksICdbZGF0YS1lcXVhbGl6ZXJdJykubGVuZ3RoID4gMDtcbiAgICB0aGlzLmlzT24gPSBmYWxzZTtcbiAgICB0aGlzLl9iaW5kSGFuZGxlciA9IHtcbiAgICAgIG9uUmVzaXplTWVCb3VuZDogdGhpcy5fb25SZXNpemVNZS5iaW5kKHRoaXMpLFxuICAgICAgb25Qb3N0RXF1YWxpemVkQm91bmQ6IHRoaXMuX29uUG9zdEVxdWFsaXplZC5iaW5kKHRoaXMpXG4gICAgfTtcblxuICAgIHZhciBpbWdzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKTtcbiAgICB2YXIgdG9vU21hbGw7XG4gICAgaWYodGhpcy5vcHRpb25zLmVxdWFsaXplT24pe1xuICAgICAgdG9vU21hbGwgPSB0aGlzLl9jaGVja01RKCk7XG4gICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX2NoZWNrTVEuYmluZCh0aGlzKSk7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICB9XG4gICAgaWYoKHRvb1NtYWxsICE9PSB1bmRlZmluZWQgJiYgdG9vU21hbGwgPT09IGZhbHNlKSB8fCB0b29TbWFsbCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIGlmKGltZ3MubGVuZ3RoKXtcbiAgICAgICAgRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZChpbWdzLCB0aGlzLl9yZWZsb3cuYmluZCh0aGlzKSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5fcmVmbG93KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGlmIHRoZSBicmVha3BvaW50IGlzIHRvbyBzbWFsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wYXVzZUV2ZW50cygpIHtcbiAgICB0aGlzLmlzT24gPSBmYWxzZTtcbiAgICB0aGlzLiRlbGVtZW50Lm9mZih7XG4gICAgICAnLnpmLmVxdWFsaXplcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kLFxuICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmRcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmdW5jdGlvbiB0byBoYW5kbGUgJGVsZW1lbnRzIHJlc2l6ZW1lLnpmLnRyaWdnZXIsIHdpdGggYm91bmQgdGhpcyBvbiBfYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25SZXNpemVNZShlKSB7XG4gICAgdGhpcy5fcmVmbG93KCk7XG4gIH1cblxuICAvKipcbiAgICogZnVuY3Rpb24gdG8gaGFuZGxlICRlbGVtZW50cyBwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplciwgd2l0aCBib3VuZCB0aGlzIG9uIF9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUG9zdEVxdWFsaXplZChlKSB7XG4gICAgaWYoZS50YXJnZXQgIT09IHRoaXMuJGVsZW1lbnRbMF0peyB0aGlzLl9yZWZsb3coKTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgRXF1YWxpemVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V2ZW50cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX3BhdXNlRXZlbnRzKCk7XG4gICAgaWYodGhpcy5oYXNOZXN0ZWQpe1xuICAgICAgdGhpcy4kZWxlbWVudC5vbigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInLCB0aGlzLl9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZCk7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgdGhpcy5fYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kKTtcbiAgICB9XG4gICAgdGhpcy5pc09uID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCB0byB0aGUgbWluaW11bSByZXF1aXJlZCBzaXplLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrTVEoKSB7XG4gICAgdmFyIHRvb1NtYWxsID0gIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uKTtcbiAgICBpZih0b29TbWFsbCl7XG4gICAgICBpZih0aGlzLmlzT24pe1xuICAgICAgICB0aGlzLl9wYXVzZUV2ZW50cygpO1xuICAgICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIGlmKCF0aGlzLmlzT24pe1xuICAgICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvb1NtYWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbm9vcCB2ZXJzaW9uIGZvciB0aGUgcGx1Z2luXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfa2lsbHN3aXRjaCgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgRXF1YWxpemVyIHVwb24gRE9NIGNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZmxvdygpIHtcbiAgICBpZighdGhpcy5vcHRpb25zLmVxdWFsaXplT25TdGFjayl7XG4gICAgICBpZih0aGlzLl9pc1N0YWNrZWQoKSl7XG4gICAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZXF1YWxpemVCeVJvdykge1xuICAgICAgdGhpcy5nZXRIZWlnaHRzQnlSb3codGhpcy5hcHBseUhlaWdodEJ5Um93LmJpbmQodGhpcykpO1xuICAgIH1lbHNle1xuICAgICAgdGhpcy5nZXRIZWlnaHRzKHRoaXMuYXBwbHlIZWlnaHQuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IGRldGVybWluZXMgaWYgdGhlIGZpcnN0IDIgZWxlbWVudHMgYXJlICpOT1QqIHN0YWNrZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaXNTdGFja2VkKCkge1xuICAgIHJldHVybiB0aGlzLiR3YXRjaGVkWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAhPT0gdGhpcy4kd2F0Y2hlZFsxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIG91dGVyIGhlaWdodHMgb2YgY2hpbGRyZW4gY29udGFpbmVkIHdpdGhpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IGFuZCByZXR1cm5zIHRoZW0gaW4gYW4gYXJyYXlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBBIG5vbi1vcHRpb25hbCBjYWxsYmFjayB0byByZXR1cm4gdGhlIGhlaWdodHMgYXJyYXkgdG8uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcbiAgICovXG4gIGdldEhlaWdodHMoY2IpIHtcbiAgICB2YXIgaGVpZ2h0cyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMuJHdhdGNoZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgdGhpcy4kd2F0Y2hlZFtpXS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICBoZWlnaHRzLnB1c2godGhpcy4kd2F0Y2hlZFtpXS5vZmZzZXRIZWlnaHQpO1xuICAgIH1cbiAgICBjYihoZWlnaHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgb3V0ZXIgaGVpZ2h0cyBvZiBjaGlsZHJlbiBjb250YWluZWQgd2l0aGluIGFuIEVxdWFsaXplciBwYXJlbnQgYW5kIHJldHVybnMgdGhlbSBpbiBhbiBhcnJheVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIEEgbm9uLW9wdGlvbmFsIGNhbGxiYWNrIHRvIHJldHVybiB0aGUgaGVpZ2h0cyBhcnJheSB0by5cbiAgICogQHJldHVybnMge0FycmF5fSBncm91cHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyIGdyb3VwZWQgYnkgcm93IHdpdGggZWxlbWVudCxoZWlnaHQgYW5kIG1heCBhcyBsYXN0IGNoaWxkXG4gICAqL1xuICBnZXRIZWlnaHRzQnlSb3coY2IpIHtcbiAgICB2YXIgbGFzdEVsVG9wT2Zmc2V0ID0gKHRoaXMuJHdhdGNoZWQubGVuZ3RoID8gdGhpcy4kd2F0Y2hlZC5maXJzdCgpLm9mZnNldCgpLnRvcCA6IDApLFxuICAgICAgICBncm91cHMgPSBbXSxcbiAgICAgICAgZ3JvdXAgPSAwO1xuICAgIC8vZ3JvdXAgYnkgUm93XG4gICAgZ3JvdXBzW2dyb3VwXSA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMuJHdhdGNoZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgdGhpcy4kd2F0Y2hlZFtpXS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAvL21heWJlIGNvdWxkIHVzZSB0aGlzLiR3YXRjaGVkW2ldLm9mZnNldFRvcFxuICAgICAgdmFyIGVsT2Zmc2V0VG9wID0gJCh0aGlzLiR3YXRjaGVkW2ldKS5vZmZzZXQoKS50b3A7XG4gICAgICBpZiAoZWxPZmZzZXRUb3AhPWxhc3RFbFRvcE9mZnNldCkge1xuICAgICAgICBncm91cCsrO1xuICAgICAgICBncm91cHNbZ3JvdXBdID0gW107XG4gICAgICAgIGxhc3RFbFRvcE9mZnNldD1lbE9mZnNldFRvcDtcbiAgICAgIH1cbiAgICAgIGdyb3Vwc1tncm91cF0ucHVzaChbdGhpcy4kd2F0Y2hlZFtpXSx0aGlzLiR3YXRjaGVkW2ldLm9mZnNldEhlaWdodF0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwLCBsbiA9IGdyb3Vwcy5sZW5ndGg7IGogPCBsbjsgaisrKSB7XG4gICAgICB2YXIgaGVpZ2h0cyA9ICQoZ3JvdXBzW2pdKS5tYXAoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbMV07IH0pLmdldCgpO1xuICAgICAgdmFyIG1heCAgICAgICAgID0gTWF0aC5tYXguYXBwbHkobnVsbCwgaGVpZ2h0cyk7XG4gICAgICBncm91cHNbal0ucHVzaChtYXgpO1xuICAgIH1cbiAgICBjYihncm91cHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIENTUyBoZWlnaHQgcHJvcGVydHkgb2YgZWFjaCBjaGlsZCBpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IHRvIG1hdGNoIHRoZSB0YWxsZXN0XG4gICAqIEBwYXJhbSB7YXJyYXl9IGhlaWdodHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyXG4gICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAqIEBmaXJlcyBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFxuICAgKi9cbiAgYXBwbHlIZWlnaHQoaGVpZ2h0cykge1xuICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBoZWlnaHRzKTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBiZWZvcmUgdGhlIGhlaWdodHMgYXJlIGFwcGxpZWRcbiAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3ByZWVxdWFsaXplZFxuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xuXG4gICAgdGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsIG1heCk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgICogQGV2ZW50IEVxdWFsaXplciNwb3N0ZXF1YWxpemVkXG4gICAgICovXG4gICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBDU1MgaGVpZ2h0IHByb3BlcnR5IG9mIGVhY2ggY2hpbGQgaW4gYW4gRXF1YWxpemVyIHBhcmVudCB0byBtYXRjaCB0aGUgdGFsbGVzdCBieSByb3dcbiAgICogQHBhcmFtIHthcnJheX0gZ3JvdXBzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lciBncm91cGVkIGJ5IHJvdyB3aXRoIGVsZW1lbnQsaGVpZ2h0IGFuZCBtYXggYXMgbGFzdCBjaGlsZFxuICAgKiBAZmlyZXMgRXF1YWxpemVyI3ByZWVxdWFsaXplZFxuICAgKiBAZmlyZXMgRXF1YWxpemVyI3ByZWVxdWFsaXplZFJvd1xuICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRSb3dcbiAgICogQGZpcmVzIEVxdWFsaXplciNwb3N0ZXF1YWxpemVkXG4gICAqL1xuICBhcHBseUhlaWdodEJ5Um93KGdyb3Vwcykge1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBhcmUgYXBwbGllZFxuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBncm91cHMubGVuZ3RoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICB2YXIgZ3JvdXBzSUxlbmd0aCA9IGdyb3Vwc1tpXS5sZW5ndGgsXG4gICAgICAgICAgbWF4ID0gZ3JvdXBzW2ldW2dyb3Vwc0lMZW5ndGggLSAxXTtcbiAgICAgIGlmIChncm91cHNJTGVuZ3RoPD0yKSB7XG4gICAgICAgICQoZ3JvdXBzW2ldWzBdWzBdKS5jc3MoeydoZWlnaHQnOidhdXRvJ30pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBwZXIgcm93IGFyZSBhcHBsaWVkXG4gICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwcmVlcXVhbGl6ZWRSb3dcbiAgICAgICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbkogPSAoZ3JvdXBzSUxlbmd0aC0xKTsgaiA8IGxlbkogOyBqKyspIHtcbiAgICAgICAgJChncm91cHNbaV1bal1bMF0pLmNzcyh7J2hlaWdodCc6bWF4fSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIHBlciByb3cgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRSb3dcbiAgICAgICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZHJvdy56Zi5lcXVhbGl6ZXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBoYXZlIGJlZW4gYXBwbGllZFxuICAgICAqL1xuICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Bvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgRXF1YWxpemVyLlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcGF1c2VFdmVudHMoKTtcbiAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICovXG5FcXVhbGl6ZXIuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBFbmFibGUgaGVpZ2h0IGVxdWFsaXphdGlvbiB3aGVuIHN0YWNrZWQgb24gc21hbGxlciBzY3JlZW5zLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGVxdWFsaXplT25TdGFjazogdHJ1ZSxcbiAgLyoqXG4gICAqIEVuYWJsZSBoZWlnaHQgZXF1YWxpemF0aW9uIHJvdyBieSByb3cuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGVxdWFsaXplQnlSb3c6IGZhbHNlLFxuICAvKipcbiAgICogU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWluaW11bSBicmVha3BvaW50IHNpemUgdGhlIHBsdWdpbiBzaG91bGQgZXF1YWxpemUgaGVpZ2h0cyBvbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnbWVkaXVtJ1xuICAgKi9cbiAgZXF1YWxpemVPbjogJydcbn07XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihFcXVhbGl6ZXIsICdFcXVhbGl6ZXInKTtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIEludGVyY2hhbmdlIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5pbnRlcmNoYW5nZVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRpbWVyQW5kSW1hZ2VMb2FkZXJcbiAqL1xuXG5jbGFzcyBJbnRlcmNoYW5nZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEludGVyY2hhbmdlLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIEludGVyY2hhbmdlI2luaXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBJbnRlcmNoYW5nZS5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgdGhpcy5ydWxlcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSAnJztcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgICB0aGlzLl9ldmVudHMoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ0ludGVyY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIEludGVyY2hhbmdlIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBpbnRlcmNoYW5nZSBmdW5jdGlvbmluZyBvbiBsb2FkLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2FkZEJyZWFrcG9pbnRzKCk7XG4gICAgdGhpcy5fZ2VuZXJhdGVSdWxlcygpO1xuICAgIHRoaXMuX3JlZmxvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgSW50ZXJjaGFuZ2UuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V2ZW50cygpIHtcbiAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS56Zi5pbnRlcmNoYW5nZScsIEZvdW5kYXRpb24udXRpbC50aHJvdHRsZSh0aGlzLl9yZWZsb3cuYmluZCh0aGlzKSwgNTApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBJbnRlcmNoYW5nZSB1cG9uIERPTSBjaGFuZ2VcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVmbG93KCkge1xuICAgIHZhciBtYXRjaDtcblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHJ1bGUsIGJ1dCBvbmx5IHNhdmUgdGhlIGxhc3QgbWF0Y2hcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucnVsZXMpIHtcbiAgICAgIGlmKHRoaXMucnVsZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzW2ldO1xuXG4gICAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShydWxlLnF1ZXJ5KS5tYXRjaGVzKSB7XG4gICAgICAgICAgbWF0Y2ggPSBydWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0aGlzLnJlcGxhY2UobWF0Y2gucGF0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIEZvdW5kYXRpb24gYnJlYWtwb2ludHMgYW5kIGFkZHMgdGhlbSB0byB0aGUgSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTIG9iamVjdC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkQnJlYWtwb2ludHMoKSB7XG4gICAgZm9yICh2YXIgaSBpbiBGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllcykge1xuICAgICAgaWYgKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5xdWVyaWVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IEZvdW5kYXRpb24uTWVkaWFRdWVyeS5xdWVyaWVzW2ldO1xuICAgICAgICBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnkubmFtZV0gPSBxdWVyeS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBJbnRlcmNoYW5nZSBlbGVtZW50IGZvciB0aGUgcHJvdmlkZWQgbWVkaWEgcXVlcnkgKyBjb250ZW50IHBhaXJpbmdzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdGhhdCBpcyBhbiBJbnRlcmNoYW5nZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHNjZW5hcmlvcyAtIEFycmF5IG9mIG9iamVjdHMgdGhhdCBoYXZlICdtcScgYW5kICdwYXRoJyBrZXlzIHdpdGggY29ycmVzcG9uZGluZyBrZXlzXG4gICAqL1xuICBfZ2VuZXJhdGVSdWxlcyhlbGVtZW50KSB7XG4gICAgdmFyIHJ1bGVzTGlzdCA9IFtdO1xuICAgIHZhciBydWxlcztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnVsZXMpIHtcbiAgICAgIHJ1bGVzID0gdGhpcy5vcHRpb25zLnJ1bGVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJ1bGVzID0gdGhpcy4kZWxlbWVudC5kYXRhKCdpbnRlcmNoYW5nZScpLm1hdGNoKC9cXFsuKj9cXF0vZyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBydWxlcykge1xuICAgICAgaWYocnVsZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXS5zbGljZSgxLCAtMSkuc3BsaXQoJywgJyk7XG4gICAgICAgIHZhciBwYXRoID0gcnVsZS5zbGljZSgwLCAtMSkuam9pbignJyk7XG4gICAgICAgIHZhciBxdWVyeSA9IHJ1bGVbcnVsZS5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTW3F1ZXJ5XSkge1xuICAgICAgICAgIHF1ZXJ5ID0gSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTW3F1ZXJ5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bGVzTGlzdC5wdXNoKHtcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzID0gcnVsZXNMaXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYHNyY2AgcHJvcGVydHkgb2YgYW4gaW1hZ2UsIG9yIGNoYW5nZSB0aGUgSFRNTCBvZiBhIGNvbnRhaW5lciwgdG8gdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBQYXRoIHRvIHRoZSBpbWFnZSBvciBIVE1MIHBhcnRpYWwuXG4gICAqIEBmaXJlcyBJbnRlcmNoYW5nZSNyZXBsYWNlZFxuICAgKi9cbiAgcmVwbGFjZShwYXRoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGggPT09IHBhdGgpIHJldHVybjtcblxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIHRyaWdnZXIgPSAncmVwbGFjZWQuemYuaW50ZXJjaGFuZ2UnO1xuXG4gICAgLy8gUmVwbGFjaW5nIGltYWdlc1xuICAgIGlmICh0aGlzLiRlbGVtZW50WzBdLm5vZGVOYW1lID09PSAnSU1HJykge1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdzcmMnLCBwYXRoKS5sb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5jdXJyZW50UGF0aCA9IHBhdGg7XG4gICAgICB9KVxuICAgICAgLnRyaWdnZXIodHJpZ2dlcik7XG4gICAgfVxuICAgIC8vIFJlcGxhY2luZyBiYWNrZ3JvdW5kIGltYWdlc1xuICAgIGVsc2UgaWYgKHBhdGgubWF0Y2goL1xcLihnaWZ8anBnfGpwZWd8cG5nfHN2Z3x0aWZmKShbPyNdLiopPy9pKSkge1xuICAgICAgdGhpcy4kZWxlbWVudC5jc3MoeyAnYmFja2dyb3VuZC1pbWFnZSc6ICd1cmwoJytwYXRoKycpJyB9KVxuICAgICAgICAgIC50cmlnZ2VyKHRyaWdnZXIpO1xuICAgIH1cbiAgICAvLyBSZXBsYWNpbmcgSFRNTFxuICAgIGVsc2Uge1xuICAgICAgJC5nZXQocGF0aCwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQuaHRtbChyZXNwb25zZSlcbiAgICAgICAgICAgICAudHJpZ2dlcih0cmlnZ2VyKTtcbiAgICAgICAgJChyZXNwb25zZSkuZm91bmRhdGlvbigpO1xuICAgICAgICBfdGhpcy5jdXJyZW50UGF0aCA9IHBhdGg7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIGNvbnRlbnQgaW4gYW4gSW50ZXJjaGFuZ2UgZWxlbWVudCBpcyBkb25lIGJlaW5nIGxvYWRlZC5cbiAgICAgKiBAZXZlbnQgSW50ZXJjaGFuZ2UjcmVwbGFjZWRcbiAgICAgKi9cbiAgICAvLyB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3JlcGxhY2VkLnpmLmludGVyY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgaW50ZXJjaGFuZ2UuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICAvL1RPRE8gdGhpcy5cbiAgfVxufVxuXG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICovXG5JbnRlcmNoYW5nZS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFJ1bGVzIHRvIGJlIGFwcGxpZWQgdG8gSW50ZXJjaGFuZ2UgZWxlbWVudHMuIFNldCB3aXRoIHRoZSBgZGF0YS1pbnRlcmNoYW5nZWAgYXJyYXkgbm90YXRpb24uXG4gICAqIEBvcHRpb25cbiAgICovXG4gIHJ1bGVzOiBudWxsXG59O1xuXG5JbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVMgPSB7XG4gICdsYW5kc2NhcGUnOiAnc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxuICAncG9ydHJhaXQnOiAnc2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KScsXG4gICdyZXRpbmEnOiAnb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMi8xKSwgb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpJ1xufTtcblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKEludGVyY2hhbmdlLCAnSW50ZXJjaGFuZ2UnKTtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIE1hZ2VsbGFuIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5tYWdlbGxhblxuICovXG5cbmNsYXNzIE1hZ2VsbGFuIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgTWFnZWxsYW4uXG4gICAqIEBjbGFzc1xuICAgKiBAZmlyZXMgTWFnZWxsYW4jaW5pdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zICA9ICQuZXh0ZW5kKHt9LCBNYWdlbGxhbi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnTWFnZWxsYW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgTWFnZWxsYW4gcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IGVxdWFsaXplciBmdW5jdGlvbmluZyBvbiBsb2FkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdtYWdlbGxhbicpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy4kdGFyZ2V0cyA9ICQoJ1tkYXRhLW1hZ2VsbGFuLXRhcmdldF0nKTtcbiAgICB0aGlzLiRsaW5rcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnYScpO1xuICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAnZGF0YS1yZXNpemUnOiBpZCxcbiAgICAgICdkYXRhLXNjcm9sbCc6IGlkLFxuICAgICAgJ2lkJzogaWRcbiAgICB9KTtcbiAgICB0aGlzLiRhY3RpdmUgPSAkKCk7XG4gICAgdGhpcy5zY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsIDEwKTtcblxuICAgIHRoaXMuX2V2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgYW4gYXJyYXkgb2YgcGl4ZWwgdmFsdWVzIHRoYXQgYXJlIHRoZSBkZW1hcmNhdGlvbiBsaW5lcyBiZXR3ZWVuIGxvY2F0aW9ucyBvbiB0aGUgcGFnZS5cbiAgICogQ2FuIGJlIGludm9rZWQgaWYgbmV3IGVsZW1lbnRzIGFyZSBhZGRlZCBvciB0aGUgc2l6ZSBvZiBhIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgY2FsY1BvaW50cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy53aW5IZWlnaHQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KHdpbmRvdy5pbm5lckhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQpKTtcbiAgICB0aGlzLmRvY0hlaWdodCA9IE1hdGgucm91bmQoTWF0aC5tYXgoYm9keS5zY3JvbGxIZWlnaHQsIGJvZHkub2Zmc2V0SGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwub2Zmc2V0SGVpZ2h0KSk7XG5cbiAgICB0aGlzLiR0YXJnZXRzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciAkdGFyID0gJCh0aGlzKSxcbiAgICAgICAgICBwdCA9IE1hdGgucm91bmQoJHRhci5vZmZzZXQoKS50b3AgLSBfdGhpcy5vcHRpb25zLnRocmVzaG9sZCk7XG4gICAgICAkdGFyLnRhcmdldFBvaW50ID0gcHQ7XG4gICAgICBfdGhpcy5wb2ludHMucHVzaChwdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBNYWdlbGxhbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ldmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgJGJvZHkgPSAkKCdodG1sLCBib2R5JyksXG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgZHVyYXRpb246IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiAgIF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgIH07XG4gICAgJCh3aW5kb3cpLm9uZSgnbG9hZCcsIGZ1bmN0aW9uKCl7XG4gICAgICBpZihfdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKXtcbiAgICAgICAgaWYobG9jYXRpb24uaGFzaCl7XG4gICAgICAgICAgX3RoaXMuc2Nyb2xsVG9Mb2MobG9jYXRpb24uaGFzaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF90aGlzLmNhbGNQb2ludHMoKTtcbiAgICAgIF90aGlzLl91cGRhdGVBY3RpdmUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGVsZW1lbnQub24oe1xuICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLnJlZmxvdy5iaW5kKHRoaXMpLFxuICAgICAgJ3Njcm9sbG1lLnpmLnRyaWdnZXInOiB0aGlzLl91cGRhdGVBY3RpdmUuYmluZCh0aGlzKVxuICAgIH0pLm9uKCdjbGljay56Zi5tYWdlbGxhbicsICdhW2hyZWZePVwiI1wiXScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgYXJyaXZhbCAgID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsVG9Mb2MoYXJyaXZhbCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gc2Nyb2xsIHRvIGEgZ2l2ZW4gbG9jYXRpb24gb24gdGhlIHBhZ2UuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsb2MgLSBhIHByb3Blcmx5IGZvcm1hdHRlZCBqUXVlcnkgaWQgc2VsZWN0b3IuIEV4YW1wbGU6ICcjZm9vJ1xuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIHNjcm9sbFRvTG9jKGxvYykge1xuICAgIHZhciBzY3JvbGxQb3MgPSBNYXRoLnJvdW5kKCQobG9jKS5vZmZzZXQoKS50b3AgLSB0aGlzLm9wdGlvbnMudGhyZXNob2xkIC8gMiAtIHRoaXMub3B0aW9ucy5iYXJPZmZzZXQpO1xuXG4gICAgJCgnaHRtbCwgYm9keScpLnN0b3AodHJ1ZSkuYW5pbWF0ZSh7IHNjcm9sbFRvcDogc2Nyb2xsUG9zIH0sIHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbkVhc2luZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgTWFnZWxsYW4gdXBvbiBET00gY2hhbmdlXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgcmVmbG93KCkge1xuICAgIHRoaXMuY2FsY1BvaW50cygpO1xuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHZpc2liaWxpdHkgb2YgYW4gYWN0aXZlIGxvY2F0aW9uIGxpbmssIGFuZCB1cGRhdGVzIHRoZSB1cmwgaGFzaCBmb3IgdGhlIHBhZ2UsIGlmIGRlZXBMaW5raW5nIGVuYWJsZWQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvblxuICAgKiBAZmlyZXMgTWFnZWxsYW4jdXBkYXRlXG4gICAqL1xuICBfdXBkYXRlQWN0aXZlKC8qZXZ0LCBlbGVtLCBzY3JvbGxQb3MqLykge1xuICAgIHZhciB3aW5Qb3MgPSAvKnNjcm9sbFBvcyB8fCovIHBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwgMTApLFxuICAgICAgICBjdXJJZHg7XG5cbiAgICBpZih3aW5Qb3MgKyB0aGlzLndpbkhlaWdodCA9PT0gdGhpcy5kb2NIZWlnaHQpeyBjdXJJZHggPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyB9XG4gICAgZWxzZSBpZih3aW5Qb3MgPCB0aGlzLnBvaW50c1swXSl7IGN1cklkeCA9IDA7IH1cbiAgICBlbHNle1xuICAgICAgdmFyIGlzRG93biA9IHRoaXMuc2Nyb2xsUG9zIDwgd2luUG9zLFxuICAgICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBjdXJWaXNpYmxlID0gdGhpcy5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHAsIGkpe1xuICAgICAgICAgICAgcmV0dXJuIGlzRG93biA/IHAgLSBfdGhpcy5vcHRpb25zLmJhck9mZnNldCA8PSB3aW5Qb3MgOiBwIC0gX3RoaXMub3B0aW9ucy5iYXJPZmZzZXQgLSBfdGhpcy5vcHRpb25zLnRocmVzaG9sZCA8PSB3aW5Qb3M7XG4gICAgICAgICAgfSk7XG4gICAgICBjdXJJZHggPSBjdXJWaXNpYmxlLmxlbmd0aCA/IGN1clZpc2libGUubGVuZ3RoIC0gMSA6IDA7XG4gICAgfVxuXG4gICAgdGhpcy4kYWN0aXZlLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG4gICAgdGhpcy4kYWN0aXZlID0gdGhpcy4kbGlua3MuZXEoY3VySWR4KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXG4gICAgaWYodGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKXtcbiAgICAgIHZhciBoYXNoID0gdGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgaWYod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKXtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIGhhc2gpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gaGFzaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNjcm9sbFBvcyA9IHdpblBvcztcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIG1hZ2VsbGFuIGlzIGZpbmlzaGVkIHVwZGF0aW5nIHRvIHRoZSBuZXcgYWN0aXZlIGVsZW1lbnQuXG4gICAgICogQGV2ZW50IE1hZ2VsbGFuI3VwZGF0ZVxuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigndXBkYXRlLnpmLm1hZ2VsbGFuJywgW3RoaXMuJGFjdGl2ZV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIE1hZ2VsbGFuIGFuZCByZXNldHMgdGhlIHVybCBvZiB0aGUgd2luZG93LlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5tYWdlbGxhbicpXG4gICAgICAgIC5maW5kKGAuJHt0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3N9YCkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblxuICAgIGlmKHRoaXMub3B0aW9ucy5kZWVwTGlua2luZyl7XG4gICAgICB2YXIgaGFzaCA9IHRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoaGFzaCwgJycpO1xuICAgIH1cblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICovXG5NYWdlbGxhbi5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lLCBpbiBtcywgdGhlIGFuaW1hdGVkIHNjcm9sbGluZyBzaG91bGQgdGFrZSBiZXR3ZWVuIGxvY2F0aW9ucy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSA1MDBcbiAgICovXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8qKlxuICAgKiBBbmltYXRpb24gc3R5bGUgdG8gdXNlIHdoZW4gc2Nyb2xsaW5nIGJldHdlZW4gbG9jYXRpb25zLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdlYXNlLWluLW91dCdcbiAgICovXG4gIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIHVzZSBhcyBhIG1hcmtlciBmb3IgbG9jYXRpb24gY2hhbmdlcy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSA1MFxuICAgKi9cbiAgdGhyZXNob2xkOiA1MCxcbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBsb2NhdGlvbnMgbGluayBvbiB0aGUgbWFnZWxsYW4gY29udGFpbmVyLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdhY3RpdmUnXG4gICAqL1xuICBhY3RpdmVDbGFzczogJ2FjdGl2ZScsXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIHNjcmlwdCB0byBtYW5pcHVsYXRlIHRoZSB1cmwgb2YgdGhlIGN1cnJlbnQgcGFnZSwgYW5kIGlmIHN1cHBvcnRlZCwgYWx0ZXIgdGhlIGhpc3RvcnkuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgZGVlcExpbmtpbmc6IGZhbHNlLFxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyB0byBvZmZzZXQgdGhlIHNjcm9sbCBvZiB0aGUgcGFnZSBvbiBpdGVtIGNsaWNrIGlmIHVzaW5nIGEgc3RpY2t5IG5hdiBiYXIuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMjVcbiAgICovXG4gIGJhck9mZnNldDogMFxufVxuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oTWFnZWxsYW4sICdNYWdlbGxhbicpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogT2ZmQ2FudmFzIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5vZmZjYW52YXNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqL1xuXG5jbGFzcyBPZmZDYW52YXMge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBvZmYtY2FudmFzIHdyYXBwZXIuXG4gICAqIEBjbGFzc1xuICAgKiBAZmlyZXMgT2ZmQ2FudmFzI2luaXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGluaXRpYWxpemUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgT2ZmQ2FudmFzLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgdGhpcy4kbGFzdFRyaWdnZXIgPSAkKCk7XG4gICAgdGhpcy4kdHJpZ2dlcnMgPSAkKCk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gICAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdPZmZDYW52YXMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgb2ZmLWNhbnZhcyB3cmFwcGVyIGJ5IGFkZGluZyB0aGUgZXhpdCBvdmVybGF5IChpZiBuZWVkZWQpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcblxuICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgLy8gRmluZCB0cmlnZ2VycyB0aGF0IGFmZmVjdCB0aGlzIGVsZW1lbnQgYW5kIGFkZCBhcmlhLWV4cGFuZGVkIHRvIHRoZW1cbiAgICB0aGlzLiR0cmlnZ2VycyA9ICQoZG9jdW1lbnQpXG4gICAgICAuZmluZCgnW2RhdGEtb3Blbj1cIicraWQrJ1wiXSwgW2RhdGEtY2xvc2U9XCInK2lkKydcIl0sIFtkYXRhLXRvZ2dsZT1cIicraWQrJ1wiXScpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpXG4gICAgICAuYXR0cignYXJpYS1jb250cm9scycsIGlkKTtcblxuICAgIC8vIEFkZCBhIGNsb3NlIHRyaWdnZXIgb3ZlciB0aGUgYm9keSBpZiBuZWNlc3NhcnlcbiAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xuICAgICAgaWYgKCQoJy5qcy1vZmYtY2FudmFzLWV4aXQnKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4kZXhpdGVyID0gJCgnLmpzLW9mZi1jYW52YXMtZXhpdCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4aXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBleGl0ZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsICdqcy1vZmYtY2FudmFzLWV4aXQnKTtcbiAgICAgICAgJCgnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmFwcGVuZChleGl0ZXIpO1xuXG4gICAgICAgIHRoaXMuJGV4aXRlciA9ICQoZXhpdGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCA9IHRoaXMub3B0aW9ucy5pc1JldmVhbGVkIHx8IG5ldyBSZWdFeHAodGhpcy5vcHRpb25zLnJldmVhbENsYXNzLCAnZycpLnRlc3QodGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5pc1JldmVhbGVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMucmV2ZWFsT24gPSB0aGlzLm9wdGlvbnMucmV2ZWFsT24gfHwgdGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyhyZXZlYWwtZm9yLW1lZGl1bXxyZXZlYWwtZm9yLWxhcmdlKS9nKVswXS5zcGxpdCgnLScpWzJdO1xuICAgICAgdGhpcy5fc2V0TVFDaGVja2VyKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUgPSBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCQoJ1tkYXRhLW9mZi1jYW52YXMtd3JhcHBlcl0nKVswXSkudHJhbnNpdGlvbkR1cmF0aW9uKSAqIDEwMDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIG9mZi1jYW52YXMgd3JhcHBlciBhbmQgdGhlIGV4aXQgb3ZlcmxheS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlciAuemYub2ZmY2FudmFzJykub24oe1xuICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmNsb3NlLmJpbmQodGhpcyksXG4gICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxuICAgICAgJ2tleWRvd24uemYub2ZmY2FudmFzJzogdGhpcy5faGFuZGxlS2V5Ym9hcmQuYmluZCh0aGlzKVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy4kZXhpdGVyLmxlbmd0aCkge1xuICAgICAgdGhpcy4kZXhpdGVyLm9uKHsnY2xpY2suemYub2ZmY2FudmFzJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgZXZlbnQgbGlzdGVuZXIgZm9yIGVsZW1lbnRzIHRoYXQgd2lsbCByZXZlYWwgYXQgY2VydGFpbiBicmVha3BvaW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRNUUNoZWNrZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoX3RoaXMub3B0aW9ucy5yZXZlYWxPbikpIHtcbiAgICAgICAgX3RoaXMucmV2ZWFsKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMucmV2ZWFsKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KS5vbmUoJ2xvYWQuemYub2ZmY2FudmFzJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoX3RoaXMub3B0aW9ucy5yZXZlYWxPbikpIHtcbiAgICAgICAgX3RoaXMucmV2ZWFsKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHJldmVhbGluZy9oaWRpbmcgdGhlIG9mZi1jYW52YXMgYXQgYnJlYWtwb2ludHMsIG5vdCB0aGUgc2FtZSBhcyBvcGVuLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmV2ZWFsZWQgLSB0cnVlIGlmIGVsZW1lbnQgc2hvdWxkIGJlIHJldmVhbGVkLlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIHJldmVhbChpc1JldmVhbGVkKSB7XG4gICAgdmFyICRjbG9zZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWNsb3NlXScpO1xuICAgIGlmIChpc1JldmVhbGVkKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB0aGlzLmlzUmV2ZWFsZWQgPSB0cnVlO1xuICAgICAgLy8gaWYgKCF0aGlzLm9wdGlvbnMuZm9yY2VUb3ApIHtcbiAgICAgIC8vICAgdmFyIHNjcm9sbFBvcyA9IHBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAvLyAgIHRoaXMuJGVsZW1lbnRbMF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBzY3JvbGxQb3MgKyAncHgpJztcbiAgICAgIC8vIH1cbiAgICAgIC8vIGlmICh0aGlzLm9wdGlvbnMuaXNTdGlja3kpIHsgdGhpcy5fc3RpY2soKTsgfVxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ29wZW4uemYudHJpZ2dlciB0b2dnbGUuemYudHJpZ2dlcicpO1xuICAgICAgaWYgKCRjbG9zZXIubGVuZ3RoKSB7ICRjbG9zZXIuaGlkZSgpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNSZXZlYWxlZCA9IGZhbHNlO1xuICAgICAgLy8gaWYgKHRoaXMub3B0aW9ucy5pc1N0aWNreSB8fCAhdGhpcy5vcHRpb25zLmZvcmNlVG9wKSB7XG4gICAgICAvLyAgIHRoaXMuJGVsZW1lbnRbMF0uc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICAvLyAgICQod2luZG93KS5vZmYoJ3Njcm9sbC56Zi5vZmZjYW52YXMnKTtcbiAgICAgIC8vIH1cbiAgICAgIHRoaXMuJGVsZW1lbnQub24oe1xuICAgICAgICAnb3Blbi56Zi50cmlnZ2VyJzogdGhpcy5vcGVuLmJpbmQodGhpcyksXG4gICAgICAgICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcylcbiAgICAgIH0pO1xuICAgICAgaWYgKCRjbG9zZXIubGVuZ3RoKSB7XG4gICAgICAgICRjbG9zZXIuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgb2ZmLWNhbnZhcyBtZW51LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRXZlbnQgb2JqZWN0IHBhc3NlZCBmcm9tIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gdHJpZ2dlciAtIGVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIG9mZi1jYW52YXMgdG8gb3Blbi5cbiAgICogQGZpcmVzIE9mZkNhbnZhcyNvcGVuZWRcbiAgICovXG4gIG9wZW4oZXZlbnQsIHRyaWdnZXIpIHtcbiAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpIHx8IHRoaXMuaXNSZXZlYWxlZCkgeyByZXR1cm47IH1cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAkYm9keSA9ICQoZG9jdW1lbnQuYm9keSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlVG9wKSB7XG4gICAgICAkKCdib2R5Jykuc2Nyb2xsVG9wKDApO1xuICAgIH1cbiAgICAvLyB3aW5kb3cucGFnZVlPZmZzZXQgPSAwO1xuXG4gICAgLy8gaWYgKCF0aGlzLm9wdGlvbnMuZm9yY2VUb3ApIHtcbiAgICAvLyAgIHZhciBzY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQpO1xuICAgIC8vICAgdGhpcy4kZWxlbWVudFswXS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsJyArIHNjcm9sbFBvcyArICdweCknO1xuICAgIC8vICAgaWYgKHRoaXMuJGV4aXRlci5sZW5ndGgpIHtcbiAgICAvLyAgICAgdGhpcy4kZXhpdGVyWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwnICsgc2Nyb2xsUG9zICsgJ3B4KSc7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cbiAgICAgKiBAZXZlbnQgT2ZmQ2FudmFzI29wZW5lZFxuICAgICAqL1xuICAgIEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUsIHRoaXMuJGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgJCgnW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXScpLmFkZENsYXNzKCdpcy1vZmYtY2FudmFzLW9wZW4gaXMtb3Blbi0nKyBfdGhpcy5vcHRpb25zLnBvc2l0aW9uKTtcblxuICAgICAgX3RoaXMuJGVsZW1lbnRcbiAgICAgICAgLmFkZENsYXNzKCdpcy1vcGVuJylcblxuICAgICAgLy8gaWYgKF90aGlzLm9wdGlvbnMuaXNTdGlja3kpIHtcbiAgICAgIC8vICAgX3RoaXMuX3N0aWNrKCk7XG4gICAgICAvLyB9XG4gICAgfSk7XG5cbiAgICB0aGlzLiR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJylcbiAgICAgICAgLnRyaWdnZXIoJ29wZW5lZC56Zi5vZmZjYW52YXMnKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICB0aGlzLiRleGl0ZXIuYWRkQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgICB9XG5cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgdGhpcy4kbGFzdFRyaWdnZXIgPSB0cmlnZ2VyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQodGhpcy4kZWxlbWVudCksIGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy4kZWxlbWVudC5maW5kKCdhLCBidXR0b24nKS5lcSgwKS5mb2N1cygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMpIHtcbiAgICAgICQoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5hdHRyKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgdGhpcy5fdHJhcEZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYXBzIGZvY3VzIHdpdGhpbiB0aGUgb2ZmY2FudmFzIG9uIG9wZW4uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJhcEZvY3VzKCkge1xuICAgIHZhciBmb2N1c2FibGUgPSBGb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCksXG4gICAgICAgIGZpcnN0ID0gZm9jdXNhYmxlLmVxKDApLFxuICAgICAgICBsYXN0ID0gZm9jdXNhYmxlLmVxKC0xKTtcblxuICAgIGZvY3VzYWJsZS5vZmYoJy56Zi5vZmZjYW52YXMnKS5vbigna2V5ZG93bi56Zi5vZmZjYW52YXMnLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS53aGljaCA9PT0gOSB8fCBlLmtleWNvZGUgPT09IDkpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBsYXN0WzBdICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGZpcnN0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBmaXJzdFswXSAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGxhc3QuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgb2ZmY2FudmFzIHRvIGFwcGVhciBzdGlja3kgdXRpbGl6aW5nIHRyYW5zbGF0ZSBwcm9wZXJ0aWVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLy8gT2ZmQ2FudmFzLnByb3RvdHlwZS5fc3RpY2sgPSBmdW5jdGlvbigpIHtcbiAgLy8gICB2YXIgZWxTdHlsZSA9IHRoaXMuJGVsZW1lbnRbMF0uc3R5bGU7XG4gIC8vXG4gIC8vICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcbiAgLy8gICAgIHZhciBleGl0U3R5bGUgPSB0aGlzLiRleGl0ZXJbMF0uc3R5bGU7XG4gIC8vICAgfVxuICAvL1xuICAvLyAgICQod2luZG93KS5vbignc2Nyb2xsLnpmLm9mZmNhbnZhcycsIGZ1bmN0aW9uKGUpIHtcbiAgLy8gICAgIGNvbnNvbGUubG9nKGUpO1xuICAvLyAgICAgdmFyIHBhZ2VZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAvLyAgICAgZWxTdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsJyArIHBhZ2VZICsgJ3B4KSc7XG4gIC8vICAgICBpZiAoZXhpdFN0eWxlICE9PSB1bmRlZmluZWQpIHsgZXhpdFN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwnICsgcGFnZVkgKyAncHgpJzsgfVxuICAvLyAgIH0pO1xuICAvLyAgIC8vIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc3R1Y2suemYub2ZmY2FudmFzJyk7XG4gIC8vIH07XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG9mZi1jYW52YXMgbWVudS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gb3B0aW9uYWwgY2IgdG8gZmlyZSBhZnRlciBjbG9zdXJlLlxuICAgKiBAZmlyZXMgT2ZmQ2FudmFzI2Nsb3NlZFxuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSB8fCB0aGlzLmlzUmV2ZWFsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gIEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUsIHRoaXMuJGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICQoJ1tkYXRhLW9mZi1jYW52YXMtd3JhcHBlcl0nKS5yZW1vdmVDbGFzcyhgaXMtb2ZmLWNhbnZhcy1vcGVuIGlzLW9wZW4tJHtfdGhpcy5vcHRpb25zLnBvc2l0aW9ufWApO1xuICAgIF90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJyk7XG4gICAgICAvLyBGb3VuZGF0aW9uLl9yZWZsb3coKTtcbiAgICAvLyB9KTtcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBvZmYtY2FudmFzIG1lbnUgb3BlbnMuXG4gICAgICAgKiBAZXZlbnQgT2ZmQ2FudmFzI2Nsb3NlZFxuICAgICAgICovXG4gICAgICAgIC50cmlnZ2VyKCdjbG9zZWQuemYub2ZmY2FudmFzJyk7XG4gICAgLy8gaWYgKF90aGlzLm9wdGlvbnMuaXNTdGlja3kgfHwgIV90aGlzLm9wdGlvbnMuZm9yY2VUb3ApIHtcbiAgICAvLyAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgLy8gICAgIF90aGlzLiRlbGVtZW50WzBdLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgIC8vICAgICAkKHdpbmRvdykub2ZmKCdzY3JvbGwuemYub2ZmY2FudmFzJyk7XG4gICAgLy8gICB9LCB0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUpO1xuICAgIC8vIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xuICAgICAgdGhpcy4kZXhpdGVyLnJlbW92ZUNsYXNzKCdpcy12aXNpYmxlJyk7XG4gICAgfVxuXG4gICAgdGhpcy4kdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudHJhcEZvY3VzKSB7XG4gICAgICAkKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW4gb3IgY2xvc2VkLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRXZlbnQgb2JqZWN0IHBhc3NlZCBmcm9tIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gdHJpZ2dlciAtIGVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIG9mZi1jYW52YXMgdG8gb3Blbi5cbiAgICovXG4gIHRvZ2dsZShldmVudCwgdHJpZ2dlcikge1xuICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcbiAgICAgIHRoaXMuY2xvc2UoZXZlbnQsIHRyaWdnZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMub3BlbihldmVudCwgdHJpZ2dlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5Ym9hcmQgaW5wdXQgd2hlbiBkZXRlY3RlZC4gV2hlbiB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkLCB0aGUgb2ZmLWNhbnZhcyBtZW51IGNsb3NlcywgYW5kIGZvY3VzIGlzIHJlc3RvcmVkIHRvIHRoZSBlbGVtZW50IHRoYXQgb3BlbmVkIHRoZSBtZW51LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVLZXlib2FyZChldmVudCkge1xuICAgIGlmIChldmVudC53aGljaCAhPT0gMjcpIHJldHVybjtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIHRoaXMuJGxhc3RUcmlnZ2VyLmZvY3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIG9mZmNhbnZhcyBwbHVnaW4uXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXMnKTtcbiAgICB0aGlzLiRleGl0ZXIub2ZmKCcuemYub2ZmY2FudmFzJyk7XG5cbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cbn1cblxuT2ZmQ2FudmFzLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gY2xpY2sgb3V0c2lkZSBvZiB0aGUgbWVudSB0byBjbG9zZSBpdC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBjbG9zZU9uQ2xpY2s6IHRydWUsXG5cbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lIGluIG1zIHRoZSBvcGVuIGFuZCBjbG9zZSB0cmFuc2l0aW9uIHJlcXVpcmVzLiBJZiBub25lIHNlbGVjdGVkLCBwdWxscyBmcm9tIGJvZHkgc3R5bGUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgNTAwXG4gICAqL1xuICB0cmFuc2l0aW9uVGltZTogMCxcblxuICAvKipcbiAgICogRGlyZWN0aW9uIHRoZSBvZmZjYW52YXMgb3BlbnMgZnJvbS4gRGV0ZXJtaW5lcyBjbGFzcyBhcHBsaWVkIHRvIGJvZHkuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgbGVmdFxuICAgKi9cbiAgcG9zaXRpb246ICdsZWZ0JyxcblxuICAvKipcbiAgICogRm9yY2UgdGhlIHBhZ2UgdG8gc2Nyb2xsIHRvIHRvcCBvbiBvcGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGZvcmNlVG9wOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgb2ZmY2FudmFzIHRvIHJlbWFpbiBvcGVuIGZvciBjZXJ0YWluIGJyZWFrcG9pbnRzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBpc1JldmVhbGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogQnJlYWtwb2ludCBhdCB3aGljaCB0byByZXZlYWwuIEpTIHdpbGwgdXNlIGEgUmVnRXhwIHRvIHRhcmdldCBzdGFuZGFyZCBjbGFzc2VzLCBpZiBjaGFuZ2luZyBjbGFzc25hbWVzLCBwYXNzIHlvdXIgY2xhc3Mgd2l0aCB0aGUgYHJldmVhbENsYXNzYCBvcHRpb24uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgcmV2ZWFsLWZvci1sYXJnZVxuICAgKi9cbiAgcmV2ZWFsT246IG51bGwsXG5cbiAgLyoqXG4gICAqIEZvcmNlIGZvY3VzIHRvIHRoZSBvZmZjYW52YXMgb24gb3Blbi4gSWYgdHJ1ZSwgd2lsbCBmb2N1cyB0aGUgb3BlbmluZyB0cmlnZ2VyIG9uIGNsb3NlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGF1dG9Gb2N1czogdHJ1ZSxcblxuICAvKipcbiAgICogQ2xhc3MgdXNlZCB0byBmb3JjZSBhbiBvZmZjYW52YXMgdG8gcmVtYWluIG9wZW4uIEZvdW5kYXRpb24gZGVmYXVsdHMgZm9yIHRoaXMgYXJlIGByZXZlYWwtZm9yLWxhcmdlYCAmIGByZXZlYWwtZm9yLW1lZGl1bWAuXG4gICAqIEBvcHRpb25cbiAgICogVE9ETyBpbXByb3ZlIHRoZSByZWdleCB0ZXN0aW5nIGZvciB0aGlzLlxuICAgKiBAZXhhbXBsZSByZXZlYWwtZm9yLWxhcmdlXG4gICAqL1xuICByZXZlYWxDbGFzczogJ3JldmVhbC1mb3ItJyxcblxuICAvKipcbiAgICogVHJpZ2dlcnMgb3B0aW9uYWwgZm9jdXMgdHJhcHBpbmcgd2hlbiBvcGVuaW5nIGFuIG9mZmNhbnZhcy4gU2V0cyB0YWJpbmRleCBvZiBbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdIHRvIC0xIGZvciBhY2Nlc3NpYmlsaXR5IHB1cnBvc2VzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIHRyYXBGb2N1czogZmFsc2Vcbn1cblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKE9mZkNhbnZhcywgJ09mZkNhbnZhcycpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogT3JiaXQgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm9yYml0XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRvdWNoXG4gKi9cblxuY2xhc3MgT3JiaXQge1xuICAvKipcbiAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIG9yYml0IGNhcm91c2VsLlxuICAqIEBjbGFzc1xuICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gT3JiaXQgQ2Fyb3VzZWwuXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKXtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgT3JiaXQuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ09yYml0Jyk7XG4gICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignT3JiaXQnLCB7XG4gICAgICAnbHRyJzoge1xuICAgICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXG4gICAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJ1xuICAgICAgfSxcbiAgICAgICdydGwnOiB7XG4gICAgICAgICdBUlJPV19MRUZUJzogJ25leHQnLFxuICAgICAgICAnQVJST1dfUklHSFQnOiAncHJldmlvdXMnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luIGJ5IGNyZWF0aW5nIGpRdWVyeSBjb2xsZWN0aW9ucywgc2V0dGluZyBhdHRyaWJ1dGVzLCBhbmQgc3RhcnRpbmcgdGhlIGFuaW1hdGlvbi5cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBfaW5pdCgpIHtcbiAgICB0aGlzLiR3cmFwcGVyID0gdGhpcy4kZWxlbWVudC5maW5kKGAuJHt0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3N9YCk7XG4gICAgdGhpcy4kc2xpZGVzID0gdGhpcy4kZWxlbWVudC5maW5kKGAuJHt0aGlzLm9wdGlvbnMuc2xpZGVDbGFzc31gKTtcbiAgICB2YXIgJGltYWdlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyksXG4gICAgaW5pdEFjdGl2ZSA9IHRoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKTtcblxuICAgIGlmICghaW5pdEFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuJHNsaWRlcy5lcSgwKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudXNlTVVJKSB7XG4gICAgICB0aGlzLiRzbGlkZXMuYWRkQ2xhc3MoJ25vLW1vdGlvbnVpJyk7XG4gICAgfVxuXG4gICAgaWYgKCRpbWFnZXMubGVuZ3RoKSB7XG4gICAgICBGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKCRpbWFnZXMsIHRoaXMuX3ByZXBhcmVGb3JPcmJpdC5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJlcGFyZUZvck9yYml0KCk7Ly9oZWhlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRzKSB7XG4gICAgICB0aGlzLl9sb2FkQnVsbGV0cygpO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUGxheSAmJiB0aGlzLiRzbGlkZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5nZW9TeW5jKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hY2Nlc3NpYmxlKSB7IC8vIGFsbG93IHdyYXBwZXIgdG8gYmUgZm9jdXNhYmxlIHRvIGVuYWJsZSBhcnJvdyBuYXZpZ2F0aW9uXG4gICAgICB0aGlzLiR3cmFwcGVyLmF0dHIoJ3RhYmluZGV4JywgMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogQ3JlYXRlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIGJ1bGxldHMsIGlmIHRoZXkgYXJlIGJlaW5nIHVzZWQuXG4gICogQGZ1bmN0aW9uXG4gICogQHByaXZhdGVcbiAgKi9cbiAgX2xvYWRCdWxsZXRzKCkge1xuICAgIHRoaXMuJGJ1bGxldHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoYC4ke3RoaXMub3B0aW9ucy5ib3hPZkJ1bGxldHN9YCkuZmluZCgnYnV0dG9uJyk7XG4gIH1cblxuICAvKipcbiAgKiBTZXRzIGEgYHRpbWVyYCBvYmplY3Qgb24gdGhlIG9yYml0LCBhbmQgc3RhcnRzIHRoZSBjb3VudGVyIGZvciB0aGUgbmV4dCBzbGlkZS5cbiAgKiBAZnVuY3Rpb25cbiAgKi9cbiAgZ2VvU3luYygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMudGltZXIgPSBuZXcgRm91bmRhdGlvbi5UaW1lcihcbiAgICAgIHRoaXMuJGVsZW1lbnQsXG4gICAgICB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMudGltZXJEZWxheSxcbiAgICAgICAgaW5maW5pdGU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKHRydWUpO1xuICAgICAgfSk7XG4gICAgdGhpcy50aW1lci5zdGFydCgpO1xuICB9XG5cbiAgLyoqXG4gICogU2V0cyB3cmFwcGVyIGFuZCBzbGlkZSBoZWlnaHRzIGZvciB0aGUgb3JiaXQuXG4gICogQGZ1bmN0aW9uXG4gICogQHByaXZhdGVcbiAgKi9cbiAgX3ByZXBhcmVGb3JPcmJpdCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX3NldFdyYXBwZXJIZWlnaHQoZnVuY3Rpb24obWF4KXtcbiAgICAgIF90aGlzLl9zZXRTbGlkZUhlaWdodChtYXgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICogQ2FsdWxhdGVzIHRoZSBoZWlnaHQgb2YgZWFjaCBzbGlkZSBpbiB0aGUgY29sbGVjdGlvbiwgYW5kIHVzZXMgdGhlIHRhbGxlc3Qgb25lIGZvciB0aGUgd3JhcHBlciBoZWlnaHQuXG4gICogQGZ1bmN0aW9uXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSB3aGVuIGNvbXBsZXRlLlxuICAqL1xuICBfc2V0V3JhcHBlckhlaWdodChjYikgey8vcmV3cml0ZSB0aGlzIHRvIGBmb3JgIGxvb3BcbiAgICB2YXIgbWF4ID0gMCwgdGVtcCwgY291bnRlciA9IDA7XG5cbiAgICB0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHRlbXAgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICQodGhpcykuYXR0cignZGF0YS1zbGlkZScsIGNvdW50ZXIpO1xuXG4gICAgICBpZiAoY291bnRlcikgey8vaWYgbm90IHRoZSBmaXJzdCBzbGlkZSwgc2V0IGNzcyBwb3NpdGlvbiBhbmQgZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgICAkKHRoaXMpLmNzcyh7J3Bvc2l0aW9uJzogJ3JlbGF0aXZlJywgJ2Rpc3BsYXknOiAnbm9uZSd9KTtcbiAgICAgIH1cbiAgICAgIG1heCA9IHRlbXAgPiBtYXggPyB0ZW1wIDogbWF4O1xuICAgICAgY291bnRlcisrO1xuICAgIH0pO1xuXG4gICAgaWYgKGNvdW50ZXIgPT09IHRoaXMuJHNsaWRlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHsnaGVpZ2h0JzogbWF4fSk7IC8vb25seSBjaGFuZ2UgdGhlIHdyYXBwZXIgaGVpZ2h0IHByb3BlcnR5IG9uY2UuXG4gICAgICBjYihtYXgpOyAvL2ZpcmUgY2FsbGJhY2sgd2l0aCBtYXggaGVpZ2h0IGRpbWVuc2lvbi5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBTZXRzIHRoZSBtYXgtaGVpZ2h0IG9mIGVhY2ggc2xpZGUuXG4gICogQGZ1bmN0aW9uXG4gICogQHByaXZhdGVcbiAgKi9cbiAgX3NldFNsaWRlSGVpZ2h0KGhlaWdodCkge1xuICAgIHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgJCh0aGlzKS5jc3MoJ21heC1oZWlnaHQnLCBoZWlnaHQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gYmFzaWNhbGx5IGV2ZXJ5dGhpbmcgd2l0aGluIHRoZSBlbGVtZW50LlxuICAqIEBmdW5jdGlvblxuICAqIEBwcml2YXRlXG4gICovXG4gIF9ldmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8qKk5vdyB1c2luZyBjdXN0b20gZXZlbnQgLSB0aGFua3MgdG86KipcbiAgICAvLyoqICAgICAgWW9oYWkgQXJhcmF0IG9mIFRvcm9udG8gICAgICAqKlxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgaWYgKHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxKSB7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3dpcGUpIHtcbiAgICAgICAgdGhpcy4kc2xpZGVzLm9mZignc3dpcGVsZWZ0LnpmLm9yYml0IHN3aXBlcmlnaHQuemYub3JiaXQnKVxuICAgICAgICAub24oJ3N3aXBlbGVmdC56Zi5vcmJpdCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSh0cnVlKTtcbiAgICAgICAgfSkub24oJ3N3aXBlcmlnaHQuemYub3JiaXQnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkpIHtcbiAgICAgICAgdGhpcy4kc2xpZGVzLm9uKCdjbGljay56Zi5vcmJpdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicsIF90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpID8gZmFsc2UgOiB0cnVlKTtcbiAgICAgICAgICBfdGhpcy50aW1lcltfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nKSA/ICdwYXVzZScgOiAnc3RhcnQnXSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhdXNlT25Ib3Zlcikge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ21vdXNlZW50ZXIuemYub3JiaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLnRpbWVyLnBhdXNlKCk7XG4gICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYub3JiaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykpIHtcbiAgICAgICAgICAgICAgX3RoaXMudGltZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5hdkJ1dHRvbnMpIHtcbiAgICAgICAgdmFyICRjb250cm9scyA9IHRoaXMuJGVsZW1lbnQuZmluZChgLiR7dGhpcy5vcHRpb25zLm5leHRDbGFzc30sIC4ke3RoaXMub3B0aW9ucy5wcmV2Q2xhc3N9YCk7XG4gICAgICAgICRjb250cm9scy5hdHRyKCd0YWJpbmRleCcsIDApXG4gICAgICAgIC8vYWxzbyBuZWVkIHRvIGhhbmRsZSBlbnRlci9yZXR1cm4gYW5kIHNwYWNlYmFyIGtleSBwcmVzc2VzXG4gICAgICAgIC5vbignY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXQnLCBmdW5jdGlvbihlKXtcblx0ICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoJCh0aGlzKS5oYXNDbGFzcyhfdGhpcy5vcHRpb25zLm5leHRDbGFzcykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRzKSB7XG4gICAgICAgIHRoaXMuJGJ1bGxldHMub24oJ2NsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKC9pcy1hY3RpdmUvZy50ZXN0KHRoaXMuY2xhc3NOYW1lKSkgeyByZXR1cm4gZmFsc2U7IH0vL2lmIHRoaXMgaXMgYWN0aXZlLCBraWNrIG91dCBvZiBmdW5jdGlvbi5cbiAgICAgICAgICB2YXIgaWR4ID0gJCh0aGlzKS5kYXRhKCdzbGlkZScpLFxuICAgICAgICAgIGx0ciA9IGlkeCA+IF90aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZGF0YSgnc2xpZGUnKSxcbiAgICAgICAgICAkc2xpZGUgPSBfdGhpcy4kc2xpZGVzLmVxKGlkeCk7XG5cbiAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShsdHIsICRzbGlkZSwgaWR4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJHdyYXBwZXIuYWRkKHRoaXMuJGJ1bGxldHMpLm9uKCdrZXlkb3duLnpmLm9yYml0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBoYW5kbGUga2V5Ym9hcmQgZXZlbnQgd2l0aCBrZXlib2FyZCB1dGlsXG4gICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdPcmJpdCcsIHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKHRydWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24oKSB7IC8vIGlmIGJ1bGxldCBpcyBmb2N1c2VkLCBtYWtlIHN1cmUgZm9jdXMgbW92ZXNcbiAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyhfdGhpcy4kYnVsbGV0cykpIHtcbiAgICAgICAgICAgICAgX3RoaXMuJGJ1bGxldHMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogQ2hhbmdlcyB0aGUgY3VycmVudCBzbGlkZSB0byBhIG5ldyBvbmUuXG4gICogQGZ1bmN0aW9uXG4gICogQHBhcmFtIHtCb29sZWFufSBpc0xUUiAtIGZsYWcgaWYgdGhlIHNsaWRlIHNob3VsZCBtb3ZlIGxlZnQgdG8gcmlnaHQuXG4gICogQHBhcmFtIHtqUXVlcnl9IGNob3NlblNsaWRlIC0gdGhlIGpRdWVyeSBlbGVtZW50IG9mIHRoZSBzbGlkZSB0byBzaG93IG5leHQsIGlmIG9uZSBpcyBzZWxlY3RlZC5cbiAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBuZXcgc2xpZGUgaW4gaXRzIGNvbGxlY3Rpb24sIGlmIG9uZSBjaG9zZW4uXG4gICogQGZpcmVzIE9yYml0I3NsaWRlY2hhbmdlXG4gICovXG4gIGNoYW5nZVNsaWRlKGlzTFRSLCBjaG9zZW5TbGlkZSwgaWR4KSB7XG4gICAgdmFyICRjdXJTbGlkZSA9IHRoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKS5lcSgwKTtcblxuICAgIGlmICgvbXVpL2cudGVzdCgkY3VyU2xpZGVbMF0uY2xhc3NOYW1lKSkgeyByZXR1cm4gZmFsc2U7IH0gLy9pZiB0aGUgc2xpZGUgaXMgY3VycmVudGx5IGFuaW1hdGluZywga2ljayBvdXQgb2YgdGhlIGZ1bmN0aW9uXG5cbiAgICB2YXIgJGZpcnN0U2xpZGUgPSB0aGlzLiRzbGlkZXMuZmlyc3QoKSxcbiAgICAkbGFzdFNsaWRlID0gdGhpcy4kc2xpZGVzLmxhc3QoKSxcbiAgICBkaXJJbiA9IGlzTFRSID8gJ1JpZ2h0JyA6ICdMZWZ0JyxcbiAgICBkaXJPdXQgPSBpc0xUUiA/ICdMZWZ0JyA6ICdSaWdodCcsXG4gICAgX3RoaXMgPSB0aGlzLFxuICAgICRuZXdTbGlkZTtcblxuICAgIGlmICghY2hvc2VuU2xpZGUpIHsgLy9tb3N0IG9mIHRoZSB0aW1lLCB0aGlzIHdpbGwgYmUgYXV0byBwbGF5ZWQgb3IgY2xpY2tlZCBmcm9tIHRoZSBuYXZCdXR0b25zLlxuICAgICAgJG5ld1NsaWRlID0gaXNMVFIgPyAvL2lmIHdyYXBwaW5nIGVuYWJsZWQsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGBuZXh0YCBvciBgcHJldmAgc2libGluZywgaWYgbm90LCBzZWxlY3QgdGhlIGZpcnN0IG9yIGxhc3Qgc2xpZGUgdG8gZmlsbCBpbi4gaWYgd3JhcHBpbmcgbm90IGVuYWJsZWQsIGF0dGVtcHQgdG8gc2VsZWN0IGBuZXh0YCBvciBgcHJldmAsIGlmIHRoZXJlJ3Mgbm90aGluZyB0aGVyZSwgdGhlIGZ1bmN0aW9uIHdpbGwga2ljayBvdXQgb24gbmV4dCBzdGVwLiBDUkFaWSBORVNURUQgVEVSTkFSSUVTISEhISFcbiAgICAgICh0aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwID8gJGN1clNsaWRlLm5leHQoYC4ke3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzfWApLmxlbmd0aCA/ICRjdXJTbGlkZS5uZXh0KGAuJHt0aGlzLm9wdGlvbnMuc2xpZGVDbGFzc31gKSA6ICRmaXJzdFNsaWRlIDogJGN1clNsaWRlLm5leHQoYC4ke3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzfWApKS8vcGljayBuZXh0IHNsaWRlIGlmIG1vdmluZyBsZWZ0IHRvIHJpZ2h0XG4gICAgICA6XG4gICAgICAodGhpcy5vcHRpb25zLmluZmluaXRlV3JhcCA/ICRjdXJTbGlkZS5wcmV2KGAuJHt0aGlzLm9wdGlvbnMuc2xpZGVDbGFzc31gKS5sZW5ndGggPyAkY3VyU2xpZGUucHJldihgLiR7dGhpcy5vcHRpb25zLnNsaWRlQ2xhc3N9YCkgOiAkbGFzdFNsaWRlIDogJGN1clNsaWRlLnByZXYoYC4ke3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzfWApKTsvL3BpY2sgcHJldiBzbGlkZSBpZiBtb3ZpbmcgcmlnaHQgdG8gbGVmdFxuICAgIH0gZWxzZSB7XG4gICAgICAkbmV3U2xpZGUgPSBjaG9zZW5TbGlkZTtcbiAgICB9XG5cbiAgICBpZiAoJG5ld1NsaWRlLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRzKSB7XG4gICAgICAgIGlkeCA9IGlkeCB8fCB0aGlzLiRzbGlkZXMuaW5kZXgoJG5ld1NsaWRlKTsgLy9ncmFiIGluZGV4IHRvIHVwZGF0ZSBidWxsZXRzXG4gICAgICAgIHRoaXMuX3VwZGF0ZUJ1bGxldHMoaWR4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VNVUkpIHtcbiAgICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKFxuICAgICAgICAgICRuZXdTbGlkZS5hZGRDbGFzcygnaXMtYWN0aXZlJykuY3NzKHsncG9zaXRpb24nOiAnYWJzb2x1dGUnLCAndG9wJzogMH0pLFxuICAgICAgICAgIHRoaXMub3B0aW9uc1tgYW5pbUluRnJvbSR7ZGlySW59YF0sXG4gICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICRuZXdTbGlkZS5jc3Moeydwb3NpdGlvbic6ICdyZWxhdGl2ZScsICdkaXNwbGF5JzogJ2Jsb2NrJ30pXG4gICAgICAgICAgICAuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KFxuICAgICAgICAgICRjdXJTbGlkZS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyksXG4gICAgICAgICAgdGhpcy5vcHRpb25zW2BhbmltT3V0VG8ke2Rpck91dH1gXSxcbiAgICAgICAgICBmdW5jdGlvbigpe1xuICAgICAgICAgICAgJGN1clNsaWRlLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpO1xuICAgICAgICAgICAgaWYoX3RoaXMub3B0aW9ucy5hdXRvUGxheSAmJiAhX3RoaXMudGltZXIuaXNQYXVzZWQpe1xuICAgICAgICAgICAgICBfdGhpcy50aW1lci5yZXN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2RvIHN0dWZmP1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGN1clNsaWRlLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtaW4nKS5yZW1vdmVBdHRyKCdhcmlhLWxpdmUnKS5oaWRlKCk7XG4gICAgICAgICRuZXdTbGlkZS5hZGRDbGFzcygnaXMtYWN0aXZlIGlzLWluJykuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpLnNob3coKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUGxheSAmJiAhdGhpcy50aW1lci5pc1BhdXNlZCkge1xuICAgICAgICAgIHRoaXMudGltZXIucmVzdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgLyoqXG4gICAgKiBUcmlnZ2VycyB3aGVuIHRoZSBzbGlkZSBoYXMgZmluaXNoZWQgYW5pbWF0aW5nIGluLlxuICAgICogQGV2ZW50IE9yYml0I3NsaWRlY2hhbmdlXG4gICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2xpZGVjaGFuZ2UuemYub3JiaXQnLCBbJG5ld1NsaWRlXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogVXBkYXRlcyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBidWxsZXRzLCBpZiBkaXNwbGF5ZWQuXG4gICogQGZ1bmN0aW9uXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHNsaWRlLlxuICAqL1xuICBfdXBkYXRlQnVsbGV0cyhpZHgpIHtcbiAgICB2YXIgJG9sZEJ1bGxldCA9IHRoaXMuJGVsZW1lbnQuZmluZChgLiR7dGhpcy5vcHRpb25zLmJveE9mQnVsbGV0c31gKVxuICAgIC5maW5kKCcuaXMtYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmJsdXIoKSxcbiAgICBzcGFuID0gJG9sZEJ1bGxldC5maW5kKCdzcGFuOmxhc3QnKS5kZXRhY2goKSxcbiAgICAkbmV3QnVsbGV0ID0gdGhpcy4kYnVsbGV0cy5lcShpZHgpLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hcHBlbmQoc3Bhbik7XG4gIH1cblxuICAvKipcbiAgKiBEZXN0cm95cyB0aGUgY2Fyb3VzZWwgYW5kIGhpZGVzIHRoZSBlbGVtZW50LlxuICAqIEBmdW5jdGlvblxuICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYub3JiaXQnKS5maW5kKCcqJykub2ZmKCcuemYub3JiaXQnKS5lbmQoKS5oaWRlKCk7XG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG59XG5cbk9yYml0LmRlZmF1bHRzID0ge1xuICAvKipcbiAgKiBUZWxscyB0aGUgSlMgdG8gbG9vayBmb3IgYW5kIGxvYWRCdWxsZXRzLlxuICAqIEBvcHRpb25cbiAgKiBAZXhhbXBsZSB0cnVlXG4gICovXG4gIGJ1bGxldHM6IHRydWUsXG4gIC8qKlxuICAqIFRlbGxzIHRoZSBKUyB0byBhcHBseSBldmVudCBsaXN0ZW5lcnMgdG8gbmF2IGJ1dHRvbnNcbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgdHJ1ZVxuICAqL1xuICBuYXZCdXR0b25zOiB0cnVlLFxuICAvKipcbiAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlICdzbGlkZS1pbi1yaWdodCdcbiAgKi9cbiAgYW5pbUluRnJvbVJpZ2h0OiAnc2xpZGUtaW4tcmlnaHQnLFxuICAvKipcbiAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlICdzbGlkZS1vdXQtcmlnaHQnXG4gICovXG4gIGFuaW1PdXRUb1JpZ2h0OiAnc2xpZGUtb3V0LXJpZ2h0JyxcbiAgLyoqXG4gICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxuICAqIEBvcHRpb25cbiAgKiBAZXhhbXBsZSAnc2xpZGUtaW4tbGVmdCdcbiAgKlxuICAqL1xuICBhbmltSW5Gcm9tTGVmdDogJ3NsaWRlLWluLWxlZnQnLFxuICAvKipcbiAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlICdzbGlkZS1vdXQtbGVmdCdcbiAgKi9cbiAgYW5pbU91dFRvTGVmdDogJ3NsaWRlLW91dC1sZWZ0JyxcbiAgLyoqXG4gICogQWxsb3dzIE9yYml0IHRvIGF1dG9tYXRpY2FsbHkgYW5pbWF0ZSBvbiBwYWdlIGxvYWQuXG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlIHRydWVcbiAgKi9cbiAgYXV0b1BsYXk6IHRydWUsXG4gIC8qKlxuICAqIEFtb3VudCBvZiB0aW1lLCBpbiBtcywgYmV0d2VlbiBzbGlkZSB0cmFuc2l0aW9uc1xuICAqIEBvcHRpb25cbiAgKiBAZXhhbXBsZSA1MDAwXG4gICovXG4gIHRpbWVyRGVsYXk6IDUwMDAsXG4gIC8qKlxuICAqIEFsbG93cyBPcmJpdCB0byBpbmZpbml0ZWx5IGxvb3AgdGhyb3VnaCB0aGUgc2xpZGVzXG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlIHRydWVcbiAgKi9cbiAgaW5maW5pdGVXcmFwOiB0cnVlLFxuICAvKipcbiAgKiBBbGxvd3MgdGhlIE9yYml0IHNsaWRlcyB0byBiaW5kIHRvIHN3aXBlIGV2ZW50cyBmb3IgbW9iaWxlLCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHV0aWwgbGlicmFyeVxuICAqIEBvcHRpb25cbiAgKiBAZXhhbXBsZSB0cnVlXG4gICovXG4gIHN3aXBlOiB0cnVlLFxuICAvKipcbiAgKiBBbGxvd3MgdGhlIHRpbWluZyBmdW5jdGlvbiB0byBwYXVzZSBhbmltYXRpb24gb24gaG92ZXIuXG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlIHRydWVcbiAgKi9cbiAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICAvKipcbiAgKiBBbGxvd3MgT3JiaXQgdG8gYmluZCBrZXlib2FyZCBldmVudHMgdG8gdGhlIHNsaWRlciwgdG8gYW5pbWF0ZSBmcmFtZXMgd2l0aCBhcnJvdyBrZXlzXG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlIHRydWVcbiAgKi9cbiAgYWNjZXNzaWJsZTogdHJ1ZSxcbiAgLyoqXG4gICogQ2xhc3MgYXBwbGllZCB0byB0aGUgY29udGFpbmVyIG9mIE9yYml0XG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlICdvcmJpdC1jb250YWluZXInXG4gICovXG4gIGNvbnRhaW5lckNsYXNzOiAnb3JiaXQtY29udGFpbmVyJyxcbiAgLyoqXG4gICogQ2xhc3MgYXBwbGllZCB0byBpbmRpdmlkdWFsIHNsaWRlcy5cbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgJ29yYml0LXNsaWRlJ1xuICAqL1xuICBzbGlkZUNsYXNzOiAnb3JiaXQtc2xpZGUnLFxuICAvKipcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBidWxsZXQgY29udGFpbmVyLiBZb3UncmUgd2VsY29tZS5cbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgJ29yYml0LWJ1bGxldHMnXG4gICovXG4gIGJveE9mQnVsbGV0czogJ29yYml0LWJ1bGxldHMnLFxuICAvKipcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBgbmV4dGAgbmF2aWdhdGlvbiBidXR0b24uXG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlICdvcmJpdC1uZXh0J1xuICAqL1xuICBuZXh0Q2xhc3M6ICdvcmJpdC1uZXh0JyxcbiAgLyoqXG4gICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYHByZXZpb3VzYCBuYXZpZ2F0aW9uIGJ1dHRvbi5cbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgJ29yYml0LXByZXZpb3VzJ1xuICAqL1xuICBwcmV2Q2xhc3M6ICdvcmJpdC1wcmV2aW91cycsXG4gIC8qKlxuICAqIEJvb2xlYW4gdG8gZmxhZyB0aGUganMgdG8gdXNlIG1vdGlvbiB1aSBjbGFzc2VzIG9yIG5vdC4gRGVmYXVsdCB0byB0cnVlIGZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eS5cbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgdHJ1ZVxuICAqL1xuICB1c2VNVUk6IHRydWVcbn07XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihPcmJpdCwgJ09yYml0Jyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBSZXNwb25zaXZlTWVudSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnVcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5hY2NvcmRpb25NZW51XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmRyaWxsZG93blxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5kcm9wZG93bi1tZW51XG4gKi9cblxuY2xhc3MgUmVzcG9uc2l2ZU1lbnUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHJlc3BvbnNpdmUgbWVudS5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBSZXNwb25zaXZlTWVudSNpbml0XG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93biBtZW51LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgdGhpcy5ydWxlcyA9IHRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS1tZW51Jyk7XG4gICAgdGhpcy5jdXJyZW50TXEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG51bGw7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gICAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdSZXNwb25zaXZlTWVudScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBNZW51IGJ5IHBhcnNpbmcgdGhlIGNsYXNzZXMgZnJvbSB0aGUgJ2RhdGEtUmVzcG9uc2l2ZU1lbnUnIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICAvLyBUaGUgZmlyc3QgdGltZSBhbiBJbnRlcmNoYW5nZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQsIHRoaXMucnVsZXMgaXMgY29udmVydGVkIGZyb20gYSBzdHJpbmcgb2YgXCJjbGFzc2VzXCIgdG8gYW4gb2JqZWN0IG9mIHJ1bGVzXG4gICAgaWYgKHR5cGVvZiB0aGlzLnJ1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IHJ1bGVzVHJlZSA9IHt9O1xuXG4gICAgICAvLyBQYXJzZSBydWxlcyBmcm9tIFwiY2xhc3Nlc1wiIHB1bGxlZCBmcm9tIGRhdGEgYXR0cmlidXRlXG4gICAgICBsZXQgcnVsZXMgPSB0aGlzLnJ1bGVzLnNwbGl0KCcgJyk7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBldmVyeSBydWxlIGZvdW5kXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBydWxlID0gcnVsZXNbaV0uc3BsaXQoJy0nKTtcbiAgICAgICAgbGV0IHJ1bGVTaXplID0gcnVsZS5sZW5ndGggPiAxID8gcnVsZVswXSA6ICdzbWFsbCc7XG4gICAgICAgIGxldCBydWxlUGx1Z2luID0gcnVsZS5sZW5ndGggPiAxID8gcnVsZVsxXSA6IHJ1bGVbMF07XG5cbiAgICAgICAgaWYgKE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dICE9PSBudWxsKSB7XG4gICAgICAgICAgcnVsZXNUcmVlW3J1bGVTaXplXSA9IE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucnVsZXMgPSBydWxlc1RyZWU7XG4gICAgfVxuXG4gICAgaWYgKCEkLmlzRW1wdHlPYmplY3QodGhpcy5ydWxlcykpIHtcbiAgICAgIHRoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIE1lbnUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V2ZW50cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xuICAgIH0pO1xuICAgIC8vICQod2luZG93KS5vbigncmVzaXplLnpmLlJlc3BvbnNpdmVNZW51JywgZnVuY3Rpb24oKSB7XG4gICAgLy8gICBfdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcbiAgICAvLyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgc2NyZWVuIHdpZHRoIGFnYWluc3QgYXZhaWxhYmxlIG1lZGlhIHF1ZXJpZXMuIElmIHRoZSBtZWRpYSBxdWVyeSBoYXMgY2hhbmdlZCwgYW5kIHRoZSBwbHVnaW4gbmVlZGVkIGhhcyBjaGFuZ2VkLCB0aGUgcGx1Z2lucyB3aWxsIHN3YXAgb3V0LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja01lZGlhUXVlcmllcygpIHtcbiAgICB2YXIgbWF0Y2hlZE1xLCBfdGhpcyA9IHRoaXM7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSBhbmQgZmluZCB0aGUgbGFzdCBtYXRjaGluZyBydWxlXG4gICAgJC5lYWNoKHRoaXMucnVsZXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KGtleSkpIHtcbiAgICAgICAgbWF0Y2hlZE1xID0ga2V5O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTm8gbWF0Y2g/IE5vIGRpY2VcbiAgICBpZiAoIW1hdGNoZWRNcSkgcmV0dXJuO1xuXG4gICAgLy8gUGx1Z2luIGFscmVhZHkgaW5pdGlhbGl6ZWQ/IFdlIGdvb2RcbiAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luIGluc3RhbmNlb2YgdGhpcy5ydWxlc1ttYXRjaGVkTXFdLnBsdWdpbikgcmV0dXJuO1xuXG4gICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHBsdWdpbi1zcGVjaWZpYyBDU1MgY2xhc3Nlc1xuICAgICQuZWFjaChNZW51UGx1Z2lucywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgX3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModmFsdWUuY3NzQ2xhc3MpO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIHRoZSBDU1MgY2xhc3MgZm9yIHRoZSBuZXcgcGx1Z2luXG4gICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW21hdGNoZWRNcV0uY3NzQ2xhc3MpO1xuXG4gICAgLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBuZXcgcGx1Z2luXG4gICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbikgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcbiAgICB0aGlzLmN1cnJlbnRQbHVnaW4gPSBuZXcgdGhpcy5ydWxlc1ttYXRjaGVkTXFdLnBsdWdpbih0aGlzLiRlbGVtZW50LCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IHBsdWdpbiBvbiB0aGlzIGVsZW1lbnQsIGFzIHdlbGwgYXMgdGhlIHdpbmRvdyByZXNpemUgaGFuZGxlciB0aGF0IHN3aXRjaGVzIHRoZSBwbHVnaW5zIG91dC5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCk7XG4gICAgJCh3aW5kb3cpLm9mZignLnpmLlJlc3BvbnNpdmVNZW51Jyk7XG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG59XG5cblJlc3BvbnNpdmVNZW51LmRlZmF1bHRzID0ge307XG5cbi8vIFRoZSBwbHVnaW4gbWF0Y2hlcyB0aGUgcGx1Z2luIGNsYXNzZXMgd2l0aCB0aGVzZSBwbHVnaW4gaW5zdGFuY2VzLlxudmFyIE1lbnVQbHVnaW5zID0ge1xuICBkcm9wZG93bjoge1xuICAgIGNzc0NsYXNzOiAnZHJvcGRvd24nLFxuICAgIHBsdWdpbjogRm91bmRhdGlvbi5fcGx1Z2luc1snZHJvcGRvd24tbWVudSddIHx8IG51bGxcbiAgfSxcbiBkcmlsbGRvd246IHtcbiAgICBjc3NDbGFzczogJ2RyaWxsZG93bicsXG4gICAgcGx1Z2luOiBGb3VuZGF0aW9uLl9wbHVnaW5zWydkcmlsbGRvd24nXSB8fCBudWxsXG4gIH0sXG4gIGFjY29yZGlvbjoge1xuICAgIGNzc0NsYXNzOiAnYWNjb3JkaW9uLW1lbnUnLFxuICAgIHBsdWdpbjogRm91bmRhdGlvbi5fcGx1Z2luc1snYWNjb3JkaW9uLW1lbnUnXSB8fCBudWxsXG4gIH1cbn07XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlTWVudSwgJ1Jlc3BvbnNpdmVNZW51Jyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBSZXNwb25zaXZlVG9nZ2xlIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXNwb25zaXZlVG9nZ2xlXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqL1xuXG5jbGFzcyBSZXNwb25zaXZlVG9nZ2xlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVGFiIEJhci5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBSZXNwb25zaXZlVG9nZ2xlI2luaXRcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGF0dGFjaCB0YWIgYmFyIGZ1bmN0aW9uYWxpdHkgdG8uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgUmVzcG9uc2l2ZVRvZ2dsZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnUmVzcG9uc2l2ZVRvZ2dsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSB0YWIgYmFyIGJ5IGZpbmRpbmcgdGhlIHRhcmdldCBlbGVtZW50LCB0b2dnbGluZyBlbGVtZW50LCBhbmQgcnVubmluZyB1cGRhdGUoKS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgdGFyZ2V0SUQgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3Jlc3BvbnNpdmUtdG9nZ2xlJyk7XG4gICAgaWYgKCF0YXJnZXRJRCkge1xuICAgICAgY29uc29sZS5lcnJvcignWW91ciB0YWIgYmFyIG5lZWRzIGFuIElEIG9mIGEgTWVudSBhcyB0aGUgdmFsdWUgb2YgZGF0YS10YWItYmFyLicpO1xuICAgIH1cblxuICAgIHRoaXMuJHRhcmdldE1lbnUgPSAkKGAjJHt0YXJnZXRJRH1gKTtcbiAgICB0aGlzLiR0b2dnbGVyID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS10b2dnbGVdJyk7XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyBmb3IgdGhlIHRhYiBiYXIgdG8gd29yay5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl91cGRhdGVNcUhhbmRsZXIgPSB0aGlzLl91cGRhdGUuYmluZCh0aGlzKTtcbiAgICBcbiAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX3VwZGF0ZU1xSGFuZGxlcik7XG5cbiAgICB0aGlzLiR0b2dnbGVyLm9uKCdjbGljay56Zi5yZXNwb25zaXZlVG9nZ2xlJywgdGhpcy50b2dnbGVNZW51LmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgY3VycmVudCBtZWRpYSBxdWVyeSB0byBkZXRlcm1pbmUgaWYgdGhlIHRhYiBiYXIgc2hvdWxkIGJlIHZpc2libGUgb3IgaGlkZGVuLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGUoKSB7XG4gICAgLy8gTW9iaWxlXG4gICAgaWYgKCFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuc2hvdygpO1xuICAgICAgdGhpcy4kdGFyZ2V0TWVudS5oaWRlKCk7XG4gICAgfVxuXG4gICAgLy8gRGVza3RvcFxuICAgIGVsc2Uge1xuICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKCk7XG4gICAgICB0aGlzLiR0YXJnZXRNZW51LnNob3coKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgZWxlbWVudCBhdHRhY2hlZCB0byB0aGUgdGFiIGJhci4gVGhlIHRvZ2dsZSBvbmx5IGhhcHBlbnMgaWYgdGhlIHNjcmVlbiBpcyBzbWFsbCBlbm91Z2ggdG8gYWxsb3cgaXQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAZmlyZXMgUmVzcG9uc2l2ZVRvZ2dsZSN0b2dnbGVkXG4gICAqL1xuICB0b2dnbGVNZW51KCkgeyAgIFxuICAgIGlmICghRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmhpZGVGb3IpKSB7XG4gICAgICB0aGlzLiR0YXJnZXRNZW51LnRvZ2dsZSgwKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyIHRvZ2dsZXMuXG4gICAgICAgKiBAZXZlbnQgUmVzcG9uc2l2ZVRvZ2dsZSN0b2dnbGVkXG4gICAgICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigndG9nZ2xlZC56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XG4gICAgfVxuICB9O1xuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XG4gICAgdGhpcy4kdG9nZ2xlci5vZmYoJy56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XG4gICAgXG4gICAgJCh3aW5kb3cpLm9mZignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fdXBkYXRlTXFIYW5kbGVyKTtcbiAgICBcbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cbn1cblxuUmVzcG9uc2l2ZVRvZ2dsZS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFRoZSBicmVha3BvaW50IGFmdGVyIHdoaWNoIHRoZSBtZW51IGlzIGFsd2F5cyBzaG93biwgYW5kIHRoZSB0YWIgYmFyIGlzIGhpZGRlbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnbWVkaXVtJ1xuICAgKi9cbiAgaGlkZUZvcjogJ21lZGl1bSdcbn07XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlVG9nZ2xlLCAnUmVzcG9uc2l2ZVRvZ2dsZScpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogUmV2ZWFsIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXZlYWxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uIGlmIHVzaW5nIGFuaW1hdGlvbnNcbiAqL1xuXG5jbGFzcyBSZXZlYWwge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXZlYWwuXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGZvciB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgUmV2ZWFsLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnUmV2ZWFsJyk7XG4gICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignUmV2ZWFsJywge1xuICAgICAgJ0VOVEVSJzogJ29wZW4nLFxuICAgICAgJ1NQQUNFJzogJ29wZW4nLFxuICAgICAgJ0VTQ0FQRSc6ICdjbG9zZScsXG4gICAgICAnVEFCJzogJ3RhYl9mb3J3YXJkJyxcbiAgICAgICdTSElGVF9UQUInOiAndGFiX2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2RhbCBieSBhZGRpbmcgdGhlIG92ZXJsYXkgYW5kIGNsb3NlIGJ1dHRvbnMsIChpZiBzZWxlY3RlZCkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB0aGlzLmlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xuICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNhY2hlZCA9IHttcTogRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmN1cnJlbnR9O1xuICAgIHRoaXMuaXNNb2JpbGUgPSBtb2JpbGVTbmlmZigpO1xuXG4gICAgdGhpcy4kYW5jaG9yID0gJChgW2RhdGEtb3Blbj1cIiR7dGhpcy5pZH1cIl1gKS5sZW5ndGggPyAkKGBbZGF0YS1vcGVuPVwiJHt0aGlzLmlkfVwiXWApIDogJChgW2RhdGEtdG9nZ2xlPVwiJHt0aGlzLmlkfVwiXWApO1xuICAgIHRoaXMuJGFuY2hvci5hdHRyKHtcbiAgICAgICdhcmlhLWNvbnRyb2xzJzogdGhpcy5pZCxcbiAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcbiAgICAgICd0YWJpbmRleCc6IDBcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbiB8fCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmdWxsJykpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuID0gdHJ1ZTtcbiAgICAgIHRoaXMub3B0aW9ucy5vdmVybGF5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiAhdGhpcy4kb3ZlcmxheSkge1xuICAgICAgdGhpcy4kb3ZlcmxheSA9IHRoaXMuX21ha2VPdmVybGF5KHRoaXMuaWQpO1xuICAgIH1cblxuICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAgICdyb2xlJzogJ2RpYWxvZycsXG4gICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAgICdkYXRhLXlldGktYm94JzogdGhpcy5pZCxcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogdGhpcy5pZFxuICAgIH0pO1xuXG4gICAgaWYodGhpcy4kb3ZlcmxheSkge1xuICAgICAgdGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyh0aGlzLiRvdmVybGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbygkKCdib2R5JykpO1xuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnd2l0aG91dC1vdmVybGF5Jyk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmsgJiYgd2luZG93LmxvY2F0aW9uLmhhc2ggPT09ICggYCMke3RoaXMuaWR9YCkpIHtcbiAgICAgICQod2luZG93KS5vbmUoJ2xvYWQuemYucmV2ZWFsJywgdGhpcy5vcGVuLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkgZGl2IHRvIGRpc3BsYXkgYmVoaW5kIHRoZSBtb2RhbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlT3ZlcmxheShpZCkge1xuICAgIHZhciAkb3ZlcmxheSA9ICQoJzxkaXY+PC9kaXY+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdyZXZlYWwtb3ZlcmxheScpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbygnYm9keScpO1xuICAgIHJldHVybiAkb3ZlcmxheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHBvc2l0aW9uIG9mIG1vZGFsXG4gICAqIFRPRE86ICBGaWd1cmUgb3V0IGlmIHdlIGFjdHVhbGx5IG5lZWQgdG8gY2FjaGUgdGhlc2UgdmFsdWVzIG9yIGlmIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy4kZWxlbWVudC5vdXRlcldpZHRoKCk7XG4gICAgdmFyIG91dGVyV2lkdGggPSAkKHdpbmRvdykud2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy4kZWxlbWVudC5vdXRlckhlaWdodCgpO1xuICAgIHZhciBvdXRlckhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKTtcbiAgICB2YXIgbGVmdCwgdG9wO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaE9mZnNldCA9PT0gJ2F1dG8nKSB7XG4gICAgICBsZWZ0ID0gcGFyc2VJbnQoKG91dGVyV2lkdGggLSB3aWR0aCkgLyAyLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMuaE9mZnNldCwgMTApO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnZPZmZzZXQgPT09ICdhdXRvJykge1xuICAgICAgaWYgKGhlaWdodCA+IG91dGVySGVpZ2h0KSB7XG4gICAgICAgIHRvcCA9IHBhcnNlSW50KE1hdGgubWluKDEwMCwgb3V0ZXJIZWlnaHQgLyAxMCksIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvcCA9IHBhcnNlSW50KChvdXRlckhlaWdodCAtIGhlaWdodCkgLyA0LCAxMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy52T2Zmc2V0LCAxMCk7XG4gICAgfVxuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHt0b3A6IHRvcCArICdweCd9KTtcbiAgICAvLyBvbmx5IHdvcnJ5IGFib3V0IGxlZnQgaWYgd2UgZG9uJ3QgaGF2ZSBhbiBvdmVybGF5IG9yIHdlIGhhdmVhICBob3Jpem9udGFsIG9mZnNldCxcbiAgICAvLyBvdGhlcndpc2Ugd2UncmUgcGVyZmVjdGx5IGluIHRoZSBtaWRkbGVcbiAgICBpZighdGhpcy4kb3ZlcmxheSB8fCAodGhpcy5vcHRpb25zLmhPZmZzZXQgIT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtsZWZ0OiBsZWZ0ICsgJ3B4J30pO1xuICAgICAgdGhpcy4kZWxlbWVudC5jc3Moe21hcmdpbjogJzBweCd9KTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgbW9kYWwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLiRlbGVtZW50Lm9uKHtcbiAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcbiAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogKGV2ZW50LCAkZWxlbWVudCkgPT4ge1xuICAgICAgICBpZiAoKGV2ZW50LnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0pIHx8XG4gICAgICAgICAgICAoJChldmVudC50YXJnZXQpLnBhcmVudHMoJ1tkYXRhLWNsb3NhYmxlXScpWzBdID09PSAkZWxlbWVudCkpIHsgLy8gb25seSBjbG9zZSByZXZlYWwgd2hlbiBpdCdzIGV4cGxpY2l0bHkgY2FsbGVkXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UuYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxuICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy4kYW5jaG9yLmxlbmd0aCkge1xuICAgICAgdGhpcy4kYW5jaG9yLm9uKCdrZXlkb3duLnpmLnJldmVhbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUud2hpY2ggPT09IDEzIHx8IGUud2hpY2ggPT09IDMyKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgX3RoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiB0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgdGhpcy4kb3ZlcmxheS5vZmYoJy56Zi5yZXZlYWwnKS5vbignY2xpY2suemYucmV2ZWFsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8ICQuY29udGFpbnMoX3RoaXMuJGVsZW1lbnRbMF0sIGUudGFyZ2V0KSkgeyByZXR1cm47IH1cbiAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XG4gICAgICAkKHdpbmRvdykub24oYHBvcHN0YXRlLnpmLnJldmVhbDoke3RoaXMuaWR9YCwgdGhpcy5faGFuZGxlU3RhdGUuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgbW9kYWwgbWV0aG9kcyBvbiBiYWNrL2ZvcndhcmQgYnV0dG9uIGNsaWNrcyBvciBhbnkgb3RoZXIgZXZlbnQgdGhhdCB0cmlnZ2VycyBwb3BzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVTdGF0ZShlKSB7XG4gICAgaWYod2luZG93LmxvY2F0aW9uLmhhc2ggPT09ICggJyMnICsgdGhpcy5pZCkgJiYgIXRoaXMuaXNBY3RpdmUpeyB0aGlzLm9wZW4oKTsgfVxuICAgIGVsc2V7IHRoaXMuY2xvc2UoKTsgfVxuICB9XG5cblxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsIGNvbnRyb2xsZWQgYnkgYHRoaXMuJGFuY2hvcmAsIGFuZCBjbG9zZXMgYWxsIG90aGVycyBieSBkZWZhdWx0LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIFJldmVhbCNjbG9zZW1lXG4gICAqIEBmaXJlcyBSZXZlYWwjb3BlblxuICAgKi9cbiAgb3BlbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XG4gICAgICB2YXIgaGFzaCA9IGAjJHt0aGlzLmlkfWA7XG5cbiAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIGhhc2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgLy8gTWFrZSBlbGVtZW50cyBpbnZpc2libGUsIGJ1dCByZW1vdmUgZGlzcGxheTogbm9uZSBzbyB3ZSBjYW4gZ2V0IHNpemUgYW5kIHBvc2l0aW9uaW5nXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAuY3NzKHsgJ3Zpc2liaWxpdHknOiAnaGlkZGVuJyB9KVxuICAgICAgICAuc2hvdygpXG4gICAgICAgIC5zY3JvbGxUb3AoMCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICB0aGlzLiRvdmVybGF5LmNzcyh7J3Zpc2liaWxpdHknOiAnaGlkZGVuJ30pLnNob3coKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLmhpZGUoKVxuICAgICAgLmNzcyh7ICd2aXNpYmlsaXR5JzogJycgfSk7XG5cbiAgICBpZih0aGlzLiRvdmVybGF5KSB7XG4gICAgICB0aGlzLiRvdmVybGF5LmNzcyh7J3Zpc2liaWxpdHknOiAnJ30pLmhpZGUoKTtcbiAgICAgIGlmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2Zhc3QnKSkge1xuICAgICAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdmYXN0Jyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3Nsb3cnKSkge1xuICAgICAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdzbG93Jyk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aXBsZU9wZW5lZCkge1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIG1vZGFsIG9wZW5zLlxuICAgICAgICogQ2xvc2VzIGFueSBvdGhlciBtb2RhbHMgdGhhdCBhcmUgY3VycmVudGx5IG9wZW5cbiAgICAgICAqIEBldmVudCBSZXZlYWwjY2xvc2VtZVxuICAgICAgICovXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYucmV2ZWFsJywgdGhpcy5pZCk7XG4gICAgfVxuICAgIC8vIE1vdGlvbiBVSSBtZXRob2Qgb2YgcmV2ZWFsXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb25Jbikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGFmdGVyQW5pbWF0aW9uRm9jdXMoKXtcbiAgICAgICAgX3RoaXMuJGVsZW1lbnRcbiAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZSxcbiAgICAgICAgICAgICd0YWJpbmRleCc6IC0xXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZm9jdXMoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnZm9jdXMnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4odGhpcy4kb3ZlcmxheSwgJ2ZhZGUtaW4nKTtcbiAgICAgIH1cbiAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbih0aGlzLiRlbGVtZW50LCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uSW4sICgpID0+IHtcbiAgICAgICAgdGhpcy5mb2N1c2FibGVFbGVtZW50cyA9IEZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgYWZ0ZXJBbmltYXRpb25Gb2N1cygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGpRdWVyeSBtZXRob2Qgb2YgcmV2ZWFsXG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5zaG93KDApO1xuICAgICAgfVxuICAgICAgdGhpcy4kZWxlbWVudC5zaG93KHRoaXMub3B0aW9ucy5zaG93RGVsYXkpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBhY2Nlc3NpYmlsaXR5XG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLmF0dHIoe1xuICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZSxcbiAgICAgICAgJ3RhYmluZGV4JzogLTFcbiAgICAgIH0pXG4gICAgICAuZm9jdXMoKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIG1vZGFsIGhhcyBzdWNjZXNzZnVsbHkgb3BlbmVkLlxuICAgICAqIEBldmVudCBSZXZlYWwjb3BlblxuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb3Blbi56Zi5yZXZlYWwnKTtcblxuICAgIGlmICh0aGlzLmlzTW9iaWxlKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgJCgnaHRtbCwgYm9keScpLmFkZENsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICQoJ2JvZHknKS5hZGRDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKTtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2V4dHJhSGFuZGxlcnMoKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGV4dHJhIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgYm9keSBhbmQgd2luZG93IGlmIG5lY2Vzc2FyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9leHRyYUhhbmRsZXJzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5mb2N1c2FibGVFbGVtZW50cyA9IEZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLm92ZXJsYXkgJiYgdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiAhdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4pIHtcbiAgICAgICQoJ2JvZHknKS5vbignY2xpY2suemYucmV2ZWFsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8ICQuY29udGFpbnMoX3RoaXMuJGVsZW1lbnRbMF0sIGUudGFyZ2V0KSkgeyByZXR1cm47IH1cbiAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xuICAgICAgJCh3aW5kb3cpLm9uKCdrZXlkb3duLnpmLnJldmVhbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ1JldmVhbCcsIHtcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jbG9zZU9uRXNjKSB7XG4gICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gbG9jayBmb2N1cyB3aXRoaW4gbW9kYWwgd2hpbGUgdGFiYmluZ1xuICAgIHRoaXMuJGVsZW1lbnQub24oJ2tleWRvd24uemYucmV2ZWFsJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyICR0YXJnZXQgPSAkKHRoaXMpO1xuICAgICAgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ1JldmVhbCcsIHtcbiAgICAgICAgdGFiX2ZvcndhcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5maW5kKCc6Zm9jdXMnKS5pcyhfdGhpcy5mb2N1c2FibGVFbGVtZW50cy5lcSgtMSkpKSB7IC8vIGxlZnQgbW9kYWwgZG93bndhcmRzLCBzZXR0aW5nIGZvY3VzIHRvIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgIF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzLmVxKDApLmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCA9PT0gMCkgeyAvLyBubyBmb2N1c2FibGUgZWxlbWVudHMgaW5zaWRlIHRoZSBtb2RhbCBhdCBhbGwsIHByZXZlbnQgdGFiYmluZyBpbiBnZW5lcmFsXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRhYl9iYWNrd2FyZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKF90aGlzLiRlbGVtZW50LmZpbmQoJzpmb2N1cycpLmlzKF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzLmVxKDApKSB8fCBfdGhpcy4kZWxlbWVudC5pcygnOmZvY3VzJykpIHsgLy8gbGVmdCBtb2RhbCB1cHdhcmRzLCBzZXR0aW5nIGZvY3VzIHRvIGxhc3QgZWxlbWVudFxuICAgICAgICAgICAgX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpLmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCA9PT0gMCkgeyAvLyBubyBmb2N1c2FibGUgZWxlbWVudHMgaW5zaWRlIHRoZSBtb2RhbCBhdCBhbGwsIHByZXZlbnQgdGFiYmluZyBpbiBnZW5lcmFsXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5maW5kKCc6Zm9jdXMnKS5pcyhfdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1jbG9zZV0nKSkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IC8vIHNldCBmb2N1cyBiYWNrIHRvIGFuY2hvciBpZiBjbG9zZSBidXR0b24gaGFzIGJlZW4gYWN0aXZhdGVkXG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJHRhcmdldC5pcyhfdGhpcy5mb2N1c2FibGVFbGVtZW50cykpIHsgLy8gZG9udCd0IHRyaWdnZXIgaWYgYWN1YWwgZWxlbWVudCBoYXMgZm9jdXMgKGkuZS4gaW5wdXRzLCBsaW5rcywgLi4uKVxuICAgICAgICAgICAgX3RoaXMub3BlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICBfdGhpcy4kYW5jaG9yLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbihwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBtb2RhbC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBSZXZlYWwjY2xvc2VkXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgIXRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIE1vdGlvbiBVSSBtZXRob2Qgb2YgaGlkaW5nXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb25PdXQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJG92ZXJsYXksICdmYWRlLW91dCcsIGZpbmlzaFVwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmaW5pc2hVcCgpO1xuICAgICAgfVxuXG4gICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsIHRoaXMub3B0aW9ucy5hbmltYXRpb25PdXQpO1xuICAgIH1cbiAgICAvLyBqUXVlcnkgbWV0aG9kIG9mIGhpZGluZ1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgIHRoaXMuJG92ZXJsYXkuaGlkZSgwLCBmaW5pc2hVcCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmluaXNoVXAoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKHRoaXMub3B0aW9ucy5oaWRlRGVsYXkpO1xuICAgIH1cblxuICAgIC8vIENvbmRpdGlvbmFscyB0byByZW1vdmUgZXh0cmEgZXZlbnQgbGlzdGVuZXJzIGFkZGVkIG9uIG9wZW5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcbiAgICAgICQod2luZG93KS5vZmYoJ2tleWRvd24uemYucmV2ZWFsJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICAkKCdib2R5Jykub2ZmKCdjbGljay56Zi5yZXZlYWwnKTtcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50Lm9mZigna2V5ZG93bi56Zi5yZXZlYWwnKTtcblxuICAgIGZ1bmN0aW9uIGZpbmlzaFVwKCkge1xuICAgICAgaWYgKF90aGlzLmlzTW9iaWxlKSB7XG4gICAgICAgICQoJ2h0bWwsIGJvZHknKS5yZW1vdmVDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKTtcbiAgICAgICAgaWYoX3RoaXMub3JpZ2luYWxTY3JvbGxQb3MpIHtcbiAgICAgICAgICAkKCdib2R5Jykuc2Nyb2xsVG9wKF90aGlzLm9yaWdpbmFsU2Nyb2xsUG9zKTtcbiAgICAgICAgICBfdGhpcy5vcmlnaW5hbFNjcm9sbFBvcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJyk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG5cbiAgICAgIC8qKlxuICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtb2RhbCBpcyBkb25lIGNsb3NpbmcuXG4gICAgICAqIEBldmVudCBSZXZlYWwjY2xvc2VkXG4gICAgICAqL1xuICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VkLnpmLnJldmVhbCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogUmVzZXRzIHRoZSBtb2RhbCBjb250ZW50XG4gICAgKiBUaGlzIHByZXZlbnRzIGEgcnVubmluZyB2aWRlbyB0byBrZWVwIGdvaW5nIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgKi9cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc2V0T25DbG9zZSkge1xuICAgICAgdGhpcy4kZWxlbWVudC5odG1sKHRoaXMuJGVsZW1lbnQuaHRtbCgpKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XG4gICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFwiXCIsIGRvY3VtZW50LnRpdGxlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnO1xuICAgICAgIH1cbiAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2VkIHN0YXRlIG9mIGEgbW9kYWwuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYSBtb2RhbC5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgdGhpcy4kZWxlbWVudC5hcHBlbmRUbygkKCdib2R5JykpOyAvLyBtb3ZlICRlbGVtZW50IG91dHNpZGUgb2YgJG92ZXJsYXkgdG8gcHJldmVudCBlcnJvciB1bnJlZ2lzdGVyUGx1Z2luKClcbiAgICAgIHRoaXMuJG92ZXJsYXkuaGlkZSgpLm9mZigpLnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLiRlbGVtZW50LmhpZGUoKS5vZmYoKTtcbiAgICB0aGlzLiRhbmNob3Iub2ZmKCcuemYnKTtcbiAgICAkKHdpbmRvdykub2ZmKGAuemYucmV2ZWFsOiR7dGhpcy5pZH1gKTtcblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfTtcbn1cblxuUmV2ZWFsLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogTW90aW9uLVVJIGNsYXNzIHRvIHVzZSBmb3IgYW5pbWF0ZWQgZWxlbWVudHMuIElmIG5vbmUgdXNlZCwgZGVmYXVsdHMgdG8gc2ltcGxlIHNob3cvaGlkZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnc2xpZGUtaW4tbGVmdCdcbiAgICovXG4gIGFuaW1hdGlvbkluOiAnJyxcbiAgLyoqXG4gICAqIE1vdGlvbi1VSSBjbGFzcyB0byB1c2UgZm9yIGFuaW1hdGVkIGVsZW1lbnRzLiBJZiBub25lIHVzZWQsIGRlZmF1bHRzIHRvIHNpbXBsZSBzaG93L2hpZGUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3NsaWRlLW91dC1yaWdodCdcbiAgICovXG4gIGFuaW1hdGlvbk91dDogJycsXG4gIC8qKlxuICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIG9wZW5pbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDEwXG4gICAqL1xuICBzaG93RGVsYXk6IDAsXG4gIC8qKlxuICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIGNsb3Npbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDEwXG4gICAqL1xuICBoaWRlRGVsYXk6IDAsXG4gIC8qKlxuICAgKiBBbGxvd3MgYSBjbGljayBvbiB0aGUgYm9keS9vdmVybGF5IHRvIGNsb3NlIHRoZSBtb2RhbC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBjbG9zZU9uQ2xpY2s6IHRydWUsXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGNsb3NlIGlmIHRoZSB1c2VyIHByZXNzZXMgdGhlIGBFU0NBUEVgIGtleS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBjbG9zZU9uRXNjOiB0cnVlLFxuICAvKipcbiAgICogSWYgdHJ1ZSwgYWxsb3dzIG11bHRpcGxlIG1vZGFscyB0byBiZSBkaXNwbGF5ZWQgYXQgb25jZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgbXVsdGlwbGVPcGVuZWQ6IGZhbHNlLFxuICAvKipcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIG1vZGFsIHNob3VsZCBwdXNoIGRvd24gZnJvbSB0aGUgdG9wIG9mIHRoZSBzY3JlZW4uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgYXV0b1xuICAgKi9cbiAgdk9mZnNldDogJ2F1dG8nLFxuICAvKipcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIG1vZGFsIHNob3VsZCBwdXNoIGluIGZyb20gdGhlIHNpZGUgb2YgdGhlIHNjcmVlbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBhdXRvXG4gICAqL1xuICBoT2Zmc2V0OiAnYXV0bycsXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGJlIGZ1bGxzY3JlZW4sIGNvbXBsZXRlbHkgYmxvY2tpbmcgb3V0IHRoZSByZXN0IG9mIHRoZSB2aWV3LiBKUyBjaGVja3MgZm9yIHRoaXMgYXMgd2VsbC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgZnVsbFNjcmVlbjogZmFsc2UsXG4gIC8qKlxuICAgKiBQZXJjZW50YWdlIG9mIHNjcmVlbiBoZWlnaHQgdGhlIG1vZGFsIHNob3VsZCBwdXNoIHVwIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgdmlldy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAxMFxuICAgKi9cbiAgYnRtT2Zmc2V0UGN0OiAxMCxcbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gZ2VuZXJhdGUgYW4gb3ZlcmxheSBkaXYsIHdoaWNoIHdpbGwgY292ZXIgdGhlIHZpZXcgd2hlbiBtb2RhbCBvcGVucy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBvdmVybGF5OiB0cnVlLFxuICAvKipcbiAgICogQWxsb3dzIHRoZSBtb2RhbCB0byByZW1vdmUgYW5kIHJlaW5qZWN0IG1hcmt1cCBvbiBjbG9zZS4gU2hvdWxkIGJlIHRydWUgaWYgdXNpbmcgdmlkZW8gZWxlbWVudHMgdy9vIHVzaW5nIHByb3ZpZGVyJ3MgYXBpLCBvdGhlcndpc2UsIHZpZGVvcyB3aWxsIGNvbnRpbnVlIHRvIHBsYXkgaW4gdGhlIGJhY2tncm91bmQuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIHJlc2V0T25DbG9zZTogZmFsc2UsXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGFsdGVyIHRoZSB1cmwgb24gb3Blbi9jbG9zZSwgYW5kIGFsbG93cyB0aGUgdXNlIG9mIHRoZSBgYmFja2AgYnV0dG9uIHRvIGNsb3NlIG1vZGFscy4gQUxTTywgYWxsb3dzIGEgbW9kYWwgdG8gYXV0by1tYW5pYWNhbGx5IG9wZW4gb24gcGFnZSBsb2FkIElGIHRoZSBoYXNoID09PSB0aGUgbW9kYWwncyB1c2VyLXNldCBpZC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgZGVlcExpbms6IGZhbHNlXG59O1xuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oUmV2ZWFsLCAnUmV2ZWFsJyk7XG5cbmZ1bmN0aW9uIGlQaG9uZVNuaWZmKCkge1xuICByZXR1cm4gL2lQKGFkfGhvbmV8b2QpLipPUy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbmZ1bmN0aW9uIGFuZHJvaWRTbmlmZigpIHtcbiAgcmV0dXJuIC9BbmRyb2lkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxuZnVuY3Rpb24gbW9iaWxlU25pZmYoKSB7XG4gIHJldHVybiBpUGhvbmVTbmlmZigpIHx8IGFuZHJvaWRTbmlmZigpO1xufVxuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogU2xpZGVyIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5zbGlkZXJcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRvdWNoXG4gKi9cblxuY2xhc3MgU2xpZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcmlsbGRvd24gbWVudS5cbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgU2xpZGVyLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdTbGlkZXInKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdTbGlkZXInLCB7XG4gICAgICAnbHRyJzoge1xuICAgICAgICAnQVJST1dfUklHSFQnOiAnaW5jcmVhc2UnLFxuICAgICAgICAnQVJST1dfVVAnOiAnaW5jcmVhc2UnLFxuICAgICAgICAnQVJST1dfRE9XTic6ICdkZWNyZWFzZScsXG4gICAgICAgICdBUlJPV19MRUZUJzogJ2RlY3JlYXNlJyxcbiAgICAgICAgJ1NISUZUX0FSUk9XX1JJR0hUJzogJ2luY3JlYXNlX2Zhc3QnLFxuICAgICAgICAnU0hJRlRfQVJST1dfVVAnOiAnaW5jcmVhc2VfZmFzdCcsXG4gICAgICAgICdTSElGVF9BUlJPV19ET1dOJzogJ2RlY3JlYXNlX2Zhc3QnLFxuICAgICAgICAnU0hJRlRfQVJST1dfTEVGVCc6ICdkZWNyZWFzZV9mYXN0J1xuICAgICAgfSxcbiAgICAgICdydGwnOiB7XG4gICAgICAgICdBUlJPV19MRUZUJzogJ2luY3JlYXNlJyxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ2RlY3JlYXNlJyxcbiAgICAgICAgJ1NISUZUX0FSUk9XX0xFRlQnOiAnaW5jcmVhc2VfZmFzdCcsXG4gICAgICAgICdTSElGVF9BUlJPV19SSUdIVCc6ICdkZWNyZWFzZV9mYXN0J1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpbGl6ZXMgdGhlIHBsdWdpbiBieSByZWFkaW5nL3NldHRpbmcgYXR0cmlidXRlcywgY3JlYXRpbmcgY29sbGVjdGlvbnMgYW5kIHNldHRpbmcgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIGhhbmRsZShzKS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB0aGlzLmlucHV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQnKTtcbiAgICB0aGlzLmhhbmRsZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXNsaWRlci1oYW5kbGVdJyk7XG5cbiAgICB0aGlzLiRoYW5kbGUgPSB0aGlzLmhhbmRsZXMuZXEoMCk7XG4gICAgdGhpcy4kaW5wdXQgPSB0aGlzLmlucHV0cy5sZW5ndGggPyB0aGlzLmlucHV0cy5lcSgwKSA6ICQoYCMke3RoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLWNvbnRyb2xzJyl9YCk7XG4gICAgdGhpcy4kZmlsbCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc2xpZGVyLWZpbGxdJykuY3NzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJywgMCk7XG5cbiAgICB2YXIgaXNEYmwgPSBmYWxzZSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcykpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaW5wdXRzID0gJCgpLmFkZCh0aGlzLiRpbnB1dCk7XG4gICAgICB0aGlzLm9wdGlvbnMuYmluZGluZyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3NldEluaXRBdHRyKDApO1xuICAgIHRoaXMuX2V2ZW50cyh0aGlzLiRoYW5kbGUpO1xuXG4gICAgaWYgKHRoaXMuaGFuZGxlc1sxXSkge1xuICAgICAgdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGhhbmRsZTIgPSB0aGlzLmhhbmRsZXMuZXEoMSk7XG4gICAgICB0aGlzLiRpbnB1dDIgPSB0aGlzLmlucHV0cy5sZW5ndGggPiAxID8gdGhpcy5pbnB1dHMuZXEoMSkgOiAkKGAjJHt0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtY29udHJvbHMnKX1gKTtcblxuICAgICAgaWYgKCF0aGlzLmlucHV0c1sxXSkge1xuICAgICAgICB0aGlzLmlucHV0cyA9IHRoaXMuaW5wdXRzLmFkZCh0aGlzLiRpbnB1dDIpO1xuICAgICAgfVxuICAgICAgaXNEYmwgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLCB0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0LCB0cnVlLCBmdW5jdGlvbigpIHtcblxuICAgICAgICBfdGhpcy5fc2V0SGFuZGxlUG9zKF90aGlzLiRoYW5kbGUyLCBfdGhpcy5vcHRpb25zLmluaXRpYWxFbmQsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICAvLyB0aGlzLiRoYW5kbGUudHJpZ2dlckhhbmRsZXIoJ2NsaWNrLnpmLnNsaWRlcicpO1xuICAgICAgdGhpcy5fc2V0SW5pdEF0dHIoMSk7XG4gICAgICB0aGlzLl9ldmVudHModGhpcy4kaGFuZGxlMik7XG4gICAgfVxuXG4gICAgaWYgKCFpc0RibCkge1xuICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKHRoaXMuJGhhbmRsZSwgdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBoYW5kbGUgYW5kIGZpbGwgYmFyLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRobmRsIC0gdGhlIHNlbGVjdGVkIGhhbmRsZSB0byBtb3ZlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbG9jYXRpb24gLSBmbG9hdGluZyBwb2ludCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcyBvZiB0aGUgc2xpZGVyIGJhci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIG9uIGNvbXBsZXRpb24uXG4gICAqIEBmaXJlcyBTbGlkZXIjbW92ZWRcbiAgICogQGZpcmVzIFNsaWRlciNjaGFuZ2VkXG4gICAqL1xuICBfc2V0SGFuZGxlUG9zKCRobmRsLCBsb2NhdGlvbiwgbm9JbnZlcnQsIGNiKSB7XG4gICAgLy8gZG9uJ3QgbW92ZSBpZiB0aGUgc2xpZGVyIGhhcyBiZWVuIGRpc2FibGVkIHNpbmNlIGl0cyBpbml0aWFsaXphdGlvblxuICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvL21pZ2h0IG5lZWQgdG8gYWx0ZXIgdGhhdCBzbGlnaHRseSBmb3IgYmFycyB0aGF0IHdpbGwgaGF2ZSBvZGQgbnVtYmVyIHNlbGVjdGlvbnMuXG4gICAgbG9jYXRpb24gPSBwYXJzZUZsb2F0KGxvY2F0aW9uKTsvL29uIGlucHV0IGNoYW5nZSBldmVudHMsIGNvbnZlcnQgc3RyaW5nIHRvIG51bWJlci4uLmdydW1ibGUuXG5cbiAgICAvLyBwcmV2ZW50IHNsaWRlciBmcm9tIHJ1bm5pbmcgb3V0IG9mIGJvdW5kcywgaWYgdmFsdWUgZXhjZWVkcyB0aGUgbGltaXRzIHNldCB0aHJvdWdoIG9wdGlvbnMsIG92ZXJyaWRlIHRoZSB2YWx1ZSB0byBtaW4vbWF4XG4gICAgaWYgKGxvY2F0aW9uIDwgdGhpcy5vcHRpb25zLnN0YXJ0KSB7IGxvY2F0aW9uID0gdGhpcy5vcHRpb25zLnN0YXJ0OyB9XG4gICAgZWxzZSBpZiAobG9jYXRpb24gPiB0aGlzLm9wdGlvbnMuZW5kKSB7IGxvY2F0aW9uID0gdGhpcy5vcHRpb25zLmVuZDsgfVxuXG4gICAgdmFyIGlzRGJsID0gdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkO1xuXG4gICAgaWYgKGlzRGJsKSB7IC8vdGhpcyBibG9jayBpcyB0byBwcmV2ZW50IDIgaGFuZGxlcyBmcm9tIGNyb3NzaW5nIGVhY2hvdGhlci4gQ291bGQvc2hvdWxkIGJlIGltcHJvdmVkLlxuICAgICAgaWYgKHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCkgPT09IDApIHtcbiAgICAgICAgdmFyIGgyVmFsID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XG4gICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPj0gaDJWYWwgPyBoMlZhbCAtIHRoaXMub3B0aW9ucy5zdGVwIDogbG9jYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaDFWYWwgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JykpO1xuICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uIDw9IGgxVmFsID8gaDFWYWwgKyB0aGlzLm9wdGlvbnMuc3RlcCA6IGxvY2F0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vdGhpcyBpcyBmb3Igc2luZ2xlLWhhbmRsZWQgdmVydGljYWwgc2xpZGVycywgaXQgYWRqdXN0cyB0aGUgdmFsdWUgdG8gYWNjb3VudCBmb3IgdGhlIHNsaWRlciBiZWluZyBcInVwc2lkZS1kb3duXCJcbiAgICAvL2ZvciBjbGljayBhbmQgZHJhZyBldmVudHMsIGl0J3Mgd2VpcmQgZHVlIHRvIHRoZSBzY2FsZSgtMSwgMSkgY3NzIHByb3BlcnR5XG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCAmJiAhbm9JbnZlcnQpIHtcbiAgICAgIGxvY2F0aW9uID0gdGhpcy5vcHRpb25zLmVuZCAtIGxvY2F0aW9uO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIHZlcnQgPSB0aGlzLm9wdGlvbnMudmVydGljYWwsXG4gICAgICAgIGhPclcgPSB2ZXJ0ID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxuICAgICAgICBsT3JUID0gdmVydCA/ICd0b3AnIDogJ2xlZnQnLFxuICAgICAgICBoYW5kbGVEaW0gPSAkaG5kbFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtoT3JXXSxcbiAgICAgICAgZWxlbURpbSA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbaE9yV10sXG4gICAgICAgIC8vcGVyY2VudGFnZSBvZiBiYXIgbWluL21heCB2YWx1ZSBiYXNlZCBvbiBjbGljayBvciBkcmFnIHBvaW50XG4gICAgICAgIHBjdE9mQmFyID0gcGVyY2VudChsb2NhdGlvbiAtIHRoaXMub3B0aW9ucy5zdGFydCwgdGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCkudG9GaXhlZCgyKSxcbiAgICAgICAgLy9udW1iZXIgb2YgYWN0dWFsIHBpeGVscyB0byBzaGlmdCB0aGUgaGFuZGxlLCBiYXNlZCBvbiB0aGUgcGVyY2VudGFnZSBvYnRhaW5lZCBhYm92ZVxuICAgICAgICBweFRvTW92ZSA9IChlbGVtRGltIC0gaGFuZGxlRGltKSAqIHBjdE9mQmFyLFxuICAgICAgICAvL3BlcmNlbnRhZ2Ugb2YgYmFyIHRvIHNoaWZ0IHRoZSBoYW5kbGVcbiAgICAgICAgbW92ZW1lbnQgPSAocGVyY2VudChweFRvTW92ZSwgZWxlbURpbSkgKiAxMDApLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpO1xuICAgICAgICAvL2ZpeGluZyB0aGUgZGVjaW1hbCB2YWx1ZSBmb3IgdGhlIGxvY2F0aW9uIG51bWJlciwgaXMgcGFzc2VkIHRvIG90aGVyIG1ldGhvZHMgYXMgYSBmaXhlZCBmbG9hdGluZy1wb2ludCB2YWx1ZVxuICAgICAgICBsb2NhdGlvbiA9IHBhcnNlRmxvYXQobG9jYXRpb24udG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCkpO1xuICAgICAgICAvLyBkZWNsYXJlIGVtcHR5IG9iamVjdCBmb3IgY3NzIGFkanVzdG1lbnRzLCBvbmx5IHVzZWQgd2l0aCAyIGhhbmRsZWQtc2xpZGVyc1xuICAgIHZhciBjc3MgPSB7fTtcblxuICAgIHRoaXMuX3NldFZhbHVlcygkaG5kbCwgbG9jYXRpb24pO1xuXG4gICAgLy8gVE9ETyB1cGRhdGUgdG8gY2FsY3VsYXRlIGJhc2VkIG9uIHZhbHVlcyBzZXQgdG8gcmVzcGVjdGl2ZSBpbnB1dHM/P1xuICAgIGlmIChpc0RibCkge1xuICAgICAgdmFyIGlzTGVmdEhuZGwgPSB0aGlzLmhhbmRsZXMuaW5kZXgoJGhuZGwpID09PSAwLFxuICAgICAgICAgIC8vZW1wdHkgdmFyaWFibGUsIHdpbGwgYmUgdXNlZCBmb3IgbWluLWhlaWdodC93aWR0aCBmb3IgZmlsbCBiYXJcbiAgICAgICAgICBkaW0sXG4gICAgICAgICAgLy9wZXJjZW50YWdlIHcvaCBvZiB0aGUgaGFuZGxlIGNvbXBhcmVkIHRvIHRoZSBzbGlkZXIgYmFyXG4gICAgICAgICAgaGFuZGxlUGN0ID0gIH5+KHBlcmNlbnQoaGFuZGxlRGltLCBlbGVtRGltKSAqIDEwMCk7XG4gICAgICAvL2lmIGxlZnQgaGFuZGxlLCB0aGUgbWF0aCBpcyBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiBpZiBpdCdzIHRoZSByaWdodCBoYW5kbGUsIGFuZCB0aGUgbGVmdC90b3AgcHJvcGVydHkgbmVlZHMgdG8gYmUgY2hhbmdlZCBmb3IgdGhlIGZpbGwgYmFyXG4gICAgICBpZiAoaXNMZWZ0SG5kbCkge1xuICAgICAgICAvL2xlZnQgb3IgdG9wIHBlcmNlbnRhZ2UgdmFsdWUgdG8gYXBwbHkgdG8gdGhlIGZpbGwgYmFyLlxuICAgICAgICBjc3NbbE9yVF0gPSBgJHttb3ZlbWVudH0lYDtcbiAgICAgICAgLy9jYWxjdWxhdGUgdGhlIG5ldyBtaW4taGVpZ2h0L3dpZHRoIGZvciB0aGUgZmlsbCBiYXIuXG4gICAgICAgIGRpbSA9IHBhcnNlRmxvYXQodGhpcy4kaGFuZGxlMlswXS5zdHlsZVtsT3JUXSkgLSBtb3ZlbWVudCArIGhhbmRsZVBjdDtcbiAgICAgICAgLy90aGlzIGNhbGxiYWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IGVycm9ycyBhbmQgYWxsb3cgdGhlIHByb3BlciBwbGFjZW1lbnQgYW5kIGluaXRpYWxpemF0aW9uIG9mIGEgMi1oYW5kbGVkIHNsaWRlclxuICAgICAgICAvL3BsdXMsIGl0IG1lYW5zIHdlIGRvbid0IGNhcmUgaWYgJ2RpbScgaXNOYU4gb24gaW5pdCwgaXQgd29uJ3QgYmUgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgeyBjYigpOyB9Ly90aGlzIGlzIG9ubHkgbmVlZGVkIGZvciB0aGUgaW5pdGlhbGl6YXRpb24gb2YgMiBoYW5kbGVkIHNsaWRlcnNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vanVzdCBjYWNoaW5nIHRoZSB2YWx1ZSBvZiB0aGUgbGVmdC9ib3R0b20gaGFuZGxlJ3MgbGVmdC90b3AgcHJvcGVydHlcbiAgICAgICAgdmFyIGhhbmRsZVBvcyA9IHBhcnNlRmxvYXQodGhpcy4kaGFuZGxlWzBdLnN0eWxlW2xPclRdKTtcbiAgICAgICAgLy9jYWxjdWxhdGUgdGhlIG5ldyBtaW4taGVpZ2h0L3dpZHRoIGZvciB0aGUgZmlsbCBiYXIuIFVzZSBpc05hTiB0byBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlcyBmb3IgbnVtYmVycyA8PSAwXG4gICAgICAgIC8vYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2Ugb2YgbW92ZW1lbnQgb2YgdGhlIGhhbmRsZSBiZWluZyBtYW5pcHVsYXRlZCwgbGVzcyB0aGUgb3Bwb3NpbmcgaGFuZGxlJ3MgbGVmdC90b3AgcG9zaXRpb24sIHBsdXMgdGhlIHBlcmNlbnRhZ2Ugdy9oIG9mIHRoZSBoYW5kbGUgaXRzZWxmXG4gICAgICAgIGRpbSA9IG1vdmVtZW50IC0gKGlzTmFOKGhhbmRsZVBvcykgPyB0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0LygodGhpcy5vcHRpb25zLmVuZC10aGlzLm9wdGlvbnMuc3RhcnQpLzEwMCkgOiBoYW5kbGVQb3MpICsgaGFuZGxlUGN0O1xuICAgICAgfVxuICAgICAgLy8gYXNzaWduIHRoZSBtaW4taGVpZ2h0L3dpZHRoIHRvIG91ciBjc3Mgb2JqZWN0XG4gICAgICBjc3NbYG1pbi0ke2hPcld9YF0gPSBgJHtkaW19JWA7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC5vbmUoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhhbmRsZSBpcyBkb25lIG1vdmluZy5cbiAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50IFNsaWRlciNtb3ZlZFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignbW92ZWQuemYuc2xpZGVyJywgWyRobmRsXSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAvL2JlY2F1c2Ugd2UgZG9uJ3Qga25vdyBleGFjdGx5IGhvdyB0aGUgaGFuZGxlIHdpbGwgYmUgbW92ZWQsIGNoZWNrIHRoZSBhbW91bnQgb2YgdGltZSBpdCBzaG91bGQgdGFrZSB0byBtb3ZlLlxuICAgIHZhciBtb3ZlVGltZSA9IHRoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnKSA/IDEwMDAvNjAgOiB0aGlzLm9wdGlvbnMubW92ZVRpbWU7XG5cbiAgICBGb3VuZGF0aW9uLk1vdmUobW92ZVRpbWUsICRobmRsLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vYWRqdXN0aW5nIHRoZSBsZWZ0L3RvcCBwcm9wZXJ0eSBvZiB0aGUgaGFuZGxlLCBiYXNlZCBvbiB0aGUgcGVyY2VudGFnZSBjYWxjdWxhdGVkIGFib3ZlXG4gICAgICAkaG5kbC5jc3MobE9yVCwgYCR7bW92ZW1lbnR9JWApO1xuXG4gICAgICBpZiAoIV90aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQpIHtcbiAgICAgICAgLy9pZiBzaW5nbGUtaGFuZGxlZCwgYSBzaW1wbGUgbWV0aG9kIHRvIGV4cGFuZCB0aGUgZmlsbCBiYXJcbiAgICAgICAgX3RoaXMuJGZpbGwuY3NzKGhPclcsIGAke3BjdE9mQmFyICogMTAwfSVgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vb3RoZXJ3aXNlLCB1c2UgdGhlIGNzcyBvYmplY3Qgd2UgY3JlYXRlZCBhYm92ZVxuICAgICAgICBfdGhpcy4kZmlsbC5jc3MoY3NzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjaGFuZ2UgZm9yIGEgZ2l2ZW4gdGltZS5cbiAgICAgKiBAZXZlbnQgU2xpZGVyI2NoYW5nZWRcbiAgICAgKi9cbiAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZWQuemYuc2xpZGVyJywgWyRobmRsXSk7XG4gICAgfSwgX3RoaXMub3B0aW9ucy5jaGFuZ2VkRGVsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGluaXRpYWwgYXR0cmlidXRlIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gaW5kZXggb2YgdGhlIGN1cnJlbnQgaGFuZGxlL2lucHV0IHRvIHVzZS5cbiAgICovXG4gIF9zZXRJbml0QXR0cihpZHgpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlucHV0cy5lcShpZHgpLmF0dHIoJ2lkJykgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnc2xpZGVyJyk7XG4gICAgdGhpcy5pbnB1dHMuZXEoaWR4KS5hdHRyKHtcbiAgICAgICdpZCc6IGlkLFxuICAgICAgJ21heCc6IHRoaXMub3B0aW9ucy5lbmQsXG4gICAgICAnbWluJzogdGhpcy5vcHRpb25zLnN0YXJ0LFxuICAgICAgJ3N0ZXAnOiB0aGlzLm9wdGlvbnMuc3RlcFxuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlcy5lcShpZHgpLmF0dHIoe1xuICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcbiAgICAgICdhcmlhLWNvbnRyb2xzJzogaWQsXG4gICAgICAnYXJpYS12YWx1ZW1heCc6IHRoaXMub3B0aW9ucy5lbmQsXG4gICAgICAnYXJpYS12YWx1ZW1pbic6IHRoaXMub3B0aW9ucy5zdGFydCxcbiAgICAgICdhcmlhLXZhbHVlbm93JzogaWR4ID09PSAwID8gdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCA6IHRoaXMub3B0aW9ucy5pbml0aWFsRW5kLFxuICAgICAgJ2FyaWEtb3JpZW50YXRpb24nOiB0aGlzLm9wdGlvbnMudmVydGljYWwgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgJ3RhYmluZGV4JzogMFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGFuZCBgYXJpYS12YWx1ZW5vd2AgdmFsdWVzIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIC0gZmxvYXRpbmcgcG9pbnQgb2YgdGhlIG5ldyB2YWx1ZS5cbiAgICovXG4gIF9zZXRWYWx1ZXMoJGhhbmRsZSwgdmFsKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA/IHRoaXMuaGFuZGxlcy5pbmRleCgkaGFuZGxlKSA6IDA7XG4gICAgdGhpcy5pbnB1dHMuZXEoaWR4KS52YWwodmFsKTtcbiAgICAkaGFuZGxlLmF0dHIoJ2FyaWEtdmFsdWVub3cnLCB2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXZlbnRzIG9uIHRoZSBzbGlkZXIgZWxlbWVudC5cbiAgICogQ2FsY3VsYXRlcyB0aGUgbmV3IGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IGhhbmRsZS5cbiAgICogSWYgdGhlcmUgYXJlIHR3byBoYW5kbGVzIGFuZCB0aGUgYmFyIHdhcyBjbGlja2VkLCBpdCBkZXRlcm1pbmVzIHdoaWNoIGhhbmRsZSB0byBtb3ZlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgLSB0aGUgYGV2ZW50YCBvYmplY3QgcGFzc2VkIGZyb20gdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50IGhhbmRsZSB0byBjYWxjdWxhdGUgZm9yLCBpZiBzZWxlY3RlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIGZsb2F0aW5nIHBvaW50IG51bWJlciBmb3IgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgc2xpZGVyLlxuICAgKiBUT0RPIGNsZWFuIHRoaXMgdXAsIHRoZXJlJ3MgYSBsb3Qgb2YgcmVwZWF0ZWQgY29kZSBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBfc2V0SGFuZGxlUG9zIGZuLlxuICAgKi9cbiAgX2hhbmRsZUV2ZW50KGUsICRoYW5kbGUsIHZhbCkge1xuICAgIHZhciB2YWx1ZSwgaGFzVmFsO1xuICAgIGlmICghdmFsKSB7Ly9jbGljayBvciBkcmFnIGV2ZW50c1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICB2ZXJ0aWNhbCA9IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCxcbiAgICAgICAgICBwYXJhbSA9IHZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IHZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCcsXG4gICAgICAgICAgZXZlbnRPZmZzZXQgPSB2ZXJ0aWNhbCA/IGUucGFnZVkgOiBlLnBhZ2VYLFxuICAgICAgICAgIGhhbGZPZkhhbmRsZSA9IHRoaXMuJGhhbmRsZVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwYXJhbV0gLyAyLFxuICAgICAgICAgIGJhckRpbSA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbcGFyYW1dLFxuICAgICAgICAgIHdpbmRvd1Njcm9sbCA9IHZlcnRpY2FsID8gJCh3aW5kb3cpLnNjcm9sbFRvcCgpIDogJCh3aW5kb3cpLnNjcm9sbExlZnQoKTtcblxuXG4gICAgICB2YXIgZWxlbU9mZnNldCA9IHRoaXMuJGVsZW1lbnQub2Zmc2V0KClbZGlyZWN0aW9uXTtcblxuICAgICAgLy8gdG91Y2ggZXZlbnRzIGVtdWxhdGVkIGJ5IHRoZSB0b3VjaCB1dGlsIGdpdmUgcG9zaXRpb24gcmVsYXRpdmUgdG8gc2NyZWVuLCBhZGQgd2luZG93LnNjcm9sbCB0byBldmVudCBjb29yZGluYXRlcy4uLlxuICAgICAgLy8gYmVzdCB3YXkgdG8gZ3Vlc3MgdGhpcyBpcyBzaW11bGF0ZWQgaXMgaWYgY2xpZW50WSA9PSBwYWdlWVxuICAgICAgaWYgKGUuY2xpZW50WSA9PT0gZS5wYWdlWSkgeyBldmVudE9mZnNldCA9IGV2ZW50T2Zmc2V0ICsgd2luZG93U2Nyb2xsOyB9XG4gICAgICB2YXIgZXZlbnRGcm9tQmFyID0gZXZlbnRPZmZzZXQgLSBlbGVtT2Zmc2V0O1xuICAgICAgdmFyIGJhclhZO1xuICAgICAgaWYgKGV2ZW50RnJvbUJhciA8IDApIHtcbiAgICAgICAgYmFyWFkgPSAwO1xuICAgICAgfSBlbHNlIGlmIChldmVudEZyb21CYXIgPiBiYXJEaW0pIHtcbiAgICAgICAgYmFyWFkgPSBiYXJEaW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXJYWSA9IGV2ZW50RnJvbUJhcjtcbiAgICAgIH1cbiAgICAgIG9mZnNldFBjdCA9IHBlcmNlbnQoYmFyWFksIGJhckRpbSk7XG5cbiAgICAgIHZhbHVlID0gKHRoaXMub3B0aW9ucy5lbmQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpICogb2Zmc2V0UGN0ICsgdGhpcy5vcHRpb25zLnN0YXJ0O1xuXG4gICAgICAvLyB0dXJuIGV2ZXJ5dGhpbmcgYXJvdW5kIGZvciBSVEwsIHlheSBtYXRoIVxuICAgICAgaWYgKEZvdW5kYXRpb24ucnRsKCkgJiYgIXRoaXMub3B0aW9ucy52ZXJ0aWNhbCkge3ZhbHVlID0gdGhpcy5vcHRpb25zLmVuZCAtIHZhbHVlO31cblxuICAgICAgdmFsdWUgPSBfdGhpcy5fYWRqdXN0VmFsdWUobnVsbCwgdmFsdWUpO1xuICAgICAgLy9ib29sZWFuIGZsYWcgZm9yIHRoZSBzZXRIYW5kbGVQb3MgZm4sIHNwZWNpZmljYWxseSBmb3IgdmVydGljYWwgc2xpZGVyc1xuICAgICAgaGFzVmFsID0gZmFsc2U7XG5cbiAgICAgIGlmICghJGhhbmRsZSkgey8vZmlndXJlIG91dCB3aGljaCBoYW5kbGUgaXQgaXMsIHBhc3MgaXQgdG8gdGhlIG5leHQgZnVuY3Rpb24uXG4gICAgICAgIHZhciBmaXJzdEhuZGxQb3MgPSBhYnNQb3NpdGlvbih0aGlzLiRoYW5kbGUsIGRpcmVjdGlvbiwgYmFyWFksIHBhcmFtKSxcbiAgICAgICAgICAgIHNlY25kSG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZTIsIGRpcmVjdGlvbiwgYmFyWFksIHBhcmFtKTtcbiAgICAgICAgICAgICRoYW5kbGUgPSBmaXJzdEhuZGxQb3MgPD0gc2VjbmRIbmRsUG9zID8gdGhpcy4kaGFuZGxlIDogdGhpcy4kaGFuZGxlMjtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7Ly9jaGFuZ2UgZXZlbnQgb24gaW5wdXRcbiAgICAgIHZhbHVlID0gdGhpcy5fYWRqdXN0VmFsdWUobnVsbCwgdmFsKTtcbiAgICAgIGhhc1ZhbCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0SGFuZGxlUG9zKCRoYW5kbGUsIHZhbHVlLCBoYXNWYWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkanVzdGVzIHZhbHVlIGZvciBoYW5kbGUgaW4gcmVnYXJkIHRvIHN0ZXAgdmFsdWUuIHJldHVybnMgYWRqdXN0ZWQgdmFsdWVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIHNlbGVjdGVkIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdmFsdWUgdG8gYWRqdXN0LiB1c2VkIGlmICRoYW5kbGUgaXMgZmFsc3lcbiAgICovXG4gIF9hZGp1c3RWYWx1ZSgkaGFuZGxlLCB2YWx1ZSkge1xuICAgIHZhciB2YWwsXG4gICAgICBzdGVwID0gdGhpcy5vcHRpb25zLnN0ZXAsXG4gICAgICBkaXYgPSBwYXJzZUZsb2F0KHN0ZXAvMiksXG4gICAgICBsZWZ0LCBwcmV2X3ZhbCwgbmV4dF92YWw7XG4gICAgaWYgKCEhJGhhbmRsZSkge1xuICAgICAgdmFsID0gcGFyc2VGbG9hdCgkaGFuZGxlLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFsID0gdmFsdWU7XG4gICAgfVxuICAgIGxlZnQgPSB2YWwgJSBzdGVwO1xuICAgIHByZXZfdmFsID0gdmFsIC0gbGVmdDtcbiAgICBuZXh0X3ZhbCA9IHByZXZfdmFsICsgc3RlcDtcbiAgICBpZiAobGVmdCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgdmFsID0gdmFsID49IHByZXZfdmFsICsgZGl2ID8gbmV4dF92YWwgOiBwcmV2X3ZhbDtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzbGlkZXIgZWxlbWVudHMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50IGhhbmRsZSB0byBhcHBseSBsaXN0ZW5lcnMgdG8uXG4gICAqL1xuICBfZXZlbnRzKCRoYW5kbGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBjdXJIYW5kbGUsXG4gICAgICAgIHRpbWVyO1xuXG4gICAgICB0aGlzLmlucHV0cy5vZmYoJ2NoYW5nZS56Zi5zbGlkZXInKS5vbignY2hhbmdlLnpmLnNsaWRlcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGlkeCA9IF90aGlzLmlucHV0cy5pbmRleCgkKHRoaXMpKTtcbiAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIF90aGlzLmhhbmRsZXMuZXEoaWR4KSwgJCh0aGlzKS52YWwoKSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja1NlbGVjdCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignY2xpY2suemYuc2xpZGVyJykub24oJ2NsaWNrLnpmLnNsaWRlcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICAgIGlmICghJChlLnRhcmdldCkuaXMoJ1tkYXRhLXNsaWRlci1oYW5kbGVdJykpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBfdGhpcy4kaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuaGFuZGxlcy5hZGRUb3VjaCgpO1xuXG4gICAgICB2YXIgJGJvZHkgPSAkKCdib2R5Jyk7XG4gICAgICAkaGFuZGxlXG4gICAgICAgIC5vZmYoJ21vdXNlZG93bi56Zi5zbGlkZXInKVxuICAgICAgICAub24oJ21vdXNlZG93bi56Zi5zbGlkZXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgJGhhbmRsZS5hZGRDbGFzcygnaXMtZHJhZ2dpbmcnKTtcbiAgICAgICAgICBfdGhpcy4kZmlsbC5hZGRDbGFzcygnaXMtZHJhZ2dpbmcnKTsvL1xuICAgICAgICAgIF90aGlzLiRlbGVtZW50LmRhdGEoJ2RyYWdnaW5nJywgdHJ1ZSk7XG5cbiAgICAgICAgICBjdXJIYW5kbGUgPSAkKGUuY3VycmVudFRhcmdldCk7XG5cbiAgICAgICAgICAkYm9keS5vbignbW91c2Vtb3ZlLnpmLnNsaWRlcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBjdXJIYW5kbGUpO1xuXG4gICAgICAgICAgfSkub24oJ21vdXNldXAuemYuc2xpZGVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XG5cbiAgICAgICAgICAgICRoYW5kbGUucmVtb3ZlQ2xhc3MoJ2lzLWRyYWdnaW5nJyk7XG4gICAgICAgICAgICBfdGhpcy4kZmlsbC5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIF90aGlzLiRlbGVtZW50LmRhdGEoJ2RyYWdnaW5nJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAkYm9keS5vZmYoJ21vdXNlbW92ZS56Zi5zbGlkZXIgbW91c2V1cC56Zi5zbGlkZXInKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAvLyBwcmV2ZW50IGV2ZW50cyB0cmlnZ2VyZWQgYnkgdG91Y2hcbiAgICAgIC5vbignc2VsZWN0c3RhcnQuemYuc2xpZGVyIHRvdWNobW92ZS56Zi5zbGlkZXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgICRoYW5kbGUub2ZmKCdrZXlkb3duLnpmLnNsaWRlcicpLm9uKCdrZXlkb3duLnpmLnNsaWRlcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBfJGhhbmRsZSA9ICQodGhpcyksXG4gICAgICAgICAgaWR4ID0gX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA/IF90aGlzLmhhbmRsZXMuaW5kZXgoXyRoYW5kbGUpIDogMCxcbiAgICAgICAgICBvbGRWYWx1ZSA9IHBhcnNlRmxvYXQoX3RoaXMuaW5wdXRzLmVxKGlkeCkudmFsKCkpLFxuICAgICAgICAgIG5ld1ZhbHVlO1xuXG4gICAgICAvLyBoYW5kbGUga2V5Ym9hcmQgZXZlbnQgd2l0aCBrZXlib2FyZCB1dGlsXG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnU2xpZGVyJywge1xuICAgICAgICBkZWNyZWFzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvbGRWYWx1ZSAtIF90aGlzLm9wdGlvbnMuc3RlcDtcbiAgICAgICAgfSxcbiAgICAgICAgaW5jcmVhc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgKyBfdGhpcy5vcHRpb25zLnN0ZXA7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY3JlYXNlX2Zhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgLSBfdGhpcy5vcHRpb25zLnN0ZXAgKiAxMDtcbiAgICAgICAgfSxcbiAgICAgICAgaW5jcmVhc2VfZmFzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvbGRWYWx1ZSArIF90aGlzLm9wdGlvbnMuc3RlcCAqIDEwO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbigpIHsgLy8gb25seSBzZXQgaGFuZGxlIHBvcyB3aGVuIGV2ZW50IHdhcyBoYW5kbGVkIHNwZWNpYWxseVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBfdGhpcy5fc2V0SGFuZGxlUG9zKF8kaGFuZGxlLCBuZXdWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLyppZiAobmV3VmFsdWUpIHsgLy8gaWYgcHJlc3NlZCBrZXkgaGFzIHNwZWNpYWwgZnVuY3Rpb24sIHVwZGF0ZSB2YWx1ZVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLl9zZXRIYW5kbGVQb3MoXyRoYW5kbGUsIG5ld1ZhbHVlKTtcbiAgICAgIH0qL1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBzbGlkZXIgcGx1Z2luLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmhhbmRsZXMub2ZmKCcuemYuc2xpZGVyJyk7XG4gICAgdGhpcy5pbnB1dHMub2ZmKCcuemYuc2xpZGVyJyk7XG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5zbGlkZXInKTtcblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5TbGlkZXIuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBNaW5pbXVtIHZhbHVlIGZvciB0aGUgc2xpZGVyIHNjYWxlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDBcbiAgICovXG4gIHN0YXJ0OiAwLFxuICAvKipcbiAgICogTWF4aW11bSB2YWx1ZSBmb3IgdGhlIHNsaWRlciBzY2FsZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAxMDBcbiAgICovXG4gIGVuZDogMTAwLFxuICAvKipcbiAgICogTWluaW11bSB2YWx1ZSBjaGFuZ2UgcGVyIGNoYW5nZSBldmVudC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAxXG4gICAqL1xuICBzdGVwOiAxLFxuICAvKipcbiAgICogVmFsdWUgYXQgd2hpY2ggdGhlIGhhbmRsZS9pbnB1dCAqKGxlZnQgaGFuZGxlL2ZpcnN0IGlucHV0KSogc2hvdWxkIGJlIHNldCB0byBvbiBpbml0aWFsaXphdGlvbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAwXG4gICAqL1xuICBpbml0aWFsU3RhcnQ6IDAsXG4gIC8qKlxuICAgKiBWYWx1ZSBhdCB3aGljaCB0aGUgcmlnaHQgaGFuZGxlL3NlY29uZCBpbnB1dCBzaG91bGQgYmUgc2V0IHRvIG9uIGluaXRpYWxpemF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDEwMFxuICAgKi9cbiAgaW5pdGlhbEVuZDogMTAwLFxuICAvKipcbiAgICogQWxsb3dzIHRoZSBpbnB1dCB0byBiZSBsb2NhdGVkIG91dHNpZGUgdGhlIGNvbnRhaW5lciBhbmQgdmlzaWJsZS4gU2V0IHRvIGJ5IHRoZSBKU1xuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBiaW5kaW5nOiBmYWxzZSxcbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgdXNlciB0byBjbGljay90YXAgb24gdGhlIHNsaWRlciBiYXIgdG8gc2VsZWN0IGEgdmFsdWUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgY2xpY2tTZWxlY3Q6IHRydWUsXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBhbmQgdXNlIHRoZSBgdmVydGljYWxgIGNsYXNzIHRvIGNoYW5nZSBhbGlnbm1lbnQgdG8gdmVydGljYWwuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIHZlcnRpY2FsOiBmYWxzZSxcbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgdXNlciB0byBkcmFnIHRoZSBzbGlkZXIgaGFuZGxlKHMpIHRvIHNlbGVjdCBhIHZhbHVlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGRyYWdnYWJsZTogdHJ1ZSxcbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBzbGlkZXIgYW5kIHByZXZlbnRzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGJlaW5nIGFwcGxpZWQuIERvdWJsZSBjaGVja2VkIGJ5IEpTIHdpdGggYGRpc2FibGVkQ2xhc3NgLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBkaXNhYmxlZDogZmFsc2UsXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIHVzZSBvZiB0d28gaGFuZGxlcy4gRG91YmxlIGNoZWNrZWQgYnkgdGhlIEpTLiBDaGFuZ2VzIHNvbWUgbG9naWMgaGFuZGxpbmcuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGRvdWJsZVNpZGVkOiBmYWxzZSxcbiAgLyoqXG4gICAqIFBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZS5cbiAgICovXG4gIC8vIHN0ZXBzOiAxMDAsXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhlIHBsdWdpbiBzaG91bGQgZ28gdG8gZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAyXG4gICAqL1xuICBkZWNpbWFsOiAyLFxuICAvKipcbiAgICogVGltZSBkZWxheSBmb3IgZHJhZ2dlZCBlbGVtZW50cy5cbiAgICovXG4gIC8vIGRyYWdEZWxheTogMCxcbiAgLyoqXG4gICAqIFRpbWUsIGluIG1zLCB0byBhbmltYXRlIHRoZSBtb3ZlbWVudCBvZiBhIHNsaWRlciBoYW5kbGUgaWYgdXNlciBjbGlja3MvdGFwcyBvbiB0aGUgYmFyLiBOZWVkcyB0byBiZSBtYW51YWxseSBzZXQgaWYgdXBkYXRpbmcgdGhlIHRyYW5zaXRpb24gdGltZSBpbiB0aGUgU2FzcyBzZXR0aW5ncy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAyMDBcbiAgICovXG4gIG1vdmVUaW1lOiAyMDAsLy91cGRhdGUgdGhpcyBpZiBjaGFuZ2luZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBzYXNzXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIGRpc2FibGVkIHNsaWRlcnMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ2Rpc2FibGVkJ1xuICAgKi9cbiAgZGlzYWJsZWRDbGFzczogJ2Rpc2FibGVkJyxcbiAgLyoqXG4gICAqIFdpbGwgaW52ZXJ0IHRoZSBkZWZhdWx0IGxheW91dCBmb3IgYSB2ZXJ0aWNhbDxzcGFuIGRhdGEtdG9vbHRpcCB0aXRsZT1cIndobyB3b3VsZCBkbyB0aGlzPz8/XCI+IDwvc3Bhbj5zbGlkZXIuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGludmVydFZlcnRpY2FsOiBmYWxzZSxcbiAgLyoqXG4gICAqIE1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIGBjaGFuZ2VkLnpmLXNsaWRlcmAgZXZlbnQgaXMgdHJpZ2dlcmVkIGFmdGVyIHZhbHVlIGNoYW5nZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSA1MDBcbiAgICovXG4gIGNoYW5nZWREZWxheTogNTAwXG59O1xuXG5mdW5jdGlvbiBwZXJjZW50KGZyYWMsIG51bSkge1xuICByZXR1cm4gKGZyYWMgLyBudW0pO1xufVxuZnVuY3Rpb24gYWJzUG9zaXRpb24oJGhhbmRsZSwgZGlyLCBjbGlja1BvcywgcGFyYW0pIHtcbiAgcmV0dXJuIE1hdGguYWJzKCgkaGFuZGxlLnBvc2l0aW9uKClbZGlyXSArICgkaGFuZGxlW3BhcmFtXSgpIC8gMikpIC0gY2xpY2tQb3MpO1xufVxuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oU2xpZGVyLCAnU2xpZGVyJyk7XG5cbn0oalF1ZXJ5KTtcblxuLy8qKioqKioqKip0aGlzIGlzIGluIGNhc2Ugd2UgZ28gdG8gc3RhdGljLCBhYnNvbHV0ZSBwb3NpdGlvbnMgaW5zdGVhZCBvZiBkeW5hbWljIHBvc2l0aW9uaW5nKioqKioqKipcbi8vIHRoaXMuc2V0U3RlcHMoZnVuY3Rpb24oKSB7XG4vLyAgIF90aGlzLl9ldmVudHMoKTtcbi8vICAgdmFyIGluaXRTdGFydCA9IF90aGlzLm9wdGlvbnMucG9zaXRpb25zW190aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0IC0gMV0gfHwgbnVsbDtcbi8vICAgdmFyIGluaXRFbmQgPSBfdGhpcy5vcHRpb25zLmluaXRpYWxFbmQgPyBfdGhpcy5vcHRpb25zLnBvc2l0aW9uW190aGlzLm9wdGlvbnMuaW5pdGlhbEVuZCAtIDFdIDogbnVsbDtcbi8vICAgaWYgKGluaXRTdGFydCB8fCBpbml0RW5kKSB7XG4vLyAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGluaXRTdGFydCwgaW5pdEVuZCk7XG4vLyAgIH1cbi8vIH0pO1xuXG4vLyoqKioqKioqKioqdGhlIG90aGVyIHBhcnQgb2YgYWJzb2x1dGUgcG9zaXRpb25zKioqKioqKioqKioqKlxuLy8gU2xpZGVyLnByb3RvdHlwZS5zZXRTdGVwcyA9IGZ1bmN0aW9uKGNiKSB7XG4vLyAgIHZhciBwb3NDaGFuZ2UgPSB0aGlzLiRlbGVtZW50Lm91dGVyV2lkdGgoKSAvIHRoaXMub3B0aW9ucy5zdGVwcztcbi8vICAgdmFyIGNvdW50ZXIgPSAwXG4vLyAgIHdoaWxlKGNvdW50ZXIgPCB0aGlzLm9wdGlvbnMuc3RlcHMpIHtcbi8vICAgICBpZiAoY291bnRlcikge1xuLy8gICAgICAgdGhpcy5vcHRpb25zLnBvc2l0aW9ucy5wdXNoKHRoaXMub3B0aW9ucy5wb3NpdGlvbnNbY291bnRlciAtIDFdICsgcG9zQ2hhbmdlKTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgdGhpcy5vcHRpb25zLnBvc2l0aW9ucy5wdXNoKHBvc0NoYW5nZSk7XG4vLyAgICAgfVxuLy8gICAgIGNvdW50ZXIrKztcbi8vICAgfVxuLy8gICBjYigpO1xuLy8gfTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBTdGlja3kgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnN0aWNreVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gKi9cblxuY2xhc3MgU3RpY2t5IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBzdGlja3kgdGhpbmcuXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBzdGlja3kuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBvYmplY3QgcGFzc2VkIHdoZW4gY3JlYXRpbmcgdGhlIGVsZW1lbnQgcHJvZ3JhbW1hdGljYWxseS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgU3RpY2t5LmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdTdGlja3knKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgc3RpY2t5IGVsZW1lbnQgYnkgYWRkaW5nIGNsYXNzZXMsIGdldHRpbmcvc2V0dGluZyBkaW1lbnNpb25zLCBicmVha3BvaW50cyBhbmQgYXR0cmlidXRlc1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoJ1tkYXRhLXN0aWNreS1jb250YWluZXJdJyksXG4gICAgICAgIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdzdGlja3knKSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCEkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgdGhpcy53YXNXcmFwcGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy4kY29udGFpbmVyID0gJHBhcmVudC5sZW5ndGggPyAkcGFyZW50IDogJCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKS53cmFwSW5uZXIodGhpcy4kZWxlbWVudCk7XG4gICAgdGhpcy4kY29udGFpbmVyLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcyk7XG5cbiAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcylcbiAgICAgICAgICAgICAgICAgLmF0dHIoeydkYXRhLXJlc2l6ZSc6IGlkfSk7XG5cbiAgICB0aGlzLnNjcm9sbENvdW50ID0gdGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7XG4gICAgdGhpcy5pc1N0dWNrID0gZmFsc2U7XG4gICAgJCh3aW5kb3cpLm9uZSgnbG9hZC56Zi5zdGlja3knLCBmdW5jdGlvbigpe1xuICAgICAgaWYoX3RoaXMub3B0aW9ucy5hbmNob3IgIT09ICcnKXtcbiAgICAgICAgX3RoaXMuJGFuY2hvciA9ICQoJyMnICsgX3RoaXMub3B0aW9ucy5hbmNob3IpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIF90aGlzLl9wYXJzZVBvaW50cygpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtcbiAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5fZXZlbnRzKGlkLnNwbGl0KCctJykucmV2ZXJzZSgpLmpvaW4oJy0nKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdXNpbmcgbXVsdGlwbGUgZWxlbWVudHMgYXMgYW5jaG9ycywgY2FsY3VsYXRlcyB0aGUgdG9wIGFuZCBib3R0b20gcGl4ZWwgdmFsdWVzIHRoZSBzdGlja3kgdGhpbmcgc2hvdWxkIHN0aWNrIGFuZCB1bnN0aWNrIG9uLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wYXJzZVBvaW50cygpIHtcbiAgICB2YXIgdG9wID0gdGhpcy5vcHRpb25zLnRvcEFuY2hvciA9PSBcIlwiID8gMSA6IHRoaXMub3B0aW9ucy50b3BBbmNob3IsXG4gICAgICAgIGJ0bSA9IHRoaXMub3B0aW9ucy5idG1BbmNob3I9PSBcIlwiID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCA6IHRoaXMub3B0aW9ucy5idG1BbmNob3IsXG4gICAgICAgIHB0cyA9IFt0b3AsIGJ0bV0sXG4gICAgICAgIGJyZWFrcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwdHMubGVuZ3RoOyBpIDwgbGVuICYmIHB0c1tpXTsgaSsrKSB7XG4gICAgICB2YXIgcHQ7XG4gICAgICBpZiAodHlwZW9mIHB0c1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcHQgPSBwdHNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGxhY2UgPSBwdHNbaV0uc3BsaXQoJzonKSxcbiAgICAgICAgICAgIGFuY2hvciA9ICQoYCMke3BsYWNlWzBdfWApO1xuXG4gICAgICAgIHB0ID0gYW5jaG9yLm9mZnNldCgpLnRvcDtcbiAgICAgICAgaWYgKHBsYWNlWzFdICYmIHBsYWNlWzFdLnRvTG93ZXJDYXNlKCkgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgcHQgKz0gYW5jaG9yWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtzW2ldID0gcHQ7XG4gICAgfVxuXG5cbiAgICB0aGlzLnBvaW50cyA9IGJyZWFrcztcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgdGhlIHNjcm9sbGluZyBlbGVtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBwc3VlZG8tcmFuZG9tIGlkIGZvciB1bmlxdWUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgX2V2ZW50cyhpZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIHNjcm9sbExpc3RlbmVyID0gdGhpcy5zY3JvbGxMaXN0ZW5lciA9IGBzY3JvbGwuemYuJHtpZH1gO1xuICAgIGlmICh0aGlzLmlzT24pIHsgcmV0dXJuOyB9XG4gICAgaWYgKHRoaXMuY2FuU3RpY2spIHtcbiAgICAgIHRoaXMuaXNPbiA9IHRydWU7XG4gICAgICAkKHdpbmRvdykub2ZmKHNjcm9sbExpc3RlbmVyKVxuICAgICAgICAgICAgICAgLm9uKHNjcm9sbExpc3RlbmVyLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zY3JvbGxDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbENvdW50ID0gX3RoaXMub3B0aW9ucy5jaGVja0V2ZXJ5O1xuICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jYWxjKGZhbHNlLCB3aW5kb3cucGFnZVlPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbENvdW50LS07XG4gICAgICAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKVxuICAgICAgICAgICAgICAgICAub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbihlLCBlbCkge1xuICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jYW5TdGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaXNPbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2V2ZW50cyhpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLmlzT24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcGF1c2VMaXN0ZW5lcnMoc2Nyb2xsTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXJzIGZvciBzY3JvbGwgYW5kIGNoYW5nZSBldmVudHMgb24gYW5jaG9yLlxuICAgKiBAZmlyZXMgU3RpY2t5I3BhdXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzY3JvbGxMaXN0ZW5lciAtIHVuaXF1ZSwgbmFtZXNwYWNlZCBzY3JvbGwgbGlzdGVuZXIgYXR0YWNoZWQgdG8gYHdpbmRvd2BcbiAgICovXG4gIF9wYXVzZUxpc3RlbmVycyhzY3JvbGxMaXN0ZW5lcikge1xuICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xuICAgICQod2luZG93KS5vZmYoc2Nyb2xsTGlzdGVuZXIpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGlzIHBhdXNlZCBkdWUgdG8gcmVzaXplIGV2ZW50IHNocmlua2luZyB0aGUgdmlldy5cbiAgICAgKiBAZXZlbnQgU3RpY2t5I3BhdXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwYXVzZS56Zi5zdGlja3knKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gZXZlcnkgYHNjcm9sbGAgZXZlbnQgYW5kIG9uIGBfaW5pdGBcbiAgICogZmlyZXMgZnVuY3Rpb25zIGJhc2VkIG9uIGJvb2xlYW5zIGFuZCBjYWNoZWQgdmFsdWVzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tTaXplcyAtIHRydWUgaWYgcGx1Z2luIHNob3VsZCByZWNhbGN1bGF0ZSBzaXplcyBhbmQgYnJlYWtwb2ludHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGwgLSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBwYXNzZWQgZnJvbSBzY3JvbGwgZXZlbnQgY2IgZnVuY3Rpb24uIElmIG5vdCBwYXNzZWQsIGRlZmF1bHRzIHRvIGB3aW5kb3cucGFnZVlPZmZzZXRgLlxuICAgKi9cbiAgX2NhbGMoY2hlY2tTaXplcywgc2Nyb2xsKSB7XG4gICAgaWYgKGNoZWNrU2l6ZXMpIHsgdGhpcy5fc2V0U2l6ZXMoKTsgfVxuXG4gICAgaWYgKCF0aGlzLmNhblN0aWNrKSB7XG4gICAgICBpZiAodGhpcy5pc1N0dWNrKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXNjcm9sbCkgeyBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7IH1cblxuICAgIGlmIChzY3JvbGwgPj0gdGhpcy50b3BQb2ludCkge1xuICAgICAgaWYgKHNjcm9sbCA8PSB0aGlzLmJvdHRvbVBvaW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0dWNrKSB7XG4gICAgICAgICAgdGhpcy5fc2V0U3RpY2t5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3koZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYXVzZXMgdGhlICRlbGVtZW50IHRvIGJlY29tZSBzdHVjay5cbiAgICogQWRkcyBgcG9zaXRpb246IGZpeGVkO2AsIGFuZCBoZWxwZXIgY2xhc3Nlcy5cbiAgICogQGZpcmVzIFN0aWNreSNzdHVja3RvXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFN0aWNreSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBzdGlja1RvID0gdGhpcy5vcHRpb25zLnN0aWNrVG8sXG4gICAgICAgIG1yZ24gPSBzdGlja1RvID09PSAndG9wJyA/ICdtYXJnaW5Ub3AnIDogJ21hcmdpbkJvdHRvbScsXG4gICAgICAgIG5vdFN0dWNrVG8gPSBzdGlja1RvID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCcsXG4gICAgICAgIGNzcyA9IHt9O1xuXG4gICAgY3NzW21yZ25dID0gYCR7dGhpcy5vcHRpb25zW21yZ25dfWVtYDtcbiAgICBjc3Nbc3RpY2tUb10gPSAwO1xuICAgIGNzc1tub3RTdHVja1RvXSA9ICdhdXRvJztcbiAgICBjc3NbJ2xlZnQnXSA9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0ICsgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kY29udGFpbmVyWzBdKVtcInBhZGRpbmctbGVmdFwiXSwgMTApO1xuICAgIHRoaXMuaXNTdHVjayA9IHRydWU7XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhgaXMtYW5jaG9yZWQgaXMtYXQtJHtub3RTdHVja1RvfWApXG4gICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhgaXMtc3R1Y2sgaXMtYXQtJHtzdGlja1RvfWApXG4gICAgICAgICAgICAgICAgIC5jc3MoY3NzKVxuICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBgcG9zaXRpb246IGZpeGVkO2BcbiAgICAgICAgICAgICAgICAgICogTmFtZXNwYWNlZCB0byBgdG9wYCBvciBgYm90dG9tYCwgZS5nLiBgc3RpY2t5LnpmLnN0dWNrdG86dG9wYFxuICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgU3RpY2t5I3N0dWNrdG9cbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgIC50cmlnZ2VyKGBzdGlja3kuemYuc3R1Y2t0bzoke3N0aWNrVG99YCk7XG4gICAgdGhpcy4kZWxlbWVudC5vbihcInRyYW5zaXRpb25lbmQgd2Via2l0VHJhbnNpdGlvbkVuZCBvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCBNU1RyYW5zaXRpb25FbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5fc2V0U2l6ZXMoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXVzZXMgdGhlICRlbGVtZW50IHRvIGJlY29tZSB1bnN0dWNrLlxuICAgKiBSZW1vdmVzIGBwb3NpdGlvbjogZml4ZWQ7YCwgYW5kIGhlbHBlciBjbGFzc2VzLlxuICAgKiBBZGRzIG90aGVyIGhlbHBlciBjbGFzc2VzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzVG9wIC0gdGVsbHMgdGhlIGZ1bmN0aW9uIGlmIHRoZSAkZWxlbWVudCBzaG91bGQgYW5jaG9yIHRvIHRoZSB0b3Agb3IgYm90dG9tIG9mIGl0cyAkYW5jaG9yIGVsZW1lbnQuXG4gICAqIEBmaXJlcyBTdGlja3kjdW5zdHVja2Zyb21cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW1vdmVTdGlja3koaXNUb3ApIHtcbiAgICB2YXIgc3RpY2tUbyA9IHRoaXMub3B0aW9ucy5zdGlja1RvLFxuICAgICAgICBzdGlja1RvVG9wID0gc3RpY2tUbyA9PT0gJ3RvcCcsXG4gICAgICAgIGNzcyA9IHt9LFxuICAgICAgICBhbmNob3JQdCA9ICh0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzFdIC0gdGhpcy5wb2ludHNbMF0gOiB0aGlzLmFuY2hvckhlaWdodCkgLSB0aGlzLmVsZW1IZWlnaHQsXG4gICAgICAgIG1yZ24gPSBzdGlja1RvVG9wID8gJ21hcmdpblRvcCcgOiAnbWFyZ2luQm90dG9tJyxcbiAgICAgICAgbm90U3R1Y2tUbyA9IHN0aWNrVG9Ub3AgPyAnYm90dG9tJyA6ICd0b3AnLFxuICAgICAgICB0b3BPckJvdHRvbSA9IGlzVG9wID8gJ3RvcCcgOiAnYm90dG9tJztcblxuICAgIGNzc1ttcmduXSA9IDA7XG5cbiAgICBjc3NbJ2JvdHRvbSddID0gJ2F1dG8nO1xuICAgIGlmKGlzVG9wKSB7XG4gICAgICBjc3NbJ3RvcCddID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3NzWyd0b3AnXSA9IGFuY2hvclB0O1xuICAgIH1cblxuICAgIGNzc1snbGVmdCddID0gJyc7XG4gICAgdGhpcy5pc1N0dWNrID0gZmFsc2U7XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhgaXMtc3R1Y2sgaXMtYXQtJHtzdGlja1RvfWApXG4gICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhgaXMtYW5jaG9yZWQgaXMtYXQtJHt0b3BPckJvdHRvbX1gKVxuICAgICAgICAgICAgICAgICAuY3NzKGNzcylcbiAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlICRlbGVtZW50IGhhcyBiZWNvbWUgYW5jaG9yZWQuXG4gICAgICAgICAgICAgICAgICAqIE5hbWVzcGFjZWQgdG8gYHRvcGAgb3IgYGJvdHRvbWAsIGUuZy4gYHN0aWNreS56Zi51bnN0dWNrZnJvbTpib3R0b21gXG4gICAgICAgICAgICAgICAgICAqIEBldmVudCBTdGlja3kjdW5zdHVja2Zyb21cbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgIC50cmlnZ2VyKGBzdGlja3kuemYudW5zdHVja2Zyb206JHt0b3BPckJvdHRvbX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSAkZWxlbWVudCBhbmQgJGNvbnRhaW5lciBzaXplcyBmb3IgcGx1Z2luLlxuICAgKiBDYWxscyBgX3NldEJyZWFrUG9pbnRzYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIG9uIGNvbXBsZXRpb24gb2YgYF9zZXRCcmVha1BvaW50c2AuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U2l6ZXMoY2IpIHtcbiAgICB0aGlzLmNhblN0aWNrID0gRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLnN0aWNreU9uKTtcbiAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHsgY2IoKTsgfVxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIG5ld0VsZW1XaWR0aCA9IHRoaXMuJGNvbnRhaW5lclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxcbiAgICAgICAgY29tcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSksXG4gICAgICAgIHBkbmcgPSBwYXJzZUludChjb21wWydwYWRkaW5nLXJpZ2h0J10sIDEwKTtcblxuICAgIGlmICh0aGlzLiRhbmNob3IgJiYgdGhpcy4kYW5jaG9yLmxlbmd0aCkge1xuICAgICAgdGhpcy5hbmNob3JIZWlnaHQgPSB0aGlzLiRhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJzZVBvaW50cygpO1xuICAgIH1cblxuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgICdtYXgtd2lkdGgnOiBgJHtuZXdFbGVtV2lkdGggLSBwZG5nfXB4YFxuICAgIH0pO1xuXG4gICAgdmFyIG5ld0NvbnRhaW5lckhlaWdodCA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHx8IHRoaXMuY29udGFpbmVySGVpZ2h0O1xuICAgIGlmICh0aGlzLiRlbGVtZW50LmNzcyhcImRpc3BsYXlcIikgPT0gXCJub25lXCIpIHtcbiAgICAgIG5ld0NvbnRhaW5lckhlaWdodCA9IDA7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gbmV3Q29udGFpbmVySGVpZ2h0O1xuICAgIHRoaXMuJGNvbnRhaW5lci5jc3Moe1xuICAgICAgaGVpZ2h0OiBuZXdDb250YWluZXJIZWlnaHRcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1IZWlnaHQgPSBuZXdDb250YWluZXJIZWlnaHQ7XG5cbiAgXHRpZiAodGhpcy5pc1N0dWNrKSB7XG4gIFx0XHR0aGlzLiRlbGVtZW50LmNzcyh7XCJsZWZ0XCI6dGhpcy4kY29udGFpbmVyLm9mZnNldCgpLmxlZnQgKyBwYXJzZUludChjb21wWydwYWRkaW5nLWxlZnQnXSwgMTApfSk7XG4gIFx0fVxuXG4gICAgdGhpcy5fc2V0QnJlYWtQb2ludHMobmV3Q29udGFpbmVySGVpZ2h0LCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjYikgeyBjYigpOyB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdXBwZXIgYW5kIGxvd2VyIGJyZWFrcG9pbnRzIGZvciB0aGUgZWxlbWVudCB0byBiZWNvbWUgc3RpY2t5L3Vuc3RpY2t5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZWxlbUhlaWdodCAtIHB4IHZhbHVlIGZvciBzdGlja3kuJGVsZW1lbnQgaGVpZ2h0LCBjYWxjdWxhdGVkIGJ5IGBfc2V0U2l6ZXNgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBjb21wbGV0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEJyZWFrUG9pbnRzKGVsZW1IZWlnaHQsIGNiKSB7XG4gICAgaWYgKCF0aGlzLmNhblN0aWNrKSB7XG4gICAgICBpZiAoY2IpIHsgY2IoKTsgfVxuICAgICAgZWxzZSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cbiAgICB2YXIgbVRvcCA9IGVtQ2FsYyh0aGlzLm9wdGlvbnMubWFyZ2luVG9wKSxcbiAgICAgICAgbUJ0bSA9IGVtQ2FsYyh0aGlzLm9wdGlvbnMubWFyZ2luQm90dG9tKSxcbiAgICAgICAgdG9wUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzBdIDogdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxcbiAgICAgICAgYm90dG9tUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzFdIDogdG9wUG9pbnQgKyB0aGlzLmFuY2hvckhlaWdodCxcbiAgICAgICAgLy8gdG9wUG9pbnQgPSB0aGlzLiRhbmNob3Iub2Zmc2V0KCkudG9wIHx8IHRoaXMucG9pbnRzWzBdLFxuICAgICAgICAvLyBib3R0b21Qb2ludCA9IHRvcFBvaW50ICsgdGhpcy5hbmNob3JIZWlnaHQgfHwgdGhpcy5wb2ludHNbMV0sXG4gICAgICAgIHdpbkhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RpY2tUbyA9PT0gJ3RvcCcpIHtcbiAgICAgIHRvcFBvaW50IC09IG1Ub3A7XG4gICAgICBib3R0b21Qb2ludCAtPSAoZWxlbUhlaWdodCArIG1Ub3ApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0aWNrVG8gPT09ICdib3R0b20nKSB7XG4gICAgICB0b3BQb2ludCAtPSAod2luSGVpZ2h0IC0gKGVsZW1IZWlnaHQgKyBtQnRtKSk7XG4gICAgICBib3R0b21Qb2ludCAtPSAod2luSGVpZ2h0IC0gbUJ0bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vdGhpcyB3b3VsZCBiZSB0aGUgc3RpY2tUbzogYm90aCBvcHRpb24uLi4gdHJpY2t5XG4gICAgfVxuXG4gICAgdGhpcy50b3BQb2ludCA9IHRvcFBvaW50O1xuICAgIHRoaXMuYm90dG9tUG9pbnQgPSBib3R0b21Qb2ludDtcblxuICAgIGlmIChjYikgeyBjYigpOyB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGN1cnJlbnQgc3RpY2t5IGVsZW1lbnQuXG4gICAqIFJlc2V0cyB0aGUgZWxlbWVudCB0byB0aGUgdG9wIHBvc2l0aW9uIGZpcnN0LlxuICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycywgSlMtYWRkZWQgY3NzIHByb3BlcnRpZXMgYW5kIGNsYXNzZXMsIGFuZCB1bndyYXBzIHRoZSAkZWxlbWVudCBpZiB0aGUgSlMgYWRkZWQgdGhlICRjb250YWluZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7XG5cbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKGAke3RoaXMub3B0aW9ucy5zdGlja3lDbGFzc30gaXMtYW5jaG9yZWQgaXMtYXQtdG9wYClcbiAgICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgICAgICAgICAgICAgICB0b3A6ICcnLFxuICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJycsXG4gICAgICAgICAgICAgICAgICAgJ21heC13aWR0aCc6ICcnXG4gICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgIC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKTtcbiAgICBpZiAodGhpcy4kYW5jaG9yICYmIHRoaXMuJGFuY2hvci5sZW5ndGgpIHtcbiAgICAgIHRoaXMuJGFuY2hvci5vZmYoJ2NoYW5nZS56Zi5zdGlja3knKTtcbiAgICB9XG4gICAgJCh3aW5kb3cpLm9mZih0aGlzLnNjcm9sbExpc3RlbmVyKTtcblxuICAgIGlmICh0aGlzLndhc1dyYXBwZWQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQudW53cmFwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpXG4gICAgICAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnJ1xuICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5TdGlja3kuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBDdXN0b21pemFibGUgY29udGFpbmVyIHRlbXBsYXRlLiBBZGQgeW91ciBvd24gY2xhc3NlcyBmb3Igc3R5bGluZyBhbmQgc2l6aW5nLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICcmbHQ7ZGl2IGRhdGEtc3RpY2t5LWNvbnRhaW5lciBjbGFzcz1cInNtYWxsLTYgY29sdW1uc1wiJmd0OyZsdDsvZGl2Jmd0OydcbiAgICovXG4gIGNvbnRhaW5lcjogJzxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyPjwvZGl2PicsXG4gIC8qKlxuICAgKiBMb2NhdGlvbiBpbiB0aGUgdmlldyB0aGUgZWxlbWVudCBzdGlja3MgdG8uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3RvcCdcbiAgICovXG4gIHN0aWNrVG86ICd0b3AnLFxuICAvKipcbiAgICogSWYgYW5jaG9yZWQgdG8gYSBzaW5nbGUgZWxlbWVudCwgdGhlIGlkIG9mIHRoYXQgZWxlbWVudC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnZXhhbXBsZUlkJ1xuICAgKi9cbiAgYW5jaG9yOiAnJyxcbiAgLyoqXG4gICAqIElmIHVzaW5nIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBhcyBhbmNob3IgcG9pbnRzLCB0aGUgaWQgb2YgdGhlIHRvcCBhbmNob3IuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ2V4YW1wbGVJZDp0b3AnXG4gICAqL1xuICB0b3BBbmNob3I6ICcnLFxuICAvKipcbiAgICogSWYgdXNpbmcgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGFzIGFuY2hvciBwb2ludHMsIHRoZSBpZCBvZiB0aGUgYm90dG9tIGFuY2hvci5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnZXhhbXBsZUlkOmJvdHRvbSdcbiAgICovXG4gIGJ0bUFuY2hvcjogJycsXG4gIC8qKlxuICAgKiBNYXJnaW4sIGluIGBlbWAncyB0byBhcHBseSB0byB0aGUgdG9wIG9mIHRoZSBlbGVtZW50IHdoZW4gaXQgYmVjb21lcyBzdGlja3kuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMVxuICAgKi9cbiAgbWFyZ2luVG9wOiAxLFxuICAvKipcbiAgICogTWFyZ2luLCBpbiBgZW1gJ3MgdG8gYXBwbHkgdG8gdGhlIGJvdHRvbSBvZiB0aGUgZWxlbWVudCB3aGVuIGl0IGJlY29tZXMgc3RpY2t5LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDFcbiAgICovXG4gIG1hcmdpbkJvdHRvbTogMSxcbiAgLyoqXG4gICAqIEJyZWFrcG9pbnQgc3RyaW5nIHRoYXQgaXMgdGhlIG1pbmltdW0gc2NyZWVuIHNpemUgYW4gZWxlbWVudCBzaG91bGQgYmVjb21lIHN0aWNreS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnbWVkaXVtJ1xuICAgKi9cbiAgc3RpY2t5T246ICdtZWRpdW0nLFxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byBzdGlja3kgZWxlbWVudCwgYW5kIHJlbW92ZWQgb24gZGVzdHJ1Y3Rpb24uIEZvdW5kYXRpb24gZGVmYXVsdHMgdG8gYHN0aWNreWAuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3N0aWNreSdcbiAgICovXG4gIHN0aWNreUNsYXNzOiAnc3RpY2t5JyxcbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gc3RpY2t5IGNvbnRhaW5lci4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5LWNvbnRhaW5lcmAuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3N0aWNreS1jb250YWluZXInXG4gICAqL1xuICBjb250YWluZXJDbGFzczogJ3N0aWNreS1jb250YWluZXInLFxuICAvKipcbiAgICogTnVtYmVyIG9mIHNjcm9sbCBldmVudHMgYmV0d2VlbiB0aGUgcGx1Z2luJ3MgcmVjYWxjdWxhdGluZyBzdGlja3kgcG9pbnRzLiBTZXR0aW5nIGl0IHRvIGAwYCB3aWxsIGNhdXNlIGl0IHRvIHJlY2FsYyBldmVyeSBzY3JvbGwgZXZlbnQsIHNldHRpbmcgaXQgdG8gYC0xYCB3aWxsIHByZXZlbnQgcmVjYWxjIG9uIHNjcm9sbC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSA1MFxuICAgKi9cbiAgY2hlY2tFdmVyeTogLTFcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBlbSB2YWx1ZXNcbiAqIEBwYXJhbSBOdW1iZXIge2VtfSAtIG51bWJlciBvZiBlbSdzIHRvIGNhbGN1bGF0ZSBpbnRvIHBpeGVsc1xuICovXG5mdW5jdGlvbiBlbUNhbGMoZW0pIHtcbiAgcmV0dXJuIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHksIG51bGwpLmZvbnRTaXplLCAxMCkgKiBlbTtcbn1cblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKFN0aWNreSwgJ1N0aWNreScpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogVGFicyBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udGFic1xuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyIGlmIHRhYnMgY29udGFpbiBpbWFnZXNcbiAqL1xuXG5jbGFzcyBUYWJzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGFicy5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBUYWJzI2luaXRcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byB0YWJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRhYnMuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdUYWJzJyk7XG4gICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignVGFicycsIHtcbiAgICAgICdFTlRFUic6ICdvcGVuJyxcbiAgICAgICdTUEFDRSc6ICdvcGVuJyxcbiAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcbiAgICAgICdBUlJPV19VUCc6ICdwcmV2aW91cycsXG4gICAgICAnQVJST1dfRE9XTic6ICduZXh0JyxcbiAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJ1xuICAgICAgLy8gJ1RBQic6ICduZXh0JyxcbiAgICAgIC8vICdTSElGVF9UQUInOiAncHJldmlvdXMnXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHRhYnMgYnkgc2hvd2luZyBhbmQgZm9jdXNpbmcgKGlmIGF1dG9Gb2N1cz10cnVlKSB0aGUgcHJlc2V0IGFjdGl2ZSB0YWIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy4kdGFiVGl0bGVzID0gdGhpcy4kZWxlbWVudC5maW5kKGAuJHt0aGlzLm9wdGlvbnMubGlua0NsYXNzfWApO1xuICAgIHRoaXMuJHRhYkNvbnRlbnQgPSAkKGBbZGF0YS10YWJzLWNvbnRlbnQ9XCIke3RoaXMuJGVsZW1lbnRbMF0uaWR9XCJdYCk7XG5cbiAgICB0aGlzLiR0YWJUaXRsZXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyICRlbGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAkbGluayA9ICRlbGVtLmZpbmQoJ2EnKSxcbiAgICAgICAgICBpc0FjdGl2ZSA9ICRlbGVtLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSxcbiAgICAgICAgICBoYXNoID0gJGxpbmtbMF0uaGFzaC5zbGljZSgxKSxcbiAgICAgICAgICBsaW5rSWQgPSAkbGlua1swXS5pZCA/ICRsaW5rWzBdLmlkIDogYCR7aGFzaH0tbGFiZWxgLFxuICAgICAgICAgICR0YWJDb250ZW50ID0gJChgIyR7aGFzaH1gKTtcblxuICAgICAgJGVsZW0uYXR0cih7J3JvbGUnOiAncHJlc2VudGF0aW9uJ30pO1xuXG4gICAgICAkbGluay5hdHRyKHtcbiAgICAgICAgJ3JvbGUnOiAndGFiJyxcbiAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBoYXNoLFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGlzQWN0aXZlLFxuICAgICAgICAnaWQnOiBsaW5rSWRcbiAgICAgIH0pO1xuXG4gICAgICAkdGFiQ29udGVudC5hdHRyKHtcbiAgICAgICAgJ3JvbGUnOiAndGFicGFuZWwnLFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiAhaXNBY3RpdmUsXG4gICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWRcbiAgICAgIH0pO1xuXG4gICAgICBpZihpc0FjdGl2ZSAmJiBfdGhpcy5vcHRpb25zLmF1dG9Gb2N1cyl7XG4gICAgICAgICRsaW5rLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpIHtcbiAgICAgIHZhciAkaW1hZ2VzID0gdGhpcy4kdGFiQ29udGVudC5maW5kKCdpbWcnKTtcblxuICAgICAgaWYgKCRpbWFnZXMubGVuZ3RoKSB7XG4gICAgICAgIEZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQoJGltYWdlcywgdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0SGVpZ2h0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRzKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V2ZW50cygpIHtcbiAgICB0aGlzLl9hZGRLZXlIYW5kbGVyKCk7XG4gICAgdGhpcy5fYWRkQ2xpY2tIYW5kbGVyKCk7XG4gICAgdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyID0gbnVsbDtcbiAgICBcbiAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KSB7XG4gICAgICB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIgPSB0aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKTtcbiAgICAgIFxuICAgICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGNsaWNrIGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkQ2xpY2tIYW5kbGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAub2ZmKCdjbGljay56Zi50YWJzJylcbiAgICAgIC5vbignY2xpY2suemYudGFicycsIGAuJHt0aGlzLm9wdGlvbnMubGlua0NsYXNzfWAsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCQodGhpcykpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBrZXlib2FyZCBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZEtleUhhbmRsZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgJGZpcnN0VGFiID0gX3RoaXMuJGVsZW1lbnQuZmluZCgnbGk6Zmlyc3Qtb2YtdHlwZScpO1xuICAgIHZhciAkbGFzdFRhYiA9IF90aGlzLiRlbGVtZW50LmZpbmQoJ2xpOmxhc3Qtb2YtdHlwZScpO1xuXG4gICAgdGhpcy4kdGFiVGl0bGVzLm9mZigna2V5ZG93bi56Zi50YWJzJykub24oJ2tleWRvd24uemYudGFicycsIGZ1bmN0aW9uKGUpe1xuICAgICAgaWYgKGUud2hpY2ggPT09IDkpIHJldHVybjtcbiAgICAgIFxuXG4gICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpLFxuICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXG4gICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgJG5leHRFbGVtZW50O1xuXG4gICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLndyYXBPbktleXMpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCA9IGkgPT09IDAgPyAkZWxlbWVudHMubGFzdCgpIDogJGVsZW1lbnRzLmVxKGktMSk7XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSBpID09PSAkZWxlbWVudHMubGVuZ3RoIC0xID8gJGVsZW1lbnRzLmZpcnN0KCkgOiAkZWxlbWVudHMuZXEoaSsxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWF4KDAsIGktMSkpO1xuICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkrMSwgJGVsZW1lbnRzLmxlbmd0aC0xKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcbiAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdUYWJzJywge1xuICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkZWxlbWVudC5maW5kKCdbcm9sZT1cInRhYlwiXScpLmZvY3VzKCk7XG4gICAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkZWxlbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkcHJldkVsZW1lbnQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKS5mb2N1cygpO1xuICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJHByZXZFbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJG5leHRFbGVtZW50LmZpbmQoJ1tyb2xlPVwidGFiXCJdJykuZm9jdXMoKTtcbiAgICAgICAgICBfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCRuZXh0RWxlbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgdGFiIGAkdGFyZ2V0Q29udGVudGAgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gVGFiIHRvIG9wZW4uXG4gICAqIEBmaXJlcyBUYWJzI2NoYW5nZVxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIF9oYW5kbGVUYWJDaGFuZ2UoJHRhcmdldCkge1xuICAgIHZhciAkdGFiTGluayA9ICR0YXJnZXQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKSxcbiAgICAgICAgaGFzaCA9ICR0YWJMaW5rWzBdLmhhc2gsXG4gICAgICAgICR0YXJnZXRDb250ZW50ID0gdGhpcy4kdGFiQ29udGVudC5maW5kKGhhc2gpLFxuICAgICAgICAkb2xkVGFiID0gdGhpcy4kZWxlbWVudC5cbiAgICAgICAgICBmaW5kKGAuJHt0aGlzLm9wdGlvbnMubGlua0NsYXNzfS5pcy1hY3RpdmVgKVxuICAgICAgICAgIC5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJylcbiAgICAgICAgICAuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgIC5hdHRyKHsgJ2FyaWEtc2VsZWN0ZWQnOiAnZmFsc2UnIH0pO1xuXG4gICAgJChgIyR7JG9sZFRhYi5hdHRyKCdhcmlhLWNvbnRyb2xzJyl9YClcbiAgICAgIC5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJylcbiAgICAgIC5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogJ3RydWUnIH0pO1xuXG4gICAgJHRhcmdldC5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG5cbiAgICAkdGFiTGluay5hdHRyKHsnYXJpYS1zZWxlY3RlZCc6ICd0cnVlJ30pO1xuXG4gICAgJHRhcmdldENvbnRlbnRcbiAgICAgIC5hZGRDbGFzcygnaXMtYWN0aXZlJylcbiAgICAgIC5hdHRyKHsnYXJpYS1oaWRkZW4nOiAnZmFsc2UnfSk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIHN1Y2Nlc3NmdWxseSBjaGFuZ2VkIHRhYnMuXG4gICAgICogQGV2ZW50IFRhYnMjY2hhbmdlXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2UuemYudGFicycsIFskdGFyZ2V0XSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZCBmb3Igc2VsZWN0aW5nIGEgY29udGVudCBwYW5lIHRvIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7alF1ZXJ5IHwgU3RyaW5nfSBlbGVtIC0galF1ZXJ5IG9iamVjdCBvciBzdHJpbmcgb2YgdGhlIGlkIG9mIHRoZSBwYW5lIHRvIGRpc3BsYXkuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgc2VsZWN0VGFiKGVsZW0pIHtcbiAgICB2YXIgaWRTdHI7XG5cbiAgICBpZiAodHlwZW9mIGVsZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICBpZFN0ciA9IGVsZW1bMF0uaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkU3RyID0gZWxlbTtcbiAgICB9XG5cbiAgICBpZiAoaWRTdHIuaW5kZXhPZignIycpIDwgMCkge1xuICAgICAgaWRTdHIgPSBgIyR7aWRTdHJ9YDtcbiAgICB9XG5cbiAgICB2YXIgJHRhcmdldCA9IHRoaXMuJHRhYlRpdGxlcy5maW5kKGBbaHJlZj1cIiR7aWRTdHJ9XCJdYCkucGFyZW50KGAuJHt0aGlzLm9wdGlvbnMubGlua0NsYXNzfWApO1xuXG4gICAgdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCR0YXJnZXQpO1xuICB9O1xuICAvKipcbiAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIGVhY2ggcGFuZWwgdG8gdGhlIGhlaWdodCBvZiB0aGUgdGFsbGVzdCBwYW5lbC5cbiAgICogSWYgZW5hYmxlZCBpbiBvcHRpb25zLCBnZXRzIGNhbGxlZCBvbiBtZWRpYSBxdWVyeSBjaGFuZ2UuXG4gICAqIElmIGxvYWRpbmcgY29udGVudCB2aWEgZXh0ZXJuYWwgc291cmNlLCBjYW4gYmUgY2FsbGVkIGRpcmVjdGx5IG9yIHdpdGggX3JlZmxvdy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0SGVpZ2h0KCkge1xuICAgIHZhciBtYXggPSAwO1xuICAgIHRoaXMuJHRhYkNvbnRlbnRcbiAgICAgIC5maW5kKGAuJHt0aGlzLm9wdGlvbnMucGFuZWxDbGFzc31gKVxuICAgICAgLmNzcygnaGVpZ2h0JywgJycpXG4gICAgICAuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhbmVsID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGlzQWN0aXZlID0gcGFuZWwuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXG4gICAgICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgICBwYW5lbC5jc3Moeyd2aXNpYmlsaXR5JzogJ2hpZGRlbicsICdkaXNwbGF5JzogJ2Jsb2NrJ30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcblxuICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgICAgcGFuZWwuY3NzKHtcbiAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJycsXG4gICAgICAgICAgICAnZGlzcGxheSc6ICcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXggPSB0ZW1wID4gbWF4ID8gdGVtcCA6IG1heDtcbiAgICAgIH0pXG4gICAgICAuY3NzKCdoZWlnaHQnLCBgJHttYXh9cHhgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhbiB0YWJzLlxuICAgKiBAZmlyZXMgVGFicyNkZXN0cm95ZWRcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLmZpbmQoYC4ke3RoaXMub3B0aW9ucy5saW5rQ2xhc3N9YClcbiAgICAgIC5vZmYoJy56Zi50YWJzJykuaGlkZSgpLmVuZCgpXG4gICAgICAuZmluZChgLiR7dGhpcy5vcHRpb25zLnBhbmVsQ2xhc3N9YClcbiAgICAgIC5oaWRlKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICQod2luZG93KS5vZmYoJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG59XG5cblRhYnMuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIHdpbmRvdyB0byBzY3JvbGwgdG8gY29udGVudCBvZiBhY3RpdmUgcGFuZSBvbiBsb2FkIGlmIHNldCB0byB0cnVlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBhdXRvRm9jdXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBBbGxvd3Mga2V5Ym9hcmQgaW5wdXQgdG8gJ3dyYXAnIGFyb3VuZCB0aGUgdGFiIGxpbmtzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIHdyYXBPbktleXM6IHRydWUsXG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgdGFiIGNvbnRlbnQgcGFuZXMgdG8gbWF0Y2ggaGVpZ2h0cyBpZiBzZXQgdG8gdHJ1ZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgbWF0Y2hIZWlnaHQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIGBsaWAncyBpbiB0YWIgbGluayBsaXN0LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICd0YWJzLXRpdGxlJ1xuICAgKi9cbiAgbGlua0NsYXNzOiAndGFicy10aXRsZScsXG5cbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGNvbnRlbnQgY29udGFpbmVycy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAndGFicy1wYW5lbCdcbiAgICovXG4gIHBhbmVsQ2xhc3M6ICd0YWJzLXBhbmVsJ1xufTtcblxuZnVuY3Rpb24gY2hlY2tDbGFzcygkZWxlbSl7XG4gIHJldHVybiAkZWxlbS5oYXNDbGFzcygnaXMtYWN0aXZlJyk7XG59XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihUYWJzLCAnVGFicycpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogVG9nZ2xlciBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udG9nZ2xlclxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqL1xuXG5jbGFzcyBUb2dnbGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVG9nZ2xlci5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBUb2dnbGVyI2luaXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBUb2dnbGVyLmRlZmF1bHRzLCBlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5jbGFzc05hbWUgPSAnJztcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgICB0aGlzLl9ldmVudHMoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1RvZ2dsZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgVG9nZ2xlciBwbHVnaW4gYnkgcGFyc2luZyB0aGUgdG9nZ2xlIGNsYXNzIGZyb20gZGF0YS10b2dnbGVyLCBvciBhbmltYXRpb24gY2xhc3NlcyBmcm9tIGRhdGEtYW5pbWF0ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgaW5wdXQ7XG4gICAgLy8gUGFyc2UgYW5pbWF0aW9uIGNsYXNzZXMgaWYgdGhleSB3ZXJlIHNldFxuICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgaW5wdXQgPSB0aGlzLm9wdGlvbnMuYW5pbWF0ZS5zcGxpdCgnICcpO1xuXG4gICAgICB0aGlzLmFuaW1hdGlvbkluID0gaW5wdXRbMF07XG4gICAgICB0aGlzLmFuaW1hdGlvbk91dCA9IGlucHV0WzFdIHx8IG51bGw7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgcGFyc2UgdG9nZ2xlIGNsYXNzXG4gICAgZWxzZSB7XG4gICAgICBpbnB1dCA9IHRoaXMuJGVsZW1lbnQuZGF0YSgndG9nZ2xlcicpO1xuICAgICAgLy8gQWxsb3cgZm9yIGEgLiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gaW5wdXRbMF0gPT09ICcuJyA/IGlucHV0LnNsaWNlKDEpIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIEFSSUEgYXR0cmlidXRlcyB0byB0cmlnZ2Vyc1xuICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQ7XG4gICAgJChgW2RhdGEtb3Blbj1cIiR7aWR9XCJdLCBbZGF0YS1jbG9zZT1cIiR7aWR9XCJdLCBbZGF0YS10b2dnbGU9XCIke2lkfVwiXWApXG4gICAgICAuYXR0cignYXJpYS1jb250cm9scycsIGlkKTtcbiAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGhpZGRlbiwgYWRkIGFyaWEtaGlkZGVuXG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdGhpcy4kZWxlbWVudC5pcygnOmhpZGRlbicpID8gZmFsc2UgOiB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSB0b2dnbGUgdHJpZ2dlci5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHRoaXMuJGVsZW1lbnQub2ZmKCd0b2dnbGUuemYudHJpZ2dlcicpLm9uKCd0b2dnbGUuemYudHJpZ2dlcicsIHRoaXMudG9nZ2xlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHRhcmdldCBjbGFzcyBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuIEFuIGV2ZW50IGlzIGZpcmVkIGZyb20gdGhlIG9yaWdpbmFsIHRyaWdnZXIgZGVwZW5kaW5nIG9uIGlmIHRoZSByZXN1bHRhbnQgc3RhdGUgd2FzIFwib25cIiBvciBcIm9mZlwiLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIFRvZ2dsZXIjb25cbiAgICogQGZpcmVzIFRvZ2dsZXIjb2ZmXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgdGhpc1sgdGhpcy5vcHRpb25zLmFuaW1hdGUgPyAnX3RvZ2dsZUFuaW1hdGUnIDogJ190b2dnbGVDbGFzcyddKCk7XG4gIH1cblxuICBfdG9nZ2xlQ2xhc3MoKSB7XG4gICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLmNsYXNzTmFtZSk7XG5cbiAgICB2YXIgaXNPbiA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5jbGFzc05hbWUpO1xuICAgIGlmIChpc09uKSB7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBoYXMgdGhlIGNsYXNzIGFmdGVyIGEgdG9nZ2xlLlxuICAgICAgICogQGV2ZW50IFRvZ2dsZXIjb25cbiAgICAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvbi56Zi50b2dnbGVyJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSB0aGUgY2xhc3MgYWZ0ZXIgYSB0b2dnbGUuXG4gICAgICAgKiBAZXZlbnQgVG9nZ2xlciNvZmZcbiAgICAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvZmYuemYudG9nZ2xlcicpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUFSSUEoaXNPbik7XG4gIH1cblxuICBfdG9nZ2xlQW5pbWF0ZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fdXBkYXRlQVJJQSh0cnVlKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdvbi56Zi50b2dnbGVyJyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uT3V0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX3VwZGF0ZUFSSUEoZmFsc2UpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ29mZi56Zi50b2dnbGVyJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlQVJJQShpc09uKSB7XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPbiA/IHRydWUgOiBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIFRvZ2dsZXIgb24gdGhlIGVsZW1lbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRvZ2dsZXInKTtcbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cbn1cblxuVG9nZ2xlci5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFRlbGxzIHRoZSBwbHVnaW4gaWYgdGhlIGVsZW1lbnQgc2hvdWxkIGFuaW1hdGVkIHdoZW4gdG9nZ2xlZC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgYW5pbWF0ZTogZmFsc2Vcbn07XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihUb2dnbGVyLCAnVG9nZ2xlcicpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogVG9vbHRpcCBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udG9vbHRpcFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5ib3hcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqL1xuXG5jbGFzcyBUb29sdGlwIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBUb29sdGlwLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIFRvb2x0aXAjaW5pdFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYXR0YWNoIGEgdG9vbHRpcCB0by5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvYmplY3QgdG8gZXh0ZW5kIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvb2x0aXAuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ2xpY2sgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdUb29sdGlwJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHRvb2x0aXAgYnkgc2V0dGluZyB0aGUgY3JlYXRpbmcgdGhlIHRpcCBlbGVtZW50LCBhZGRpbmcgaXQncyB0ZXh0LCBzZXR0aW5nIHByaXZhdGUgdmFyaWFibGVzIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgb24gdGhlIGFuY2hvci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciBlbGVtSWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKSB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICd0b29sdGlwJyk7XG5cbiAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzIHx8IHRoaXMuX2dldFBvc2l0aW9uQ2xhc3ModGhpcy4kZWxlbWVudCk7XG4gICAgdGhpcy5vcHRpb25zLnRpcFRleHQgPSB0aGlzLm9wdGlvbnMudGlwVGV4dCB8fCB0aGlzLiRlbGVtZW50LmF0dHIoJ3RpdGxlJyk7XG4gICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZSA/ICQodGhpcy5vcHRpb25zLnRlbXBsYXRlKSA6IHRoaXMuX2J1aWxkVGVtcGxhdGUoZWxlbUlkKTtcblxuICAgIHRoaXMudGVtcGxhdGUuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSlcbiAgICAgICAgLnRleHQodGhpcy5vcHRpb25zLnRpcFRleHQpXG4gICAgICAgIC5oaWRlKCk7XG5cbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgJ3RpdGxlJzogJycsXG4gICAgICAnYXJpYS1kZXNjcmliZWRieSc6IGVsZW1JZCxcbiAgICAgICdkYXRhLXlldGktYm94JzogZWxlbUlkLFxuICAgICAgJ2RhdGEtdG9nZ2xlJzogZWxlbUlkLFxuICAgICAgJ2RhdGEtcmVzaXplJzogZWxlbUlkXG4gICAgfSkuYWRkQ2xhc3ModGhpcy50cmlnZ2VyQ2xhc3MpO1xuXG4gICAgLy9oZWxwZXIgdmFyaWFibGVzIHRvIHRyYWNrIG1vdmVtZW50IG9uIGNvbGxpc2lvbnNcbiAgICB0aGlzLnVzZWRQb3NpdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvdW50ZXIgPSA0O1xuICAgIHRoaXMuY2xhc3NDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9ldmVudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcmFicyB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBjbGFzcywgaWYgcHJlc2VudCwgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRQb3NpdGlvbkNsYXNzKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHsgcmV0dXJuICcnOyB9XG4gICAgLy8gdmFyIHBvc2l0aW9uID0gZWxlbWVudC5hdHRyKCdjbGFzcycpLm1hdGNoKC90b3B8bGVmdHxyaWdodC9nKTtcbiAgICB2YXIgcG9zaXRpb24gPSBlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvXFxiKHRvcHxsZWZ0fHJpZ2h0KVxcYi9nKTtcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uWzBdIDogJyc7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuICAvKipcbiAgICogYnVpbGRzIHRoZSB0b29sdGlwIGVsZW1lbnQsIGFkZHMgYXR0cmlidXRlcywgYW5kIHJldHVybnMgdGhlIHRlbXBsYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkVGVtcGxhdGUoaWQpIHtcbiAgICB2YXIgdGVtcGxhdGVDbGFzc2VzID0gKGAke3RoaXMub3B0aW9ucy50b29sdGlwQ2xhc3N9ICR7dGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3N9ICR7dGhpcy5vcHRpb25zLnRlbXBsYXRlQ2xhc3Nlc31gKS50cmltKCk7XG4gICAgdmFyICR0ZW1wbGF0ZSA9ICAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKHRlbXBsYXRlQ2xhc3NlcykuYXR0cih7XG4gICAgICAncm9sZSc6ICd0b29sdGlwJyxcbiAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAnZGF0YS1pcy1hY3RpdmUnOiBmYWxzZSxcbiAgICAgICdkYXRhLWlzLWZvY3VzJzogZmFsc2UsXG4gICAgICAnaWQnOiBpZFxuICAgIH0pO1xuICAgIHJldHVybiAkdGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBpZiBhIGNvbGxpc2lvbiBldmVudCBpcyBkZXRlY3RlZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gcG9zaXRpb25pbmcgY2xhc3MgdG8gdHJ5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVwb3NpdGlvbihwb3NpdGlvbikge1xuICAgIHRoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uID8gcG9zaXRpb24gOiAnYm90dG9tJyk7XG5cbiAgICAvL2RlZmF1bHQsIHRyeSBzd2l0Y2hpbmcgdG8gb3Bwb3NpdGUgc2lkZVxuICAgIGlmICghcG9zaXRpb24gJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCd0b3AnKSA8IDApKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlLmFkZENsYXNzKCd0b3AnKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAndG9wJyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkpIHtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3JpZ2h0JykgPCAwKSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbilcbiAgICAgICAgICAuYWRkQ2xhc3MoJ3JpZ2h0Jyk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0JyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA8IDApKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKVxuICAgICAgICAgIC5hZGRDbGFzcygnbGVmdCcpO1xuICAgIH1cblxuICAgIC8vaWYgZGVmYXVsdCBjaGFuZ2UgZGlkbid0IHdvcmssIHRyeSBib3R0b20gb3IgbGVmdCBmaXJzdFxuICAgIGVsc2UgaWYgKCFwb3NpdGlvbiAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpID4gLTEpICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpIHtcbiAgICAgIHRoaXMudGVtcGxhdGUuYWRkQ2xhc3MoJ2xlZnQnKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAndG9wJyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpID4gLTEpICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpIHtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pXG4gICAgICAgICAgLmFkZENsYXNzKCdsZWZ0Jyk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA+IC0xKSAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkpIHtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPiAtMSkgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA8IDApKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgLy9pZiBub3RoaW5nIGNsZWFyZWQsIHNldCB0byBib3R0b21cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgIH1cbiAgICB0aGlzLmNsYXNzQ2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5jb3VudGVyLS07XG4gIH1cblxuICAvKipcbiAgICogc2V0cyB0aGUgcG9zaXRpb24gY2xhc3Mgb2YgYW4gZWxlbWVudCBhbmQgcmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmIHVudGlsIHRoZXJlIGFyZSBubyBtb3JlIHBvc3NpYmxlIHBvc2l0aW9ucyB0byBhdHRlbXB0LCBvciB0aGUgdG9vbHRpcCBlbGVtZW50IGlzIG5vIGxvbmdlciBjb2xsaWRpbmcuXG4gICAqIGlmIHRoZSB0b29sdGlwIGlzIGxhcmdlciB0aGFuIHRoZSBzY3JlZW4gd2lkdGgsIGRlZmF1bHQgdG8gZnVsbCB3aWR0aCAtIGFueSB1c2VyIHNlbGVjdGVkIG1hcmdpblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFBvc2l0aW9uKCkge1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uQ2xhc3ModGhpcy50ZW1wbGF0ZSksXG4gICAgICAgICR0aXBEaW1zID0gRm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLnRlbXBsYXRlKSxcbiAgICAgICAgJGFuY2hvckRpbXMgPSBGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGVsZW1lbnQpLFxuICAgICAgICBkaXJlY3Rpb24gPSAocG9zaXRpb24gPT09ICdsZWZ0JyA/ICdsZWZ0JyA6ICgocG9zaXRpb24gPT09ICdyaWdodCcpID8gJ2xlZnQnIDogJ3RvcCcpKSxcbiAgICAgICAgcGFyYW0gPSAoZGlyZWN0aW9uID09PSAndG9wJykgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsXG4gICAgICAgIG9mZnNldCA9IChwYXJhbSA9PT0gJ2hlaWdodCcpID8gdGhpcy5vcHRpb25zLnZPZmZzZXQgOiB0aGlzLm9wdGlvbnMuaE9mZnNldCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCgkdGlwRGltcy53aWR0aCA+PSAkdGlwRGltcy53aW5kb3dEaW1zLndpZHRoKSB8fCAoIXRoaXMuY291bnRlciAmJiAhRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLnRlbXBsYXRlKSkpIHtcbiAgICAgIHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSwgdGhpcy4kZWxlbWVudCwgJ2NlbnRlciBib3R0b20nLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQsIHRydWUpKS5jc3Moe1xuICAgICAgLy8gdGhpcy4kZWxlbWVudC5vZmZzZXQoRm91bmRhdGlvbi5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsIHRoaXMuJGVsZW1lbnQsICdjZW50ZXIgYm90dG9tJywgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0LCB0cnVlKSkuY3NzKHtcbiAgICAgICAgJ3dpZHRoJzogJGFuY2hvckRpbXMud2luZG93RGltcy53aWR0aCAtICh0aGlzLm9wdGlvbnMuaE9mZnNldCAqIDIpLFxuICAgICAgICAnaGVpZ2h0JzogJ2F1dG8nXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnRlbXBsYXRlLm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsIHRoaXMuJGVsZW1lbnQsJ2NlbnRlciAnICsgKHBvc2l0aW9uIHx8ICdib3R0b20nKSwgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7XG5cbiAgICB3aGlsZSghRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLnRlbXBsYXRlKSAmJiB0aGlzLmNvdW50ZXIpIHtcbiAgICAgIHRoaXMuX3JlcG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgdGhpcy5fc2V0UG9zaXRpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmV2ZWFscyB0aGUgdG9vbHRpcCwgYW5kIGZpcmVzIGFuIGV2ZW50IHRvIGNsb3NlIGFueSBvdGhlciBvcGVuIHRvb2x0aXBzIG9uIHRoZSBwYWdlXG4gICAqIEBmaXJlcyBUb29sdGlwI2Nsb3NlbWVcbiAgICogQGZpcmVzIFRvb2x0aXAjc2hvd1xuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93T24gIT09ICdhbGwnICYmICFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc2hvd09uKSkge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignVGhlIHNjcmVlbiBpcyB0b28gc21hbGwgdG8gZGlzcGxheSB0aGlzIHRvb2x0aXAnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMudGVtcGxhdGUuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpLnNob3coKTtcbiAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgdG8gY2xvc2UgYWxsIG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcbiAgICAgKiBAZXZlbnQgQ2xvc2VtZSN0b29sdGlwXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZW1lLnpmLnRvb2x0aXAnLCB0aGlzLnRlbXBsYXRlLmF0dHIoJ2lkJykpO1xuXG5cbiAgICB0aGlzLnRlbXBsYXRlLmF0dHIoe1xuICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogdHJ1ZSxcbiAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlXG4gICAgfSk7XG4gICAgX3RoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMudGVtcGxhdGUpO1xuICAgIHRoaXMudGVtcGxhdGUuc3RvcCgpLmhpZGUoKS5jc3MoJ3Zpc2liaWxpdHknLCAnJykuZmFkZUluKHRoaXMub3B0aW9ucy5mYWRlSW5EdXJhdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICAvL21heWJlIGRvIHN0dWZmP1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHRvb2x0aXAgaXMgc2hvd25cbiAgICAgKiBAZXZlbnQgVG9vbHRpcCNzaG93XG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzaG93LnpmLnRvb2x0aXAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgY3VycmVudCB0b29sdGlwLCBhbmQgcmVzZXRzIHRoZSBwb3NpdGlvbmluZyBjbGFzcyBpZiBpdCB3YXMgY2hhbmdlZCBkdWUgdG8gY29sbGlzaW9uXG4gICAqIEBmaXJlcyBUb29sdGlwI2hpZGVcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBoaWRlKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdoaWRpbmcnLCB0aGlzLiRlbGVtZW50LmRhdGEoJ3lldGktYm94JykpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy50ZW1wbGF0ZS5zdG9wKCkuYXR0cih7XG4gICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogZmFsc2VcbiAgICB9KS5mYWRlT3V0KHRoaXMub3B0aW9ucy5mYWRlT3V0RHVyYXRpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcbiAgICAgIGlmIChfdGhpcy5jbGFzc0NoYW5nZWQpIHtcbiAgICAgICAgX3RoaXMudGVtcGxhdGVcbiAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoX3RoaXMuX2dldFBvc2l0aW9uQ2xhc3MoX3RoaXMudGVtcGxhdGUpKVxuICAgICAgICAgICAgIC5hZGRDbGFzcyhfdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MpO1xuXG4gICAgICAgX3RoaXMudXNlZFBvc2l0aW9ucyA9IFtdO1xuICAgICAgIF90aGlzLmNvdW50ZXIgPSA0O1xuICAgICAgIF90aGlzLmNsYXNzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIGZpcmVzIHdoZW4gdGhlIHRvb2x0aXAgaXMgaGlkZGVuXG4gICAgICogQGV2ZW50IFRvb2x0aXAjaGlkZVxuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi50b29sdGlwJyk7XG4gIH1cblxuICAvKipcbiAgICogYWRkcyBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSB0b29sdGlwIGFuZCBpdHMgYW5jaG9yXG4gICAqIFRPRE8gY29tYmluZSBzb21lIG9mIHRoZSBsaXN0ZW5lcnMgbGlrZSBmb2N1cyBhbmQgbW91c2VlbnRlciwgZXRjLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V2ZW50cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciAkdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgIHZhciBpc0ZvY3VzID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXIpIHtcblxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgLm9uKCdtb3VzZWVudGVyLnpmLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghX3RoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKCdtb3VzZWxlYXZlLnpmLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcbiAgICAgICAgaWYgKCFpc0ZvY3VzIHx8IChfdGhpcy5pc0NsaWNrICYmICFfdGhpcy5vcHRpb25zLmNsaWNrT3BlbikpIHtcbiAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY2xpY2tPcGVuKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWRvd24uemYudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKF90aGlzLmlzQ2xpY2spIHtcbiAgICAgICAgICAvL190aGlzLmhpZGUoKTtcbiAgICAgICAgICAvLyBfdGhpcy5pc0NsaWNrID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuaXNDbGljayA9IHRydWU7XG4gICAgICAgICAgaWYgKChfdGhpcy5vcHRpb25zLmRpc2FibGVIb3ZlciB8fCAhX3RoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnKSkgJiYgIV90aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2Vkb3duLnpmLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIF90aGlzLmlzQ2xpY2sgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUZvclRvdWNoKSB7XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAub24oJ3RhcC56Zi50b29sdGlwIHRvdWNoZW5kLnpmLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIF90aGlzLmlzQWN0aXZlID8gX3RoaXMuaGlkZSgpIDogX3RoaXMuc2hvdygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAvLyAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxuICAgICAgLy8gJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmhpZGUuYmluZCh0aGlzKVxuICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmhpZGUuYmluZCh0aGlzKVxuICAgIH0pO1xuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLm9uKCdmb2N1cy56Zi50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgaWYgKF90aGlzLmlzQ2xpY2spIHtcbiAgICAgICAgICAvLyBJZiB3ZSdyZSBub3Qgc2hvd2luZyBvcGVuIG9uIGNsaWNrcywgd2UgbmVlZCB0byBwcmV0ZW5kIGEgY2xpY2stbGF1bmNoZWQgZm9jdXMgaXNuJ3RcbiAgICAgICAgICAvLyBhIHJlYWwgZm9jdXMsIG90aGVyd2lzZSBvbiBob3ZlciBhbmQgY29tZSBiYWNrIHdlIGdldCBiYWQgYmVoYXZpb3JcbiAgICAgICAgICBpZighX3RoaXMub3B0aW9ucy5jbGlja09wZW4pIHsgaXNGb2N1cyA9IGZhbHNlOyB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLm9uKCdmb2N1c291dC56Zi50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgfSlcblxuICAgICAgLm9uKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgIF90aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhZGRzIGEgdG9nZ2xlIG1ldGhvZCwgaW4gYWRkaXRpb24gdG8gdGhlIHN0YXRpYyBzaG93KCkgJiBoaWRlKCkgZnVuY3Rpb25zXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIHRvb2x0aXAsIHJlbW92ZXMgdGVtcGxhdGUgZWxlbWVudCBmcm9tIHRoZSB2aWV3LlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScsIHRoaXMudGVtcGxhdGUudGV4dCgpKVxuICAgICAgICAgICAgICAgICAub2ZmKCcuemYudHJpZ2dlciAuemYudG9vdGlwJylcbiAgICAgICAgICAgICAgICAvLyAgLnJlbW92ZUNsYXNzKCdoYXMtdGlwJylcbiAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKVxuICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS15ZXRpLWJveCcpXG4gICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXRvZ2dsZScpXG4gICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXJlc2l6ZScpO1xuXG4gICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmUoKTtcblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5Ub29sdGlwLmRlZmF1bHRzID0ge1xuICBkaXNhYmxlRm9yVG91Y2g6IGZhbHNlLFxuICAvKipcbiAgICogVGltZSwgaW4gbXMsIGJlZm9yZSBhIHRvb2x0aXAgc2hvdWxkIG9wZW4gb24gaG92ZXIuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMjAwXG4gICAqL1xuICBob3ZlckRlbGF5OiAyMDAsXG4gIC8qKlxuICAgKiBUaW1lLCBpbiBtcywgYSB0b29sdGlwIHNob3VsZCB0YWtlIHRvIGZhZGUgaW50byB2aWV3LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDE1MFxuICAgKi9cbiAgZmFkZUluRHVyYXRpb246IDE1MCxcbiAgLyoqXG4gICAqIFRpbWUsIGluIG1zLCBhIHRvb2x0aXAgc2hvdWxkIHRha2UgdG8gZmFkZSBvdXQgb2Ygdmlldy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAxNTBcbiAgICovXG4gIGZhZGVPdXREdXJhdGlvbjogMTUwLFxuICAvKipcbiAgICogRGlzYWJsZXMgaG92ZXIgZXZlbnRzIGZyb20gb3BlbmluZyB0aGUgdG9vbHRpcCBpZiBzZXQgdG8gdHJ1ZVxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxuICAvKipcbiAgICogT3B0aW9uYWwgYWRkdGlvbmFsIGNsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIHRvb2x0aXAgdGVtcGxhdGUgb24gaW5pdC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnbXktY29vbC10aXAtY2xhc3MnXG4gICAqL1xuICB0ZW1wbGF0ZUNsYXNzZXM6ICcnLFxuICAvKipcbiAgICogTm9uLW9wdGlvbmFsIGNsYXNzIGFkZGVkIHRvIHRvb2x0aXAgdGVtcGxhdGVzLiBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgJ3Rvb2x0aXAnLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICd0b29sdGlwJ1xuICAgKi9cbiAgdG9vbHRpcENsYXNzOiAndG9vbHRpcCcsXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSB0b29sdGlwIGFuY2hvciBlbGVtZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdoYXMtdGlwJ1xuICAgKi9cbiAgdHJpZ2dlckNsYXNzOiAnaGFzLXRpcCcsXG4gIC8qKlxuICAgKiBNaW5pbXVtIGJyZWFrcG9pbnQgc2l6ZSBhdCB3aGljaCB0byBvcGVuIHRoZSB0b29sdGlwLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdzbWFsbCdcbiAgICovXG4gIHNob3dPbjogJ3NtYWxsJyxcbiAgLyoqXG4gICAqIEN1c3RvbSB0ZW1wbGF0ZSB0byBiZSB1c2VkIHRvIGdlbmVyYXRlIG1hcmt1cCBmb3IgdG9vbHRpcC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnJmx0O2RpdiBjbGFzcz1cInRvb2x0aXBcIiZndDsmbHQ7L2RpdiZndDsnXG4gICAqL1xuICB0ZW1wbGF0ZTogJycsXG4gIC8qKlxuICAgKiBUZXh0IGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcCB0ZW1wbGF0ZSBvbiBvcGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdTb21lIGNvb2wgc3BhY2UgZmFjdCBoZXJlLidcbiAgICovXG4gIHRpcFRleHQ6ICcnLFxuICB0b3VjaENsb3NlVGV4dDogJ1RhcCB0byBjbG9zZS4nLFxuICAvKipcbiAgICogQWxsb3dzIHRoZSB0b29sdGlwIHRvIHJlbWFpbiBvcGVuIGlmIHRyaWdnZXJlZCB3aXRoIGEgY2xpY2sgb3IgdG91Y2ggZXZlbnQuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgY2xpY2tPcGVuOiB0cnVlLFxuICAvKipcbiAgICogQWRkaXRpb25hbCBwb3NpdGlvbmluZyBjbGFzc2VzLCBzZXQgYnkgdGhlIEpTXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3RvcCdcbiAgICovXG4gIHBvc2l0aW9uQ2xhc3M6ICcnLFxuICAvKipcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNob3VsZCBwdXNoIGF3YXkgZnJvbSB0aGUgYW5jaG9yIG9uIHRoZSBZIGF4aXMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMTBcbiAgICovXG4gIHZPZmZzZXQ6IDEwLFxuICAvKipcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNob3VsZCBwdXNoIGF3YXkgZnJvbSB0aGUgYW5jaG9yIG9uIHRoZSBYIGF4aXMsIGlmIGFsaWduZWQgdG8gYSBzaWRlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDEyXG4gICAqL1xuICBoT2Zmc2V0OiAxMlxufTtcblxuLyoqXG4gKiBUT0RPIHV0aWxpemUgcmVzaXplIGV2ZW50IHRyaWdnZXJcbiAqL1xuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oVG9vbHRpcCwgJ1Rvb2x0aXAnKTtcblxufShqUXVlcnkpOyIsIid1c2Ugc3RyaWN0JztcblxuLy8gUG9seWZpbGwgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuKGZ1bmN0aW9uKCkge1xuICBpZiAoIURhdGUubm93KVxuICAgIERhdGUubm93ID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuICB2YXIgdmVuZG9ycyA9IFsnd2Via2l0JywgJ21veiddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK2kpIHtcbiAgICAgIHZhciB2cCA9IHZlbmRvcnNbaV07XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZwKydSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9ICh3aW5kb3dbdnArJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvd1t2cCsnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10pO1xuICB9XG4gIGlmICgvaVAoYWR8aG9uZXxvZCkuKk9TIDYvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgfHwgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgbmV4dFRpbWUgPSBNYXRoLm1heChsYXN0VGltZSArIDE2LCBub3cpO1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2sobGFzdFRpbWUgPSBuZXh0VGltZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRUaW1lIC0gbm93KTtcbiAgICB9O1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dDtcbiAgfVxufSkoKTtcblxudmFyIGluaXRDbGFzc2VzICAgPSBbJ211aS1lbnRlcicsICdtdWktbGVhdmUnXTtcbnZhciBhY3RpdmVDbGFzc2VzID0gWydtdWktZW50ZXItYWN0aXZlJywgJ211aS1sZWF2ZS1hY3RpdmUnXTtcblxuLy8gRmluZCB0aGUgcmlnaHQgXCJ0cmFuc2l0aW9uZW5kXCIgZXZlbnQgZm9yIHRoaXMgYnJvd3NlclxudmFyIGVuZEV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdHJhbnNpdGlvbnMgPSB7XG4gICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ09UcmFuc2l0aW9uJzogJ290cmFuc2l0aW9uZW5kJ1xuICB9XG4gIHZhciBlbGVtID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIGZvciAodmFyIHQgaW4gdHJhbnNpdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGVsZW0uc3R5bGVbdF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbnNbdF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59KSgpO1xuXG5mdW5jdGlvbiBhbmltYXRlKGlzSW4sIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcbiAgZWxlbWVudCA9ICQoZWxlbWVudCkuZXEoMCk7XG5cbiAgaWYgKCFlbGVtZW50Lmxlbmd0aCkgcmV0dXJuO1xuXG4gIGlmIChlbmRFdmVudCA9PT0gbnVsbCkge1xuICAgIGlzSW4gPyBlbGVtZW50LnNob3coKSA6IGVsZW1lbnQuaGlkZSgpO1xuICAgIGNiKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGluaXRDbGFzcyA9IGlzSW4gPyBpbml0Q2xhc3Nlc1swXSA6IGluaXRDbGFzc2VzWzFdO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0luID8gYWN0aXZlQ2xhc3Nlc1swXSA6IGFjdGl2ZUNsYXNzZXNbMV07XG5cbiAgLy8gU2V0IHVwIHRoZSBhbmltYXRpb25cbiAgcmVzZXQoKTtcbiAgZWxlbWVudC5hZGRDbGFzcyhhbmltYXRpb24pO1xuICBlbGVtZW50LmNzcygndHJhbnNpdGlvbicsICdub25lJyk7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICBlbGVtZW50LmFkZENsYXNzKGluaXRDbGFzcyk7XG4gICAgaWYgKGlzSW4pIGVsZW1lbnQuc2hvdygpO1xuICB9KTtcblxuICAvLyBTdGFydCB0aGUgYW5pbWF0aW9uXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICBlbGVtZW50WzBdLm9mZnNldFdpZHRoO1xuICAgIGVsZW1lbnQuY3NzKCd0cmFuc2l0aW9uJywgJycpO1xuICAgIGVsZW1lbnQuYWRkQ2xhc3MoYWN0aXZlQ2xhc3MpO1xuICB9KTtcblxuICAvLyBDbGVhbiB1cCB0aGUgYW5pbWF0aW9uIHdoZW4gaXQgZmluaXNoZXNcbiAgZWxlbWVudC5vbmUoJ3RyYW5zaXRpb25lbmQnLCBmaW5pc2gpO1xuXG4gIC8vIEhpZGVzIHRoZSBlbGVtZW50IChmb3Igb3V0IGFuaW1hdGlvbnMpLCByZXNldHMgdGhlIGVsZW1lbnQsIGFuZCBydW5zIGEgY2FsbGJhY2tcbiAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIGlmICghaXNJbikgZWxlbWVudC5oaWRlKCk7XG4gICAgcmVzZXQoKTtcbiAgICBpZiAoY2IpIGNiLmFwcGx5KGVsZW1lbnQpO1xuICB9XG5cbiAgLy8gUmVzZXRzIHRyYW5zaXRpb25zIGFuZCByZW1vdmVzIG1vdGlvbi1zcGVjaWZpYyBjbGFzc2VzXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGVsZW1lbnRbMF0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gMDtcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGluaXRDbGFzcyArICcgJyArIGFjdGl2ZUNsYXNzICsgJyAnICsgYW5pbWF0aW9uKTtcbiAgfVxufVxuXG52YXIgTW90aW9uVUkgPSB7XG4gIGFuaW1hdGVJbjogZnVuY3Rpb24oZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICAgIGFuaW1hdGUodHJ1ZSwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYik7XG4gIH0sXG5cbiAgYW5pbWF0ZU91dDogZnVuY3Rpb24oZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICAgIGFuaW1hdGUoZmFsc2UsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xuICB9XG59XG4iLCIvLyBTbmFwLnN2ZyAwLjQuMVxuLy9cbi8vIENvcHlyaWdodCAoYykgMjAxMyDigJMgMjAxNSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8vXG4vLyBidWlsZDogMjAxNS0wNC0xM1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgXFxcXFxuLy8g4pSCIEV2ZSAwLjQuMiAtIEphdmFTY3JpcHQgRXZlbnRzIExpYnJhcnkgICAgICAgICAgICAgICAgICAgICAg4pSCIFxcXFxcbi8vIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpCBcXFxcXG4vLyDilIIgQXV0aG9yIERtaXRyeSBCYXJhbm92c2tpeSAoaHR0cDovL2RtaXRyeS5iYXJhbm92c2tpeS5jb20vKSDilIIgXFxcXFxuLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxcXFxcblxuKGZ1bmN0aW9uIChnbG9iKSB7XG4gICAgdmFyIHZlcnNpb24gPSBcIjAuNC4yXCIsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgc2VwYXJhdG9yID0gL1tcXC5cXC9dLyxcbiAgICAgICAgY29tYXNlcGFyYXRvciA9IC9cXHMqLFxccyovLFxuICAgICAgICB3aWxkY2FyZCA9IFwiKlwiLFxuICAgICAgICBmdW4gPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgbnVtc29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbnRfZXZlbnQsXG4gICAgICAgIHN0b3AsXG4gICAgICAgIGV2ZW50cyA9IHtuOiB7fX0sXG4gICAgICAgIGZpcnN0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGFzdERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKC0taSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAvKlxcXG4gICAgICogZXZlXG4gICAgIFsgbWV0aG9kIF1cblxuICAgICAqIEZpcmVzIGV2ZW50IHdpdGggZ2l2ZW4gYG5hbWVgLCBnaXZlbiBzY29wZSBhbmQgb3RoZXIgcGFyYW1ldGVycy5cblxuICAgICA+IEFyZ3VtZW50c1xuXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSAqZXZlbnQqLCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkXG4gICAgIC0gc2NvcGUgKG9iamVjdCkgY29udGV4dCBmb3IgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgIC0gdmFyYXJncyAoLi4uKSB0aGUgcmVzdCBvZiBhcmd1bWVudHMgd2lsbCBiZSBzZW50IHRvIGV2ZW50IGhhbmRsZXJzXG5cbiAgICAgPSAob2JqZWN0KSBhcnJheSBvZiByZXR1cm5lZCB2YWx1ZXMgZnJvbSB0aGUgbGlzdGVuZXJzLiBBcnJheSBoYXMgdHdvIG1ldGhvZHMgYC5maXJzdERlZmluZWQoKWAgYW5kIGAubGFzdERlZmluZWQoKWAgdG8gZ2V0IGZpcnN0IG9yIGxhc3Qgbm90IGB1bmRlZmluZWRgIHZhbHVlLlxuICAgIFxcKi9cbiAgICAgICAgZXZlID0gZnVuY3Rpb24gKG5hbWUsIHNjb3BlKSB7XG4gICAgICAgICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgICAgICAgdmFyIGUgPSBldmVudHMsXG4gICAgICAgICAgICAgICAgb2xkc3RvcCA9IHN0b3AsXG4gICAgICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gZXZlLmxpc3RlbmVycyhuYW1lKSxcbiAgICAgICAgICAgICAgICB6ID0gMCxcbiAgICAgICAgICAgICAgICBmID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgbCxcbiAgICAgICAgICAgICAgICBpbmRleGVkID0gW10sXG4gICAgICAgICAgICAgICAgcXVldWUgPSB7fSxcbiAgICAgICAgICAgICAgICBvdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBjZSA9IGN1cnJlbnRfZXZlbnQsXG4gICAgICAgICAgICAgICAgZXJyb3JzID0gW107XG4gICAgICAgICAgICBvdXQuZmlyc3REZWZpbmVkID0gZmlyc3REZWZpbmVkO1xuICAgICAgICAgICAgb3V0Lmxhc3REZWZpbmVkID0gbGFzdERlZmluZWQ7XG4gICAgICAgICAgICBjdXJyZW50X2V2ZW50ID0gbmFtZTtcbiAgICAgICAgICAgIHN0b3AgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGlpOyBpKyspIGlmIChcInpJbmRleFwiIGluIGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChsaXN0ZW5lcnNbaV0uekluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLnpJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVbbGlzdGVuZXJzW2ldLnpJbmRleF0gPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXhlZC5zb3J0KG51bXNvcnQpO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4ZWRbel0gPCAwKSB7XG4gICAgICAgICAgICAgICAgbCA9IHF1ZXVlW2luZGV4ZWRbeisrXV07XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobC5hcHBseShzY29wZSwgYXJncykpO1xuICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSBvbGRzdG9wO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbCA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ6SW5kZXhcIiBpbiBsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsLnpJbmRleCA9PSBpbmRleGVkW3pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHorKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gcXVldWVbaW5kZXhlZFt6XV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCAmJiBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlW2wuekluZGV4XSA9IGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3AgPSBvbGRzdG9wO1xuICAgICAgICAgICAgY3VycmVudF9ldmVudCA9IGNlO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVW5kb2N1bWVudGVkLiBEZWJ1ZyBvbmx5LlxuICAgICAgICBldmUuX2V2ZW50cyA9IGV2ZW50cztcbiAgICAvKlxcXG4gICAgICogZXZlLmxpc3RlbmVyc1xuICAgICBbIG1ldGhvZCBdXG5cbiAgICAgKiBJbnRlcm5hbCBtZXRob2Qgd2hpY2ggZ2l2ZXMgeW91IGFycmF5IG9mIGFsbCBldmVudCBoYW5kbGVycyB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IHRoZSBnaXZlbiBgbmFtZWAuXG5cbiAgICAgPiBBcmd1bWVudHNcblxuICAgICAtIG5hbWUgKHN0cmluZykgbmFtZSBvZiB0aGUgZXZlbnQsIGRvdCAoYC5gKSBvciBzbGFzaCAoYC9gKSBzZXBhcmF0ZWRcblxuICAgICA9IChhcnJheSkgYXJyYXkgb2YgZXZlbnQgaGFuZGxlcnNcbiAgICBcXCovXG4gICAgZXZlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoc2VwYXJhdG9yKSxcbiAgICAgICAgICAgIGUgPSBldmVudHMsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGpqLFxuICAgICAgICAgICAgbmVzLFxuICAgICAgICAgICAgZXMgPSBbZV0sXG4gICAgICAgICAgICBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBuZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGpqID0gZXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIGUgPSBlc1tqXS5uO1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gW2VbbmFtZXNbaV1dLCBlW3dpbGRjYXJkXV07XG4gICAgICAgICAgICAgICAgayA9IDI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGstLSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gaXRlbXNba107XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IG91dC5jb25jYXQoaXRlbS5mIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzID0gbmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBcbiAgICAvKlxcXG4gICAgICogZXZlLm9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCaW5kcyBnaXZlbiBldmVudCBoYW5kbGVyIHdpdGggYSBnaXZlbiBuYW1lLiBZb3UgY2FuIHVzZSB3aWxkY2FyZHMg4oCcYCpg4oCdIGZvciB0aGUgbmFtZXM6XG4gICAgIHwgZXZlLm9uKFwiKi51bmRlci4qXCIsIGYpO1xuICAgICB8IGV2ZShcIm1vdXNlLnVuZGVyLmZsb29yXCIpOyAvLyB0cmlnZ2VycyBmXG4gICAgICogVXNlIEBldmUgdG8gdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAgICoqXG4gICAgID4gQXJndW1lbnRzXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqKlxuICAgICA9IChmdW5jdGlvbikgcmV0dXJuZWQgZnVuY3Rpb24gYWNjZXB0cyBhIHNpbmdsZSBudW1lcmljIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgei1pbmRleCBvZiB0aGUgaGFuZGxlci4gSXQgaXMgYW4gb3B0aW9uYWwgZmVhdHVyZSBhbmQgb25seSB1c2VkIHdoZW4geW91IG5lZWQgdG8gZW5zdXJlIHRoYXQgc29tZSBzdWJzZXQgb2YgaGFuZGxlcnMgd2lsbCBiZSBpbnZva2VkIGluIGEgZ2l2ZW4gb3JkZXIsIGRlc3BpdGUgb2YgdGhlIG9yZGVyIG9mIGFzc2lnbm1lbnQuIFxuICAgICA+IEV4YW1wbGU6XG4gICAgIHwgZXZlLm9uKFwibW91c2VcIiwgZWF0SXQpKDIpO1xuICAgICB8IGV2ZS5vbihcIm1vdXNlXCIsIHNjcmVhbSk7XG4gICAgIHwgZXZlLm9uKFwibW91c2VcIiwgY2F0Y2hJdCkoMSk7XG4gICAgICogVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGBjYXRjaEl0YCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgYGVhdEl0YC5cbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IHRvIHB1dCB5b3VyIGhhbmRsZXIgYmVmb3JlIG5vbi1pbmRleGVkIGhhbmRsZXJzLCBzcGVjaWZ5IGEgbmVnYXRpdmUgdmFsdWUuXG4gICAgICogTm90ZTogSSBhc3N1bWUgbW9zdCBvZiB0aGUgdGltZSB5b3UgZG9u4oCZdCBuZWVkIHRvIHdvcnJ5IGFib3V0IHotaW5kZXgsIGJ1dCBpdOKAmXMgbmljZSB0byBoYXZlIHRoaXMgZmVhdHVyZSDigJxqdXN0IGluIGNhc2XigJ0uXG4gICAgXFwqL1xuICAgIGV2ZS5vbiA9IGZ1bmN0aW9uIChuYW1lLCBmKSB7XG4gICAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgZiAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KGNvbWFzZXBhcmF0b3IpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgICAgIGUgPSBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUubjtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUuaGFzT3duUHJvcGVydHkobmFtZXNbaV0pICYmIGVbbmFtZXNbaV1dIHx8IChlW25hbWVzW2ldXSA9IHtuOiB7fX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmYgPSBlLmYgfHwgW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBlLmYubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKGUuZltpXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICFleGlzdCAmJiBlLmYucHVzaChmKTtcbiAgICAgICAgICAgIH0obmFtZXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHpJbmRleCkge1xuICAgICAgICAgICAgaWYgKCt6SW5kZXggPT0gK3pJbmRleCkge1xuICAgICAgICAgICAgICAgIGYuekluZGV4ID0gK3pJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUuZlxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgZmlyZSBnaXZlbiBldmVudCB3aXRoIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKiBBcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgcmVzdWx0IGZ1bmN0aW9uIHdpbGwgYmUgYWxzb1xuICAgICAqIGNvbmNhdGVkIHRvIHRoZSBsaXN0IG9mIGZpbmFsIGFyZ3VtZW50cy5cbiAgICAgfCBlbC5vbmNsaWNrID0gZXZlLmYoXCJjbGlja1wiLCAxLCAyKTtcbiAgICAgfCBldmUub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICB8ICAgICBjb25zb2xlLmxvZyhhLCBiLCBjKTsgLy8gMSwgMiwgW2V2ZW50IG9iamVjdF1cbiAgICAgfCB9KTtcbiAgICAgPiBBcmd1bWVudHNcbiAgICAgLSBldmVudCAoc3RyaW5nKSBldmVudCBuYW1lXG4gICAgIC0gdmFyYXJncyAo4oCmKSBhbmQgYW55IG90aGVyIGFyZ3VtZW50c1xuICAgICA9IChmdW5jdGlvbikgcG9zc2libGUgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgIFxcKi9cbiAgICBldmUuZiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUuYXBwbHkobnVsbCwgW2V2ZW50LCBudWxsXS5jb25jYXQoYXR0cnMpLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSXMgdXNlZCBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlciB0byBzdG9wIHRoZSBldmVudCwgcHJldmVudGluZyBhbnkgc3Vic2VxdWVudCBsaXN0ZW5lcnMgZnJvbSBmaXJpbmcuXG4gICAgXFwqL1xuICAgIGV2ZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9wID0gMTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUubnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvdWxkIGJlIHVzZWQgaW5zaWRlIGV2ZW50IGhhbmRsZXIgdG8gZmlndXJlIG91dCBhY3R1YWwgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICoqXG4gICAgID4gQXJndW1lbnRzXG4gICAgICoqXG4gICAgIC0gc3VibmFtZSAoc3RyaW5nKSAjb3B0aW9uYWwgc3VibmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKipcbiAgICAgPSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgaWYgYHN1Ym5hbWVgIGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBvclxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAsIGlmIGN1cnJlbnQgZXZlbnTigJlzIG5hbWUgY29udGFpbnMgYHN1Ym5hbWVgXG4gICAgXFwqL1xuICAgIGV2ZS5udCA9IGZ1bmN0aW9uIChzdWJuYW1lKSB7XG4gICAgICAgIGlmIChzdWJuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/OlxcXFwufFxcXFwvfF4pXCIgKyBzdWJuYW1lICsgXCIoPzpcXFxcLnxcXFxcL3wkKVwiKS50ZXN0KGN1cnJlbnRfZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50X2V2ZW50O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5udHNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvdWxkIGJlIHVzZWQgaW5zaWRlIGV2ZW50IGhhbmRsZXIgdG8gZmlndXJlIG91dCBhY3R1YWwgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICoqXG4gICAgICoqXG4gICAgID0gKGFycmF5KSBuYW1lcyBvZiB0aGUgZXZlbnRcbiAgICBcXCovXG4gICAgZXZlLm50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRfZXZlbnQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUub2ZmXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGdpdmVuIGZ1bmN0aW9uIGZyb20gdGhlIGxpc3Qgb2YgZXZlbnQgbGlzdGVuZXJzIGFzc2lnbmVkIHRvIGdpdmVuIG5hbWUuXG4gICAgICogSWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZCBhbGwgdGhlIGV2ZW50cyB3aWxsIGJlIGNsZWFyZWQuXG4gICAgICoqXG4gICAgID4gQXJndW1lbnRzXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogZXZlLnVuYmluZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBldmUub2ZmXG4gICAgXFwqL1xuICAgIGV2ZS5vZmYgPSBldmUudW5iaW5kID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBldmUuX2V2ZW50cyA9IGV2ZW50cyA9IHtuOiB7fX07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChjb21hc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBldmUub2ZmKG5hbWVzW2ldLCBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuYW1lcyA9IG5hbWUuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzcGxpY2UsXG4gICAgICAgICAgICBpLCBpaSwgaiwgamosXG4gICAgICAgICAgICBjdXIgPSBbZXZlbnRzXTtcbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VyLmxlbmd0aDsgaiArPSBzcGxpY2UubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgICAgIHNwbGljZSA9IFtqLCAxXTtcbiAgICAgICAgICAgICAgICBlID0gY3VyW2pdLm47XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzW2ldICE9IHdpbGRjYXJkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlW25hbWVzW2ldXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlLnB1c2goZVtuYW1lc1tpXV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gZSkgaWYgKGVbaGFzXShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2UucHVzaChlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ci5zcGxpY2UuYXBwbHkoY3VyLCBzcGxpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gY3VyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGUgPSBjdXJbaV07XG4gICAgICAgICAgICB3aGlsZSAoZS5uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBlLmYubGVuZ3RoOyBqIDwgamo7IGorKykgaWYgKGUuZltqXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5mLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICFlLmYubGVuZ3RoICYmIGRlbGV0ZSBlLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gZS5uKSBpZiAoZS5uW2hhc10oa2V5KSAmJiBlLm5ba2V5XS5mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3MgPSBlLm5ba2V5XS5mO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBmdW5jcy5sZW5ndGg7IGogPCBqajsgaisrKSBpZiAoZnVuY3Nbal0gPT0gZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jcy5sZW5ndGggJiYgZGVsZXRlIGUubltrZXldLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZS5mO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlLm4pIGlmIChlLm5baGFzXShrZXkpICYmIGUubltrZXldLmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlLm5ba2V5XS5mO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUgPSBlLm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUub25jZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQmluZHMgZ2l2ZW4gZXZlbnQgaGFuZGxlciB3aXRoIGEgZ2l2ZW4gbmFtZSB0byBvbmx5IHJ1biBvbmNlIHRoZW4gdW5iaW5kIGl0c2VsZi5cbiAgICAgfCBldmUub25jZShcImxvZ2luXCIsIGYpO1xuICAgICB8IGV2ZShcImxvZ2luXCIpOyAvLyB0cmlnZ2VycyBmXG4gICAgIHwgZXZlKFwibG9naW5cIik7IC8vIG5vIGxpc3RlbmVyc1xuICAgICAqIFVzZSBAZXZlIHRvIHRyaWdnZXIgdGhlIGxpc3RlbmVyLlxuICAgICAqKlxuICAgICA+IEFyZ3VtZW50c1xuICAgICAqKlxuICAgICAtIG5hbWUgKHN0cmluZykgbmFtZSBvZiB0aGUgZXZlbnQsIGRvdCAoYC5gKSBvciBzbGFzaCAoYC9gKSBzZXBhcmF0ZWQsIHdpdGggb3B0aW9uYWwgd2lsZGNhcmRzXG4gICAgIC0gZiAoZnVuY3Rpb24pIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKipcbiAgICAgPSAoZnVuY3Rpb24pIHNhbWUgcmV0dXJuIGZ1bmN0aW9uIGFzIEBldmUub25cbiAgICBcXCovXG4gICAgZXZlLm9uY2UgPSBmdW5jdGlvbiAobmFtZSwgZikge1xuICAgICAgICB2YXIgZjIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUudW5iaW5kKG5hbWUsIGYyKTtcbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBldmUub24obmFtZSwgZjIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS52ZXJzaW9uXG4gICAgIFsgcHJvcGVydHkgKHN0cmluZykgXVxuICAgICAqKlxuICAgICAqIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS5cbiAgICBcXCovXG4gICAgZXZlLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGV2ZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiWW91IGFyZSBydW5uaW5nIEV2ZSBcIiArIHZlcnNpb247XG4gICAgfTtcbiAgICAodHlwZW9mIG1vZHVsZSAhPSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSA/IChtb2R1bGUuZXhwb3J0cyA9IGV2ZSkgOiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgPyAoZGVmaW5lKFwiZXZlXCIsIFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGV2ZTsgfSkpIDogKGdsb2IuZXZlID0gZXZlKSk7XG59KSh0aGlzKTtcblxuKGZ1bmN0aW9uIChnbG9iLCBmYWN0b3J5KSB7XG4gICAgLy8gQU1EIHN1cHBvcnRcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZVxuICAgICAgICBkZWZpbmUoW1wiZXZlXCJdLCBmdW5jdGlvbiAoZXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShnbG9iLCBldmUpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE5leHQgZm9yIE5vZGUuanMgb3IgQ29tbW9uSlNcbiAgICAgICAgdmFyIGV2ZSA9IHJlcXVpcmUoJ2V2ZScpO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZ2xvYiwgZXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKGdsb2IgaXMgd2luZG93KVxuICAgICAgICAvLyBTbmFwIGFkZHMgaXRzZWxmIHRvIHdpbmRvd1xuICAgICAgICBmYWN0b3J5KGdsb2IsIGdsb2IuZXZlKTtcbiAgICB9XG59KHdpbmRvdyB8fCB0aGlzLCBmdW5jdGlvbiAod2luZG93LCBldmUpIHtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLyBcbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIG1pbmEgPSAoZnVuY3Rpb24gKGV2ZSkge1xuICAgIHZhciBhbmltYXRpb25zID0ge30sXG4gICAgcmVxdWVzdEFuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gYSBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgIH0sXG4gICAgaWRnZW4gPSAwLFxuICAgIGlkcHJlZml4ID0gXCJNXCIgKyAoK25ldyBEYXRlKS50b1N0cmluZygzNiksXG4gICAgSUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZHByZWZpeCArIChpZGdlbisrKS50b1N0cmluZygzNik7XG4gICAgfSxcbiAgICBkaWZmID0gZnVuY3Rpb24gKGEsIGIsIEEsIEIpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gZGlmZihhW2ldLCBiLCBBW2ldLCBCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZiA9IChBIC0gYSkgLyAoQiAtIGIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGJiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSArIGRpZiAqIChiYiAtIGIpO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGltZXIgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiArbmV3IERhdGU7XG4gICAgfSxcbiAgICBzdGEgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcyA9IGEucyAtIHZhbDtcbiAgICAgICAgYS5iICs9IGEuZHVyICogZHM7XG4gICAgICAgIGEuQiArPSBhLmR1ciAqIGRzO1xuICAgICAgICBhLnMgPSB2YWw7XG4gICAgfSxcbiAgICBzcGVlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnNwZDtcbiAgICAgICAgfVxuICAgICAgICBhLnNwZCA9IHZhbDtcbiAgICB9LFxuICAgIGR1cmF0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGEuZHVyO1xuICAgICAgICB9XG4gICAgICAgIGEucyA9IGEucyAqIHZhbCAvIGEuZHVyO1xuICAgICAgICBhLmR1ciA9IHZhbDtcbiAgICB9LFxuICAgIHN0b3BpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBkZWxldGUgYW5pbWF0aW9uc1thLmlkXTtcbiAgICAgICAgYS51cGRhdGUoKTtcbiAgICAgICAgZXZlKFwibWluYS5zdG9wLlwiICsgYS5pZCwgYSk7XG4gICAgfSxcbiAgICBwYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBpZiAoYS5wZGlmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGFuaW1hdGlvbnNbYS5pZF07XG4gICAgICAgIGEudXBkYXRlKCk7XG4gICAgICAgIGEucGRpZiA9IGEuZ2V0KCkgLSBhLmI7XG4gICAgfSxcbiAgICByZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKCFhLnBkaWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhLmIgPSBhLmdldCgpIC0gYS5wZGlmO1xuICAgICAgICBkZWxldGUgYS5wZGlmO1xuICAgICAgICBhbmltYXRpb25zW2EuaWRdID0gYTtcbiAgICB9LFxuICAgIHVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgcmVzO1xuICAgICAgICBpZiAoaXNBcnJheShhLnN0YXJ0KSkge1xuICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBhLnN0YXJ0Lmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZXNbal0gPSArYS5zdGFydFtqXSArXG4gICAgICAgICAgICAgICAgICAgIChhLmVuZFtqXSAtIGEuc3RhcnRbal0pICogYS5lYXNpbmcoYS5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9ICthLnN0YXJ0ICsgKGEuZW5kIC0gYS5zdGFydCkgKiBhLmVhc2luZyhhLnMpO1xuICAgICAgICB9XG4gICAgICAgIGEuc2V0KHJlcyk7XG4gICAgfSxcbiAgICBmcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYW5pbWF0aW9ucykgaWYgKGFuaW1hdGlvbnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHZhciBhID0gYW5pbWF0aW9uc1tpXSxcbiAgICAgICAgICAgICAgICBiID0gYS5nZXQoKSxcbiAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIGEucyA9IChiIC0gYS5iKSAvIChhLmR1ciAvIGEuc3BkKTtcbiAgICAgICAgICAgIGlmIChhLnMgPj0gMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhbmltYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGEucyA9IDE7XG4gICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlKFwibWluYS5maW5pc2guXCIgKyBhLmlkLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiAmJiByZXF1ZXN0QW5pbUZyYW1lKGZyYW1lKTtcbiAgICB9LFxuICAgIC8qXFxcbiAgICAgKiBtaW5hXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHZW5lcmljIGFuaW1hdGlvbiBvZiBudW1iZXJzXG4gICAgICoqXG4gICAgIC0gYSAobnVtYmVyKSBzdGFydCBfc2xhdmVfIG51bWJlclxuICAgICAtIEEgKG51bWJlcikgZW5kIF9zbGF2ZV8gbnVtYmVyXG4gICAgIC0gYiAobnVtYmVyKSBzdGFydCBfbWFzdGVyXyBudW1iZXIgKHN0YXJ0IHRpbWUgaW4gZ2VuZXJhbCBjYXNlKVxuICAgICAtIEIgKG51bWJlcikgZW5kIF9tYXN0ZXJfIG51bWJlciAoZW5kIHRpbWUgaW4gZ2VyZWFsIGNhc2UpXG4gICAgIC0gZ2V0IChmdW5jdGlvbikgZ2V0dGVyIG9mIF9tYXN0ZXJfIG51bWJlciAoc2VlIEBtaW5hLnRpbWUpXG4gICAgIC0gc2V0IChmdW5jdGlvbikgc2V0dGVyIG9mIF9zbGF2ZV8gbnVtYmVyXG4gICAgIC0gZWFzaW5nIChmdW5jdGlvbikgI29wdGlvbmFsIGVhc2luZyBmdW5jdGlvbiwgZGVmYXVsdCBpcyBAbWluYS5saW5lYXJcbiAgICAgPSAob2JqZWN0KSBhbmltYXRpb24gZGVzY3JpcHRvclxuICAgICBvIHtcbiAgICAgbyAgICAgICAgIGlkIChzdHJpbmcpIGFuaW1hdGlvbiBpZCxcbiAgICAgbyAgICAgICAgIHN0YXJ0IChudW1iZXIpIHN0YXJ0IF9zbGF2ZV8gbnVtYmVyLFxuICAgICBvICAgICAgICAgZW5kIChudW1iZXIpIGVuZCBfc2xhdmVfIG51bWJlcixcbiAgICAgbyAgICAgICAgIGIgKG51bWJlcikgc3RhcnQgX21hc3Rlcl8gbnVtYmVyLFxuICAgICBvICAgICAgICAgcyAobnVtYmVyKSBhbmltYXRpb24gc3RhdHVzICgwLi4xKSxcbiAgICAgbyAgICAgICAgIGR1ciAobnVtYmVyKSBhbmltYXRpb24gZHVyYXRpb24sXG4gICAgIG8gICAgICAgICBzcGQgKG51bWJlcikgYW5pbWF0aW9uIHNwZWVkLFxuICAgICBvICAgICAgICAgZ2V0IChmdW5jdGlvbikgZ2V0dGVyIG9mIF9tYXN0ZXJfIG51bWJlciAoc2VlIEBtaW5hLnRpbWUpLFxuICAgICBvICAgICAgICAgc2V0IChmdW5jdGlvbikgc2V0dGVyIG9mIF9zbGF2ZV8gbnVtYmVyLFxuICAgICBvICAgICAgICAgZWFzaW5nIChmdW5jdGlvbikgZWFzaW5nIGZ1bmN0aW9uLCBkZWZhdWx0IGlzIEBtaW5hLmxpbmVhcixcbiAgICAgbyAgICAgICAgIHN0YXR1cyAoZnVuY3Rpb24pIHN0YXR1cyBnZXR0ZXIvc2V0dGVyLFxuICAgICBvICAgICAgICAgc3BlZWQgKGZ1bmN0aW9uKSBzcGVlZCBnZXR0ZXIvc2V0dGVyLFxuICAgICBvICAgICAgICAgZHVyYXRpb24gKGZ1bmN0aW9uKSBkdXJhdGlvbiBnZXR0ZXIvc2V0dGVyLFxuICAgICBvICAgICAgICAgc3RvcCAoZnVuY3Rpb24pIGFuaW1hdGlvbiBzdG9wcGVyXG4gICAgIG8gICAgICAgICBwYXVzZSAoZnVuY3Rpb24pIHBhdXNlcyB0aGUgYW5pbWF0aW9uXG4gICAgIG8gICAgICAgICByZXN1bWUgKGZ1bmN0aW9uKSByZXN1bWVzIHRoZSBhbmltYXRpb25cbiAgICAgbyAgICAgICAgIHVwZGF0ZSAoZnVuY3Rpb24pIGNhbGxlcyBzZXR0ZXIgd2l0aCB0aGUgcmlnaHQgdmFsdWUgb2YgdGhlIGFuaW1hdGlvblxuICAgICBvIH1cbiAgICBcXCovXG4gICAgbWluYSA9IGZ1bmN0aW9uIChhLCBBLCBiLCBCLCBnZXQsIHNldCwgZWFzaW5nKSB7XG4gICAgICAgIHZhciBhbmltID0ge1xuICAgICAgICAgICAgaWQ6IElEKCksXG4gICAgICAgICAgICBzdGFydDogYSxcbiAgICAgICAgICAgIGVuZDogQSxcbiAgICAgICAgICAgIGI6IGIsXG4gICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgZHVyOiBCIC0gYixcbiAgICAgICAgICAgIHNwZDogMSxcbiAgICAgICAgICAgIGdldDogZ2V0LFxuICAgICAgICAgICAgc2V0OiBzZXQsXG4gICAgICAgICAgICBlYXNpbmc6IGVhc2luZyB8fCBtaW5hLmxpbmVhcixcbiAgICAgICAgICAgIHN0YXR1czogc3RhLFxuICAgICAgICAgICAgc3BlZWQ6IHNwZWVkLFxuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgc3RvcDogc3RvcGl0LFxuICAgICAgICAgICAgcGF1c2U6IHBhdXNlLFxuICAgICAgICAgICAgcmVzdW1lOiByZXN1bWUsXG4gICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZVxuICAgICAgICB9O1xuICAgICAgICBhbmltYXRpb25zW2FuaW0uaWRdID0gYW5pbTtcbiAgICAgICAgdmFyIGxlbiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSBpbiBhbmltYXRpb25zKSBpZiAoYW5pbWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgbGVuKys7XG4gICAgICAgICAgICBpZiAobGVuID09IDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZW4gPT0gMSAmJiByZXF1ZXN0QW5pbUZyYW1lKGZyYW1lKTtcbiAgICAgICAgcmV0dXJuIGFuaW07XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS50aW1lXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUuIEVxdWl2YWxlbnQgdG86XG4gICAgIHwgZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICByZXR1cm4gKG5ldyBEYXRlKS5nZXRUaW1lKCk7XG4gICAgIHwgfVxuICAgIFxcKi9cbiAgICBtaW5hLnRpbWUgPSB0aW1lcjtcbiAgICAvKlxcXG4gICAgICogbWluYS5nZXRCeUlkXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIGFuaW1hdGlvbiBieSBpdHMgaWRcbiAgICAgLSBpZCAoc3RyaW5nKSBhbmltYXRpb24ncyBpZFxuICAgICA9IChvYmplY3QpIFNlZSBAbWluYVxuICAgIFxcKi9cbiAgICBtaW5hLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbnNbaWRdIHx8IG51bGw7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBtaW5hLmxpbmVhclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRGVmYXVsdCBsaW5lYXIgZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5saW5lYXIgPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmVhc2VvdXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEVhc2VvdXQgZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5lYXNlb3V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KG4sIDEuNyk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5lYXNlaW5cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEVhc2VpbiBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmVhc2VpbiA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhuLCAuNDgpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuZWFzZWlub3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFYXNlaW5vdXQgZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5lYXNlaW5vdXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcSA9IC40OCAtIG4gLyAxLjA0LFxuICAgICAgICAgICAgUSA9IE1hdGguc3FydCguMTczNCArIHEgKiBxKSxcbiAgICAgICAgICAgIHggPSBRIC0gcSxcbiAgICAgICAgICAgIFggPSBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpICogKHggPCAwID8gLTEgOiAxKSxcbiAgICAgICAgICAgIHkgPSAtUSAtIHEsXG4gICAgICAgICAgICBZID0gTWF0aC5wb3coTWF0aC5hYnMoeSksIDEgLyAzKSAqICh5IDwgMCA/IC0xIDogMSksXG4gICAgICAgICAgICB0ID0gWCArIFkgKyAuNTtcbiAgICAgICAgcmV0dXJuICgxIC0gdCkgKiAzICogdCAqIHQgKyB0ICogdCAqIHQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5iYWNraW5cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJhY2tpbiBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmJhY2tpbiA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmIChuID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIG4gKiBuICogKChzICsgMSkgKiBuIC0gcyk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5iYWNrb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCYWNrb3V0IGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuYmFja291dCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmIChuID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuIC0gMTtcbiAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICByZXR1cm4gbiAqIG4gKiAoKHMgKyAxKSAqIG4gKyBzKSArIDE7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5lbGFzdGljXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFbGFzdGljIGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuZWxhc3RpYyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmIChuID09ICEhbikge1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMCAqIG4pICogTWF0aC5zaW4oKG4gLSAuMDc1KSAqXG4gICAgICAgICAgICAoMiAqIE1hdGguUEkpIC8gLjMpICsgMTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmJvdW5jZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQm91bmNlIGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuYm91bmNlID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIHMgPSA3LjU2MjUsXG4gICAgICAgICAgICBwID0gMi43NSxcbiAgICAgICAgICAgIGw7XG4gICAgICAgIGlmIChuIDwgKDEgLyBwKSkge1xuICAgICAgICAgICAgbCA9IHMgKiBuICogbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuIDwgKDIgLyBwKSkge1xuICAgICAgICAgICAgICAgIG4gLT0gKDEuNSAvIHApO1xuICAgICAgICAgICAgICAgIGwgPSBzICogbiAqIG4gKyAuNzU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChuIDwgKDIuNSAvIHApKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gLT0gKDIuMjUgLyBwKTtcbiAgICAgICAgICAgICAgICAgICAgbCA9IHMgKiBuICogbiArIC45Mzc1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4gLT0gKDIuNjI1IC8gcCk7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBzICogbiAqIG4gKyAuOTg0Mzc1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbDtcbiAgICB9O1xuICAgIHdpbmRvdy5taW5hID0gbWluYTtcbiAgICByZXR1cm4gbWluYTtcbn0pKHR5cGVvZiBldmUgPT0gXCJ1bmRlZmluZWRcIiA/IGZ1bmN0aW9uICgpIHt9IDogZXZlKTtcbi8vIENvcHlyaWdodCAoYykgMjAxMyAtIDIwMTUgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbnZhciBTbmFwID0gKGZ1bmN0aW9uKHJvb3QpIHtcblNuYXAudmVyc2lvbiA9IFwiMC40LjBcIjtcbi8qXFxcbiAqIFNuYXBcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENyZWF0ZXMgYSBkcmF3aW5nIHN1cmZhY2Ugb3Igd3JhcHMgZXhpc3RpbmcgU1ZHIGVsZW1lbnQuXG4gKipcbiAtIHdpZHRoIChudW1iZXJ8c3RyaW5nKSB3aWR0aCBvZiBzdXJmYWNlXG4gLSBoZWlnaHQgKG51bWJlcnxzdHJpbmcpIGhlaWdodCBvZiBzdXJmYWNlXG4gKiBvclxuIC0gRE9NIChTVkdFbGVtZW50KSBlbGVtZW50IHRvIGJlIHdyYXBwZWQgaW50byBTbmFwIHN0cnVjdHVyZVxuICogb3JcbiAtIGFycmF5IChhcnJheSkgYXJyYXkgb2YgZWxlbWVudHMgKHdpbGwgcmV0dXJuIHNldCBvZiBlbGVtZW50cylcbiAqIG9yXG4gLSBxdWVyeSAoc3RyaW5nKSBDU1MgcXVlcnkgc2VsZWN0b3JcbiA9IChvYmplY3QpIEBFbGVtZW50XG5cXCovXG5mdW5jdGlvbiBTbmFwKHcsIGgpIHtcbiAgICBpZiAodykge1xuICAgICAgICBpZiAody5ub2RlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAodyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHcsIFwiYXJyYXlcIikgJiYgU25hcC5zZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLnNldC5hcHBseShTbmFwLCB3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoID09IG51bGwpIHtcbiAgICAgICAgICAgIHcgPSBnbG9iLmRvYy5xdWVyeVNlbGVjdG9yKFN0cmluZyh3KSk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcCh3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3ID0gdyA9PSBudWxsID8gXCIxMDAlXCIgOiB3O1xuICAgIGggPSBoID09IG51bGwgPyBcIjEwMCVcIiA6IGg7XG4gICAgcmV0dXJuIG5ldyBQYXBlcih3LCBoKTtcbn1cblNuYXAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiU25hcCB2XCIgKyB0aGlzLnZlcnNpb247XG59O1xuU25hcC5fID0ge307XG52YXIgZ2xvYiA9IHtcbiAgICB3aW46IHJvb3Qud2luZG93LFxuICAgIGRvYzogcm9vdC53aW5kb3cuZG9jdW1lbnRcbn07XG5TbmFwLl8uZ2xvYiA9IGdsb2I7XG52YXIgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgIFN0ciA9IFN0cmluZyxcbiAgICB0b0Zsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICB0b0ludCA9IHBhcnNlSW50LFxuICAgIG1hdGggPSBNYXRoLFxuICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICBtbWluID0gbWF0aC5taW4sXG4gICAgYWJzID0gbWF0aC5hYnMsXG4gICAgcG93ID0gbWF0aC5wb3csXG4gICAgUEkgPSBtYXRoLlBJLFxuICAgIHJvdW5kID0gbWF0aC5yb3VuZCxcbiAgICBFID0gXCJcIixcbiAgICBTID0gXCIgXCIsXG4gICAgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIElTVVJMID0gL151cmxcXChbJ1wiXT8oW15cXCldKz8pWydcIl0/XFwpJC9pLFxuICAgIGNvbG91clJlZ0V4cCA9IC9eXFxzKigoI1thLWZcXGRdezZ9KXwoI1thLWZcXGRdezN9KXxyZ2JhP1xcKFxccyooW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyU/KD86XFxzKixcXHMqW1xcZFxcLl0rJT8pPylcXHMqXFwpfGhzYmE/XFwoXFxzKihbXFxkXFwuXSsoPzpkZWd8XFx4YjB8JSk/XFxzKixcXHMqW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSsoPzolP1xccyosXFxzKltcXGRcXC5dKyk/JT8pXFxzKlxcKXxoc2xhP1xcKFxccyooW1xcZFxcLl0rKD86ZGVnfFxceGIwfCUpP1xccyosXFxzKltcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rKD86JT9cXHMqLFxccypbXFxkXFwuXSspPyU/KVxccypcXCkpXFxzKiQvaSxcbiAgICBiZXppZXJyZyA9IC9eKD86Y3ViaWMtKT9iZXppZXJcXCgoW14sXSspLChbXixdKyksKFteLF0rKSwoW15cXCldKylcXCkvLFxuICAgIHJlVVJMVmFsdWUgPSAvXnVybFxcKCM/KFteKV0rKVxcKSQvLFxuICAgIHNlcGFyYXRvciA9IFNuYXAuXy5zZXBhcmF0b3IgPSAvWyxcXHNdKy8sXG4gICAgd2hpdGVzcGFjZSA9IC9bXFxzXS9nLFxuICAgIGNvbW1hU3BhY2VzID0gL1tcXHNdKixbXFxzXSovLFxuICAgIGhzcmcgPSB7aHM6IDEsIHJnOiAxfSxcbiAgICBwYXRoQ29tbWFuZCA9IC8oW2Etel0pW1xccyxdKigoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspP1tcXHNdKiw/W1xcc10qKSspL2lnLFxuICAgIHRDb21tYW5kID0gLyhbcnN0bV0pW1xccyxdKigoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspP1tcXHNdKiw/W1xcc10qKSspL2lnLFxuICAgIHBhdGhWYWx1ZXMgPSAvKC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXFxcZCspPylbXFxzXSosP1tcXHNdKi9pZyxcbiAgICBpZGdlbiA9IDAsXG4gICAgaWRwcmVmaXggPSBcIlNcIiArICgrbmV3IERhdGUpLnRvU3RyaW5nKDM2KSxcbiAgICBJRCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gKGVsICYmIGVsLnR5cGUgPyBlbC50eXBlIDogRSkgKyBpZHByZWZpeCArIChpZGdlbisrKS50b1N0cmluZygzNik7XG4gICAgfSxcbiAgICB4bGluayA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgIHhtbG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIGh1YiA9IHt9LFxuICAgIFVSTCA9IFNuYXAudXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gXCJ1cmwoJyNcIiArIHVybCArIFwiJylcIjtcbiAgICB9O1xuXG5mdW5jdGlvbiAkKGVsLCBhdHRyKSB7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgICAgaWYgKGVsID09IFwiI3RleHRcIikge1xuICAgICAgICAgICAgZWwgPSBnbG9iLmRvYy5jcmVhdGVUZXh0Tm9kZShhdHRyLnRleHQgfHwgYXR0cltcIiN0ZXh0XCJdIHx8IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbCA9PSBcIiNjb21tZW50XCIpIHtcbiAgICAgICAgICAgIGVsID0gZ2xvYi5kb2MuY3JlYXRlQ29tbWVudChhdHRyLnRleHQgfHwgYXR0cltcIiN0ZXh0XCJdIHx8IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZWwgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZWwgPSAkKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGF0dHIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGVsLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5zdWJzdHJpbmcoMCwgNikgPT0gXCJ4bGluazpcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlTlMoeGxpbmssIGF0dHIuc3Vic3RyaW5nKDYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIuc3Vic3RyaW5nKDAsIDQpID09IFwieG1sOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGVOUyh4bWxucywgYXR0ci5zdWJzdHJpbmcoNCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyID09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyKSBpZiAoYXR0cltoYXNdKGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gU3RyKGF0dHJba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN1YnN0cmluZygwLCA2KSA9PSBcInhsaW5rOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGluaywga2V5LnN1YnN0cmluZyg2KSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkuc3Vic3RyaW5nKDAsIDQpID09IFwieG1sOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bWxucywga2V5LnN1YnN0cmluZyg0KSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXCJ0ZXh0XCIgaW4gYXR0cikge1xuICAgICAgICAgICAgZWwubm9kZVZhbHVlID0gYXR0ci50ZXh0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSBnbG9iLmRvYy5jcmVhdGVFbGVtZW50TlMoeG1sbnMsIGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xufVxuU25hcC5fLiQgPSAkO1xuU25hcC5fLmlkID0gSUQ7XG5mdW5jdGlvbiBnZXRBdHRycyhlbCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJpYnV0ZXMsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIG91dCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGF0dHJzW2ldLm5hbWVzcGFjZVVSSSA9PSB4bGluaykge1xuICAgICAgICAgICAgbmFtZSA9IFwieGxpbms6XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBuYW1lICs9IGF0dHJzW2ldLm5hbWU7XG4gICAgICAgIG91dFtuYW1lXSA9IGF0dHJzW2ldLnRleHRDb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gaXMobywgdHlwZSkge1xuICAgIHR5cGUgPSBTdHIucHJvdG90eXBlLnRvTG93ZXJDYXNlLmNhbGwodHlwZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJmaW5pdGVcIikge1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUobyk7XG4gICAgfVxuICAgIGlmICh0eXBlID09IFwiYXJyYXlcIiAmJlxuICAgICAgICAobyBpbnN0YW5jZW9mIEFycmF5IHx8IEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheShvKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAgKHR5cGUgPT0gXCJudWxsXCIgJiYgbyA9PT0gbnVsbCkgfHxcbiAgICAgICAgICAgICh0eXBlID09IHR5cGVvZiBvICYmIG8gIT09IG51bGwpIHx8XG4gICAgICAgICAgICAodHlwZSA9PSBcIm9iamVjdFwiICYmIG8gPT09IE9iamVjdChvKSkgfHxcbiAgICAgICAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkgPT0gdHlwZTtcbn1cbi8qXFxcbiAqIFNuYXAuZm9ybWF0XG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXBsYWNlcyBjb25zdHJ1Y3Rpb24gb2YgdHlwZSBgezxuYW1lPn1gIHRvIHRoZSBjb3JyZXNwb25kaW5nIGFyZ3VtZW50XG4gKipcbiAtIHRva2VuIChzdHJpbmcpIHN0cmluZyB0byBmb3JtYXRcbiAtIGpzb24gKG9iamVjdCkgb2JqZWN0IHdoaWNoIHByb3BlcnRpZXMgYXJlIHVzZWQgYXMgYSByZXBsYWNlbWVudFxuID0gKHN0cmluZykgZm9ybWF0dGVkIHN0cmluZ1xuID4gVXNhZ2VcbiB8IC8vIHRoaXMgZHJhd3MgYSByZWN0YW5ndWxhciBzaGFwZSBlcXVpdmFsZW50IHRvIFwiTTEwLDIwaDQwdjUwaC00MHpcIlxuIHwgcGFwZXIucGF0aChTbmFwLmZvcm1hdChcIk17eH0se3l9aHtkaW0ud2lkdGh9dntkaW0uaGVpZ2h0fWh7ZGltWyduZWdhdGl2ZSB3aWR0aCddfXpcIiwge1xuIHwgICAgIHg6IDEwLFxuIHwgICAgIHk6IDIwLFxuIHwgICAgIGRpbToge1xuIHwgICAgICAgICB3aWR0aDogNDAsXG4gfCAgICAgICAgIGhlaWdodDogNTAsXG4gfCAgICAgICAgIFwibmVnYXRpdmUgd2lkdGhcIjogLTQwXG4gfCAgICAgfVxuIHwgfSkpO1xuXFwqL1xuU25hcC5mb3JtYXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b2tlblJlZ2V4ID0gL1xceyhbXlxcfV0rKVxcfS9nLFxuICAgICAgICBvYmpOb3RhdGlvblJlZ2V4ID0gLyg/Oig/Ol58XFwuKSguKz8pKD89XFxbfFxcLnwkfFxcKCl8XFxbKCd8XCIpKC4rPylcXDJcXF0pKFxcKFxcKSk/L2csIC8vIG1hdGNoZXMgLnh4eHh4IG9yIFtcInh4eHh4XCJdIHRvIHJ1biBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIHJlcGxhY2VyID0gZnVuY3Rpb24gKGFsbCwga2V5LCBvYmopIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBvYmo7XG4gICAgICAgICAgICBrZXkucmVwbGFjZShvYmpOb3RhdGlvblJlZ2V4LCBmdW5jdGlvbiAoYWxsLCBuYW1lLCBxdW90ZSwgcXVvdGVkTmFtZSwgaXNGdW5jKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUgfHwgcXVvdGVkTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXMgPT0gXCJmdW5jdGlvblwiICYmIGlzRnVuYyAmJiAocmVzID0gcmVzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA9PSBudWxsIHx8IHJlcyA9PSBvYmogPyBhbGwgOiByZXMpICsgXCJcIjtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIG9iaikge1xuICAgICAgICByZXR1cm4gU3RyKHN0cikucmVwbGFjZSh0b2tlblJlZ2V4LCBmdW5jdGlvbiAoYWxsLCBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlcihhbGwsIGtleSwgb2JqKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pKCk7XG5mdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PSBcImZ1bmN0aW9uXCIgfHwgT2JqZWN0KG9iaikgIT09IG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgcmVzID0gbmV3IG9iai5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAob2JqW2hhc10oa2V5KSkge1xuICAgICAgICByZXNba2V5XSA9IGNsb25lKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblNuYXAuXy5jbG9uZSA9IGNsb25lO1xuZnVuY3Rpb24gcmVwdXNoKGFycmF5LCBpdGVtKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSB7XG4gICAgICAgIHJldHVybiBhcnJheS5wdXNoKGFycmF5LnNwbGljZShpLCAxKVswXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FjaGVyKGYsIHNjb3BlLCBwb3N0cHJvY2Vzc29yKSB7XG4gICAgZnVuY3Rpb24gbmV3ZigpIHtcbiAgICAgICAgdmFyIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgICAgICBhcmdzID0gYXJnLmpvaW4oXCJcXHUyNDAwXCIpLFxuICAgICAgICAgICAgY2FjaGUgPSBuZXdmLmNhY2hlID0gbmV3Zi5jYWNoZSB8fCB7fSxcbiAgICAgICAgICAgIGNvdW50ID0gbmV3Zi5jb3VudCA9IG5ld2YuY291bnQgfHwgW107XG4gICAgICAgIGlmIChjYWNoZVtoYXNdKGFyZ3MpKSB7XG4gICAgICAgICAgICByZXB1c2goY291bnQsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3Rwcm9jZXNzb3IgPyBwb3N0cHJvY2Vzc29yKGNhY2hlW2FyZ3NdKSA6IGNhY2hlW2FyZ3NdO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50Lmxlbmd0aCA+PSAxZTMgJiYgZGVsZXRlIGNhY2hlW2NvdW50LnNoaWZ0KCldO1xuICAgICAgICBjb3VudC5wdXNoKGFyZ3MpO1xuICAgICAgICBjYWNoZVthcmdzXSA9IGYuYXBwbHkoc2NvcGUsIGFyZyk7XG4gICAgICAgIHJldHVybiBwb3N0cHJvY2Vzc29yID8gcG9zdHByb2Nlc3NvcihjYWNoZVthcmdzXSkgOiBjYWNoZVthcmdzXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld2Y7XG59XG5TbmFwLl8uY2FjaGVyID0gY2FjaGVyO1xuZnVuY3Rpb24gYW5nbGUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIGlmICh4MyA9PSBudWxsKSB7XG4gICAgICAgIHZhciB4ID0geDEgLSB4MixcbiAgICAgICAgICAgIHkgPSB5MSAtIHkyO1xuICAgICAgICBpZiAoIXggJiYgIXkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMTgwICsgbWF0aC5hdGFuMigteSwgLXgpICogMTgwIC8gUEkgKyAzNjApICUgMzYwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhbmdsZSh4MSwgeTEsIHgzLCB5MykgLSBhbmdsZSh4MiwgeTIsIHgzLCB5Myk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmFkKGRlZykge1xuICAgIHJldHVybiBkZWcgJSAzNjAgKiBQSSAvIDE4MDtcbn1cbmZ1bmN0aW9uIGRlZyhyYWQpIHtcbiAgICByZXR1cm4gcmFkICogMTgwIC8gUEkgJSAzNjA7XG59XG5mdW5jdGlvbiB4X3koKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIFMgKyB0aGlzLnk7XG59XG5mdW5jdGlvbiB4X3lfd19oKCkge1xuICAgIHJldHVybiB0aGlzLnggKyBTICsgdGhpcy55ICsgUyArIHRoaXMud2lkdGggKyBcIiBcXHhkNyBcIiArIHRoaXMuaGVpZ2h0O1xufVxuXG4vKlxcXG4gKiBTbmFwLnJhZFxuIFsgbWV0aG9kIF1cbiAqKlxuICogVHJhbnNmb3JtIGFuZ2xlIHRvIHJhZGlhbnNcbiAtIGRlZyAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzXG4gPSAobnVtYmVyKSBhbmdsZSBpbiByYWRpYW5zXG5cXCovXG5TbmFwLnJhZCA9IHJhZDtcbi8qXFxcbiAqIFNuYXAuZGVnXG4gWyBtZXRob2QgXVxuICoqXG4gKiBUcmFuc2Zvcm0gYW5nbGUgdG8gZGVncmVlc1xuIC0gcmFkIChudW1iZXIpIGFuZ2xlIGluIHJhZGlhbnNcbiA9IChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuZGVnID0gZGVnO1xuLypcXFxuICogU25hcC5zaW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIEVxdWl2YWxlbnQgdG8gYE1hdGguc2luKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIGFuZ2xlIChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcbiA9IChudW1iZXIpIHNpblxuXFwqL1xuU25hcC5zaW4gPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICByZXR1cm4gbWF0aC5zaW4oU25hcC5yYWQoYW5nbGUpKTtcbn07XG4vKlxcXG4gKiBTbmFwLnRhblxuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC50YW4oKWAgb25seSB3b3JrcyB3aXRoIGRlZ3JlZXMsIG5vdCByYWRpYW5zLlxuIC0gYW5nbGUgKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuID0gKG51bWJlcikgdGFuXG5cXCovXG5TbmFwLnRhbiA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgIHJldHVybiBtYXRoLnRhbihTbmFwLnJhZChhbmdsZSkpO1xufTtcbi8qXFxcbiAqIFNuYXAuY29zXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmNvcygpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBhbmdsZSAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzXG4gPSAobnVtYmVyKSBjb3NcblxcKi9cblNuYXAuY29zID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgcmV0dXJuIG1hdGguY29zKFNuYXAucmFkKGFuZ2xlKSk7XG59O1xuLypcXFxuICogU25hcC5hc2luXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmFzaW4oKWAgb25seSB3b3JrcyB3aXRoIGRlZ3JlZXMsIG5vdCByYWRpYW5zLlxuIC0gbnVtIChudW1iZXIpIHZhbHVlXG4gPSAobnVtYmVyKSBhc2luIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuYXNpbiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gU25hcC5kZWcobWF0aC5hc2luKG51bSkpO1xufTtcbi8qXFxcbiAqIFNuYXAuYWNvc1xuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5hY29zKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIG51bSAobnVtYmVyKSB2YWx1ZVxuID0gKG51bWJlcikgYWNvcyBpbiBkZWdyZWVzXG5cXCovXG5TbmFwLmFjb3MgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIFNuYXAuZGVnKG1hdGguYWNvcyhudW0pKTtcbn07XG4vKlxcXG4gKiBTbmFwLmF0YW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIEVxdWl2YWxlbnQgdG8gYE1hdGguYXRhbigpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBudW0gKG51bWJlcikgdmFsdWVcbiA9IChudW1iZXIpIGF0YW4gaW4gZGVncmVlc1xuXFwqL1xuU25hcC5hdGFuID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBTbmFwLmRlZyhtYXRoLmF0YW4obnVtKSk7XG59O1xuLypcXFxuICogU25hcC5hdGFuMlxuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5hdGFuMigpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBudW0gKG51bWJlcikgdmFsdWVcbiA9IChudW1iZXIpIGF0YW4yIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuYXRhbjIgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIFNuYXAuZGVnKG1hdGguYXRhbjIobnVtKSk7XG59O1xuLypcXFxuICogU25hcC5hbmdsZVxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBhbiBhbmdsZSBiZXR3ZWVuIHR3byBvciB0aHJlZSBwb2ludHNcbiA+IFBhcmFtZXRlcnNcbiAtIHgxIChudW1iZXIpIHggY29vcmQgb2YgZmlyc3QgcG9pbnRcbiAtIHkxIChudW1iZXIpIHkgY29vcmQgb2YgZmlyc3QgcG9pbnRcbiAtIHgyIChudW1iZXIpIHggY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gLSB5MiAobnVtYmVyKSB5IGNvb3JkIG9mIHNlY29uZCBwb2ludFxuIC0geDMgKG51bWJlcikgI29wdGlvbmFsIHggY29vcmQgb2YgdGhpcmQgcG9pbnRcbiAtIHkzIChudW1iZXIpICNvcHRpb25hbCB5IGNvb3JkIG9mIHRoaXJkIHBvaW50XG4gPSAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzXG5cXCovXG5TbmFwLmFuZ2xlID0gYW5nbGU7XG4vKlxcXG4gKiBTbmFwLmxlblxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiA+IFBhcmFtZXRlcnNcbiAtIHgxIChudW1iZXIpIHggY29vcmQgb2YgZmlyc3QgcG9pbnRcbiAtIHkxIChudW1iZXIpIHkgY29vcmQgb2YgZmlyc3QgcG9pbnRcbiAtIHgyIChudW1iZXIpIHggY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gLSB5MiAobnVtYmVyKSB5IGNvb3JkIG9mIHNlY29uZCBwb2ludFxuID0gKG51bWJlcikgZGlzdGFuY2VcblxcKi9cblNuYXAubGVuID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChTbmFwLmxlbjIoeDEsIHkxLCB4MiwgeTIpKTtcbn07XG4vKlxcXG4gKiBTbmFwLmxlbjJcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiA+IFBhcmFtZXRlcnNcbiAtIHgxIChudW1iZXIpIHggY29vcmQgb2YgZmlyc3QgcG9pbnRcbiAtIHkxIChudW1iZXIpIHkgY29vcmQgb2YgZmlyc3QgcG9pbnRcbiAtIHgyIChudW1iZXIpIHggY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gLSB5MiAobnVtYmVyKSB5IGNvb3JkIG9mIHNlY29uZCBwb2ludFxuID0gKG51bWJlcikgZGlzdGFuY2VcblxcKi9cblNuYXAubGVuMiA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiAoeDEgLSB4MikgKiAoeDEgLSB4MikgKyAoeTEgLSB5MikgKiAoeTEgLSB5Mik7XG59O1xuLypcXFxuICogU25hcC5jbG9zZXN0UG9pbnRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgY2xvc2VzdCBwb2ludCB0byBhIGdpdmVuIG9uZSBvbiBhIGdpdmVuIHBhdGguXG4gPiBQYXJhbWV0ZXJzXG4gLSBwYXRoIChFbGVtZW50KSBwYXRoIGVsZW1lbnRcbiAtIHggKG51bWJlcikgeCBjb29yZCBvZiBhIHBvaW50XG4gLSB5IChudW1iZXIpIHkgY29vcmQgb2YgYSBwb2ludFxuID0gKG9iamVjdCkgaW4gZm9ybWF0XG4ge1xuICAgIHggKG51bWJlcikgeCBjb29yZCBvZiB0aGUgcG9pbnQgb24gdGhlIHBhdGhcbiAgICB5IChudW1iZXIpIHkgY29vcmQgb2YgdGhlIHBvaW50IG9uIHRoZSBwYXRoXG4gICAgbGVuZ3RoIChudW1iZXIpIGxlbmd0aCBvZiB0aGUgcGF0aCB0byB0aGUgcG9pbnRcbiAgICBkaXN0YW5jZSAobnVtYmVyKSBkaXN0YW5jZSBmcm9tIHRoZSBnaXZlbiBwb2ludCB0byB0aGUgcGF0aFxuIH1cblxcKi9cbi8vIENvcGllZCBmcm9tIGh0dHA6Ly9ibC5vY2tzLm9yZy9tYm9zdG9jay84MDI3NjM3XG5TbmFwLmNsb3Nlc3RQb2ludCA9IGZ1bmN0aW9uIChwYXRoLCB4LCB5KSB7XG4gICAgZnVuY3Rpb24gZGlzdGFuY2UyKHApIHtcbiAgICAgICAgdmFyIGR4ID0gcC54IC0geCxcbiAgICAgICAgICAgIGR5ID0gcC55IC0geTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH1cbiAgICB2YXIgcGF0aE5vZGUgPSBwYXRoLm5vZGUsXG4gICAgICAgIHBhdGhMZW5ndGggPSBwYXRoTm9kZS5nZXRUb3RhbExlbmd0aCgpLFxuICAgICAgICBwcmVjaXNpb24gPSBwYXRoTGVuZ3RoIC8gcGF0aE5vZGUucGF0aFNlZ0xpc3QubnVtYmVyT2ZJdGVtcyAqIC4xMjUsXG4gICAgICAgIGJlc3QsXG4gICAgICAgIGJlc3RMZW5ndGgsXG4gICAgICAgIGJlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgLy8gbGluZWFyIHNjYW4gZm9yIGNvYXJzZSBhcHByb3hpbWF0aW9uXG4gICAgZm9yICh2YXIgc2Nhbiwgc2Nhbkxlbmd0aCA9IDAsIHNjYW5EaXN0YW5jZTsgc2Nhbkxlbmd0aCA8PSBwYXRoTGVuZ3RoOyBzY2FuTGVuZ3RoICs9IHByZWNpc2lvbikge1xuICAgICAgICBpZiAoKHNjYW5EaXN0YW5jZSA9IGRpc3RhbmNlMihzY2FuID0gcGF0aE5vZGUuZ2V0UG9pbnRBdExlbmd0aChzY2FuTGVuZ3RoKSkpIDwgYmVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICBiZXN0ID0gc2NhbiwgYmVzdExlbmd0aCA9IHNjYW5MZW5ndGgsIGJlc3REaXN0YW5jZSA9IHNjYW5EaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJpbmFyeSBzZWFyY2ggZm9yIHByZWNpc2UgZXN0aW1hdGVcbiAgICBwcmVjaXNpb24gKj0gLjU7XG4gICAgd2hpbGUgKHByZWNpc2lvbiA+IC41KSB7XG4gICAgICAgIHZhciBiZWZvcmUsXG4gICAgICAgICAgICBhZnRlcixcbiAgICAgICAgICAgIGJlZm9yZUxlbmd0aCxcbiAgICAgICAgICAgIGFmdGVyTGVuZ3RoLFxuICAgICAgICAgICAgYmVmb3JlRGlzdGFuY2UsXG4gICAgICAgICAgICBhZnRlckRpc3RhbmNlO1xuICAgICAgICBpZiAoKGJlZm9yZUxlbmd0aCA9IGJlc3RMZW5ndGggLSBwcmVjaXNpb24pID49IDAgJiYgKGJlZm9yZURpc3RhbmNlID0gZGlzdGFuY2UyKGJlZm9yZSA9IHBhdGhOb2RlLmdldFBvaW50QXRMZW5ndGgoYmVmb3JlTGVuZ3RoKSkpIDwgYmVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICBiZXN0ID0gYmVmb3JlLCBiZXN0TGVuZ3RoID0gYmVmb3JlTGVuZ3RoLCBiZXN0RGlzdGFuY2UgPSBiZWZvcmVEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIGlmICgoYWZ0ZXJMZW5ndGggPSBiZXN0TGVuZ3RoICsgcHJlY2lzaW9uKSA8PSBwYXRoTGVuZ3RoICYmIChhZnRlckRpc3RhbmNlID0gZGlzdGFuY2UyKGFmdGVyID0gcGF0aE5vZGUuZ2V0UG9pbnRBdExlbmd0aChhZnRlckxlbmd0aCkpKSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgYmVzdCA9IGFmdGVyLCBiZXN0TGVuZ3RoID0gYWZ0ZXJMZW5ndGgsIGJlc3REaXN0YW5jZSA9IGFmdGVyRGlzdGFuY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gKj0gLjU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiZXN0ID0ge1xuICAgICAgICB4OiBiZXN0LngsXG4gICAgICAgIHk6IGJlc3QueSxcbiAgICAgICAgbGVuZ3RoOiBiZXN0TGVuZ3RoLFxuICAgICAgICBkaXN0YW5jZTogTWF0aC5zcXJ0KGJlc3REaXN0YW5jZSlcbiAgICB9O1xuICAgIHJldHVybiBiZXN0O1xufVxuLypcXFxuICogU25hcC5pc1xuIFsgbWV0aG9kIF1cbiAqKlxuICogSGFuZHkgcmVwbGFjZW1lbnQgZm9yIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuIC0gbyAo4oCmKSBhbnkgb2JqZWN0IG9yIHByaW1pdGl2ZVxuIC0gdHlwZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSB0eXBlLCBlLmcuLCBgc3RyaW5nYCwgYGZ1bmN0aW9uYCwgYG51bWJlcmAsIGV0Yy5cbiA9IChib29sZWFuKSBgdHJ1ZWAgaWYgZ2l2ZW4gdmFsdWUgaXMgb2YgZ2l2ZW4gdHlwZVxuXFwqL1xuU25hcC5pcyA9IGlzO1xuLypcXFxuICogU25hcC5zbmFwVG9cbiBbIG1ldGhvZCBdXG4gKipcbiAqIFNuYXBzIGdpdmVuIHZhbHVlIHRvIGdpdmVuIGdyaWRcbiAtIHZhbHVlcyAoYXJyYXl8bnVtYmVyKSBnaXZlbiBhcnJheSBvZiB2YWx1ZXMgb3Igc3RlcCBvZiB0aGUgZ3JpZFxuIC0gdmFsdWUgKG51bWJlcikgdmFsdWUgdG8gYWRqdXN0XG4gLSB0b2xlcmFuY2UgKG51bWJlcikgI29wdGlvbmFsIG1heGltdW0gZGlzdGFuY2UgdG8gdGhlIHRhcmdldCB2YWx1ZSB0aGF0IHdvdWxkIHRyaWdnZXIgdGhlIHNuYXAuIERlZmF1bHQgaXMgYDEwYC5cbiA9IChudW1iZXIpIGFkanVzdGVkIHZhbHVlXG5cXCovXG5TbmFwLnNuYXBUbyA9IGZ1bmN0aW9uICh2YWx1ZXMsIHZhbHVlLCB0b2xlcmFuY2UpIHtcbiAgICB0b2xlcmFuY2UgPSBpcyh0b2xlcmFuY2UsIFwiZmluaXRlXCIpID8gdG9sZXJhbmNlIDogMTA7XG4gICAgaWYgKGlzKHZhbHVlcywgXCJhcnJheVwiKSkge1xuICAgICAgICB2YXIgaSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIGlmIChhYnModmFsdWVzW2ldIC0gdmFsdWUpIDw9IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcyA9ICt2YWx1ZXM7XG4gICAgICAgIHZhciByZW0gPSB2YWx1ZSAlIHZhbHVlcztcbiAgICAgICAgaWYgKHJlbSA8IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gcmVtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW0gPiB2YWx1ZXMgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAtIHJlbSArIHZhbHVlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLy8gQ29sb3VyXG4vKlxcXG4gKiBTbmFwLmdldFJHQlxuIFsgbWV0aG9kIF1cbiAqKlxuICogUGFyc2VzIGNvbG9yIHN0cmluZyBhcyBSR0Igb2JqZWN0XG4gLSBjb2xvciAoc3RyaW5nKSBjb2xvciBzdHJpbmcgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcbiAjIDx1bD5cbiAjICAgICA8bGk+Q29sb3IgbmFtZSAoPGNvZGU+cmVkPC9jb2RlPiwgPGNvZGU+Z3JlZW48L2NvZGU+LCA8Y29kZT5jb3JuZmxvd2VyYmx1ZTwvY29kZT4sIGV0Yyk8L2xpPlxuICMgICAgIDxsaT4j4oCi4oCi4oCiIOKAlCBzaG9ydGVuZWQgSFRNTCBjb2xvcjogKDxjb2RlPiMwMDA8L2NvZGU+LCA8Y29kZT4jZmMwPC9jb2RlPiwgZXRjLik8L2xpPlxuICMgICAgIDxsaT4j4oCi4oCi4oCi4oCi4oCi4oCiIOKAlCBmdWxsIGxlbmd0aCBIVE1MIGNvbG9yOiAoPGNvZGU+IzAwMDAwMDwvY29kZT4sIDxjb2RlPiNiZDIzMDA8L2NvZGU+KTwvbGk+XG4gIyAgICAgPGxpPnJnYijigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgcmVkLCBncmVlbiBhbmQgYmx1ZSBjaGFubmVscyB2YWx1ZXM6ICg8Y29kZT5yZ2IoMjAwLCZuYnNwOzEwMCwmbmJzcDswKTwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+cmdiYSjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPnJnYijigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgc2FtZSBhcyBhYm92ZSwgYnV0IGluICU6ICg8Y29kZT5yZ2IoMTAwJSwmbmJzcDsxNzUlLCZuYnNwOzAlKTwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+cmdiYSjigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgYWxzbyB3aXRoIG9wYWNpdHk8L2xpPlxuICMgICAgIDxsaT5oc2Io4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGh1ZSwgc2F0dXJhdGlvbiBhbmQgYnJpZ2h0bmVzcyB2YWx1ZXM6ICg8Y29kZT5oc2IoMC41LCZuYnNwOzAuMjUsJm5ic3A7MSk8L2NvZGU+KTwvbGk+XG4gIyAgICAgPGxpPmhzYmEo4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgYWxzbyB3aXRoIG9wYWNpdHk8L2xpPlxuICMgICAgIDxsaT5oc2Io4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCBpbiAlPC9saT5cbiAjICAgICA8bGk+aHNiYSjigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgYWxzbyB3aXRoIG9wYWNpdHk8L2xpPlxuICMgICAgIDxsaT5oc2wo4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGh1ZSwgc2F0dXJhdGlvbiBhbmQgbHVtaW5vc2l0eSB2YWx1ZXM6ICg8Y29kZT5oc2IoMC41LCZuYnNwOzAuMjUsJm5ic3A7MC41KTwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+aHNsYSjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzbCjigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgc2FtZSBhcyBhYm92ZSwgYnV0IGluICU8L2xpPlxuICMgICAgIDxsaT5oc2xhKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyA8L3VsPlxuICogTm90ZSB0aGF0IGAlYCBjYW4gYmUgdXNlZCBhbnkgdGltZTogYHJnYigyMCUsIDI1NSwgNTAlKWAuXG4gPSAob2JqZWN0KSBSR0Igb2JqZWN0IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuIG8ge1xuIG8gICAgIHIgKG51bWJlcikgcmVkLFxuIG8gICAgIGcgKG51bWJlcikgZ3JlZW4sXG4gbyAgICAgYiAobnVtYmVyKSBibHVlLFxuIG8gICAgIGhleCAoc3RyaW5nKSBjb2xvciBpbiBIVE1ML0NTUyBmb3JtYXQ6ICPigKLigKLigKLigKLigKLigKIsXG4gbyAgICAgZXJyb3IgKGJvb2xlYW4pIHRydWUgaWYgc3RyaW5nIGNhbid0IGJlIHBhcnNlZFxuIG8gfVxuXFwqL1xuU25hcC5nZXRSR0IgPSBjYWNoZXIoZnVuY3Rpb24gKGNvbG91cikge1xuICAgIGlmICghY29sb3VyIHx8ICEhKChjb2xvdXIgPSBTdHIoY29sb3VyKSkuaW5kZXhPZihcIi1cIikgKyAxKSkge1xuICAgICAgICByZXR1cm4ge3I6IC0xLCBnOiAtMSwgYjogLTEsIGhleDogXCJub25lXCIsIGVycm9yOiAxLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xuICAgIH1cbiAgICBpZiAoY29sb3VyID09IFwibm9uZVwiKSB7XG4gICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgdG9TdHJpbmc6IHJnYnRvU3RyaW5nfTtcbiAgICB9XG4gICAgIShoc3JnW2hhc10oY29sb3VyLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsIDIpKSB8fCBjb2xvdXIuY2hhckF0KCkgPT0gXCIjXCIpICYmIChjb2xvdXIgPSB0b0hleChjb2xvdXIpKTtcbiAgICBpZiAoIWNvbG91cikge1xuICAgICAgICByZXR1cm4ge3I6IC0xLCBnOiAtMSwgYjogLTEsIGhleDogXCJub25lXCIsIGVycm9yOiAxLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xuICAgIH1cbiAgICB2YXIgcmVzLFxuICAgICAgICByZWQsXG4gICAgICAgIGdyZWVuLFxuICAgICAgICBibHVlLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICB0LFxuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIHJnYiA9IGNvbG91ci5tYXRjaChjb2xvdXJSZWdFeHApO1xuICAgIGlmIChyZ2IpIHtcbiAgICAgICAgaWYgKHJnYlsyXSkge1xuICAgICAgICAgICAgYmx1ZSA9IHRvSW50KHJnYlsyXS5zdWJzdHJpbmcoNSksIDE2KTtcbiAgICAgICAgICAgIGdyZWVuID0gdG9JbnQocmdiWzJdLnN1YnN0cmluZygzLCA1KSwgMTYpO1xuICAgICAgICAgICAgcmVkID0gdG9JbnQocmdiWzJdLnN1YnN0cmluZygxLCAzKSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2JbM10pIHtcbiAgICAgICAgICAgIGJsdWUgPSB0b0ludCgodCA9IHJnYlszXS5jaGFyQXQoMykpICsgdCwgMTYpO1xuICAgICAgICAgICAgZ3JlZW4gPSB0b0ludCgodCA9IHJnYlszXS5jaGFyQXQoMikpICsgdCwgMTYpO1xuICAgICAgICAgICAgcmVkID0gdG9JbnQoKHQgPSByZ2JbM10uY2hhckF0KDEpKSArIHQsIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmdiWzRdKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSByZ2JbNF0uc3BsaXQoY29tbWFTcGFjZXMpO1xuICAgICAgICAgICAgcmVkID0gdG9GbG9hdCh2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAocmVkICo9IDIuNTUpO1xuICAgICAgICAgICAgZ3JlZW4gPSB0b0Zsb2F0KHZhbHVlc1sxXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMV0uc2xpY2UoLTEpID09IFwiJVwiICYmIChncmVlbiAqPSAyLjU1KTtcbiAgICAgICAgICAgIGJsdWUgPSB0b0Zsb2F0KHZhbHVlc1syXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMl0uc2xpY2UoLTEpID09IFwiJVwiICYmIChibHVlICo9IDIuNTUpO1xuICAgICAgICAgICAgcmdiWzFdLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNCkgPT0gXCJyZ2JhXCIgJiYgKG9wYWNpdHkgPSB0b0Zsb2F0KHZhbHVlc1szXSkpO1xuICAgICAgICAgICAgdmFsdWVzWzNdICYmIHZhbHVlc1szXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKG9wYWNpdHkgLz0gMTAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmdiWzVdKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSByZ2JbNV0uc3BsaXQoY29tbWFTcGFjZXMpO1xuICAgICAgICAgICAgcmVkID0gdG9GbG9hdCh2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAocmVkIC89IDEwMCk7XG4gICAgICAgICAgICBncmVlbiA9IHRvRmxvYXQodmFsdWVzWzFdKTtcbiAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuIC89IDEwMCk7XG4gICAgICAgICAgICBibHVlID0gdG9GbG9hdCh2YWx1ZXNbMl0pO1xuICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAvPSAxMDApO1xuICAgICAgICAgICAgKHZhbHVlc1swXS5zbGljZSgtMykgPT0gXCJkZWdcIiB8fCB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiXFx4YjBcIikgJiYgKHJlZCAvPSAzNjApO1xuICAgICAgICAgICAgcmdiWzFdLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNCkgPT0gXCJoc2JhXCIgJiYgKG9wYWNpdHkgPSB0b0Zsb2F0KHZhbHVlc1szXSkpO1xuICAgICAgICAgICAgdmFsdWVzWzNdICYmIHZhbHVlc1szXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKG9wYWNpdHkgLz0gMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLmhzYjJyZ2IocmVkLCBncmVlbiwgYmx1ZSwgb3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJnYls2XSkge1xuICAgICAgICAgICAgdmFsdWVzID0gcmdiWzZdLnNwbGl0KGNvbW1hU3BhY2VzKTtcbiAgICAgICAgICAgIHJlZCA9IHRvRmxvYXQodmFsdWVzWzBdKTtcbiAgICAgICAgICAgIHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKHJlZCAvPSAxMDApO1xuICAgICAgICAgICAgZ3JlZW4gPSB0b0Zsb2F0KHZhbHVlc1sxXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMV0uc2xpY2UoLTEpID09IFwiJVwiICYmIChncmVlbiAvPSAxMDApO1xuICAgICAgICAgICAgYmx1ZSA9IHRvRmxvYXQodmFsdWVzWzJdKTtcbiAgICAgICAgICAgIHZhbHVlc1syXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGJsdWUgLz0gMTAwKTtcbiAgICAgICAgICAgICh2YWx1ZXNbMF0uc2xpY2UoLTMpID09IFwiZGVnXCIgfHwgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIlxceGIwXCIpICYmIChyZWQgLz0gMzYwKTtcbiAgICAgICAgICAgIHJnYlsxXS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDQpID09IFwiaHNsYVwiICYmIChvcGFjaXR5ID0gdG9GbG9hdCh2YWx1ZXNbM10pKTtcbiAgICAgICAgICAgIHZhbHVlc1szXSAmJiB2YWx1ZXNbM10uc2xpY2UoLTEpID09IFwiJVwiICYmIChvcGFjaXR5IC89IDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gU25hcC5oc2wycmdiKHJlZCwgZ3JlZW4sIGJsdWUsIG9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHJlZCA9IG1taW4obWF0aC5yb3VuZChyZWQpLCAyNTUpO1xuICAgICAgICBncmVlbiA9IG1taW4obWF0aC5yb3VuZChncmVlbiksIDI1NSk7XG4gICAgICAgIGJsdWUgPSBtbWluKG1hdGgucm91bmQoYmx1ZSksIDI1NSk7XG4gICAgICAgIG9wYWNpdHkgPSBtbWluKG1tYXgob3BhY2l0eSwgMCksIDEpO1xuICAgICAgICByZ2IgPSB7cjogcmVkLCBnOiBncmVlbiwgYjogYmx1ZSwgdG9TdHJpbmc6IHJnYnRvU3RyaW5nfTtcbiAgICAgICAgcmdiLmhleCA9IFwiI1wiICsgKDE2Nzc3MjE2IHwgYmx1ZSB8IChncmVlbiA8PCA4KSB8IChyZWQgPDwgMTYpKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgICAgIHJnYi5vcGFjaXR5ID0gaXMob3BhY2l0eSwgXCJmaW5pdGVcIikgPyBvcGFjaXR5IDogMTtcbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG4gICAgcmV0dXJuIHtyOiAtMSwgZzogLTEsIGI6IC0xLCBoZXg6IFwibm9uZVwiLCBlcnJvcjogMSwgdG9TdHJpbmc6IHJnYnRvU3RyaW5nfTtcbn0sIFNuYXApO1xuLypcXFxuICogU25hcC5oc2JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIEhTQiB2YWx1ZXMgdG8gYSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG4gLSBoIChudW1iZXIpIGh1ZVxuIC0gcyAobnVtYmVyKSBzYXR1cmF0aW9uXG4gLSBiIChudW1iZXIpIHZhbHVlIG9yIGJyaWdodG5lc3NcbiA9IChzdHJpbmcpIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcblxcKi9cblNuYXAuaHNiID0gY2FjaGVyKGZ1bmN0aW9uIChoLCBzLCBiKSB7XG4gICAgcmV0dXJuIFNuYXAuaHNiMnJnYihoLCBzLCBiKS5oZXg7XG59KTtcbi8qXFxcbiAqIFNuYXAuaHNsXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBIU0wgdmFsdWVzIHRvIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuIC0gaCAobnVtYmVyKSBodWVcbiAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuIC0gbCAobnVtYmVyKSBsdW1pbm9zaXR5XG4gPSAoc3RyaW5nKSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG5cXCovXG5TbmFwLmhzbCA9IGNhY2hlcihmdW5jdGlvbiAoaCwgcywgbCkge1xuICAgIHJldHVybiBTbmFwLmhzbDJyZ2IoaCwgcywgbCkuaGV4O1xufSk7XG4vKlxcXG4gKiBTbmFwLnJnYlxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgUkdCIHZhbHVlcyB0byBhIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcbiAtIHIgKG51bWJlcikgcmVkXG4gLSBnIChudW1iZXIpIGdyZWVuXG4gLSBiIChudW1iZXIpIGJsdWVcbiA9IChzdHJpbmcpIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcblxcKi9cblNuYXAucmdiID0gY2FjaGVyKGZ1bmN0aW9uIChyLCBnLCBiLCBvKSB7XG4gICAgaWYgKGlzKG8sIFwiZmluaXRlXCIpKSB7XG4gICAgICAgIHZhciByb3VuZCA9IG1hdGgucm91bmQ7XG4gICAgICAgIHJldHVybiBcInJnYmEoXCIgKyBbcm91bmQociksIHJvdW5kKGcpLCByb3VuZChiKSwgK28udG9GaXhlZCgyKV0gKyBcIilcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiI1wiICsgKDE2Nzc3MjE2IHwgYiB8IChnIDw8IDgpIHwgKHIgPDwgMTYpKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG59KTtcbnZhciB0b0hleCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHZhciBpID0gZ2xvYi5kb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdIHx8IGdsb2IuZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdLFxuICAgICAgICByZWQgPSBcInJnYigyNTUsIDAsIDApXCI7XG4gICAgdG9IZXggPSBjYWNoZXIoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmIChjb2xvci50b0xvd2VyQ2FzZSgpID09IFwicmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IHJlZDtcbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgICAgICB2YXIgb3V0ID0gZ2xvYi5kb2MuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShpLCBFKS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29sb3JcIik7XG4gICAgICAgIHJldHVybiBvdXQgPT0gcmVkID8gbnVsbCA6IG91dDtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9IZXgoY29sb3IpO1xufSxcbmhzYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImhzYihcIiArIFt0aGlzLmgsIHRoaXMucywgdGhpcy5iXSArIFwiKVwiO1xufSxcbmhzbHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImhzbChcIiArIFt0aGlzLmgsIHRoaXMucywgdGhpcy5sXSArIFwiKVwiO1xufSxcbnJnYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPT0gMSB8fCB0aGlzLm9wYWNpdHkgPT0gbnVsbCA/XG4gICAgICAgICAgICB0aGlzLmhleCA6XG4gICAgICAgICAgICBcInJnYmEoXCIgKyBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5vcGFjaXR5XSArIFwiKVwiO1xufSxcbnByZXBhcmVSR0IgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIGlmIChnID09IG51bGwgJiYgaXMociwgXCJvYmplY3RcIikgJiYgXCJyXCIgaW4gciAmJiBcImdcIiBpbiByICYmIFwiYlwiIGluIHIpIHtcbiAgICAgICAgYiA9IHIuYjtcbiAgICAgICAgZyA9IHIuZztcbiAgICAgICAgciA9IHIucjtcbiAgICB9XG4gICAgaWYgKGcgPT0gbnVsbCAmJiBpcyhyLCBzdHJpbmcpKSB7XG4gICAgICAgIHZhciBjbHIgPSBTbmFwLmdldFJHQihyKTtcbiAgICAgICAgciA9IGNsci5yO1xuICAgICAgICBnID0gY2xyLmc7XG4gICAgICAgIGIgPSBjbHIuYjtcbiAgICB9XG4gICAgaWYgKHIgPiAxIHx8IGcgPiAxIHx8IGIgPiAxKSB7XG4gICAgICAgIHIgLz0gMjU1O1xuICAgICAgICBnIC89IDI1NTtcbiAgICAgICAgYiAvPSAyNTU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBbciwgZywgYl07XG59LFxucGFja2FnZVJHQiA9IGZ1bmN0aW9uIChyLCBnLCBiLCBvKSB7XG4gICAgciA9IG1hdGgucm91bmQociAqIDI1NSk7XG4gICAgZyA9IG1hdGgucm91bmQoZyAqIDI1NSk7XG4gICAgYiA9IG1hdGgucm91bmQoYiAqIDI1NSk7XG4gICAgdmFyIHJnYiA9IHtcbiAgICAgICAgcjogcixcbiAgICAgICAgZzogZyxcbiAgICAgICAgYjogYixcbiAgICAgICAgb3BhY2l0eTogaXMobywgXCJmaW5pdGVcIikgPyBvIDogMSxcbiAgICAgICAgaGV4OiBTbmFwLnJnYihyLCBnLCBiKSxcbiAgICAgICAgdG9TdHJpbmc6IHJnYnRvU3RyaW5nXG4gICAgfTtcbiAgICBpcyhvLCBcImZpbml0ZVwiKSAmJiAocmdiLm9wYWNpdHkgPSBvKTtcbiAgICByZXR1cm4gcmdiO1xufTtcbi8qXFxcbiAqIFNuYXAuY29sb3JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFBhcnNlcyB0aGUgY29sb3Igc3RyaW5nIGFuZCByZXR1cm5zIGFuIG9iamVjdCBmZWF0dXJpbmcgdGhlIGNvbG9yJ3MgY29tcG9uZW50IHZhbHVlc1xuIC0gY2xyIChzdHJpbmcpIGNvbG9yIHN0cmluZyBpbiBvbmUgb2YgdGhlIHN1cHBvcnRlZCBmb3JtYXRzIChzZWUgQFNuYXAuZ2V0UkdCKVxuID0gKG9iamVjdCkgQ29tYmluZWQgUkdCL0hTQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgciAobnVtYmVyKSByZWQsXG4gbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAoixcbiBvICAgICBlcnJvciAoYm9vbGVhbikgYHRydWVgIGlmIHN0cmluZyBjYW4ndCBiZSBwYXJzZWQsXG4gbyAgICAgaCAobnVtYmVyKSBodWUsXG4gbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uLFxuIG8gICAgIHYgKG51bWJlcikgdmFsdWUgKGJyaWdodG5lc3MpLFxuIG8gICAgIGwgKG51bWJlcikgbGlnaHRuZXNzXG4gbyB9XG5cXCovXG5TbmFwLmNvbG9yID0gZnVuY3Rpb24gKGNscikge1xuICAgIHZhciByZ2I7XG4gICAgaWYgKGlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gY2xyICYmIFwic1wiIGluIGNsciAmJiBcImJcIiBpbiBjbHIpIHtcbiAgICAgICAgcmdiID0gU25hcC5oc2IycmdiKGNscik7XG4gICAgICAgIGNsci5yID0gcmdiLnI7XG4gICAgICAgIGNsci5nID0gcmdiLmc7XG4gICAgICAgIGNsci5iID0gcmdiLmI7XG4gICAgICAgIGNsci5vcGFjaXR5ID0gMTtcbiAgICAgICAgY2xyLmhleCA9IHJnYi5oZXg7XG4gICAgfSBlbHNlIGlmIChpcyhjbHIsIFwib2JqZWN0XCIpICYmIFwiaFwiIGluIGNsciAmJiBcInNcIiBpbiBjbHIgJiYgXCJsXCIgaW4gY2xyKSB7XG4gICAgICAgIHJnYiA9IFNuYXAuaHNsMnJnYihjbHIpO1xuICAgICAgICBjbHIuciA9IHJnYi5yO1xuICAgICAgICBjbHIuZyA9IHJnYi5nO1xuICAgICAgICBjbHIuYiA9IHJnYi5iO1xuICAgICAgICBjbHIub3BhY2l0eSA9IDE7XG4gICAgICAgIGNsci5oZXggPSByZ2IuaGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpcyhjbHIsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBjbHIgPSBTbmFwLmdldFJHQihjbHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhjbHIsIFwib2JqZWN0XCIpICYmIFwiclwiIGluIGNsciAmJiBcImdcIiBpbiBjbHIgJiYgXCJiXCIgaW4gY2xyICYmICEoXCJlcnJvclwiIGluIGNscikpIHtcbiAgICAgICAgICAgIHJnYiA9IFNuYXAucmdiMmhzbChjbHIpO1xuICAgICAgICAgICAgY2xyLmggPSByZ2IuaDtcbiAgICAgICAgICAgIGNsci5zID0gcmdiLnM7XG4gICAgICAgICAgICBjbHIubCA9IHJnYi5sO1xuICAgICAgICAgICAgcmdiID0gU25hcC5yZ2IyaHNiKGNscik7XG4gICAgICAgICAgICBjbHIudiA9IHJnYi5iO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xyID0ge2hleDogXCJub25lXCJ9O1xuICAgICAgICAgICAgY2xyLnIgPSBjbHIuZyA9IGNsci5iID0gY2xyLmggPSBjbHIucyA9IGNsci52ID0gY2xyLmwgPSAtMTtcbiAgICAgICAgICAgIGNsci5lcnJvciA9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xyLnRvU3RyaW5nID0gcmdidG9TdHJpbmc7XG4gICAgcmV0dXJuIGNscjtcbn07XG4vKlxcXG4gKiBTbmFwLmhzYjJyZ2JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIEhTQiB2YWx1ZXMgdG8gYW4gUkdCIG9iamVjdFxuIC0gaCAobnVtYmVyKSBodWVcbiAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuIC0gdiAobnVtYmVyKSB2YWx1ZSBvciBicmlnaHRuZXNzXG4gPSAob2JqZWN0KSBSR0Igb2JqZWN0IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuIG8ge1xuIG8gICAgIHIgKG51bWJlcikgcmVkLFxuIG8gICAgIGcgKG51bWJlcikgZ3JlZW4sXG4gbyAgICAgYiAobnVtYmVyKSBibHVlLFxuIG8gICAgIGhleCAoc3RyaW5nKSBjb2xvciBpbiBIVE1ML0NTUyBmb3JtYXQ6ICPigKLigKLigKLigKLigKLigKJcbiBvIH1cblxcKi9cblNuYXAuaHNiMnJnYiA9IGZ1bmN0aW9uIChoLCBzLCB2LCBvKSB7XG4gICAgaWYgKGlzKGgsIFwib2JqZWN0XCIpICYmIFwiaFwiIGluIGggJiYgXCJzXCIgaW4gaCAmJiBcImJcIiBpbiBoKSB7XG4gICAgICAgIHYgPSBoLmI7XG4gICAgICAgIHMgPSBoLnM7XG4gICAgICAgIG8gPSBoLm87XG4gICAgICAgIGggPSBoLmg7XG4gICAgfVxuICAgIGggKj0gMzYwO1xuICAgIHZhciBSLCBHLCBCLCBYLCBDO1xuICAgIGggPSAoaCAlIDM2MCkgLyA2MDtcbiAgICBDID0gdiAqIHM7XG4gICAgWCA9IEMgKiAoMSAtIGFicyhoICUgMiAtIDEpKTtcbiAgICBSID0gRyA9IEIgPSB2IC0gQztcblxuICAgIGggPSB+fmg7XG4gICAgUiArPSBbQywgWCwgMCwgMCwgWCwgQ11baF07XG4gICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgQiArPSBbMCwgMCwgWCwgQywgQywgWF1baF07XG4gICAgcmV0dXJuIHBhY2thZ2VSR0IoUiwgRywgQiwgbyk7XG59O1xuLypcXFxuICogU25hcC5oc2wycmdiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBIU0wgdmFsdWVzIHRvIGFuIFJHQiBvYmplY3RcbiAtIGggKG51bWJlcikgaHVlXG4gLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAtIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuID0gKG9iamVjdCkgUkdCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICByIChudW1iZXIpIHJlZCxcbiBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiXG4gbyB9XG5cXCovXG5TbmFwLmhzbDJyZ2IgPSBmdW5jdGlvbiAoaCwgcywgbCwgbykge1xuICAgIGlmIChpcyhoLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBoICYmIFwic1wiIGluIGggJiYgXCJsXCIgaW4gaCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBzID0gaC5zO1xuICAgICAgICBoID0gaC5oO1xuICAgIH1cbiAgICBpZiAoaCA+IDEgfHwgcyA+IDEgfHwgbCA+IDEpIHtcbiAgICAgICAgaCAvPSAzNjA7XG4gICAgICAgIHMgLz0gMTAwO1xuICAgICAgICBsIC89IDEwMDtcbiAgICB9XG4gICAgaCAqPSAzNjA7XG4gICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgaCA9IChoICUgMzYwKSAvIDYwO1xuICAgIEMgPSAyICogcyAqIChsIDwgLjUgPyBsIDogMSAtIGwpO1xuICAgIFggPSBDICogKDEgLSBhYnMoaCAlIDIgLSAxKSk7XG4gICAgUiA9IEcgPSBCID0gbCAtIEMgLyAyO1xuXG4gICAgaCA9IH5+aDtcbiAgICBSICs9IFtDLCBYLCAwLCAwLCBYLCBDXVtoXTtcbiAgICBHICs9IFtYLCBDLCBDLCBYLCAwLCAwXVtoXTtcbiAgICBCICs9IFswLCAwLCBYLCBDLCBDLCBYXVtoXTtcbiAgICByZXR1cm4gcGFja2FnZVJHQihSLCBHLCBCLCBvKTtcbn07XG4vKlxcXG4gKiBTbmFwLnJnYjJoc2JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIFJHQiB2YWx1ZXMgdG8gYW4gSFNCIG9iamVjdFxuIC0gciAobnVtYmVyKSByZWRcbiAtIGcgKG51bWJlcikgZ3JlZW5cbiAtIGIgKG51bWJlcikgYmx1ZVxuID0gKG9iamVjdCkgSFNCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICBoIChudW1iZXIpIGh1ZSxcbiBvICAgICBzIChudW1iZXIpIHNhdHVyYXRpb24sXG4gbyAgICAgYiAobnVtYmVyKSBicmlnaHRuZXNzXG4gbyB9XG5cXCovXG5TbmFwLnJnYjJoc2IgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIGIgPSBwcmVwYXJlUkdCKHIsIGcsIGIpO1xuICAgIHIgPSBiWzBdO1xuICAgIGcgPSBiWzFdO1xuICAgIGIgPSBiWzJdO1xuXG4gICAgdmFyIEgsIFMsIFYsIEM7XG4gICAgViA9IG1tYXgociwgZywgYik7XG4gICAgQyA9IFYgLSBtbWluKHIsIGcsIGIpO1xuICAgIEggPSAoQyA9PSAwID8gbnVsbCA6XG4gICAgICAgICBWID09IHIgPyAoZyAtIGIpIC8gQyA6XG4gICAgICAgICBWID09IGcgPyAoYiAtIHIpIC8gQyArIDIgOlxuICAgICAgICAgICAgICAgICAgKHIgLSBnKSAvIEMgKyA0XG4gICAgICAgICk7XG4gICAgSCA9ICgoSCArIDM2MCkgJSA2KSAqIDYwIC8gMzYwO1xuICAgIFMgPSBDID09IDAgPyAwIDogQyAvIFY7XG4gICAgcmV0dXJuIHtoOiBILCBzOiBTLCBiOiBWLCB0b1N0cmluZzogaHNidG9TdHJpbmd9O1xufTtcbi8qXFxcbiAqIFNuYXAucmdiMmhzbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgUkdCIHZhbHVlcyB0byBhbiBIU0wgb2JqZWN0XG4gLSByIChudW1iZXIpIHJlZFxuIC0gZyAobnVtYmVyKSBncmVlblxuIC0gYiAobnVtYmVyKSBibHVlXG4gPSAob2JqZWN0KSBIU0wgb2JqZWN0IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuIG8ge1xuIG8gICAgIGggKG51bWJlcikgaHVlLFxuIG8gICAgIHMgKG51bWJlcikgc2F0dXJhdGlvbixcbiBvICAgICBsIChudW1iZXIpIGx1bWlub3NpdHlcbiBvIH1cblxcKi9cblNuYXAucmdiMmhzbCA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgYiA9IHByZXBhcmVSR0IociwgZywgYik7XG4gICAgciA9IGJbMF07XG4gICAgZyA9IGJbMV07XG4gICAgYiA9IGJbMl07XG5cbiAgICB2YXIgSCwgUywgTCwgTSwgbSwgQztcbiAgICBNID0gbW1heChyLCBnLCBiKTtcbiAgICBtID0gbW1pbihyLCBnLCBiKTtcbiAgICBDID0gTSAtIG07XG4gICAgSCA9IChDID09IDAgPyBudWxsIDpcbiAgICAgICAgIE0gPT0gciA/IChnIC0gYikgLyBDIDpcbiAgICAgICAgIE0gPT0gZyA/IChiIC0gcikgLyBDICsgMiA6XG4gICAgICAgICAgICAgICAgICAociAtIGcpIC8gQyArIDQpO1xuICAgIEggPSAoKEggKyAzNjApICUgNikgKiA2MCAvIDM2MDtcbiAgICBMID0gKE0gKyBtKSAvIDI7XG4gICAgUyA9IChDID09IDAgPyAwIDpcbiAgICAgICAgIEwgPCAuNSA/IEMgLyAoMiAqIEwpIDpcbiAgICAgICAgICAgICAgICAgIEMgLyAoMiAtIDIgKiBMKSk7XG4gICAgcmV0dXJuIHtoOiBILCBzOiBTLCBsOiBMLCB0b1N0cmluZzogaHNsdG9TdHJpbmd9O1xufTtcblxuLy8gVHJhbnNmb3JtYXRpb25zXG4vKlxcXG4gKiBTbmFwLnBhcnNlUGF0aFN0cmluZ1xuIFsgbWV0aG9kIF1cbiAqKlxuICogVXRpbGl0eSBtZXRob2RcbiAqKlxuICogUGFyc2VzIGdpdmVuIHBhdGggc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBhdGggc2VnbWVudHNcbiAtIHBhdGhTdHJpbmcgKHN0cmluZ3xhcnJheSkgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2Ygc2VnbWVudHMgKGluIHRoZSBsYXN0IGNhc2UgaXQgaXMgcmV0dXJuZWQgc3RyYWlnaHQgYXdheSlcbiA9IChhcnJheSkgYXJyYXkgb2Ygc2VnbWVudHNcblxcKi9cblNuYXAucGFyc2VQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICBpZiAoIXBhdGhTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBwdGggPSBTbmFwLnBhdGgocGF0aFN0cmluZyk7XG4gICAgaWYgKHB0aC5hcnIpIHtcbiAgICAgICAgcmV0dXJuIFNuYXAucGF0aC5jbG9uZShwdGguYXJyKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHBhcmFtQ291bnRzID0ge2E6IDcsIGM6IDYsIG86IDIsIGg6IDEsIGw6IDIsIG06IDIsIHI6IDQsIHE6IDQsIHM6IDQsIHQ6IDIsIHY6IDEsIHU6IDMsIHo6IDB9LFxuICAgICAgICBkYXRhID0gW107XG4gICAgaWYgKGlzKHBhdGhTdHJpbmcsIFwiYXJyYXlcIikgJiYgaXMocGF0aFN0cmluZ1swXSwgXCJhcnJheVwiKSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgICAgIGRhdGEgPSBTbmFwLnBhdGguY2xvbmUocGF0aFN0cmluZyk7XG4gICAgfVxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgU3RyKHBhdGhTdHJpbmcpLnJlcGxhY2UocGF0aENvbW1hbmQsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gW10sXG4gICAgICAgICAgICAgICAgbmFtZSA9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGMucmVwbGFjZShwYXRoVmFsdWVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGIgJiYgcGFyYW1zLnB1c2goK2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcIm1cIiAmJiBwYXJhbXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgMikpKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJsXCI7XG4gICAgICAgICAgICAgICAgYiA9IGIgPT0gXCJtXCIgPyBcImxcIiA6IFwiTFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJvXCIgJiYgcGFyYW1zLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiLCBwYXJhbXNbMF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiclwiKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zKSk7XG4gICAgICAgICAgICB9IGVsc2Ugd2hpbGUgKHBhcmFtcy5sZW5ndGggPj0gcGFyYW1Db3VudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIHBhcmFtQ291bnRzW25hbWVdKSkpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW1Db3VudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0YS50b1N0cmluZyA9IFNuYXAucGF0aC50b1N0cmluZztcbiAgICBwdGguYXJyID0gU25hcC5wYXRoLmNsb25lKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufTtcbi8qXFxcbiAqIFNuYXAucGFyc2VUcmFuc2Zvcm1TdHJpbmdcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFV0aWxpdHkgbWV0aG9kXG4gKipcbiAqIFBhcnNlcyBnaXZlbiB0cmFuc2Zvcm0gc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgdHJhbnNmb3JtYXRpb25zXG4gLSBUU3RyaW5nIChzdHJpbmd8YXJyYXkpIHRyYW5zZm9ybSBzdHJpbmcgb3IgYXJyYXkgb2YgdHJhbnNmb3JtYXRpb25zIChpbiB0aGUgbGFzdCBjYXNlIGl0IGlzIHJldHVybmVkIHN0cmFpZ2h0IGF3YXkpXG4gPSAoYXJyYXkpIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9uc1xuXFwqL1xudmFyIHBhcnNlVHJhbnNmb3JtU3RyaW5nID0gU25hcC5wYXJzZVRyYW5zZm9ybVN0cmluZyA9IGZ1bmN0aW9uIChUU3RyaW5nKSB7XG4gICAgaWYgKCFUU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcGFyYW1Db3VudHMgPSB7cjogMywgczogNCwgdDogMiwgbTogNn0sXG4gICAgICAgIGRhdGEgPSBbXTtcbiAgICBpZiAoaXMoVFN0cmluZywgXCJhcnJheVwiKSAmJiBpcyhUU3RyaW5nWzBdLCBcImFycmF5XCIpKSB7IC8vIHJvdWdoIGFzc3VtcHRpb25cbiAgICAgICAgZGF0YSA9IFNuYXAucGF0aC5jbG9uZShUU3RyaW5nKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgICBTdHIoVFN0cmluZykucmVwbGFjZSh0Q29tbWFuZCwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXSxcbiAgICAgICAgICAgICAgICBuYW1lID0gYi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgYy5yZXBsYWNlKHBhdGhWYWx1ZXMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgYiAmJiBwYXJhbXMucHVzaCgrYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0YS50b1N0cmluZyA9IFNuYXAucGF0aC50b1N0cmluZztcbiAgICByZXR1cm4gZGF0YTtcbn07XG5mdW5jdGlvbiBzdmdUcmFuc2Zvcm0yc3RyaW5nKHRzdHIpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdHN0ciA9IHRzdHIucmVwbGFjZSgvKD86XnxcXHMpKFxcdyspXFwoKFteKV0rKVxcKS9nLCBmdW5jdGlvbiAoYWxsLCBuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zLnNwbGl0KC9cXHMqLFxccyp8XFxzKy8pO1xuICAgICAgICBpZiAobmFtZSA9PSBcInJvdGF0ZVwiICYmIHBhcmFtcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMuc2xpY2UoMCwgMik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtc1swXSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJza2V3WFwiKSB7XG4gICAgICAgICAgICByZXMucHVzaChbXCJtXCIsIDEsIDAsIG1hdGgudGFuKHJhZChwYXJhbXNbMF0pKSwgMSwgMCwgMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJza2V3WVwiKSB7XG4gICAgICAgICAgICByZXMucHVzaChbXCJtXCIsIDEsIG1hdGgudGFuKHJhZChwYXJhbXNbMF0pKSwgMCwgMSwgMCwgMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2goW25hbWUuY2hhckF0KDApXS5jb25jYXQocGFyYW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufVxuU25hcC5fLnN2Z1RyYW5zZm9ybTJzdHJpbmcgPSBzdmdUcmFuc2Zvcm0yc3RyaW5nO1xuU25hcC5fLnJnVHJhbnNmb3JtID0gL15bYS16XVtcXHNdKi0/XFwuP1xcZC9pO1xuZnVuY3Rpb24gdHJhbnNmb3JtMm1hdHJpeCh0c3RyLCBiYm94KSB7XG4gICAgdmFyIHRkYXRhID0gcGFyc2VUcmFuc2Zvcm1TdHJpbmcodHN0ciksXG4gICAgICAgIG0gPSBuZXcgU25hcC5NYXRyaXg7XG4gICAgaWYgKHRkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRkYXRhLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGRhdGFbaV0sXG4gICAgICAgICAgICAgICAgdGxlbiA9IHQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBTdHIodFswXSkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZSA9IHRbMF0gIT0gY29tbWFuZCxcbiAgICAgICAgICAgICAgICBpbnZlciA9IGFic29sdXRlID8gbS5pbnZlcnQoKSA6IDAsXG4gICAgICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICAgICAgeDIsXG4gICAgICAgICAgICAgICAgeTIsXG4gICAgICAgICAgICAgICAgYmI7XG4gICAgICAgICAgICBpZiAoY29tbWFuZCA9PSBcInRcIiAmJiB0bGVuID09IDIpe1xuICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKHRbMV0sIDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwidFwiICYmIHRsZW4gPT0gMykge1xuICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICB4MSA9IGludmVyLngoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHkxID0gaW52ZXIueSgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBpbnZlci54KHRbMV0sIHRbMl0pO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFsxXSwgdFsyXSk7XG4gICAgICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKHgyIC0geDEsIHkyIC0geTEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKHRbMV0sIHRbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PSBcInJcIikge1xuICAgICAgICAgICAgICAgIGlmICh0bGVuID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmIgPSBiYiB8fCBiYm94O1xuICAgICAgICAgICAgICAgICAgICBtLnJvdGF0ZSh0WzFdLCBiYi54ICsgYmIud2lkdGggLyAyLCBiYi55ICsgYmIuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bGVuID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IGludmVyLngodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnJvdGF0ZSh0WzFdLCB4MiwgeTIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yb3RhdGUodFsxXSwgdFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGxlbiA9PSAyIHx8IHRsZW4gPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBiYiA9IGJiIHx8IGJib3g7XG4gICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFt0bGVuIC0gMV0sIGJiLnggKyBiYi53aWR0aCAvIDIsIGJiLnkgKyBiYi5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRsZW4gPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzJdLCB0WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gaW52ZXIueSh0WzJdLCB0WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFsxXSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFsxXSwgdFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRsZW4gPT0gNSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzNdLCB0WzRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gaW52ZXIueSh0WzNdLCB0WzRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFsyXSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFsyXSwgdFszXSwgdFs0XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJtXCIgJiYgdGxlbiA9PSA3KSB7XG4gICAgICAgICAgICAgICAgbS5hZGQodFsxXSwgdFsyXSwgdFszXSwgdFs0XSwgdFs1XSwgdFs2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG07XG59XG5TbmFwLl8udHJhbnNmb3JtMm1hdHJpeCA9IHRyYW5zZm9ybTJtYXRyaXg7XG5TbmFwLl91bml0MnB4ID0gdW5pdDJweDtcbnZhciBjb250YWlucyA9IGdsb2IuZG9jLmNvbnRhaW5zIHx8IGdsb2IuZG9jLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID9cbiAgICBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG4gICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiBhID09IGJ1cCB8fCAhIShidXAgJiYgYnVwLm5vZGVUeXBlID09IDEgJiYgKFxuICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zID9cbiAgICAgICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMoYnVwKSA6XG4gICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihidXApICYgMTZcbiAgICAgICAgICAgICkpO1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICB3aGlsZSAoYikge1xuICAgICAgICAgICAgICAgIGIgPSBiLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGIgPT0gYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5mdW5jdGlvbiBnZXRTb21lRGVmcyhlbCkge1xuICAgIHZhciBwID0gKGVsLm5vZGUub3duZXJTVkdFbGVtZW50ICYmIHdyYXAoZWwubm9kZS5vd25lclNWR0VsZW1lbnQpKSB8fFxuICAgICAgICAgICAgKGVsLm5vZGUucGFyZW50Tm9kZSAmJiB3cmFwKGVsLm5vZGUucGFyZW50Tm9kZSkpIHx8XG4gICAgICAgICAgICBTbmFwLnNlbGVjdChcInN2Z1wiKSB8fFxuICAgICAgICAgICAgU25hcCgwLCAwKSxcbiAgICAgICAgcGRlZnMgPSBwLnNlbGVjdChcImRlZnNcIiksXG4gICAgICAgIGRlZnMgID0gcGRlZnMgPT0gbnVsbCA/IGZhbHNlIDogcGRlZnMubm9kZTtcbiAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgZGVmcyA9IG1ha2UoXCJkZWZzXCIsIHAubm9kZSkubm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZnM7XG59XG5mdW5jdGlvbiBnZXRTb21lU1ZHKGVsKSB7XG4gICAgcmV0dXJuIGVsLm5vZGUub3duZXJTVkdFbGVtZW50ICYmIHdyYXAoZWwubm9kZS5vd25lclNWR0VsZW1lbnQpIHx8IFNuYXAuc2VsZWN0KFwic3ZnXCIpO1xufVxuU25hcC5fLmdldFNvbWVEZWZzID0gZ2V0U29tZURlZnM7XG5TbmFwLl8uZ2V0U29tZVNWRyA9IGdldFNvbWVTVkc7XG5mdW5jdGlvbiB1bml0MnB4KGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBzdmcgPSBnZXRTb21lU1ZHKGVsKS5ub2RlLFxuICAgICAgICBvdXQgPSB7fSxcbiAgICAgICAgbWdyID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoXCIuc3ZnLS0tbWdyXCIpO1xuICAgIGlmICghbWdyKSB7XG4gICAgICAgIG1nciA9ICQoXCJyZWN0XCIpO1xuICAgICAgICAkKG1nciwge3g6IC05ZTksIHk6IC05ZTksIHdpZHRoOiAxMCwgaGVpZ2h0OiAxMCwgXCJjbGFzc1wiOiBcInN2Zy0tLW1nclwiLCBmaWxsOiBcIm5vbmVcIn0pO1xuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQobWdyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Vyh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09ICt2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgJChtZ3IsIHt3aWR0aDogdmFsfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbWdyLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09ICt2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgJChtZ3IsIHtoZWlnaHQ6IHZhbH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG1nci5nZXRCQm94KCkuaGVpZ2h0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXQobmFtLCBmKSB7XG4gICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIG91dFtuYW1dID0gZihlbC5hdHRyKG5hbSkgfHwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtID09IG5hbWUpIHtcbiAgICAgICAgICAgIG91dCA9IGYodmFsdWUgPT0gbnVsbCA/IGVsLmF0dHIobmFtKSB8fCAwIDogdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZWwudHlwZSkge1xuICAgICAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgICAgICAgc2V0KFwicnhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJyeVwiLCBnZXRIKTtcbiAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgICBzZXQoXCJ3aWR0aFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImhlaWdodFwiLCBnZXRIKTtcbiAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHNldChcInhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJ5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgICAgc2V0KFwiY3hcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJjeVwiLCBnZXRIKTtcbiAgICAgICAgICAgIHNldChcInJcIiwgZ2V0Vyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgICAgc2V0KFwiY3hcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJjeVwiLCBnZXRIKTtcbiAgICAgICAgICAgIHNldChcInJ4XCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwicnlcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgc2V0KFwieDFcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJ4MlwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcInkxXCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwieTJcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWFya2VyXCI6XG4gICAgICAgICAgICBzZXQoXCJyZWZYXCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwibWFya2VyV2lkdGhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJyZWZZXCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwibWFya2VySGVpZ2h0XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJhZGlhbEdyYWRpZW50XCI6XG4gICAgICAgICAgICBzZXQoXCJmeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImZ5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRzcGFuXCI6XG4gICAgICAgICAgICBzZXQoXCJkeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImR5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNldChuYW1lLCBnZXRXKTtcbiAgICB9XG4gICAgc3ZnLnJlbW92ZUNoaWxkKG1ncik7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qXFxcbiAqIFNuYXAuc2VsZWN0XG4gWyBtZXRob2QgXVxuICoqXG4gKiBXcmFwcyBhIERPTSBlbGVtZW50IHNwZWNpZmllZCBieSBDU1Mgc2VsZWN0b3IgYXMgQEVsZW1lbnRcbiAtIHF1ZXJ5IChzdHJpbmcpIENTUyBzZWxlY3RvciBvZiB0aGUgZWxlbWVudFxuID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcblxcKi9cblNuYXAuc2VsZWN0ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBTdHIocXVlcnkpLnJlcGxhY2UoLyhbXlxcXFxdKTovZywgXCIkMVxcXFw6XCIpO1xuICAgIHJldHVybiB3cmFwKGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3IocXVlcnkpKTtcbn07XG4vKlxcXG4gKiBTbmFwLnNlbGVjdEFsbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogV3JhcHMgRE9NIGVsZW1lbnRzIHNwZWNpZmllZCBieSBDU1Mgc2VsZWN0b3IgYXMgc2V0IG9yIGFycmF5IG9mIEBFbGVtZW50XG4gLSBxdWVyeSAoc3RyaW5nKSBDU1Mgc2VsZWN0b3Igb2YgdGhlIGVsZW1lbnRcbiA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG5cXCovXG5TbmFwLnNlbGVjdEFsbCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIHZhciBub2RlbGlzdCA9IGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICBzZXQgPSAoU25hcC5zZXQgfHwgQXJyYXkpKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZXQucHVzaCh3cmFwKG5vZGVsaXN0W2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG59O1xuXG5mdW5jdGlvbiBhZGQyZ3JvdXAobGlzdCkge1xuICAgIGlmICghaXMobGlzdCwgXCJhcnJheVwiKSkge1xuICAgICAgICBsaXN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB9XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgbm9kZSA9IHRoaXMubm9kZTtcbiAgICB3aGlsZSAodGhpc1tpXSkgZGVsZXRlIHRoaXNbaSsrXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGlzdFtpXS50eXBlID09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIGxpc3RbaV0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGVsLm5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGxpc3RbaV0ubm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2orK10gPSB3cmFwKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG4vLyBIdWIgZ2FyYmFnZSBjb2xsZWN0b3IgZXZlcnkgMTBzXG5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGh1YikgaWYgKGh1YltoYXNdKGtleSkpIHtcbiAgICAgICAgdmFyIGVsID0gaHViW2tleV0sXG4gICAgICAgICAgICBub2RlID0gZWwubm9kZTtcbiAgICAgICAgaWYgKGVsLnR5cGUgIT0gXCJzdmdcIiAmJiAhbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgZWwudHlwZSA9PSBcInN2Z1wiICYmICghbm9kZS5wYXJlbnROb2RlIHx8IFwib3duZXJTVkdFbGVtZW50XCIgaW4gbm9kZS5wYXJlbnROb2RlICYmICFub2RlLm93bmVyU1ZHRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBodWJba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn0sIDFlNCk7XG5mdW5jdGlvbiBFbGVtZW50KGVsKSB7XG4gICAgaWYgKGVsLnNuYXAgaW4gaHViKSB7XG4gICAgICAgIHJldHVybiBodWJbZWwuc25hcF07XG4gICAgfVxuICAgIHZhciBzdmc7XG4gICAgdHJ5IHtcbiAgICAgICAgc3ZnID0gZWwub3duZXJTVkdFbGVtZW50O1xuICAgIH0gY2F0Y2goZSkge31cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5ub2RlXG4gICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAqKlxuICAgICAqIEdpdmVzIHlvdSBhIHJlZmVyZW5jZSB0byB0aGUgRE9NIG9iamVjdCwgc28geW91IGNhbiBhc3NpZ24gZXZlbnQgaGFuZGxlcnMgb3IganVzdCBtZXNzIGFyb3VuZC5cbiAgICAgPiBVc2FnZVxuICAgICB8IC8vIGRyYXcgYSBjaXJjbGUgYXQgY29vcmRpbmF0ZSAxMCwxMCB3aXRoIHJhZGl1cyBvZiAxMFxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApO1xuICAgICB8IGMubm9kZS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICBjLmF0dHIoXCJmaWxsXCIsIFwicmVkXCIpO1xuICAgICB8IH07XG4gICAgXFwqL1xuICAgIHRoaXMubm9kZSA9IGVsO1xuICAgIGlmIChzdmcpIHtcbiAgICAgICAgdGhpcy5wYXBlciA9IG5ldyBQYXBlcihzdmcpO1xuICAgIH1cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50eXBlXG4gICAgIFsgcHJvcGVydHkgKHN0cmluZykgXVxuICAgICAqKlxuICAgICAqIFNWRyB0YWcgbmFtZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICBcXCovXG4gICAgdGhpcy50eXBlID0gZWwudGFnTmFtZSB8fCBlbC5ub2RlTmFtZTtcbiAgICB2YXIgaWQgPSB0aGlzLmlkID0gSUQodGhpcyk7XG4gICAgdGhpcy5hbmltcyA9IHt9O1xuICAgIHRoaXMuXyA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiBbXVxuICAgIH07XG4gICAgZWwuc25hcCA9IGlkO1xuICAgIGh1YltpZF0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJnXCIpIHtcbiAgICAgICAgdGhpcy5hZGQgPSBhZGQyZ3JvdXA7XG4gICAgfVxuICAgIGlmICh0aGlzLnR5cGUgaW4ge2c6IDEsIG1hc2s6IDEsIHBhdHRlcm46IDEsIHN5bWJvbDogMX0pIHtcbiAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIFBhcGVyLnByb3RvdHlwZSkgaWYgKFBhcGVyLnByb3RvdHlwZVtoYXNdKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IFBhcGVyLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICB9XG4gICAgfVxufVxuICAgLypcXFxuICAgICAqIEVsZW1lbnQuYXR0clxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2V0cyBvciBzZXRzIGdpdmVuIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQuXG4gICAgICoqXG4gICAgIC0gcGFyYW1zIChvYmplY3QpIGNvbnRhaW5zIGtleS12YWx1ZSBwYWlycyBvZiBhdHRyaWJ1dGVzIHlvdSB3YW50IHRvIHNldFxuICAgICAqIG9yXG4gICAgIC0gcGFyYW0gKHN0cmluZykgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKiBvclxuICAgICA9IChzdHJpbmcpIHZhbHVlIG9mIGF0dHJpYnV0ZVxuICAgICA+IFVzYWdlXG4gICAgIHwgZWwuYXR0cih7XG4gICAgIHwgICAgIGZpbGw6IFwiI2ZjMFwiLFxuICAgICB8ICAgICBzdHJva2U6IFwiIzAwMFwiLFxuICAgICB8ICAgICBzdHJva2VXaWR0aDogMiwgLy8gQ2FtZWxDYXNlLi4uXG4gICAgIHwgICAgIFwiZmlsbC1vcGFjaXR5XCI6IDAuNSwgLy8gb3IgZGFzaC1zZXBhcmF0ZWQgbmFtZXNcbiAgICAgfCAgICAgd2lkdGg6IFwiKj0yXCIgLy8gcHJlZml4ZWQgdmFsdWVzXG4gICAgIHwgfSk7XG4gICAgIHwgY29uc29sZS5sb2coZWwuYXR0cihcImZpbGxcIikpOyAvLyAjZmMwXG4gICAgICogUHJlZml4ZWQgdmFsdWVzIGluIGZvcm1hdCBgXCIrPTEwXCJgIHN1cHBvcnRlZC4gQWxsIGZvdXIgb3BlcmF0aW9uc1xuICAgICAqIChgK2AsIGAtYCwgYCpgIGFuZCBgL2ApIGNvdWxkIGJlIHVzZWQuIE9wdGlvbmFsbHkgeW91IGNhbiB1c2UgdW5pdHMgZm9yIGArYFxuICAgICAqIGFuZCBgLWA6IGBcIis9MmVtXCJgLlxuICAgIFxcKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBlbC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG5vZGUubm9kZVZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXR0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2F0dHJbaV0ubm9kZU5hbWVdID0gYXR0cltpXS5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhwYXJhbXMsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGpzb25bcGFyYW1zXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGpzb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmUoXCJzbmFwLnV0aWwuZ2V0YXR0ci5cIiArIHBhcmFtcywgZWwpLmZpcnN0RGVmaW5lZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGF0dCBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbaGFzXShhdHQpKSB7XG4gICAgICAgICAgICAgICAgZXZlKFwic25hcC51dGlsLmF0dHIuXCIgKyBhdHQsIGVsLCBwYXJhbXNbYXR0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4vKlxcXG4gKiBTbmFwLnBhcnNlXG4gWyBtZXRob2QgXVxuICoqXG4gKiBQYXJzZXMgU1ZHIGZyYWdtZW50IGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgQEZyYWdtZW50XG4gKipcbiAtIHN2ZyAoc3RyaW5nKSBTVkcgc3RyaW5nXG4gPSAoRnJhZ21lbnQpIHRoZSBARnJhZ21lbnRcblxcKi9cblNuYXAucGFyc2UgPSBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgdmFyIGYgPSBnbG9iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIGZ1bGwgPSB0cnVlLFxuICAgICAgICBkaXYgPSBnbG9iLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHN2ZyA9IFN0cihzdmcpO1xuICAgIGlmICghc3ZnLm1hdGNoKC9eXFxzKjxcXHMqc3ZnKD86XFxzfD4pLykpIHtcbiAgICAgICAgc3ZnID0gXCI8c3ZnPlwiICsgc3ZnICsgXCI8L3N2Zz5cIjtcbiAgICAgICAgZnVsbCA9IGZhbHNlO1xuICAgIH1cbiAgICBkaXYuaW5uZXJIVE1MID0gc3ZnO1xuICAgIHN2ZyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXTtcbiAgICBpZiAoc3ZnKSB7XG4gICAgICAgIGlmIChmdWxsKSB7XG4gICAgICAgICAgICBmID0gc3ZnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChmKTtcbn07XG5mdW5jdGlvbiBGcmFnbWVudChmcmFnKSB7XG4gICAgdGhpcy5ub2RlID0gZnJhZztcbn1cbi8qXFxcbiAqIFNuYXAuZnJhZ21lbnRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENyZWF0ZXMgYSBET00gZnJhZ21lbnQgZnJvbSBhIGdpdmVuIGxpc3Qgb2YgZWxlbWVudHMgb3Igc3RyaW5nc1xuICoqXG4gLSB2YXJhcmdzICjigKYpIFNWRyBzdHJpbmdcbiA9IChGcmFnbWVudCkgdGhlIEBGcmFnbWVudFxuXFwqL1xuU25hcC5mcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgIGYgPSBnbG9iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0ubm9kZSAmJiBpdGVtLm5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGYuYXBwZW5kQ2hpbGQoaXRlbS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChTbmFwLnBhcnNlKGl0ZW0pLm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoZik7XG59O1xuXG5mdW5jdGlvbiBtYWtlKG5hbWUsIHBhcmVudCkge1xuICAgIHZhciByZXMgPSAkKG5hbWUpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZXMpO1xuICAgIHZhciBlbCA9IHdyYXAocmVzKTtcbiAgICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBQYXBlcih3LCBoKSB7XG4gICAgdmFyIHJlcyxcbiAgICAgICAgZGVzYyxcbiAgICAgICAgZGVmcyxcbiAgICAgICAgcHJvdG8gPSBQYXBlci5wcm90b3R5cGU7XG4gICAgaWYgKHcgJiYgdy50YWdOYW1lID09IFwic3ZnXCIpIHtcbiAgICAgICAgaWYgKHcuc25hcCBpbiBodWIpIHtcbiAgICAgICAgICAgIHJldHVybiBodWJbdy5zbmFwXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jID0gdy5vd25lckRvY3VtZW50O1xuICAgICAgICByZXMgPSBuZXcgRWxlbWVudCh3KTtcbiAgICAgICAgZGVzYyA9IHcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkZXNjXCIpWzBdO1xuICAgICAgICBkZWZzID0gdy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRlZnNcIilbMF07XG4gICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgZGVzYyA9ICQoXCJkZXNjXCIpO1xuICAgICAgICAgICAgZGVzYy5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoXCJDcmVhdGVkIHdpdGggU25hcFwiKSk7XG4gICAgICAgICAgICByZXMubm9kZS5hcHBlbmRDaGlsZChkZXNjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgICAgIGRlZnMgPSAkKFwiZGVmc1wiKTtcbiAgICAgICAgICAgIHJlcy5ub2RlLmFwcGVuZENoaWxkKGRlZnMpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5kZWZzID0gZGVmcztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3RvKSBpZiAocHJvdG9baGFzXShrZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IHByb3RvW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnBhcGVyID0gcmVzLnJvb3QgPSByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gbWFrZShcInN2Z1wiLCBnbG9iLmRvYy5ib2R5KTtcbiAgICAgICAgJChyZXMubm9kZSwge1xuICAgICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgdmVyc2lvbjogMS4xLFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICB4bWxuczogeG1sbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB3cmFwKGRvbSkge1xuICAgIGlmICghZG9tKSB7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGlmIChkb20gaW5zdGFuY2VvZiBFbGVtZW50IHx8IGRvbSBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGlmIChkb20udGFnTmFtZSAmJiBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwic3ZnXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXBlcihkb20pO1xuICAgIH1cbiAgICBpZiAoZG9tLnRhZ05hbWUgJiYgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcIm9iamVjdFwiICYmIGRvbS50eXBlID09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFwZXIoZG9tLmNvbnRlbnREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRWxlbWVudChkb20pO1xufVxuXG5TbmFwLl8ubWFrZSA9IG1ha2U7XG5TbmFwLl8ud3JhcCA9IHdyYXA7XG4vKlxcXG4gKiBQYXBlci5lbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IG9uIHBhcGVyIHdpdGggYSBnaXZlbiBuYW1lIGFuZCBubyBhdHRyaWJ1dGVzXG4gKipcbiAtIG5hbWUgKHN0cmluZykgdGFnIG5hbWVcbiAtIGF0dHIgKG9iamVjdCkgYXR0cmlidXRlc1xuID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiA+IFVzYWdlXG4gfCB2YXIgYyA9IHBhcGVyLmNpcmNsZSgxMCwgMTAsIDEwKTsgLy8gaXMgdGhlIHNhbWUgYXMuLi5cbiB8IHZhciBjID0gcGFwZXIuZWwoXCJjaXJjbGVcIikuYXR0cih7XG4gfCAgICAgY3g6IDEwLFxuIHwgICAgIGN5OiAxMCxcbiB8ICAgICByOiAxMFxuIHwgfSk7XG4gfCAvLyBhbmQgdGhlIHNhbWUgYXNcbiB8IHZhciBjID0gcGFwZXIuZWwoXCJjaXJjbGVcIiwge1xuIHwgICAgIGN4OiAxMCxcbiB8ICAgICBjeTogMTAsXG4gfCAgICAgcjogMTBcbiB8IH0pO1xuXFwqL1xuUGFwZXIucHJvdG90eXBlLmVsID0gZnVuY3Rpb24gKG5hbWUsIGF0dHIpIHtcbiAgICB2YXIgZWwgPSBtYWtlKG5hbWUsIHRoaXMubm9kZSk7XG4gICAgYXR0ciAmJiBlbC5hdHRyKGF0dHIpO1xuICAgIHJldHVybiBlbDtcbn07XG4vKlxcXG4gKiBFbGVtZW50LmNoaWxkcmVuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQuXG4gPSAoYXJyYXkpIGFycmF5IG9mIEVsZW1lbnRzXG5cXCovXG5FbGVtZW50LnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgIGNoID0gdGhpcy5ub2RlLmNoaWxkTm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2gubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBTbmFwKGNoW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5mdW5jdGlvbiBqc29uRmlsbGVyKHJvb3QsIG8pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByb290Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcm9vdFtpXS50eXBlLFxuICAgICAgICAgICAgICAgIGF0dHI6IHJvb3RbaV0uYXR0cigpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW4gPSByb290W2ldLmNoaWxkcmVuKCk7XG4gICAgICAgIG8ucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAganNvbkZpbGxlcihjaGlsZHJlbiwgaXRlbS5jaGlsZE5vZGVzID0gW10pO1xuICAgICAgICB9XG4gICAgfVxufVxuLypcXFxuICogRWxlbWVudC50b0pTT05cbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuLlxuID0gKG9iamVjdCkgaW4gZm9ybWF0XG4gbyB7XG4gbyAgICAgdHlwZSAoc3RyaW5nKSB0aGlzLnR5cGUsXG4gbyAgICAgYXR0ciAob2JqZWN0KSBhdHRyaWJ1dGVzIG1hcCxcbiBvICAgICBjaGlsZE5vZGVzIChhcnJheSkgb3B0aW9uYWwgYXJyYXkgb2YgY2hpbGRyZW4gaW4gdGhlIHNhbWUgZm9ybWF0XG4gbyB9XG5cXCovXG5FbGVtZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGpzb25GaWxsZXIoW3RoaXNdLCBvdXQpO1xuICAgIHJldHVybiBvdXRbMF07XG59O1xuLy8gZGVmYXVsdFxuZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhdHQgPSBldmUubnQoKTtcbiAgICBhdHQgPSBhdHQuc3Vic3RyaW5nKGF0dC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgICB2YXIgY3NzID0gYXR0LnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiLVwiICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgaWYgKGNzc0F0dHJbaGFzXShjc3MpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShjc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAkKHRoaXMubm9kZSwgYXR0KTtcbiAgICB9XG59KTtcbnZhciBjc3NBdHRyID0ge1xuICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCI6IDAsXG4gICAgXCJiYXNlbGluZS1zaGlmdFwiOiAwLFxuICAgIFwiY2xpcFwiOiAwLFxuICAgIFwiY2xpcC1wYXRoXCI6IDAsXG4gICAgXCJjbGlwLXJ1bGVcIjogMCxcbiAgICBcImNvbG9yXCI6IDAsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCI6IDAsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogMCxcbiAgICBcImNvbG9yLXByb2ZpbGVcIjogMCxcbiAgICBcImNvbG9yLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwiY3Vyc29yXCI6IDAsXG4gICAgXCJkaXJlY3Rpb25cIjogMCxcbiAgICBcImRpc3BsYXlcIjogMCxcbiAgICBcImRvbWluYW50LWJhc2VsaW5lXCI6IDAsXG4gICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiAwLFxuICAgIFwiZmlsbFwiOiAwLFxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IDAsXG4gICAgXCJmaWxsLXJ1bGVcIjogMCxcbiAgICBcImZpbHRlclwiOiAwLFxuICAgIFwiZmxvb2QtY29sb3JcIjogMCxcbiAgICBcImZsb29kLW9wYWNpdHlcIjogMCxcbiAgICBcImZvbnRcIjogMCxcbiAgICBcImZvbnQtZmFtaWx5XCI6IDAsXG4gICAgXCJmb250LXNpemVcIjogMCxcbiAgICBcImZvbnQtc2l6ZS1hZGp1c3RcIjogMCxcbiAgICBcImZvbnQtc3RyZXRjaFwiOiAwLFxuICAgIFwiZm9udC1zdHlsZVwiOiAwLFxuICAgIFwiZm9udC12YXJpYW50XCI6IDAsXG4gICAgXCJmb250LXdlaWdodFwiOiAwLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiOiAwLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogMCxcbiAgICBcImltYWdlLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwia2VybmluZ1wiOiAwLFxuICAgIFwibGV0dGVyLXNwYWNpbmdcIjogMCxcbiAgICBcImxpZ2h0aW5nLWNvbG9yXCI6IDAsXG4gICAgXCJtYXJrZXJcIjogMCxcbiAgICBcIm1hcmtlci1lbmRcIjogMCxcbiAgICBcIm1hcmtlci1taWRcIjogMCxcbiAgICBcIm1hcmtlci1zdGFydFwiOiAwLFxuICAgIFwibWFza1wiOiAwLFxuICAgIFwib3BhY2l0eVwiOiAwLFxuICAgIFwib3ZlcmZsb3dcIjogMCxcbiAgICBcInBvaW50ZXItZXZlbnRzXCI6IDAsXG4gICAgXCJzaGFwZS1yZW5kZXJpbmdcIjogMCxcbiAgICBcInN0b3AtY29sb3JcIjogMCxcbiAgICBcInN0b3Atb3BhY2l0eVwiOiAwLFxuICAgIFwic3Ryb2tlXCI6IDAsXG4gICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IDAsXG4gICAgXCJzdHJva2UtZGFzaG9mZnNldFwiOiAwLFxuICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogMCxcbiAgICBcInN0cm9rZS1saW5lam9pblwiOiAwLFxuICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjogMCxcbiAgICBcInN0cm9rZS1vcGFjaXR5XCI6IDAsXG4gICAgXCJzdHJva2Utd2lkdGhcIjogMCxcbiAgICBcInRleHQtYW5jaG9yXCI6IDAsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogMCxcbiAgICBcInRleHQtcmVuZGVyaW5nXCI6IDAsXG4gICAgXCJ1bmljb2RlLWJpZGlcIjogMCxcbiAgICBcInZpc2liaWxpdHlcIjogMCxcbiAgICBcIndvcmQtc3BhY2luZ1wiOiAwLFxuICAgIFwid3JpdGluZy1tb2RlXCI6IDBcbn07XG5cbmV2ZS5vbihcInNuYXAudXRpbC5hdHRyXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBhdHQgPSBldmUubnQoKSxcbiAgICAgICAgYXR0ciA9IHt9O1xuICAgIGF0dCA9IGF0dC5zdWJzdHJpbmcoYXR0Lmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgIGF0dHJbYXR0XSA9IHZhbHVlO1xuICAgIHZhciBzdHlsZSA9IGF0dC5yZXBsYWNlKC8tKFxcdykvZ2ksIGZ1bmN0aW9uIChhbGwsIGxldHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KSxcbiAgICAgICAgY3NzID0gYXR0LnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi1cIiArIGxldHRlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICBpZiAoY3NzQXR0cltoYXNdKGNzcykpIHtcbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlW3N0eWxlXSA9IHZhbHVlID09IG51bGwgPyBFIDogdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCh0aGlzLm5vZGUsIGF0dHIpO1xuICAgIH1cbn0pO1xuKGZ1bmN0aW9uIChwcm90bykge30oUGFwZXIucHJvdG90eXBlKSk7XG5cbi8vIHNpbXBsZSBhamF4XG4vKlxcXG4gKiBTbmFwLmFqYXhcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBBamF4XG4gKipcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIHBvc3REYXRhIChvYmplY3R8c3RyaW5nKSBkYXRhIGZvciBwb3N0IHJlcXVlc3RcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuICogb3JcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuID0gKFhNTEh0dHBSZXF1ZXN0KSB0aGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LCBqdXN0IGluIGNhc2VcblxcKi9cblNuYXAuYWpheCA9IGZ1bmN0aW9uICh1cmwsIHBvc3REYXRhLCBjYWxsYmFjaywgc2NvcGUpe1xuICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QsXG4gICAgICAgIGlkID0gSUQoKTtcbiAgICBpZiAocmVxKSB7XG4gICAgICAgIGlmIChpcyhwb3N0RGF0YSwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgc2NvcGUgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcG9zdERhdGE7XG4gICAgICAgICAgICBwb3N0RGF0YSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMocG9zdERhdGEsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICB2YXIgcGQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwb3N0RGF0YSkgaWYgKHBvc3REYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBwZC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocG9zdERhdGFba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zdERhdGEgPSBwZC5qb2luKFwiJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub3BlbigocG9zdERhdGEgPyBcIlBPU1RcIiA6IFwiR0VUXCIpLCB1cmwsIHRydWUpO1xuICAgICAgICBpZiAocG9zdERhdGEpIHtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLCBcIlhNTEh0dHBSZXF1ZXN0XCIpO1xuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBldmUub25jZShcInNuYXAuYWpheC5cIiArIGlkICsgXCIuMFwiLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBldmUub25jZShcInNuYXAuYWpheC5cIiArIGlkICsgXCIuMjAwXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGV2ZS5vbmNlKFwic25hcC5hamF4LlwiICsgaWQgKyBcIi4zMDRcIiwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSAhPSA0KSByZXR1cm47XG4gICAgICAgICAgICBldmUoXCJzbmFwLmFqYXguXCIgKyBpZCArIFwiLlwiICsgcmVxLnN0YXR1cywgc2NvcGUsIHJlcSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxO1xuICAgICAgICB9XG4gICAgICAgIHJlcS5zZW5kKHBvc3REYXRhKTtcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG59O1xuLypcXFxuICogU25hcC5sb2FkXG4gWyBtZXRob2QgXVxuICoqXG4gKiBMb2FkcyBleHRlcm5hbCBTVkcgZmlsZSBhcyBhIEBGcmFnbWVudCAoc2VlIEBTbmFwLmFqYXggZm9yIG1vcmUgYWR2YW5jZWQgQUpBWClcbiAqKlxuIC0gdXJsIChzdHJpbmcpIFVSTFxuIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSBjYWxsYmFja1xuIC0gc2NvcGUgKG9iamVjdCkgI29wdGlvbmFsIHNjb3BlIG9mIGNhbGxiYWNrXG5cXCovXG5TbmFwLmxvYWQgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICBTbmFwLmFqYXgodXJsLCBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHZhciBmID0gU25hcC5wYXJzZShyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2NvcGUgPyBjYWxsYmFjay5jYWxsKHNjb3BlLCBmKSA6IGNhbGxiYWNrKGYpO1xuICAgIH0pO1xufTtcbnZhciBnZXRPZmZzZXQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGJvZHkgPSBkb2MuYm9keSxcbiAgICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIGNsaWVudFRvcCA9IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDAsIGNsaWVudExlZnQgPSBkb2NFbGVtLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDAsXG4gICAgICAgIHRvcCAgPSBib3gudG9wICArIChnLndpbi5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcCApIC0gY2xpZW50VG9wLFxuICAgICAgICBsZWZ0ID0gYm94LmxlZnQgKyAoZy53aW4ucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdCkgLSBjbGllbnRMZWZ0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHk6IHRvcCxcbiAgICAgICAgeDogbGVmdFxuICAgIH07XG59O1xuLypcXFxuICogU25hcC5nZXRFbGVtZW50QnlQb2ludFxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyB5b3UgdG9wbW9zdCBlbGVtZW50IHVuZGVyIGdpdmVuIHBvaW50LlxuICoqXG4gPSAob2JqZWN0KSBTbmFwIGVsZW1lbnQgb2JqZWN0XG4gLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHdpbmRvd1xuIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB3aW5kb3dcbiA+IFVzYWdlXG4gfCBTbmFwLmdldEVsZW1lbnRCeVBvaW50KG1vdXNlWCwgbW91c2VZKS5hdHRyKHtzdHJva2U6IFwiI2YwMFwifSk7XG5cXCovXG5TbmFwLmdldEVsZW1lbnRCeVBvaW50ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgcGFwZXIgPSB0aGlzLFxuICAgICAgICBzdmcgPSBwYXBlci5jYW52YXMsXG4gICAgICAgIHRhcmdldCA9IGdsb2IuZG9jLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKGdsb2Iud2luLm9wZXJhICYmIHRhcmdldC50YWdOYW1lID09IFwic3ZnXCIpIHtcbiAgICAgICAgdmFyIHNvID0gZ2V0T2Zmc2V0KHRhcmdldCksXG4gICAgICAgICAgICBzciA9IHRhcmdldC5jcmVhdGVTVkdSZWN0KCk7XG4gICAgICAgIHNyLnggPSB4IC0gc28ueDtcbiAgICAgICAgc3IueSA9IHkgLSBzby55O1xuICAgICAgICBzci53aWR0aCA9IHNyLmhlaWdodCA9IDE7XG4gICAgICAgIHZhciBoaXRzID0gdGFyZ2V0LmdldEludGVyc2VjdGlvbkxpc3Qoc3IsIG51bGwpO1xuICAgICAgICBpZiAoaGl0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGhpdHNbaGl0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXAodGFyZ2V0KTtcbn07XG4vKlxcXG4gKiBTbmFwLnBsdWdpblxuIFsgbWV0aG9kIF1cbiAqKlxuICogTGV0IHlvdSB3cml0ZSBwbHVnaW5zLiBZb3UgcGFzcyBpbiBhIGZ1bmN0aW9uIHdpdGggZml2ZSBhcmd1bWVudHMsIGxpa2UgdGhpczpcbiB8IFNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYmFsLCBGcmFnbWVudCkge1xuIHwgICAgIFNuYXAubmV3bWV0aG9kID0gZnVuY3Rpb24gKCkge307XG4gfCAgICAgRWxlbWVudC5wcm90b3R5cGUubmV3bWV0aG9kID0gZnVuY3Rpb24gKCkge307XG4gfCAgICAgUGFwZXIucHJvdG90eXBlLm5ld21ldGhvZCA9IGZ1bmN0aW9uICgpIHt9O1xuIHwgfSk7XG4gKiBJbnNpZGUgdGhlIGZ1bmN0aW9uIHlvdSBoYXZlIGFjY2VzcyB0byBhbGwgbWFpbiBvYmplY3RzIChhbmQgdGhlaXJcbiAqIHByb3RvdHlwZXMpLiBUaGlzIGFsbG93IHlvdSB0byBleHRlbmQgYW55dGhpbmcgeW91IHdhbnQuXG4gKipcbiAtIGYgKGZ1bmN0aW9uKSB5b3VyIHBsdWdpbiBib2R5XG5cXCovXG5TbmFwLnBsdWdpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgZihTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYiwgRnJhZ21lbnQpO1xufTtcbmdsb2Iud2luLlNuYXAgPSBTbmFwO1xucmV0dXJuIFNuYXA7XG59KHdpbmRvdyB8fCB0aGlzKSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYiwgRnJhZ21lbnQpIHtcbiAgICB2YXIgZWxwcm90byA9IEVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICBpcyA9IFNuYXAuaXMsXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgdW5pdDJweCA9IFNuYXAuX3VuaXQycHgsXG4gICAgICAgICQgPSBTbmFwLl8uJCxcbiAgICAgICAgbWFrZSA9IFNuYXAuXy5tYWtlLFxuICAgICAgICBnZXRTb21lRGVmcyA9IFNuYXAuXy5nZXRTb21lRGVmcyxcbiAgICAgICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICB3cmFwID0gU25hcC5fLndyYXA7XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0QkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGRlc2NyaXB0b3IgZm9yIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgYm91bmRpbmcgYm94IGRlc2NyaXB0b3I6XG4gICAgIG8ge1xuICAgICBvICAgICBjeDogKG51bWJlcikgeCBvZiB0aGUgY2VudGVyLFxuICAgICBvICAgICBjeTogKG51bWJlcikgeCBvZiB0aGUgY2VudGVyLFxuICAgICBvICAgICBoOiAobnVtYmVyKSBoZWlnaHQsXG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0LFxuICAgICBvICAgICBwYXRoOiAoc3RyaW5nKSBwYXRoIGNvbW1hbmQgZm9yIHRoZSBib3gsXG4gICAgIG8gICAgIHIwOiAobnVtYmVyKSByYWRpdXMgb2YgYSBjaXJjbGUgdGhhdCBmdWxseSBlbmNsb3NlcyB0aGUgYm94LFxuICAgICBvICAgICByMTogKG51bWJlcikgcmFkaXVzIG9mIHRoZSBzbWFsbGVzdCBjaXJjbGUgdGhhdCBjYW4gYmUgZW5jbG9zZWQsXG4gICAgIG8gICAgIHIyOiAobnVtYmVyKSByYWRpdXMgb2YgdGhlIGxhcmdlc3QgY2lyY2xlIHRoYXQgY2FuIGJlIGVuY2xvc2VkLFxuICAgICBvICAgICB2YjogKHN0cmluZykgYm94IGFzIGEgdmlld2JveCBjb21tYW5kLFxuICAgICBvICAgICB3OiAobnVtYmVyKSB3aWR0aCxcbiAgICAgbyAgICAgd2lkdGg6IChudW1iZXIpIHdpZHRoLFxuICAgICBvICAgICB4MjogKG51bWJlcikgeCBvZiB0aGUgcmlnaHQgc2lkZSxcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBvZiB0aGUgbGVmdCBzaWRlLFxuICAgICBvICAgICB5MjogKG51bWJlcikgeSBvZiB0aGUgYm90dG9tIGVkZ2UsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgb2YgdGhlIHRvcCBlZGdlXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmdldEJCb3ggPSBmdW5jdGlvbiAoaXNXaXRob3V0VHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICghU25hcC5NYXRyaXggfHwgIVNuYXAucGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRCQm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsID0gdGhpcyxcbiAgICAgICAgICAgIG0gPSBuZXcgU25hcC5NYXRyaXg7XG4gICAgICAgIGlmIChlbC5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveCgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbC50eXBlID09IFwidXNlXCIpIHtcbiAgICAgICAgICAgIGlmICghaXNXaXRob3V0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgbSA9IG0uYWRkKGVsLnRyYW5zZm9ybSgpLmxvY2FsTWF0cml4LnRyYW5zbGF0ZShlbC5hdHRyKFwieFwiKSB8fCAwLCBlbC5hdHRyKFwieVwiKSB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwub3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGVsLm9yaWdpbmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IGVsLmF0dHIoXCJ4bGluazpocmVmXCIpO1xuICAgICAgICAgICAgICAgIGVsID0gZWwub3JpZ2luYWwgPSBlbC5ub2RlLm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaHJlZi5zdWJzdHJpbmcoaHJlZi5pbmRleE9mKFwiI1wiKSArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgXyA9IGVsLl8sXG4gICAgICAgICAgICBwYXRoZmluZGVyID0gU25hcC5wYXRoLmdldFtlbC50eXBlXSB8fCBTbmFwLnBhdGguZ2V0LmRlZmx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGlzV2l0aG91dFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIF8uYmJveHd0ID0gcGF0aGZpbmRlciA/IFNuYXAucGF0aC5nZXRCQm94KGVsLnJlYWxQYXRoID0gcGF0aGZpbmRlcihlbCkpIDogU25hcC5fLmJveChlbC5ub2RlLmdldEJCb3goKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3goXy5iYm94d3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5yZWFsUGF0aCA9IHBhdGhmaW5kZXIoZWwpO1xuICAgICAgICAgICAgICAgIGVsLm1hdHJpeCA9IGVsLnRyYW5zZm9ybSgpLmxvY2FsTWF0cml4O1xuICAgICAgICAgICAgICAgIF8uYmJveCA9IFNuYXAucGF0aC5nZXRCQm94KFNuYXAucGF0aC5tYXAoZWwucmVhbFBhdGgsIG0uYWRkKGVsLm1hdHJpeCkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveChfLmJib3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IGRvZXNu4oCZdCBnaXZlIHlvdSBiYm94IG9mIGhpZGRlbiBlbGVtZW50XG4gICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcHJvcFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZXh0cmFjdFRyYW5zZm9ybShlbCwgdHN0cikge1xuICAgICAgICBpZiAodHN0ciA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZG9SZXR1cm4gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT0gXCJsaW5lYXJHcmFkaWVudFwiIHx8IGVsLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgdHN0ciA9IGVsLm5vZGUuZ2V0QXR0cmlidXRlKFwiZ3JhZGllbnRUcmFuc2Zvcm1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsLnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gZWwubm9kZS5nZXRBdHRyaWJ1dGUoXCJwYXR0ZXJuVHJhbnNmb3JtXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gZWwubm9kZS5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNuYXAuTWF0cml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHN0ciA9IFNuYXAuXy5zdmdUcmFuc2Zvcm0yc3RyaW5nKHRzdHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFTbmFwLl8ucmdUcmFuc2Zvcm0udGVzdCh0c3RyKSkge1xuICAgICAgICAgICAgICAgIHRzdHIgPSBTbmFwLl8uc3ZnVHJhbnNmb3JtMnN0cmluZyh0c3RyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHN0ciA9IFN0cih0c3RyKS5yZXBsYWNlKC9cXC57M318XFx1MjAyNi9nLCBlbC5fLnRyYW5zZm9ybSB8fCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpcyh0c3RyLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICAgICAgdHN0ciA9IFNuYXAucGF0aCA/IFNuYXAucGF0aC50b1N0cmluZy5jYWxsKHRzdHIpIDogU3RyKHRzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuXy50cmFuc2Zvcm0gPSB0c3RyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtID0gU25hcC5fLnRyYW5zZm9ybTJtYXRyaXgodHN0ciwgZWwuZ2V0QkJveCgxKSk7XG4gICAgICAgIGlmIChkb1JldHVybikge1xuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5tYXRyaXggPSBtO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRyYW5zZm9ybVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2V0cyBvciBzZXRzIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgICoqXG4gICAgIC0gdHN0ciAoc3RyaW5nKSB0cmFuc2Zvcm0gc3RyaW5nIGluIFNuYXAgb3IgU1ZHIGZvcm1hdFxuICAgICA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICogb3JcbiAgICAgPSAob2JqZWN0KSB0cmFuc2Zvcm1hdGlvbiBkZXNjcmlwdG9yOlxuICAgICBvIHtcbiAgICAgbyAgICAgc3RyaW5nIChzdHJpbmcpIHRyYW5zZm9ybSBzdHJpbmcsXG4gICAgIG8gICAgIGdsb2JhbE1hdHJpeCAoTWF0cml4KSBtYXRyaXggb2YgYWxsIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIHRvIGVsZW1lbnQgb3IgaXRzIHBhcmVudHMsXG4gICAgIG8gICAgIGxvY2FsTWF0cml4IChNYXRyaXgpIG1hdHJpeCBvZiB0cmFuc2Zvcm1hdGlvbnMgYXBwbGllZCBvbmx5IHRvIHRoZSBlbGVtZW50LFxuICAgICBvICAgICBkaWZmTWF0cml4IChNYXRyaXgpIG1hdHJpeCBvZiBkaWZmZXJlbmNlIGJldHdlZW4gZ2xvYmFsIGFuZCBsb2NhbCB0cmFuc2Zvcm1hdGlvbnMsXG4gICAgIG8gICAgIGdsb2JhbCAoc3RyaW5nKSBnbG9iYWwgdHJhbnNmb3JtYXRpb24gYXMgc3RyaW5nLFxuICAgICBvICAgICBsb2NhbCAoc3RyaW5nKSBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBhcyBzdHJpbmcsXG4gICAgIG8gICAgIHRvU3RyaW5nIChmdW5jdGlvbikgcmV0dXJucyBgc3RyaW5nYCBwcm9wZXJ0eVxuICAgICBvIH1cbiAgICBcXCovXG4gICAgZWxwcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodHN0cikge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgaWYgKHRzdHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBhcGEgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGdsb2JhbCA9IG5ldyBTbmFwLk1hdHJpeCh0aGlzLm5vZGUuZ2V0Q1RNKCkpLFxuICAgICAgICAgICAgICAgIGxvY2FsID0gZXh0cmFjdFRyYW5zZm9ybSh0aGlzKSxcbiAgICAgICAgICAgICAgICBtcyA9IFtsb2NhbF0sXG4gICAgICAgICAgICAgICAgbSA9IG5ldyBTbmFwLk1hdHJpeCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGxvY2FsU3RyaW5nID0gbG9jYWwudG9UcmFuc2Zvcm1TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBTdHIobG9jYWwpID09IFN0cih0aGlzLm1hdHJpeCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cihfLnRyYW5zZm9ybSkgOiBsb2NhbFN0cmluZztcbiAgICAgICAgICAgIHdoaWxlIChwYXBhLnR5cGUgIT0gXCJzdmdcIiAmJiAocGFwYSA9IHBhcGEucGFyZW50KCkpKSB7XG4gICAgICAgICAgICAgICAgbXMucHVzaChleHRyYWN0VHJhbnNmb3JtKHBhcGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBtcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgbS5hZGQobXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgICAgICAgICAgICBnbG9iYWxNYXRyaXg6IGdsb2JhbCxcbiAgICAgICAgICAgICAgICB0b3RhbE1hdHJpeDogbSxcbiAgICAgICAgICAgICAgICBsb2NhbE1hdHJpeDogbG9jYWwsXG4gICAgICAgICAgICAgICAgZGlmZk1hdHJpeDogZ2xvYmFsLmNsb25lKCkuYWRkKGxvY2FsLmludmVydCgpKSxcbiAgICAgICAgICAgICAgICBnbG9iYWw6IGdsb2JhbC50b1RyYW5zZm9ybVN0cmluZygpLFxuICAgICAgICAgICAgICAgIHRvdGFsOiBtLnRvVHJhbnNmb3JtU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbG9jYWw6IGxvY2FsU3RyaW5nLFxuICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBwcm9wU3RyaW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0c3RyIGluc3RhbmNlb2YgU25hcC5NYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMubWF0cml4ID0gdHN0cjtcbiAgICAgICAgICAgIHRoaXMuXy50cmFuc2Zvcm0gPSB0c3RyLnRvVHJhbnNmb3JtU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRyYWN0VHJhbnNmb3JtKHRoaXMsIHRzdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcImxpbmVhckdyYWRpZW50XCIgfHwgdGhpcy50eXBlID09IFwicmFkaWFsR3JhZGllbnRcIikge1xuICAgICAgICAgICAgICAgICQodGhpcy5ub2RlLCB7Z3JhZGllbnRUcmFuc2Zvcm06IHRoaXMubWF0cml4fSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PSBcInBhdHRlcm5cIikge1xuICAgICAgICAgICAgICAgICQodGhpcy5ub2RlLCB7cGF0dGVyblRyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHt0cmFuc2Zvcm06IHRoaXMubWF0cml4fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnBhcmVudFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudCdzIHBhcmVudFxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5wYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3cmFwKHRoaXMubm9kZS5wYXJlbnROb2RlKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFwcGVuZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gZWxlbWVudCB0byBjdXJyZW50IG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50fFNldCkgZWxlbWVudCB0byBhcHBlbmRcbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFkZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBFbGVtZW50LmFwcGVuZFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmFwcGVuZCA9IGVscHJvdG8uYWRkID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT0gXCJzZXRcIikge1xuICAgICAgICAgICAgICAgIHZhciBpdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZWwuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuYWRkKGVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZWwubm9kZSk7XG4gICAgICAgICAgICBlbC5wYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hcHBlbmRUb1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQXBwZW5kcyB0aGUgY3VycmVudCBlbGVtZW50IHRvIHRoZSBnaXZlbiBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgcGFyZW50IGVsZW1lbnQgdG8gYXBwZW5kIHRvXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjaGlsZCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYXBwZW5kVG8gPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBlbCA9IHdyYXAoZWwpO1xuICAgICAgICAgICAgZWwuYXBwZW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucHJlcGVuZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUHJlcGVuZHMgdGhlIGdpdmVuIGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnQpIGVsZW1lbnQgdG8gcHJlcGVuZFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5wcmVwZW5kID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT0gXCJzZXRcIikge1xuICAgICAgICAgICAgICAgIHZhciBpdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0O1xuICAgICAgICAgICAgICAgIGVsLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QuYWZ0ZXIoZWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQucHJlcGVuZChlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBlbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50KCk7XG4gICAgICAgICAgICB0aGlzLm5vZGUuaW5zZXJ0QmVmb3JlKGVsLm5vZGUsIHRoaXMubm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuYWRkICYmIHRoaXMuYWRkKCk7XG4gICAgICAgICAgICBlbC5wYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuYWRkKCk7XG4gICAgICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFkZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucHJlcGVuZFRvXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgY3VycmVudCBlbGVtZW50IHRvIHRoZSBnaXZlbiBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgcGFyZW50IGVsZW1lbnQgdG8gcHJlcGVuZCB0b1xuICAgICA9IChFbGVtZW50KSB0aGUgY2hpbGQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnByZXBlbmRUbyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbCA9IHdyYXAoZWwpO1xuICAgICAgICBlbC5wcmVwZW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmJlZm9yZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSW5zZXJ0cyBnaXZlbiBlbGVtZW50IGJlZm9yZSB0aGUgY3VycmVudCBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgZWxlbWVudCB0byBpbnNlcnRcbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYmVmb3JlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChlbC50eXBlID09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIHZhciBpdCA9IHRoaXM7XG4gICAgICAgICAgICBlbC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBpdC5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLm5vZGUsIGl0Lm5vZGUpO1xuICAgICAgICAgICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50KCkuYWRkKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbCA9IHdyYXAoZWwpO1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50KCk7XG4gICAgICAgIHRoaXMubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbC5ub2RlLCB0aGlzLm5vZGUpO1xuICAgICAgICB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuYWRkKCk7XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hZnRlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSW5zZXJ0cyBnaXZlbiBlbGVtZW50IGFmdGVyIHRoZSBjdXJyZW50IG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IHRvIGluc2VydFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5hZnRlciA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbCA9IHdyYXAoZWwpO1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50KCk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbC5ub2RlLCB0aGlzLm5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwubm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmFkZCgpO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFkZCgpO1xuICAgICAgICBlbC5wYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5zZXJ0QmVmb3JlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBnaXZlbiBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgZWxlbWVudCBuZXh0IHRvIHdob20gaW5zZXJ0IHRvXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbCA9IHdyYXAoZWwpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgZWwubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm5vZGUsIGVsLm5vZGUpO1xuICAgICAgICB0aGlzLnBhcGVyID0gZWwucGFwZXI7XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIGVsLnBhcmVudCgpICYmIGVsLnBhcmVudCgpLmFkZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lmluc2VydEFmdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBnaXZlbiBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgZWxlbWVudCBuZXh0IHRvIHdob20gaW5zZXJ0IHRvXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICBlbC5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubm9kZSwgZWwubm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIHRoaXMucGFwZXIgPSBlbC5wYXBlcjtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgZWwucGFyZW50KCkgJiYgZWwucGFyZW50KCkuYWRkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucmVtb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnQgZnJvbSB0aGUgRE9NXG4gICAgID0gKEVsZW1lbnQpIHRoZSBkZXRhY2hlZCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUgJiYgdGhpcy5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucGFwZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc2VsZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHYXRoZXJzIHRoZSBuZXN0ZWQgQEVsZW1lbnQgbWF0Y2hpbmcgdGhlIGdpdmVuIHNldCBvZiBDU1Mgc2VsZWN0b3JzXG4gICAgICoqXG4gICAgIC0gcXVlcnkgKHN0cmluZykgQ1NTIHNlbGVjdG9yXG4gICAgID0gKEVsZW1lbnQpIHJlc3VsdCBvZiBxdWVyeSBzZWxlY3Rpb25cbiAgICBcXCovXG4gICAgZWxwcm90by5zZWxlY3QgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IocXVlcnkpKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnNlbGVjdEFsbFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2F0aGVycyBuZXN0ZWQgQEVsZW1lbnQgb2JqZWN0cyBtYXRjaGluZyB0aGUgZ2l2ZW4gc2V0IG9mIENTUyBzZWxlY3RvcnNcbiAgICAgKipcbiAgICAgLSBxdWVyeSAoc3RyaW5nKSBDU1Mgc2VsZWN0b3JcbiAgICAgPSAoU2V0fGFycmF5KSByZXN1bHQgb2YgcXVlcnkgc2VsZWN0aW9uXG4gICAgXFwqL1xuICAgIGVscHJvdG8uc2VsZWN0QWxsID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHZhciBub2RlbGlzdCA9IHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSxcbiAgICAgICAgICAgIHNldCA9IChTbmFwLnNldCB8fCBBcnJheSkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2V0LnB1c2god3JhcChub2RlbGlzdFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hc1BYXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGdpdmVuIGF0dHJpYnV0ZSBvZiB0aGUgZWxlbWVudCBhcyBhIGBweGAgdmFsdWUgKG5vdCAlLCBlbSwgZXRjLilcbiAgICAgKipcbiAgICAgLSBhdHRyIChzdHJpbmcpIGF0dHJpYnV0ZSBuYW1lXG4gICAgIC0gdmFsdWUgKHN0cmluZykgI29wdGlvbmFsIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICA9IChFbGVtZW50KSByZXN1bHQgb2YgcXVlcnkgc2VsZWN0aW9uXG4gICAgXFwqL1xuICAgIGVscHJvdG8uYXNQWCA9IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmF0dHIoYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICt1bml0MnB4KHRoaXMsIGF0dHIsIHZhbHVlKTtcbiAgICB9O1xuICAgIC8vIFNJRVJSQSBFbGVtZW50LnVzZSgpOiBJIHN1Z2dlc3QgYWRkaW5nIGEgbm90ZSBhYm91dCBob3cgdG8gYWNjZXNzIHRoZSBvcmlnaW5hbCBlbGVtZW50IHRoZSByZXR1cm5lZCA8dXNlPiBpbnN0YW50aWF0ZXMuIEl0J3MgYSBwYXJ0IG9mIFNWRyB3aXRoIHdoaWNoIG9yZGluYXJ5IHdlYiBkZXZlbG9wZXJzIG1heSBiZSBsZWFzdCBmYW1pbGlhci5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51c2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPHVzZT5gIGVsZW1lbnQgbGlua2VkIHRvIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKipcbiAgICAgPSAoRWxlbWVudCkgdGhlIGA8dXNlPmAgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVzZSxcbiAgICAgICAgICAgIGlkID0gdGhpcy5ub2RlLmlkO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcImxpbmVhckdyYWRpZW50XCIgfHwgdGhpcy50eXBlID09IFwicmFkaWFsR3JhZGllbnRcIiB8fFxuICAgICAgICAgICAgdGhpcy50eXBlID09IFwicGF0dGVyblwiKSB7XG4gICAgICAgICAgICB1c2UgPSBtYWtlKHRoaXMudHlwZSwgdGhpcy5ub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXNlID0gbWFrZShcInVzZVwiLCB0aGlzLm5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgJCh1c2Uubm9kZSwge1xuICAgICAgICAgICAgXCJ4bGluazpocmVmXCI6IFwiI1wiICsgaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHVzZS5vcmlnaW5hbCA9IHRoaXM7XG4gICAgICAgIHJldHVybiB1c2U7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmaXhpZHMoZWwpIHtcbiAgICAgICAgdmFyIGVscyA9IGVsLnNlbGVjdEFsbChcIipcIiksXG4gICAgICAgICAgICBpdCxcbiAgICAgICAgICAgIHVybCA9IC9eXFxzKnVybFxcKChcInwnfCkoLiopXFwxXFwpXFxzKiQvLFxuICAgICAgICAgICAgaWRzID0gW10sXG4gICAgICAgICAgICB1c2VzID0ge307XG4gICAgICAgIGZ1bmN0aW9uIHVybHRlc3QoaXQsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSAkKGl0Lm5vZGUsIG5hbWUpO1xuICAgICAgICAgICAgdmFsID0gdmFsICYmIHZhbC5tYXRjaCh1cmwpO1xuICAgICAgICAgICAgdmFsID0gdmFsICYmIHZhbFsyXTtcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdmFsLmNoYXJBdCgpID09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHVzZXNbdmFsXSA9ICh1c2VzW3ZhbF0gfHwgW10pLmNvbmNhdChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgYXR0cltuYW1lXSA9IFVSTChpZCk7XG4gICAgICAgICAgICAgICAgICAgICQoaXQubm9kZSwgYXR0cik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGlua3Rlc3QoaXQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSAkKGl0Lm5vZGUsIFwieGxpbms6aHJlZlwiKTtcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdmFsLmNoYXJBdCgpID09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHVzZXNbdmFsXSA9ICh1c2VzW3ZhbF0gfHwgW10pLmNvbmNhdChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuYXR0cihcInhsaW5rOmhyZWZcIiwgXCIjXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZWxzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGl0ID0gZWxzW2ldO1xuICAgICAgICAgICAgdXJsdGVzdChpdCwgXCJmaWxsXCIpO1xuICAgICAgICAgICAgdXJsdGVzdChpdCwgXCJzdHJva2VcIik7XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcImZpbHRlclwiKTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwibWFza1wiKTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwiY2xpcC1wYXRoXCIpO1xuICAgICAgICAgICAgbGlua3Rlc3QoaXQpO1xuICAgICAgICAgICAgdmFyIG9sZGlkID0gJChpdC5ub2RlLCBcImlkXCIpO1xuICAgICAgICAgICAgaWYgKG9sZGlkKSB7XG4gICAgICAgICAgICAgICAgJChpdC5ub2RlLCB7aWQ6IGl0LmlkfSk7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvbGQ6IG9sZGlkLFxuICAgICAgICAgICAgICAgICAgICBpZDogaXQuaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGlkcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnMgPSB1c2VzW2lkc1tpXS5vbGRdO1xuICAgICAgICAgICAgaWYgKGZzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gZnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBmc1tqXShpZHNbaV0uaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5jbG9uZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBlbGVtZW50IGFuZCBpbnNlcnRzIGl0IGFmdGVyIHRoZSBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjbG9uZVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwKHRoaXMubm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICBpZiAoJChjbG9uZS5ub2RlLCBcImlkXCIpKSB7XG4gICAgICAgICAgICAkKGNsb25lLm5vZGUsIHtpZDogY2xvbmUuaWR9KTtcbiAgICAgICAgfVxuICAgICAgICBmaXhpZHMoY2xvbmUpO1xuICAgICAgICBjbG9uZS5pbnNlcnRBZnRlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9EZWZzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBNb3ZlcyBlbGVtZW50IHRvIHRoZSBzaGFyZWQgYDxkZWZzPmAgYXJlYVxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnRvRGVmcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlZnMgPSBnZXRTb21lRGVmcyh0aGlzKTtcbiAgICAgICAgZGVmcy5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvUGF0dGVyblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGA8cGF0dGVybj5gIGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgICogVG8gY3JlYXRlIGEgcGF0dGVybiB5b3UgaGF2ZSB0byBzcGVjaWZ5IHRoZSBwYXR0ZXJuIHJlY3Q6XG4gICAgIC0geCAoc3RyaW5nfG51bWJlcilcbiAgICAgLSB5IChzdHJpbmd8bnVtYmVyKVxuICAgICAtIHdpZHRoIChzdHJpbmd8bnVtYmVyKVxuICAgICAtIGhlaWdodCAoc3RyaW5nfG51bWJlcilcbiAgICAgPSAoRWxlbWVudCkgdGhlIGA8cGF0dGVybj5gIGVsZW1lbnRcbiAgICAgKiBZb3UgY2FuIHVzZSBwYXR0ZXJuIGxhdGVyIG9uIGFzIGFuIGFyZ3VtZW50IGZvciBgZmlsbGAgYXR0cmlidXRlOlxuICAgICB8IHZhciBwID0gcGFwZXIucGF0aChcIk0xMC01LTEwLDE1TTE1LDAsMCwxNU0wLTUtMjAsMTVcIikuYXR0cih7XG4gICAgIHwgICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgfCAgICAgICAgIHN0cm9rZTogXCIjYmFkYTU1XCIsXG4gICAgIHwgICAgICAgICBzdHJva2VXaWR0aDogNVxuICAgICB8ICAgICB9KS5wYXR0ZXJuKDAsIDAsIDEwLCAxMCksXG4gICAgIHwgICAgIGMgPSBwYXBlci5jaXJjbGUoMjAwLCAyMDAsIDEwMCk7XG4gICAgIHwgYy5hdHRyKHtcbiAgICAgfCAgICAgZmlsbDogcFxuICAgICB8IH0pO1xuICAgIFxcKi9cbiAgICBlbHByb3RvLnBhdHRlcm4gPSBlbHByb3RvLnRvUGF0dGVybiA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBwID0gbWFrZShcInBhdHRlcm5cIiwgZ2V0U29tZURlZnModGhpcykpO1xuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpICYmIFwieFwiIGluIHgpIHtcbiAgICAgICAgICAgIHkgPSB4Lnk7XG4gICAgICAgICAgICB3aWR0aCA9IHgud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB4LmhlaWdodDtcbiAgICAgICAgICAgIHggPSB4Lng7XG4gICAgICAgIH1cbiAgICAgICAgJChwLm5vZGUsIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBwYXR0ZXJuVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIixcbiAgICAgICAgICAgIGlkOiBwLmlkLFxuICAgICAgICAgICAgdmlld0JveDogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oXCIgXCIpXG4gICAgICAgIH0pO1xuICAgICAgICBwLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcbi8vIFNJRVJSQSBFbGVtZW50Lm1hcmtlcigpOiBjbGFyaWZ5IHdoYXQgYSByZWZlcmVuY2UgcG9pbnQgaXMuIEUuZy4sIGhlbHBzIHlvdSBvZmZzZXQgdGhlIG9iamVjdCBmcm9tIGl0cyBlZGdlIHN1Y2ggYXMgd2hlbiBjZW50ZXJpbmcgaXQgb3ZlciBhIHBhdGguXG4vLyBTSUVSUkEgRWxlbWVudC5tYXJrZXIoKTogSSBzdWdnZXN0IHRoZSBtZXRob2Qgc2hvdWxkIGFjY2VwdCBkZWZhdWx0IHJlZmVyZW5jZSBwb2ludCB2YWx1ZXMuICBQZXJoYXBzIGNlbnRlcmVkIHdpdGggKHJlZlggPSB3aWR0aC8yKSBhbmQgKHJlZlkgPSBoZWlnaHQvMik/IEFsc28sIGNvdWxkbid0IGl0IGFzc3VtZSB0aGUgZWxlbWVudCdzIGN1cnJlbnQgX3dpZHRoXyBhbmQgX2hlaWdodF8/IEFuZCBwbGVhc2Ugc3BlY2lmeSB3aGF0IF94XyBhbmQgX3lfIG1lYW46IG9mZnNldHM/IElmIHNvLCBmcm9tIHdoZXJlPyAgQ291bGRuJ3QgdGhleSBhbHNvIGJlIGFzc2lnbmVkIGRlZmF1bHQgdmFsdWVzP1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1hcmtlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGA8bWFya2VyPmAgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKipcbiAgICAgKiBUbyBjcmVhdGUgYSBtYXJrZXIgeW91IGhhdmUgdG8gc3BlY2lmeSB0aGUgYm91bmRpbmcgcmVjdCBhbmQgcmVmZXJlbmNlIHBvaW50OlxuICAgICAtIHggKG51bWJlcilcbiAgICAgLSB5IChudW1iZXIpXG4gICAgIC0gd2lkdGggKG51bWJlcilcbiAgICAgLSBoZWlnaHQgKG51bWJlcilcbiAgICAgLSByZWZYIChudW1iZXIpXG4gICAgIC0gcmVmWSAobnVtYmVyKVxuICAgICA9IChFbGVtZW50KSB0aGUgYDxtYXJrZXI+YCBlbGVtZW50XG4gICAgICogWW91IGNhbiBzcGVjaWZ5IHRoZSBtYXJrZXIgbGF0ZXIgYXMgYW4gYXJndW1lbnQgZm9yIGBtYXJrZXItc3RhcnRgLCBgbWFya2VyLWVuZGAsIGBtYXJrZXItbWlkYCwgYW5kIGBtYXJrZXJgIGF0dHJpYnV0ZXMuIFRoZSBgbWFya2VyYCBhdHRyaWJ1dGUgcGxhY2VzIHRoZSBtYXJrZXIgYXQgZXZlcnkgcG9pbnQgYWxvbmcgdGhlIHBhdGgsIGFuZCBgbWFya2VyLW1pZGAgcGxhY2VzIHRoZW0gYXQgZXZlcnkgcG9pbnQgZXhjZXB0IHRoZSBzdGFydCBhbmQgZW5kLlxuICAgIFxcKi9cbiAgICAvLyBUT0RPIGFkZCB1c2FnZSBmb3IgbWFya2Vyc1xuICAgIGVscHJvdG8ubWFya2VyID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJlZlgsIHJlZlkpIHtcbiAgICAgICAgdmFyIHAgPSBtYWtlKFwibWFya2VyXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSAmJiBcInhcIiBpbiB4KSB7XG4gICAgICAgICAgICB5ID0geC55O1xuICAgICAgICAgICAgd2lkdGggPSB4LndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0geC5oZWlnaHQ7XG4gICAgICAgICAgICByZWZYID0geC5yZWZYIHx8IHguY3g7XG4gICAgICAgICAgICByZWZZID0geC5yZWZZIHx8IHguY3k7XG4gICAgICAgICAgICB4ID0geC54O1xuICAgICAgICB9XG4gICAgICAgICQocC5ub2RlLCB7XG4gICAgICAgICAgICB2aWV3Qm94OiBbeCwgeSwgd2lkdGgsIGhlaWdodF0uam9pbihcIiBcIiksXG4gICAgICAgICAgICBtYXJrZXJXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICBtYXJrZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIG9yaWVudDogXCJhdXRvXCIsXG4gICAgICAgICAgICByZWZYOiByZWZYIHx8IDAsXG4gICAgICAgICAgICByZWZZOiByZWZZIHx8IDAsXG4gICAgICAgICAgICBpZDogcC5pZFxuICAgICAgICB9KTtcbiAgICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG4gICAgLy8gYW5pbWF0aW9uXG4gICAgZnVuY3Rpb24gc2xpY2UoZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBhcnIuc2xpY2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmID8gZihyZXMpIDogcmVzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKGF0dHIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWFzaW5nID09IFwiZnVuY3Rpb25cIiAmJiAhZWFzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICBlYXNpbmcgPSBtaW5hLmxpbmVhcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLmR1ciA9IG1zO1xuICAgICAgICBlYXNpbmcgJiYgKHRoaXMuZWFzaW5nID0gZWFzaW5nKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgKHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBTbmFwLl8uQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmFuaW1hdGlvblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhbiBhbmltYXRpb24gb2JqZWN0XG4gICAgICoqXG4gICAgIC0gYXR0ciAob2JqZWN0KSBhdHRyaWJ1dGVzIG9mIGZpbmFsIGRlc3RpbmF0aW9uXG4gICAgIC0gZHVyYXRpb24gKG51bWJlcikgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiwgaW4gbWlsbGlzZWNvbmRzXG4gICAgIC0gZWFzaW5nIChmdW5jdGlvbikgI29wdGlvbmFsIG9uZSBvZiBlYXNpbmcgZnVuY3Rpb25zIG9mIEBtaW5hIG9yIGN1c3RvbSBvbmVcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pICNvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGZpcmVzIHdoZW4gYW5pbWF0aW9uIGVuZHNcbiAgICAgPSAob2JqZWN0KSBhbmltYXRpb24gb2JqZWN0XG4gICAgXFwqL1xuICAgIFNuYXAuYW5pbWF0aW9uID0gZnVuY3Rpb24gKGF0dHIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGF0dHIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmluQW5pbVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhIHNldCBvZiBhbmltYXRpb25zIHRoYXQgbWF5IGJlIGFibGUgdG8gbWFuaXB1bGF0ZSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgaW4gZm9ybWF0OlxuICAgICBvIHtcbiAgICAgbyAgICAgYW5pbSAob2JqZWN0KSBhbmltYXRpb24gb2JqZWN0LFxuICAgICBvICAgICBtaW5hIChvYmplY3QpIEBtaW5hIG9iamVjdCxcbiAgICAgbyAgICAgY3VyU3RhdHVzIChudW1iZXIpIDAuLjEg4oCUIHN0YXR1cyBvZiB0aGUgYW5pbWF0aW9uOiAwIOKAlCBqdXN0IHN0YXJ0ZWQsIDEg4oCUIGp1c3QgZmluaXNoZWQsXG4gICAgIG8gICAgIHN0YXR1cyAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgc3RhdHVzIG9mIHRoZSBhbmltYXRpb24sXG4gICAgIG8gICAgIHN0b3AgKGZ1bmN0aW9uKSBzdG9wcyB0aGUgYW5pbWF0aW9uXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmluQW5pbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcyxcbiAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBlbC5hbmltcykgaWYgKGVsLmFuaW1zW2hhc10oaWQpKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW06IG5ldyBBbmltYXRpb24oYS5fYXR0cnMsIGEuZHVyLCBhLmVhc2luZywgYS5fY2FsbGJhY2spLFxuICAgICAgICAgICAgICAgICAgICBtaW5hOiBhLFxuICAgICAgICAgICAgICAgICAgICBjdXJTdGF0dXM6IGEuc3RhdHVzKCksXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhdHVzKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KGVsLmFuaW1zW2lkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5hbmltYXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSdW5zIGdlbmVyaWMgYW5pbWF0aW9uIG9mIG9uZSBudW1iZXIgaW50byBhbm90aGVyIHdpdGggYSBjYXJpbmcgZnVuY3Rpb25cbiAgICAgKipcbiAgICAgLSBmcm9tIChudW1iZXJ8YXJyYXkpIG51bWJlciBvciBhcnJheSBvZiBudW1iZXJzXG4gICAgIC0gdG8gKG51bWJlcnxhcnJheSkgbnVtYmVyIG9yIGFycmF5IG9mIG51bWJlcnNcbiAgICAgLSBzZXR0ZXIgKGZ1bmN0aW9uKSBjYXJpbmcgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBudW1iZXIgYXJndW1lbnRcbiAgICAgLSBkdXJhdGlvbiAobnVtYmVyKSBkdXJhdGlvbiwgaW4gbWlsbGlzZWNvbmRzXG4gICAgIC0gZWFzaW5nIChmdW5jdGlvbikgI29wdGlvbmFsIGVhc2luZyBmdW5jdGlvbiBmcm9tIEBtaW5hIG9yIGN1c3RvbVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBhbmltYXRpb24gZW5kc1xuICAgICA9IChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3QgaW4gQG1pbmEgZm9ybWF0XG4gICAgIG8ge1xuICAgICBvICAgICBpZCAoc3RyaW5nKSBhbmltYXRpb24gaWQsIGNvbnNpZGVyIGl0IHJlYWQtb25seSxcbiAgICAgbyAgICAgZHVyYXRpb24gKGZ1bmN0aW9uKSBnZXRzIG9yIHNldHMgdGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24sXG4gICAgIG8gICAgIGVhc2luZyAoZnVuY3Rpb24pIGVhc2luZyxcbiAgICAgbyAgICAgc3BlZWQgKGZ1bmN0aW9uKSBnZXRzIG9yIHNldHMgdGhlIHNwZWVkIG9mIHRoZSBhbmltYXRpb24sXG4gICAgIG8gICAgIHN0YXR1cyAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgc3RhdHVzIG9mIHRoZSBhbmltYXRpb24sXG4gICAgIG8gICAgIHN0b3AgKGZ1bmN0aW9uKSBzdG9wcyB0aGUgYW5pbWF0aW9uXG4gICAgIG8gfVxuICAgICB8IHZhciByZWN0ID0gU25hcCgpLnJlY3QoMCwgMCwgMTAsIDEwKTtcbiAgICAgfCBTbmFwLmFuaW1hdGUoMCwgMTAsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgfCAgICAgcmVjdC5hdHRyKHtcbiAgICAgfCAgICAgICAgIHg6IHZhbFxuICAgICB8ICAgICB9KTtcbiAgICAgfCB9LCAxMDAwKTtcbiAgICAgfCAvLyBpbiBnaXZlbiBjb250ZXh0IGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgfCByZWN0LmFuaW1hdGUoe3g6IDEwfSwgMTAwMCk7XG4gICAgXFwqL1xuICAgIFNuYXAuYW5pbWF0ZSA9IGZ1bmN0aW9uIChmcm9tLCB0bywgc2V0dGVyLCBtcywgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGVhc2luZyA9PSBcImZ1bmN0aW9uXCIgJiYgIWVhc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICAgICAgZWFzaW5nID0gbWluYS5saW5lYXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vdyA9IG1pbmEudGltZSgpLFxuICAgICAgICAgICAgYW5pbSA9IG1pbmEoZnJvbSwgdG8sIG5vdywgbm93ICsgbXMsIG1pbmEudGltZSwgc2V0dGVyLCBlYXNpbmcpO1xuICAgICAgICBjYWxsYmFjayAmJiBldmUub25jZShcIm1pbmEuZmluaXNoLlwiICsgYW5pbS5pZCwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gYW5pbTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnN0b3BcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFN0b3BzIGFsbCB0aGUgYW5pbWF0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFuaW1zID0gdGhpcy5pbkFuaW0oKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYW5pbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgYW5pbXNbaV0uc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYW5pbWF0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQW5pbWF0ZXMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgICAgKipcbiAgICAgLSBhdHRycyAob2JqZWN0KSBrZXktdmFsdWUgcGFpcnMgb2YgZGVzdGluYXRpb24gYXR0cmlidXRlc1xuICAgICAtIGR1cmF0aW9uIChudW1iZXIpIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgIC0gZWFzaW5nIChmdW5jdGlvbikgI29wdGlvbmFsIGVhc2luZyBmdW5jdGlvbiBmcm9tIEBtaW5hIG9yIGN1c3RvbVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHNcbiAgICAgPSAoRWxlbWVudCkgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmFuaW1hdGUgPSBmdW5jdGlvbiAoYXR0cnMsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWFzaW5nID09IFwiZnVuY3Rpb25cIiAmJiAhZWFzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICBlYXNpbmcgPSBtaW5hLmxpbmVhcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMgaW5zdGFuY2VvZiBBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXR0cnMuY2FsbGJhY2s7XG4gICAgICAgICAgICBlYXNpbmcgPSBhdHRycy5lYXNpbmc7XG4gICAgICAgICAgICBtcyA9IGF0dHJzLmR1cjtcbiAgICAgICAgICAgIGF0dHJzID0gYXR0cnMuYXR0cjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmtleXMgPSBbXSwgdGtleXMgPSBbXSwga2V5cyA9IHt9LCBmcm9tLCB0bywgZiwgZXEsXG4gICAgICAgICAgICBlbCA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykgaWYgKGF0dHJzW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgaWYgKGVsLmVxdWFsKSB7XG4gICAgICAgICAgICAgICAgZXEgPSBlbC5lcXVhbChrZXksIFN0cihhdHRyc1trZXldKSk7XG4gICAgICAgICAgICAgICAgZnJvbSA9IGVxLmZyb207XG4gICAgICAgICAgICAgICAgdG8gPSBlcS50bztcbiAgICAgICAgICAgICAgICBmID0gZXEuZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9ICtlbC5hdHRyKGtleSk7XG4gICAgICAgICAgICAgICAgdG8gPSArYXR0cnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW4gPSBpcyhmcm9tLCBcImFycmF5XCIpID8gZnJvbS5sZW5ndGggOiAxO1xuICAgICAgICAgICAga2V5c1trZXldID0gc2xpY2UoZmtleXMubGVuZ3RoLCBma2V5cy5sZW5ndGggKyBsZW4sIGYpO1xuICAgICAgICAgICAgZmtleXMgPSBma2V5cy5jb25jYXQoZnJvbSk7XG4gICAgICAgICAgICB0a2V5cyA9IHRrZXlzLmNvbmNhdCh0byk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vdyA9IG1pbmEudGltZSgpLFxuICAgICAgICAgICAgYW5pbSA9IG1pbmEoZmtleXMsIHRrZXlzLCBub3csIG5vdyArIG1zLCBtaW5hLnRpbWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlzKSBpZiAoa2V5c1toYXNdKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cltrZXldID0ga2V5c1trZXldKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLmF0dHIoYXR0cik7XG4gICAgICAgICAgICB9LCBlYXNpbmcpO1xuICAgICAgICBlbC5hbmltc1thbmltLmlkXSA9IGFuaW07XG4gICAgICAgIGFuaW0uX2F0dHJzID0gYXR0cnM7XG4gICAgICAgIGFuaW0uX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIGV2ZShcInNuYXAuYW5pbWNyZWF0ZWQuXCIgKyBlbC5pZCwgYW5pbSk7XG4gICAgICAgIGV2ZS5vbmNlKFwibWluYS5maW5pc2guXCIgKyBhbmltLmlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWxldGUgZWwuYW5pbXNbYW5pbS5pZF07XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZS5vbmNlKFwibWluYS5zdG9wLlwiICsgYW5pbS5pZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsLmFuaW1zW2FuaW0uaWRdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgdmFyIGVsZGF0YSA9IHt9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmRhdGFcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgb3IgcmV0cmlldmVzIGdpdmVuIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBnaXZlbiBrZXkuIChEb27igJl0IGNvbmZ1c2VcbiAgICAgKiB3aXRoIGBkYXRhLWAgYXR0cmlidXRlcylcbiAgICAgKlxuICAgICAqIFNlZSBhbHNvIEBFbGVtZW50LnJlbW92ZURhdGFcbiAgICAgLSBrZXkgKHN0cmluZykga2V5IHRvIHN0b3JlIGRhdGFcbiAgICAgLSB2YWx1ZSAoYW55KSAjb3B0aW9uYWwgdmFsdWUgdG8gc3RvcmVcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgICAqIG9yLCBpZiB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkOlxuICAgICA9IChhbnkpIHZhbHVlXG4gICAgID4gVXNhZ2VcbiAgICAgfCBmb3IgKHZhciBpID0gMCwgaSA8IDUsIGkrKykge1xuICAgICB8ICAgICBwYXBlci5jaXJjbGUoMTAgKyAxNSAqIGksIDEwLCAxMClcbiAgICAgfCAgICAgICAgICAuYXR0cih7ZmlsbDogXCIjMDAwXCJ9KVxuICAgICB8ICAgICAgICAgIC5kYXRhKFwiaVwiLCBpKVxuICAgICB8ICAgICAgICAgIC5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgIHwgICAgICAgICAgICAgYWxlcnQodGhpcy5kYXRhKFwiaVwiKSk7XG4gICAgIHwgICAgICAgICAgfSk7XG4gICAgIHwgfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmRhdGEgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IGVsZGF0YVt0aGlzLmlkXSA9IGVsZGF0YVt0aGlzLmlkXSB8fCB7fTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRhdGEuZ2V0LlwiICsgdGhpcy5pZCwgdGhpcywgZGF0YSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoU25hcC5pcyhrZXksIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBrZXkpIGlmIChrZXlbaGFzXShpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEoaSwga2V5W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRhdGEuZ2V0LlwiICsgdGhpcy5pZCwgdGhpcywgZGF0YVtrZXldLCBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgZXZlKFwic25hcC5kYXRhLnNldC5cIiArIHRoaXMuaWQsIHRoaXMsIHZhbHVlLCBrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnJlbW92ZURhdGFcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGFuIGVsZW1lbnQgYnkgZ2l2ZW4ga2V5LlxuICAgICAqIElmIGtleSBpcyBub3QgcHJvdmlkZWQsIHJlbW92ZXMgYWxsIHRoZSBkYXRhIG9mIHRoZSBlbGVtZW50LlxuICAgICAtIGtleSAoc3RyaW5nKSAjb3B0aW9uYWwga2V5XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5yZW1vdmVEYXRhID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGVsZGF0YVt0aGlzLmlkXSA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxkYXRhW3RoaXMuaWRdICYmIGRlbGV0ZSBlbGRhdGFbdGhpcy5pZF1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm91dGVyU1ZHXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIFNWRyBjb2RlIGZvciB0aGUgZWxlbWVudCwgZXF1aXZhbGVudCB0byBIVE1MJ3MgYG91dGVySFRNTGAuXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbyBARWxlbWVudC5pbm5lclNWR1xuICAgICA9IChzdHJpbmcpIFNWRyBjb2RlIGZvciB0aGUgZWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b1N0cmluZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBFbGVtZW50Lm91dGVyU1ZHXG4gICAgXFwqL1xuICAgIGVscHJvdG8ub3V0ZXJTVkcgPSBlbHByb3RvLnRvU3RyaW5nID0gdG9TdHJpbmcoMSk7XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5uZXJTVkdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgU1ZHIGNvZGUgZm9yIHRoZSBlbGVtZW50J3MgY29udGVudHMsIGVxdWl2YWxlbnQgdG8gSFRNTCdzIGBpbm5lckhUTUxgXG4gICAgID0gKHN0cmluZykgU1ZHIGNvZGUgZm9yIHRoZSBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5uZXJTVkcgPSB0b1N0cmluZygpO1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB0eXBlID8gXCI8XCIgKyB0aGlzLnR5cGUgOiBcIlwiLFxuICAgICAgICAgICAgICAgIGF0dHIgPSB0aGlzLm5vZGUuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBjaGxkID0gdGhpcy5ub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGF0dHIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCIgXCIgKyBhdHRyW2ldLm5hbWUgKyAnPVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cltpXS52YWx1ZS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHR5cGUgJiYgKHJlcyArPSBcIj5cIik7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBjaGxkLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNobGRbaV0ubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IGNobGRbaV0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNobGRbaV0ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IHdyYXAoY2hsZFtpXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eXBlICYmIChyZXMgKz0gXCI8L1wiICsgdGhpcy50eXBlICsgXCI+XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlICYmIChyZXMgKz0gXCIvPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVscHJvdG8udG9EYXRhVVJMID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAod2luZG93ICYmIHdpbmRvdy5idG9hKSB7XG4gICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmdldEJCb3goKSxcbiAgICAgICAgICAgICAgICBzdmcgPSBTbmFwLmZvcm1hdCgnPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHdpZHRoPVwie3dpZHRofVwiIGhlaWdodD1cIntoZWlnaHR9XCIgdmlld0JveD1cInt4fSB7eX0ge3dpZHRofSB7aGVpZ2h0fVwiPntjb250ZW50c308L3N2Zz4nLCB7XG4gICAgICAgICAgICAgICAgeDogK2JiLngudG9GaXhlZCgzKSxcbiAgICAgICAgICAgICAgICB5OiArYmIueS50b0ZpeGVkKDMpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiArYmIud2lkdGgudG9GaXhlZCgzKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICtiYi5oZWlnaHQudG9GaXhlZCgzKSxcbiAgICAgICAgICAgICAgICBjb250ZW50czogdGhpcy5vdXRlclNWRygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdmcpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBGcmFnbWVudC5zZWxlY3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNlZSBARWxlbWVudC5zZWxlY3RcbiAgICBcXCovXG4gICAgRnJhZ21lbnQucHJvdG90eXBlLnNlbGVjdCA9IGVscHJvdG8uc2VsZWN0O1xuICAgIC8qXFxcbiAgICAgKiBGcmFnbWVudC5zZWxlY3RBbGxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNlZSBARWxlbWVudC5zZWxlY3RBbGxcbiAgICBcXCovXG4gICAgRnJhZ21lbnQucHJvdG90eXBlLnNlbGVjdEFsbCA9IGVscHJvdG8uc2VsZWN0QWxsO1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy8gXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vIFxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYiwgRnJhZ21lbnQpIHtcbiAgICB2YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIG1hdGggPSBNYXRoLFxuICAgICAgICBFID0gXCJcIjtcbiAgICBmdW5jdGlvbiBNYXRyaXgoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgICBpZiAoYiA9PSBudWxsICYmIG9iamVjdFRvU3RyaW5nLmNhbGwoYSkgPT0gXCJbb2JqZWN0IFNWR01hdHJpeF1cIikge1xuICAgICAgICAgICAgdGhpcy5hID0gYS5hO1xuICAgICAgICAgICAgdGhpcy5iID0gYS5iO1xuICAgICAgICAgICAgdGhpcy5jID0gYS5jO1xuICAgICAgICAgICAgdGhpcy5kID0gYS5kO1xuICAgICAgICAgICAgdGhpcy5lID0gYS5lO1xuICAgICAgICAgICAgdGhpcy5mID0gYS5mO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYSA9ICthO1xuICAgICAgICAgICAgdGhpcy5iID0gK2I7XG4gICAgICAgICAgICB0aGlzLmMgPSArYztcbiAgICAgICAgICAgIHRoaXMuZCA9ICtkO1xuICAgICAgICAgICAgdGhpcy5lID0gK2U7XG4gICAgICAgICAgICB0aGlzLmYgPSArZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYSA9IDE7XG4gICAgICAgICAgICB0aGlzLmIgPSAwO1xuICAgICAgICAgICAgdGhpcy5jID0gMDtcbiAgICAgICAgICAgIHRoaXMuZCA9IDE7XG4gICAgICAgICAgICB0aGlzLmUgPSAwO1xuICAgICAgICAgICAgdGhpcy5mID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAoZnVuY3Rpb24gKG1hdHJpeHByb3RvKSB7XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LmFkZFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogQWRkcyB0aGUgZ2l2ZW4gbWF0cml4IHRvIGV4aXN0aW5nIG9uZVxuICAgICAgICAgLSBhIChudW1iZXIpXG4gICAgICAgICAtIGIgKG51bWJlcilcbiAgICAgICAgIC0gYyAobnVtYmVyKVxuICAgICAgICAgLSBkIChudW1iZXIpXG4gICAgICAgICAtIGUgKG51bWJlcilcbiAgICAgICAgIC0gZiAobnVtYmVyKVxuICAgICAgICAgKiBvclxuICAgICAgICAgLSBtYXRyaXggKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmFkZCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW1tdLCBbXSwgW11dLFxuICAgICAgICAgICAgICAgIG0gPSBbW3RoaXMuYSwgdGhpcy5jLCB0aGlzLmVdLCBbdGhpcy5iLCB0aGlzLmQsIHRoaXMuZl0sIFswLCAwLCAxXV0sXG4gICAgICAgICAgICAgICAgbWF0cml4ID0gW1thLCBjLCBlXSwgW2IsIGQsIGZdLCBbMCwgMCwgMV1dLFxuICAgICAgICAgICAgICAgIHgsIHksIHosIHJlcztcblxuICAgICAgICAgICAgaWYgKGEgJiYgYSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgICAgIG1hdHJpeCA9IFtbYS5hLCBhLmMsIGEuZV0sIFthLmIsIGEuZCwgYS5mXSwgWzAsIDAsIDFdXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IDM7IHgrKykge1xuICAgICAgICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCAzOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh6ID0gMDsgeiA8IDM7IHorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IG1beF1bel0gKiBtYXRyaXhbel1beV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0W3hdW3ldID0gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYSA9IG91dFswXVswXTtcbiAgICAgICAgICAgIHRoaXMuYiA9IG91dFsxXVswXTtcbiAgICAgICAgICAgIHRoaXMuYyA9IG91dFswXVsxXTtcbiAgICAgICAgICAgIHRoaXMuZCA9IG91dFsxXVsxXTtcbiAgICAgICAgICAgIHRoaXMuZSA9IG91dFswXVsyXTtcbiAgICAgICAgICAgIHRoaXMuZiA9IG91dFsxXVsyXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5pbnZlcnRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGUgbWF0cml4XG4gICAgICAgICA9IChvYmplY3QpIEBNYXRyaXhcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHggPSBtZS5hICogbWUuZCAtIG1lLmIgKiBtZS5jO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgobWUuZCAvIHgsIC1tZS5iIC8geCwgLW1lLmMgLyB4LCBtZS5hIC8geCwgKG1lLmMgKiBtZS5mIC0gbWUuZCAqIG1lLmUpIC8geCwgKG1lLmIgKiBtZS5lIC0gbWUuYSAqIG1lLmYpIC8geCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LmNsb25lXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWF0cml4XG4gICAgICAgICA9IChvYmplY3QpIEBNYXRyaXhcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4KHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmYpO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC50cmFuc2xhdGVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFRyYW5zbGF0ZSB0aGUgbWF0cml4XG4gICAgICAgICAtIHggKG51bWJlcikgaG9yaXpvbnRhbCBvZmZzZXQgZGlzdGFuY2VcbiAgICAgICAgIC0geSAobnVtYmVyKSB2ZXJ0aWNhbCBvZmZzZXQgZGlzdGFuY2VcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by50cmFuc2xhdGUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKDEsIDAsIDAsIDEsIHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5zY2FsZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogU2NhbGVzIHRoZSBtYXRyaXhcbiAgICAgICAgIC0geCAobnVtYmVyKSBhbW91bnQgdG8gYmUgc2NhbGVkLCB3aXRoIGAxYCByZXN1bHRpbmcgaW4gbm8gY2hhbmdlXG4gICAgICAgICAtIHkgKG51bWJlcikgI29wdGlvbmFsIGFtb3VudCB0byBzY2FsZSBhbG9uZyB0aGUgdmVydGljYWwgYXhpcy4gKE90aGVyd2lzZSBgeGAgYXBwbGllcyB0byBib3RoIGF4ZXMuKVxuICAgICAgICAgLSBjeCAobnVtYmVyKSAjb3B0aW9uYWwgaG9yaXpvbnRhbCBvcmlnaW4gcG9pbnQgZnJvbSB3aGljaCB0byBzY2FsZVxuICAgICAgICAgLSBjeSAobnVtYmVyKSAjb3B0aW9uYWwgdmVydGljYWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gc2NhbGVcbiAgICAgICAgICogRGVmYXVsdCBjeCwgY3kgaXMgdGhlIG1pZGRsZSBwb2ludCBvZiB0aGUgZWxlbWVudC5cbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5zY2FsZSA9IGZ1bmN0aW9uICh4LCB5LCBjeCwgY3kpIHtcbiAgICAgICAgICAgIHkgPT0gbnVsbCAmJiAoeSA9IHgpO1xuICAgICAgICAgICAgKGN4IHx8IGN5KSAmJiB0aGlzLmFkZCgxLCAwLCAwLCAxLCBjeCwgY3kpO1xuICAgICAgICAgICAgdGhpcy5hZGQoeCwgMCwgMCwgeSwgMCwgMCk7XG4gICAgICAgICAgICAoY3ggfHwgY3kpICYmIHRoaXMuYWRkKDEsIDAsIDAsIDEsIC1jeCwgLWN5KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5yb3RhdGVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJvdGF0ZXMgdGhlIG1hdHJpeFxuICAgICAgICAgLSBhIChudW1iZXIpIGFuZ2xlIG9mIHJvdGF0aW9uLCBpbiBkZWdyZWVzXG4gICAgICAgICAtIHggKG51bWJlcikgaG9yaXpvbnRhbCBvcmlnaW4gcG9pbnQgZnJvbSB3aGljaCB0byByb3RhdGVcbiAgICAgICAgIC0geSAobnVtYmVyKSB2ZXJ0aWNhbCBvcmlnaW4gcG9pbnQgZnJvbSB3aGljaCB0byByb3RhdGVcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5yb3RhdGUgPSBmdW5jdGlvbiAoYSwgeCwgeSkge1xuICAgICAgICAgICAgYSA9IFNuYXAucmFkKGEpO1xuICAgICAgICAgICAgeCA9IHggfHwgMDtcbiAgICAgICAgICAgIHkgPSB5IHx8IDA7XG4gICAgICAgICAgICB2YXIgY29zID0gK21hdGguY29zKGEpLnRvRml4ZWQoOSksXG4gICAgICAgICAgICAgICAgc2luID0gK21hdGguc2luKGEpLnRvRml4ZWQoOSk7XG4gICAgICAgICAgICB0aGlzLmFkZChjb3MsIHNpbiwgLXNpbiwgY29zLCB4LCB5KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCgxLCAwLCAwLCAxLCAteCwgLXkpO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC54XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIHggY29vcmRpbmF0ZSBmb3IgZ2l2ZW4gcG9pbnQgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gZGVzY3JpYmVkIGJ5IHRoZSBtYXRyaXguIFNlZSBhbHNvIEBNYXRyaXgueVxuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgID0gKG51bWJlcikgeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnggPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggKiB0aGlzLmEgKyB5ICogdGhpcy5jICsgdGhpcy5lO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC55XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIHkgY29vcmRpbmF0ZSBmb3IgZ2l2ZW4gcG9pbnQgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gZGVzY3JpYmVkIGJ5IHRoZSBtYXRyaXguIFNlZSBhbHNvIEBNYXRyaXgueFxuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgID0gKG51bWJlcikgeVxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnkgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggKiB0aGlzLmIgKyB5ICogdGhpcy5kICsgdGhpcy5mO1xuICAgICAgICB9O1xuICAgICAgICBtYXRyaXhwcm90by5nZXQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzW1N0ci5mcm9tQ2hhckNvZGUoOTcgKyBpKV0udG9GaXhlZCg0KTtcbiAgICAgICAgfTtcbiAgICAgICAgbWF0cml4cHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJtYXRyaXgoXCIgKyBbdGhpcy5nZXQoMCksIHRoaXMuZ2V0KDEpLCB0aGlzLmdldCgyKSwgdGhpcy5nZXQoMyksIHRoaXMuZ2V0KDQpLCB0aGlzLmdldCg1KV0uam9pbigpICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIG1hdHJpeHByb3RvLm9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5lLnRvRml4ZWQoNCksIHRoaXMuZi50b0ZpeGVkKDQpXTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gbm9ybShhKSB7XG4gICAgICAgICAgICByZXR1cm4gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemUoYSkge1xuICAgICAgICAgICAgdmFyIG1hZyA9IG1hdGguc3FydChub3JtKGEpKTtcbiAgICAgICAgICAgIGFbMF0gJiYgKGFbMF0gLz0gbWFnKTtcbiAgICAgICAgICAgIGFbMV0gJiYgKGFbMV0gLz0gbWFnKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5kZXRlcm1pbmFudFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogRmluZHMgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIG1hdHJpeC5cbiAgICAgICAgID0gKG51bWJlcikgZGV0ZXJtaW5hbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmEgKiB0aGlzLmQgLSB0aGlzLmIgKiB0aGlzLmM7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnNwbGl0XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBTcGxpdHMgbWF0cml4IGludG8gcHJpbWl0aXZlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgPSAob2JqZWN0KSBpbiBmb3JtYXQ6XG4gICAgICAgICBvIGR4IChudW1iZXIpIHRyYW5zbGF0aW9uIGJ5IHhcbiAgICAgICAgIG8gZHkgKG51bWJlcikgdHJhbnNsYXRpb24gYnkgeVxuICAgICAgICAgbyBzY2FsZXggKG51bWJlcikgc2NhbGUgYnkgeFxuICAgICAgICAgbyBzY2FsZXkgKG51bWJlcikgc2NhbGUgYnkgeVxuICAgICAgICAgbyBzaGVhciAobnVtYmVyKSBzaGVhclxuICAgICAgICAgbyByb3RhdGUgKG51bWJlcikgcm90YXRpb24gaW4gZGVnXG4gICAgICAgICBvIGlzU2ltcGxlIChib29sZWFuKSBjb3VsZCBpdCBiZSByZXByZXNlbnRlZCB2aWEgc2ltcGxlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRpb25cbiAgICAgICAgICAgIG91dC5keCA9IHRoaXMuZTtcbiAgICAgICAgICAgIG91dC5keSA9IHRoaXMuZjtcblxuICAgICAgICAgICAgLy8gc2NhbGUgYW5kIHNoZWFyXG4gICAgICAgICAgICB2YXIgcm93ID0gW1t0aGlzLmEsIHRoaXMuY10sIFt0aGlzLmIsIHRoaXMuZF1dO1xuICAgICAgICAgICAgb3V0LnNjYWxleCA9IG1hdGguc3FydChub3JtKHJvd1swXSkpO1xuICAgICAgICAgICAgbm9ybWFsaXplKHJvd1swXSk7XG5cbiAgICAgICAgICAgIG91dC5zaGVhciA9IHJvd1swXVswXSAqIHJvd1sxXVswXSArIHJvd1swXVsxXSAqIHJvd1sxXVsxXTtcbiAgICAgICAgICAgIHJvd1sxXSA9IFtyb3dbMV1bMF0gLSByb3dbMF1bMF0gKiBvdXQuc2hlYXIsIHJvd1sxXVsxXSAtIHJvd1swXVsxXSAqIG91dC5zaGVhcl07XG5cbiAgICAgICAgICAgIG91dC5zY2FsZXkgPSBtYXRoLnNxcnQobm9ybShyb3dbMV0pKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZShyb3dbMV0pO1xuICAgICAgICAgICAgb3V0LnNoZWFyIC89IG91dC5zY2FsZXk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRldGVybWluYW50KCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgb3V0LnNjYWxleCA9IC1vdXQuc2NhbGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByb3RhdGlvblxuICAgICAgICAgICAgdmFyIHNpbiA9IC1yb3dbMF1bMV0sXG4gICAgICAgICAgICAgICAgY29zID0gcm93WzFdWzFdO1xuICAgICAgICAgICAgaWYgKGNvcyA8IDApIHtcbiAgICAgICAgICAgICAgICBvdXQucm90YXRlID0gU25hcC5kZWcobWF0aC5hY29zKGNvcykpO1xuICAgICAgICAgICAgICAgIGlmIChzaW4gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5yb3RhdGUgPSAzNjAgLSBvdXQucm90YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0LnJvdGF0ZSA9IFNuYXAuZGVnKG1hdGguYXNpbihzaW4pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0LmlzU2ltcGxlID0gIStvdXQuc2hlYXIudG9GaXhlZCg5KSAmJiAob3V0LnNjYWxleC50b0ZpeGVkKDkpID09IG91dC5zY2FsZXkudG9GaXhlZCg5KSB8fCAhb3V0LnJvdGF0ZSk7XG4gICAgICAgICAgICBvdXQuaXNTdXBlclNpbXBsZSA9ICErb3V0LnNoZWFyLnRvRml4ZWQoOSkgJiYgb3V0LnNjYWxleC50b0ZpeGVkKDkpID09IG91dC5zY2FsZXkudG9GaXhlZCg5KSAmJiAhb3V0LnJvdGF0ZTtcbiAgICAgICAgICAgIG91dC5ub1JvdGF0aW9uID0gIStvdXQuc2hlYXIudG9GaXhlZCg5KSAmJiAhb3V0LnJvdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnRvVHJhbnNmb3JtU3RyaW5nXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIHRyYW5zZm9ybSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGdpdmVuIG1hdHJpeFxuICAgICAgICAgPSAoc3RyaW5nKSB0cmFuc2Zvcm0gc3RyaW5nXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8udG9UcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbiAoc2hvcnRlcikge1xuICAgICAgICAgICAgdmFyIHMgPSBzaG9ydGVyIHx8IHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIGlmICghK3Muc2hlYXIudG9GaXhlZCg5KSkge1xuICAgICAgICAgICAgICAgIHMuc2NhbGV4ID0gK3Muc2NhbGV4LnRvRml4ZWQoNCk7XG4gICAgICAgICAgICAgICAgcy5zY2FsZXkgPSArcy5zY2FsZXkudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICBzLnJvdGF0ZSA9ICtzLnJvdGF0ZS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAgKHMuZHggfHwgcy5keSA/IFwidFwiICsgWytzLmR4LnRvRml4ZWQoNCksICtzLmR5LnRvRml4ZWQoNCldIDogRSkgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgIChzLnNjYWxleCAhPSAxIHx8IHMuc2NhbGV5ICE9IDEgPyBcInNcIiArIFtzLnNjYWxleCwgcy5zY2FsZXksIDAsIDBdIDogRSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHMucm90YXRlID8gXCJyXCIgKyBbK3Mucm90YXRlLnRvRml4ZWQoNCksIDAsIDBdIDogRSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm1cIiArIFt0aGlzLmdldCgwKSwgdGhpcy5nZXQoMSksIHRoaXMuZ2V0KDIpLCB0aGlzLmdldCgzKSwgdGhpcy5nZXQoNCksIHRoaXMuZ2V0KDUpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KShNYXRyaXgucHJvdG90eXBlKTtcbiAgICAvKlxcXG4gICAgICogU25hcC5NYXRyaXhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIE1hdHJpeCBjb25zdHJ1Y3RvciwgZXh0ZW5kIG9uIHlvdXIgb3duIHJpc2suXG4gICAgICogVG8gY3JlYXRlIG1hdHJpY2VzIHVzZSBAU25hcC5tYXRyaXguXG4gICAgXFwqL1xuICAgIFNuYXAuTWF0cml4ID0gTWF0cml4O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLm1hdHJpeFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IGJhc2VkIG9uIHRoZSBnaXZlbiBwYXJhbWV0ZXJzXG4gICAgIC0gYSAobnVtYmVyKVxuICAgICAtIGIgKG51bWJlcilcbiAgICAgLSBjIChudW1iZXIpXG4gICAgIC0gZCAobnVtYmVyKVxuICAgICAtIGUgKG51bWJlcilcbiAgICAgLSBmIChudW1iZXIpXG4gICAgICogb3JcbiAgICAgLSBzdmdNYXRyaXggKFNWR01hdHJpeClcbiAgICAgPSAob2JqZWN0KSBATWF0cml4XG4gICAgXFwqL1xuICAgIFNuYXAubWF0cml4ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoYSwgYiwgYywgZCwgZSwgZik7XG4gICAgfTtcbn0pO1xuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLyBcbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCkge1xuICAgIHZhciBoYXMgPSBcImhhc093blByb3BlcnR5XCIsXG4gICAgICAgIG1ha2UgPSBTbmFwLl8ubWFrZSxcbiAgICAgICAgd3JhcCA9IFNuYXAuXy53cmFwLFxuICAgICAgICBpcyA9IFNuYXAuaXMsXG4gICAgICAgIGdldFNvbWVEZWZzID0gU25hcC5fLmdldFNvbWVEZWZzLFxuICAgICAgICByZVVSTFZhbHVlID0gL151cmxcXCgjPyhbXildKylcXCkkLyxcbiAgICAgICAgJCA9IFNuYXAuXy4kLFxuICAgICAgICBVUkwgPSBTbmFwLnVybCxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICBzZXBhcmF0b3IgPSBTbmFwLl8uc2VwYXJhdG9yLFxuICAgICAgICBFID0gXCJcIjtcbiAgICAvLyBBdHRyaWJ1dGVzIGV2ZW50IGhhbmRsZXJzXG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFza1wiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQgJiYgdmFsdWUubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5ub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZ2V0U29tZURlZnModGhpcykuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PSBcIm1hc2tcIikge1xuICAgICAgICAgICAgICAgIHZhciBtYXNrID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hc2sgPSBtYWtlKFwibWFza1wiLCBnZXRTb21lRGVmcyh0aGlzKSk7XG4gICAgICAgICAgICAgICAgbWFzay5ub2RlLmFwcGVuZENoaWxkKHZhbHVlLm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIW1hc2subm9kZS5pZCAmJiAkKG1hc2subm9kZSwge1xuICAgICAgICAgICAgICAgIGlkOiBtYXNrLmlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQodGhpcy5ub2RlLCB7XG4gICAgICAgICAgICAgICAgbWFzazogVVJMKG1hc2suaWQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIChmdW5jdGlvbiAoY2xpcEl0KSB7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmNsaXBcIiwgY2xpcEl0KTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xpcC1wYXRoXCIsIGNsaXBJdCk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmNsaXBQYXRoXCIsIGNsaXBJdCk7XG4gICAgfShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT0gXCJjbGlwUGF0aFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaXAgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xpcCA9IG1ha2UoXCJjbGlwUGF0aFwiLCBnZXRTb21lRGVmcyh0aGlzKSk7XG4gICAgICAgICAgICAgICAgY2xpcC5ub2RlLmFwcGVuZENoaWxkKHZhbHVlLm5vZGUpO1xuICAgICAgICAgICAgICAgICFjbGlwLm5vZGUuaWQgJiYgJChjbGlwLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNsaXAuaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQodGhpcy5ub2RlLCB7XG4gICAgICAgICAgICAgICAgXCJjbGlwLXBhdGhcIjogVVJMKGNsaXAubm9kZS5pZCB8fCBjbGlwLmlkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KSk7XG4gICAgZnVuY3Rpb24gZmlsbFN0cm9rZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudCAmJiB2YWx1ZS5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiZcbiAgICAgICAgICAgICAgICAodmFsdWUubm9kZS5maXJzdENoaWxkLnRhZ05hbWUgPT0gXCJyYWRpYWxHcmFkaWVudFwiIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUubm9kZS5maXJzdENoaWxkLnRhZ05hbWUgPT0gXCJsaW5lYXJHcmFkaWVudFwiIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUubm9kZS5maXJzdENoaWxkLnRhZ05hbWUgPT0gXCJwYXR0ZXJuXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5ub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZ2V0U29tZURlZnModGhpcykuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiIHx8IHZhbHVlLnR5cGUgPT0gXCJsaW5lYXJHcmFkaWVudFwiXG4gICAgICAgICAgICAgICAgICAgfHwgdmFsdWUudHlwZSA9PSBcInBhdHRlcm5cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLm5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodmFsdWUubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGwgPSBVUkwodmFsdWUubm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbCA9IHZhbHVlLmF0dHIobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxsID0gU25hcC5jb2xvcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGwuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyYWQgPSBTbmFwKGdldFNvbWVEZWZzKHRoaXMpLm93bmVyU1ZHRWxlbWVudCkuZ3JhZGllbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFncmFkLm5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGdyYWQubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZ3JhZC5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbCA9IFVSTChncmFkLm5vZGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbCA9IFN0cihmaWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gZmlsbDtcbiAgICAgICAgICAgICQodGhpcy5ub2RlLCBhdHRycyk7XG4gICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGVbbmFtZV0gPSBFO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5maWxsXCIsIGZpbGxTdHJva2UoXCJmaWxsXCIpKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5zdHJva2VcIiwgZmlsbFN0cm9rZShcInN0cm9rZVwiKSk7XG4gICAgdmFyIGdyYWRyZyA9IC9eKFtscl0pKD86XFwoKFteKV0qKVxcKSk/KC4qKSQvaTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ3JhZC5wYXJzZVwiLCBmdW5jdGlvbiBwYXJzZUdyYWQoc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IFN0cihzdHJpbmcpO1xuICAgICAgICB2YXIgdG9rZW5zID0gc3RyaW5nLm1hdGNoKGdyYWRyZyk7XG4gICAgICAgIGlmICghdG9rZW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZSA9IHRva2Vuc1sxXSxcbiAgICAgICAgICAgIHBhcmFtcyA9IHRva2Vuc1syXSxcbiAgICAgICAgICAgIHN0b3BzID0gdG9rZW5zWzNdO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMuc3BsaXQoL1xccyosXFxzKi8pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiArZWwgPT0gZWwgPyArZWwgOiBlbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09IDEgJiYgcGFyYW1zWzBdID09IDApIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BzID0gc3RvcHMuc3BsaXQoXCItXCIpO1xuICAgICAgICBzdG9wcyA9IHN0b3BzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsID0gZWwuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogZWxbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZWxbMV0pIHtcbiAgICAgICAgICAgICAgICBvdXQub2Zmc2V0ID0gcGFyc2VGbG9hdChlbFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIHN0b3BzOiBzdG9wc1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuZFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgaWYgKGlzKHZhbHVlLCBcImFycmF5XCIpICYmIGlzKHZhbHVlWzBdLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFNuYXAucGF0aC50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IFN0cih2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvW3J1b10vaSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gU25hcC5wYXRoLnRvQWJzb2x1dGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgICQodGhpcy5ub2RlLCB7ZDogdmFsdWV9KTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuI3RleHRcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhbHVlID0gU3RyKHZhbHVlKTtcbiAgICAgICAgdmFyIHR4dCA9IGdsb2IuZG9jLmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0eHQpO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5wYXRoXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICB0aGlzLmF0dHIoe2Q6IHZhbHVlfSk7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmNsYXNzXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICB0aGlzLm5vZGUuY2xhc3NOYW1lLmJhc2VWYWwgPSB2YWx1ZTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIudmlld0JveFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHZiO1xuICAgICAgICBpZiAoaXModmFsdWUsIFwib2JqZWN0XCIpICYmIFwieFwiIGluIHZhbHVlKSB7XG4gICAgICAgICAgICB2YiA9IFt2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS53aWR0aCwgdmFsdWUuaGVpZ2h0XS5qb2luKFwiIFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpcyh2YWx1ZSwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgdmIgPSB2YWx1ZS5qb2luKFwiIFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZiID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgIHZpZXdCb3g6IHZiXG4gICAgICAgIH0pO1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci50cmFuc2Zvcm1cIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHZhbHVlKTtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuclwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInJlY3RcIikge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgICQodGhpcy5ub2RlLCB7XG4gICAgICAgICAgICAgICAgcng6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJ5OiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIudGV4dHBhdGhcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHZhciBpZCwgdHAsIG5vZGU7XG4gICAgICAgICAgICBpZiAoIXZhbHVlICYmIHRoaXMudGV4dFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0cCA9IHRoaXMudGV4dFBhdGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRwLm5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodHAubm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHAucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGV4dFBhdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzKHZhbHVlLCBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZzID0gZ2V0U29tZURlZnModGhpcyksXG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSB3cmFwKGRlZnMucGFyZW50Tm9kZSkucGF0aCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChwYXRoLm5vZGUpO1xuICAgICAgICAgICAgICAgIGlkID0gcGF0aC5pZDtcbiAgICAgICAgICAgICAgICBwYXRoLmF0dHIoe2lkOiBpZH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXAodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSB2YWx1ZS5hdHRyKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gdmFsdWUuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hdHRyKHtpZDogaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIHRwID0gdGhpcy50ZXh0UGF0aDtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICAgICAgICAgIGlmICh0cCkge1xuICAgICAgICAgICAgICAgICAgICB0cC5hdHRyKHtcInhsaW5rOmhyZWZcIjogXCIjXCIgKyBpZH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRwID0gJChcInRleHRQYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cC5hcHBlbmRDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodHApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRQYXRoID0gd3JhcCh0cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnRleHRcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgICAgIHR1bmVyID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSAkKFwidHNwYW5cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpcyhjaHVuaywgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5hcHBlbmRDaGlsZCh0dW5lcihjaHVua1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZENoaWxkKGdsb2IuZG9jLmNyZWF0ZVRleHROb2RlKGNodW5rKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0Lm5vcm1hbGl6ZSAmJiBvdXQubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHVuZWQgPSB0dW5lcih2YWx1ZSk7XG4gICAgICAgICAgICB3aGlsZSAodHVuZWQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodHVuZWQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICB9KSgtMSk7XG4gICAgZnVuY3Rpb24gc2V0Rm9udFNpemUodmFsdWUpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgaWYgKHZhbHVlID09ICt2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgKz0gXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZS5zdHlsZS5mb250U2l6ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5mb250U2l6ZVwiLCBzZXRGb250U2l6ZSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmZvbnQtc2l6ZVwiLCBzZXRGb250U2l6ZSkoLTEpO1xuXG5cbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci50cmFuc2Zvcm1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oKTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIudGV4dHBhdGhcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0UGF0aDtcbiAgICB9KSgtMSk7XG4gICAgLy8gTWFya2Vyc1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGdldHRlcihlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBnbG9iLmRvYy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmtlci1cIiArIGVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU25hcChnbG9iLmRvYy5nZXRFbGVtZW50QnlJZChzdHlsZS5tYXRjaChyZVVSTFZhbHVlKVsxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dGVyKGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBcIm1hcmtlclwiICsgZW5kLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZW5kLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJcIiB8fCAhdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLnN0eWxlW25hbWVdID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT0gXCJtYXJrZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSB2YWx1ZS5ub2RlLmlkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHZhbHVlLm5vZGUsIHtpZDogdmFsdWUuaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGVbbmFtZV0gPSBVUkwoaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5tYXJrZXItZW5kXCIsIGdldHRlcihcImVuZFwiKSkoLTEpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5tYXJrZXJFbmRcIiwgZ2V0dGVyKFwiZW5kXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlci1zdGFydFwiLCBnZXR0ZXIoXCJzdGFydFwiKSkoLTEpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5tYXJrZXJTdGFydFwiLCBnZXR0ZXIoXCJzdGFydFwiKSkoLTEpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5tYXJrZXItbWlkXCIsIGdldHRlcihcIm1pZFwiKSkoLTEpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5tYXJrZXJNaWRcIiwgZ2V0dGVyKFwibWlkXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLm1hcmtlci1lbmRcIiwgc2V0dGVyKFwiZW5kXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLm1hcmtlckVuZFwiLCBzZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyLXN0YXJ0XCIsIHNldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLm1hcmtlclN0YXJ0XCIsIHNldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLm1hcmtlci1taWRcIiwgc2V0dGVyKFwibWlkXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLm1hcmtlck1pZFwiLCBzZXR0ZXIoXCJtaWRcIikpKC0xKTtcbiAgICB9KCkpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwicmVjdFwiICYmICQodGhpcy5ub2RlLCBcInJ4XCIpID09ICQodGhpcy5ub2RlLCBcInJ5XCIpKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcy5ub2RlLCBcInJ4XCIpO1xuICAgICAgICB9XG4gICAgfSkoLTEpO1xuICAgIGZ1bmN0aW9uIHRleHRFeHRyYWN0KG5vZGUpIHtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGkgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGkubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGNoaS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaS50YWdOYW1lID09IFwidHNwYW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChjaGkuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBjaGkuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGNoaS5maXJzdENoaWxkLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2godGV4dEV4dHJhY3QoY2hpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnRleHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwidGV4dFwiIHx8IHRoaXMudHlwZSA9PSBcInRzcGFuXCIpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgb3V0ID0gdGV4dEV4dHJhY3QodGhpcy5ub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQubGVuZ3RoID09IDEgPyBvdXRbMF0gOiBvdXQ7XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuI3RleHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnRleHRDb250ZW50O1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci52aWV3Qm94XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgdmFyIHZiID0gJCh0aGlzLm5vZGUsIFwidmlld0JveFwiKTtcbiAgICAgICAgaWYgKHZiKSB7XG4gICAgICAgICAgICB2YiA9IHZiLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveCgrdmJbMF0sICt2YlsxXSwgK3ZiWzJdLCArdmJbM10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnBvaW50c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gJCh0aGlzLm5vZGUsIFwicG9pbnRzXCIpO1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5wYXRoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSAkKHRoaXMubm9kZSwgXCJkXCIpO1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuY2xhc3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmNsYXNzTmFtZS5iYXNlVmFsO1xuICAgIH0pKC0xKTtcbiAgICBmdW5jdGlvbiBnZXRGb250U2l6ZSgpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5zdHlsZS5mb250U2l6ZTtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuZm9udFNpemVcIiwgZ2V0Rm9udFNpemUpKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5mb250LXNpemVcIiwgZ2V0Rm9udFNpemUpKC0xKTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIHJnTm90U3BhY2UgPSAvXFxTKy9nLFxuICAgICAgICByZ0JhZFNwYWNlID0gL1tcXHRcXHJcXG5cXGZdL2csXG4gICAgICAgIHJnVHJpbSA9IC8oXlxccyt8XFxzKyQpL2csXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgZWxwcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFkZENsYXNzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGdpdmVuIGNsYXNzIG5hbWUgb3IgbGlzdCBvZiBjbGFzcyBuYW1lcyB0byB0aGUgZWxlbWVudC5cbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSBjbGFzcyBuYW1lIG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIG9yaWdpbmFsIGVsZW1lbnQuXG4gICAgXFwqL1xuICAgIGVscHJvdG8uYWRkQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBTdHIodmFsdWUgfHwgXCJcIikubWF0Y2gocmdOb3RTcGFjZSkgfHwgW10sXG4gICAgICAgICAgICBlbGVtID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUuYmFzZVZhbCxcbiAgICAgICAgICAgIGN1ckNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2gocmdOb3RTcGFjZSkgfHwgW10sXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgY2xhenosXG4gICAgICAgICAgICBmaW5hbFZhbHVlO1xuXG4gICAgICAgIGlmIChjbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSkge1xuICAgICAgICAgICAgICAgIHBvcyA9IGN1ckNsYXNzZXMuaW5kZXhPZihjbGF6eik7XG4gICAgICAgICAgICAgICAgaWYgKCF+cG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ckNsYXNzZXMucHVzaChjbGF6eik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gY3VyQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgIT0gZmluYWxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lLmJhc2VWYWwgPSBmaW5hbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucmVtb3ZlQ2xhc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZ2l2ZW4gY2xhc3MgbmFtZSBvciBsaXN0IG9mIGNsYXNzIG5hbWVzIGZyb20gdGhlIGVsZW1lbnQuXG4gICAgIC0gdmFsdWUgKHN0cmluZykgY2xhc3MgbmFtZSBvciBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lc1xuICAgICAqKlxuICAgICA9IChFbGVtZW50KSBvcmlnaW5hbCBlbGVtZW50LlxuICAgIFxcKi9cbiAgICBlbHByb3RvLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gU3RyKHZhbHVlIHx8IFwiXCIpLm1hdGNoKHJnTm90U3BhY2UpIHx8IFtdLFxuICAgICAgICAgICAgZWxlbSA9IHRoaXMubm9kZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lLmJhc2VWYWwsXG4gICAgICAgICAgICBjdXJDbGFzc2VzID0gY2xhc3NOYW1lLm1hdGNoKHJnTm90U3BhY2UpIHx8IFtdLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIGNsYXp6LFxuICAgICAgICAgICAgZmluYWxWYWx1ZTtcbiAgICAgICAgaWYgKGN1ckNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW2orK10pKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gY3VyQ2xhc3Nlcy5pbmRleE9mKGNsYXp6KTtcbiAgICAgICAgICAgICAgICBpZiAofnBvcykge1xuICAgICAgICAgICAgICAgICAgICBjdXJDbGFzc2VzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGN1ckNsYXNzZXMuam9pbihcIiBcIik7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lICE9IGZpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsID0gZmluYWxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lmhhc0NsYXNzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGVsZW1lbnQgaGFzIGEgZ2l2ZW4gY2xhc3MgbmFtZSBpbiB0aGUgbGlzdCBvZiBjbGFzcyBuYW1lcyBhcHBsaWVkIHRvIGl0LlxuICAgICAtIHZhbHVlIChzdHJpbmcpIGNsYXNzIG5hbWVcbiAgICAgKipcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHRoZSBlbGVtZW50IGhhcyBnaXZlbiBjbGFzc1xuICAgIFxcKi9cbiAgICBlbHByb3RvLmhhc0NsYXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUuYmFzZVZhbCxcbiAgICAgICAgICAgIGN1ckNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2gocmdOb3RTcGFjZSkgfHwgW107XG4gICAgICAgIHJldHVybiAhIX5jdXJDbGFzc2VzLmluZGV4T2YodmFsdWUpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9nZ2xlQ2xhc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZCBvciByZW1vdmUgb25lIG9yIG1vcmUgY2xhc3NlcyBmcm9tIHRoZSBlbGVtZW50LCBkZXBlbmRpbmcgb24gZWl0aGVyXG4gICAgICogdGhlIGNsYXNz4oCZcyBwcmVzZW5jZSBvciB0aGUgdmFsdWUgb2YgdGhlIGBmbGFnYCBhcmd1bWVudC5cbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSBjbGFzcyBuYW1lIG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAgIC0gZmxhZyAoYm9vbGVhbikgdmFsdWUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGNsYXNzIHNob3VsZCBiZSBhZGRlZCBvciByZW1vdmVkXG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIG9yaWdpbmFsIGVsZW1lbnQuXG4gICAgXFwqL1xuICAgIGVscHJvdG8udG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUsIGZsYWcpIHtcbiAgICAgICAgaWYgKGZsYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRDbGFzcyh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNsYXNzKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NlcyA9ICh2YWx1ZSB8fCBcIlwiKS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXSxcbiAgICAgICAgICAgIGVsZW0gPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsLFxuICAgICAgICAgICAgY3VyQ2xhc3NlcyA9IGNsYXNzTmFtZS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICBjbGF6eixcbiAgICAgICAgICAgIGZpbmFsVmFsdWU7XG4gICAgICAgIGogPSAwO1xuICAgICAgICB3aGlsZSAoKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSkge1xuICAgICAgICAgICAgcG9zID0gY3VyQ2xhc3Nlcy5pbmRleE9mKGNsYXp6KTtcbiAgICAgICAgICAgIGlmICh+cG9zKSB7XG4gICAgICAgICAgICAgICAgY3VyQ2xhc3Nlcy5zcGxpY2UocG9zLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyQ2xhc3Nlcy5wdXNoKGNsYXp6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsVmFsdWUgPSBjdXJDbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lICE9IGZpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lLmJhc2VWYWwgPSBmaW5hbFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLyBcbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCkge1xuICAgIHZhciBvcGVyYXRvcnMgPSB7XG4gICAgICAgICAgICBcIitcIjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggKyB5O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIi1cIjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggLSB5O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIi9cIjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggLyB5O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIipcIjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggKiB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICByZVVuaXQgPSAvW2Etel0rJC9pLFxuICAgICAgICByZUFkZG9uID0gL15cXHMqKFsrXFwtXFwvKl0pXFxzKj1cXHMqKFtcXGQuZUUrXFwtXSspXFxzKihbXlxcZFxcc10rKT9cXHMqJC87XG4gICAgZnVuY3Rpb24gZ2V0TnVtYmVyKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRVbml0KHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiArdmFsLnRvRml4ZWQoMykgKyB1bml0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0clwiLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBwbHVzID0gU3RyKHZhbCkubWF0Y2gocmVBZGRvbik7XG4gICAgICAgIGlmIChwbHVzKSB7XG4gICAgICAgICAgICB2YXIgZXZudCA9IGV2ZS5udCgpLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBldm50LnN1YnN0cmluZyhldm50Lmxhc3RJbmRleE9mKFwiLlwiKSArIDEpLFxuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmF0dHIobmFtZSksXG4gICAgICAgICAgICAgICAgYXRyID0ge307XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgdmFyIHVuaXQgPSBwbHVzWzNdIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgYVVuaXQgPSBhLm1hdGNoKHJlVW5pdCksXG4gICAgICAgICAgICAgICAgb3AgPSBvcGVyYXRvcnNbcGx1c1sxXV07XG4gICAgICAgICAgICBpZiAoYVVuaXQgJiYgYVVuaXQgPT0gdW5pdCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IG9wKHBhcnNlRmxvYXQoYSksICtwbHVzWzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYSA9IHRoaXMuYXNQWChuYW1lKTtcbiAgICAgICAgICAgICAgICB2YWwgPSBvcCh0aGlzLmFzUFgobmFtZSksIHRoaXMuYXNQWChuYW1lLCBwbHVzWzJdICsgdW5pdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKGEpIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHJbbmFtZV0gPSB2YWw7XG4gICAgICAgICAgICB0aGlzLmF0dHIoYXRyKTtcbiAgICAgICAgfVxuICAgIH0pKC0xMCk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmVxdWFsXCIsIGZ1bmN0aW9uIChuYW1lLCBiKSB7XG4gICAgICAgIHZhciBBLCBCLCBhID0gU3RyKHRoaXMuYXR0cihuYW1lKSB8fCBcIlwiKSxcbiAgICAgICAgICAgIGVsID0gdGhpcyxcbiAgICAgICAgICAgIGJwbHVzID0gU3RyKGIpLm1hdGNoKHJlQWRkb24pO1xuICAgICAgICBpZiAoYnBsdXMpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IGJwbHVzWzNdIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgYVVuaXQgPSBhLm1hdGNoKHJlVW5pdCksXG4gICAgICAgICAgICAgICAgb3AgPSBvcGVyYXRvcnNbYnBsdXNbMV1dO1xuICAgICAgICAgICAgaWYgKGFVbml0ICYmIGFVbml0ID09IHVuaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBwYXJzZUZsb2F0KGEpLFxuICAgICAgICAgICAgICAgICAgICB0bzogb3AocGFyc2VGbG9hdChhKSwgK2JwbHVzWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgZjogZ2V0VW5pdChhVW5pdClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhID0gdGhpcy5hc1BYKG5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IGEsXG4gICAgICAgICAgICAgICAgICAgIHRvOiBvcChhLCB0aGlzLmFzUFgobmFtZSwgYnBsdXNbMl0gKyB1bml0KSksXG4gICAgICAgICAgICAgICAgICAgIGY6IGdldE51bWJlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSgtMTApO1xufSk7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIHByb3RvID0gUGFwZXIucHJvdG90eXBlLFxuICAgICAgICBpcyA9IFNuYXAuaXM7XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnJlY3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqXG4gICAgICogRHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgY29ybmVyXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lclxuICAgICAtIHdpZHRoIChudW1iZXIpIHdpZHRoXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIGhlaWdodFxuICAgICAtIHJ4IChudW1iZXIpICNvcHRpb25hbCBob3Jpem9udGFsIHJhZGl1cyBmb3Igcm91bmRlZCBjb3JuZXJzLCBkZWZhdWx0IGlzIDBcbiAgICAgLSByeSAobnVtYmVyKSAjb3B0aW9uYWwgdmVydGljYWwgcmFkaXVzIGZvciByb3VuZGVkIGNvcm5lcnMsIGRlZmF1bHQgaXMgcnggb3IgMFxuICAgICA9IChvYmplY3QpIHRoZSBgcmVjdGAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgLy8gcmVndWxhciByZWN0YW5nbGVcbiAgICAgfCB2YXIgYyA9IHBhcGVyLnJlY3QoMTAsIDEwLCA1MCwgNTApO1xuICAgICB8IC8vIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVyc1xuICAgICB8IHZhciBjID0gcGFwZXIucmVjdCg0MCwgNDAsIDUwLCA1MCwgMTApO1xuICAgIFxcKi9cbiAgICBwcm90by5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgsIHJ4LCByeSkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgaWYgKHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ5ID0gcng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpICYmIHggPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgICAgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocnggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHIucnggPSByeDtcbiAgICAgICAgICAgICAgICBhdHRyLnJ5ID0gcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJyZWN0XCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmNpcmNsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSBjaXJjbGVcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZVxuICAgICAtIHIgKG51bWJlcikgcmFkaXVzXG4gICAgID0gKG9iamVjdCkgdGhlIGBjaXJjbGVgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDUwLCA1MCwgNDApO1xuICAgIFxcKi9cbiAgICBwcm90by5jaXJjbGUgPSBmdW5jdGlvbiAoY3gsIGN5LCByKSB7XG4gICAgICAgIHZhciBhdHRyO1xuICAgICAgICBpZiAoaXMoY3gsIFwib2JqZWN0XCIpICYmIGN4ID09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICAgIGF0dHIgPSBjeDtcbiAgICAgICAgfSBlbHNlIGlmIChjeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgICAgcjogclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcImNpcmNsZVwiLCBhdHRyKTtcbiAgICB9O1xuXG4gICAgdmFyIHByZWxvYWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBvbmVycm9yKCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3JjLCBmKSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gZ2xvYi5kb2MuY3JlYXRlRWxlbWVudChcImltZ1wiKSxcbiAgICAgICAgICAgICAgICBib2R5ID0gZ2xvYi5kb2MuYm9keTtcbiAgICAgICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5ZW07dG9wOi05OTk5ZW1cIjtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZi5jYWxsKGltZyk7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGltZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLypcXFxuICAgICAqIFBhcGVyLmltYWdlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQbGFjZXMgYW4gaW1hZ2Ugb24gdGhlIHN1cmZhY2VcbiAgICAgKipcbiAgICAgLSBzcmMgKHN0cmluZykgVVJJIG9mIHRoZSBzb3VyY2UgaW1hZ2VcbiAgICAgLSB4IChudW1iZXIpIHggb2Zmc2V0IHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IG9mZnNldCBwb3NpdGlvblxuICAgICAtIHdpZHRoIChudW1iZXIpIHdpZHRoIG9mIHRoZSBpbWFnZVxuICAgICAtIGhlaWdodCAobnVtYmVyKSBoZWlnaHQgb2YgdGhlIGltYWdlXG4gICAgID0gKG9iamVjdCkgdGhlIGBpbWFnZWAgZWxlbWVudFxuICAgICAqIG9yXG4gICAgID0gKG9iamVjdCkgU25hcCBlbGVtZW50IG9iamVjdCB3aXRoIHR5cGUgYGltYWdlYFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5pbWFnZShcImFwcGxlLnBuZ1wiLCAxMCwgMTAsIDgwLCA4MCk7XG4gICAgXFwqL1xuICAgIHByb3RvLmltYWdlID0gZnVuY3Rpb24gKHNyYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsKFwiaW1hZ2VcIik7XG4gICAgICAgIGlmIChpcyhzcmMsIFwib2JqZWN0XCIpICYmIFwic3JjXCIgaW4gc3JjKSB7XG4gICAgICAgICAgICBlbC5hdHRyKHNyYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3JjICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzZXQgPSB7XG4gICAgICAgICAgICAgICAgXCJ4bGluazpocmVmXCI6IHNyYyxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0LnggPSB4O1xuICAgICAgICAgICAgICAgIHNldC55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0LndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgc2V0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlbG9hZChzcmMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgU25hcC5fLiQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU25hcC5fLiQoZWwubm9kZSwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZWxsaXBzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYW4gZWxsaXBzZVxuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBjZW50cmVcbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0gcnggKG51bWJlcikgaG9yaXpvbnRhbCByYWRpdXNcbiAgICAgLSByeSAobnVtYmVyKSB2ZXJ0aWNhbCByYWRpdXNcbiAgICAgPSAob2JqZWN0KSB0aGUgYGVsbGlwc2VgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuZWxsaXBzZSg1MCwgNTAsIDQwLCAyMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLmVsbGlwc2UgPSBmdW5jdGlvbiAoY3gsIGN5LCByeCwgcnkpIHtcbiAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgIGlmIChpcyhjeCwgXCJvYmplY3RcIikgJiYgY3ggPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgICAgYXR0ciA9IGN4O1xuICAgICAgICB9IGVsc2UgaWYgKGN4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPXtcbiAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgIHJ4OiByeCxcbiAgICAgICAgICAgICAgICByeTogcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJlbGxpcHNlXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLy8gU0lFUlJBIFBhcGVyLnBhdGgoKTogVW5jbGVhciBmcm9tIHRoZSBsaW5rIHdoYXQgYSBDYXRtdWxsLVJvbSBjdXJ2ZXRvIGlzLCBhbmQgd2h5IGl0IHdvdWxkIG1ha2UgbGlmZSBhbnkgZWFzaWVyLlxuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wYXRoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgYDxwYXRoPmAgZWxlbWVudCB1c2luZyB0aGUgZ2l2ZW4gc3RyaW5nIGFzIHRoZSBwYXRoJ3MgZGVmaW5pdGlvblxuICAgICAtIHBhdGhTdHJpbmcgKHN0cmluZykgI29wdGlvbmFsIHBhdGggc3RyaW5nIGluIFNWRyBmb3JtYXRcbiAgICAgKiBQYXRoIHN0cmluZyBjb25zaXN0cyBvZiBvbmUtbGV0dGVyIGNvbW1hbmRzLCBmb2xsb3dlZCBieSBjb21tYSBzZXByYXJhdGVkIGFyZ3VtZW50cyBpbiBudW1lcmljYWwgZm9ybS4gRXhhbXBsZTpcbiAgICAgfCBcIk0xMCwyMEwzMCw0MFwiXG4gICAgICogVGhpcyBleGFtcGxlIGZlYXR1cmVzIHR3byBjb21tYW5kczogYE1gLCB3aXRoIGFyZ3VtZW50cyBgKDEwLCAyMClgIGFuZCBgTGAgd2l0aCBhcmd1bWVudHMgYCgzMCwgNDApYC4gVXBwZXJjYXNlIGxldHRlciBjb21tYW5kcyBleHByZXNzIGNvb3JkaW5hdGVzIGluIGFic29sdXRlIHRlcm1zLCB3aGlsZSBsb3dlcmNhc2UgY29tbWFuZHMgZXhwcmVzcyB0aGVtIGluIHJlbGF0aXZlIHRlcm1zIGZyb20gdGhlIG1vc3QgcmVjZW50bHkgZGVjbGFyZWQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgIyA8cD5IZXJlIGlzIHNob3J0IGxpc3Qgb2YgY29tbWFuZHMgYXZhaWxhYmxlLCBmb3IgbW9yZSBkZXRhaWxzIHNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcIiB0aXRsZT1cIkRldGFpbHMgb2YgYSBwYXRoJ3MgZGF0YSBhdHRyaWJ1dGUncyBmb3JtYXQgYXJlIGRlc2NyaWJlZCBpbiB0aGUgU1ZHIHNwZWNpZmljYXRpb24uXCI+U1ZHIHBhdGggc3RyaW5nIGZvcm1hdDwvYT4gb3IgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NWRy9UdXRvcmlhbC9QYXRoc1wiPmFydGljbGUgYWJvdXQgcGF0aCBzdHJpbmdzIGF0IE1ETjwvYT4uPC9wPlxuICAgICAjIDx0YWJsZT48dGhlYWQ+PHRyPjx0aD5Db21tYW5kPC90aD48dGg+TmFtZTwvdGg+PHRoPlBhcmFtZXRlcnM8L3RoPjwvdHI+PC90aGVhZD48dGJvZHk+XG4gICAgICMgPHRyPjx0ZD5NPC90ZD48dGQ+bW92ZXRvPC90ZD48dGQ+KHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+WjwvdGQ+PHRkPmNsb3NlcGF0aDwvdGQ+PHRkPihub25lKTwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkw8L3RkPjx0ZD5saW5ldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5IPC90ZD48dGQ+aG9yaXpvbnRhbCBsaW5ldG88L3RkPjx0ZD54KzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlY8L3RkPjx0ZD52ZXJ0aWNhbCBsaW5ldG88L3RkPjx0ZD55KzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkM8L3RkPjx0ZD5jdXJ2ZXRvPC90ZD48dGQ+KHgxIHkxIHgyIHkyIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UzwvdGQ+PHRkPnNtb290aCBjdXJ2ZXRvPC90ZD48dGQ+KHgyIHkyIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UTwvdGQ+PHRkPnF1YWRyYXRpYyBCw6l6aWVyIGN1cnZldG88L3RkPjx0ZD4oeDEgeTEgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5UPC90ZD48dGQ+c21vb3RoIHF1YWRyYXRpYyBCw6l6aWVyIGN1cnZldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5BPC90ZD48dGQ+ZWxsaXB0aWNhbCBhcmM8L3RkPjx0ZD4ocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5SPC90ZD48dGQ+PGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F0bXVsbOKAk1JvbV9zcGxpbmUjQ2F0bXVsbC5FMi44MC45M1JvbV9zcGxpbmVcIj5DYXRtdWxsLVJvbSBjdXJ2ZXRvPC9hPio8L3RkPjx0ZD54MSB5MSAoeCB5KSs8L3RkPjwvdHI+PC90Ym9keT48L3RhYmxlPlxuICAgICAqICogX0NhdG11bGwtUm9tIGN1cnZldG9fIGlzIGEgbm90IHN0YW5kYXJkIFNWRyBjb21tYW5kIGFuZCBhZGRlZCB0byBtYWtlIGxpZmUgZWFzaWVyLlxuICAgICAqIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHdoZW4gYSBwYXRoIGNvbnNpc3RzIG9mIG9ubHkgdGhyZWUgY29tbWFuZHM6IGBNMTAsMTBS4oCmemAuIEluIHRoaXMgY2FzZSB0aGUgcGF0aCBjb25uZWN0cyBiYWNrIHRvIGl0cyBzdGFydGluZyBwb2ludC5cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIucGF0aChcIk0xMCAxMEw5MCA5MFwiKTtcbiAgICAgfCAvLyBkcmF3IGEgZGlhZ29uYWwgbGluZTpcbiAgICAgfCAvLyBtb3ZlIHRvIDEwLDEwLCBsaW5lIHRvIDkwLDkwXG4gICAgXFwqL1xuICAgIHByb3RvLnBhdGggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgaWYgKGlzKGQsIFwib2JqZWN0XCIpICYmICFpcyhkLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBhdHRyID0gZDtcbiAgICAgICAgfSBlbHNlIGlmIChkKSB7XG4gICAgICAgICAgICBhdHRyID0ge2Q6IGR9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicGF0aFwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5nXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgZ3JvdXAgZWxlbWVudFxuICAgICAqKlxuICAgICAtIHZhcmFyZ3MgKOKApikgI29wdGlvbmFsIGVsZW1lbnRzIHRvIG5lc3Qgd2l0aGluIHRoZSBncm91cFxuICAgICA9IChvYmplY3QpIHRoZSBgZ2AgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMxID0gcGFwZXIuY2lyY2xlKCksXG4gICAgIHwgICAgIGMyID0gcGFwZXIucmVjdCgpLFxuICAgICB8ICAgICBnID0gcGFwZXIuZyhjMiwgYzEpOyAvLyBub3RlIHRoYXQgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGlzIGRpZmZlcmVudFxuICAgICAqIG9yXG4gICAgIHwgdmFyIGMxID0gcGFwZXIuY2lyY2xlKCksXG4gICAgIHwgICAgIGMyID0gcGFwZXIucmVjdCgpLFxuICAgICB8ICAgICBnID0gcGFwZXIuZygpO1xuICAgICB8IGcuYWRkKGMyLCBjMSk7XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5ncm91cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBQYXBlci5nXG4gICAgXFwqL1xuICAgIHByb3RvLmdyb3VwID0gcHJvdG8uZyA9IGZ1bmN0aW9uIChmaXJzdCkge1xuICAgICAgICB2YXIgYXR0cixcbiAgICAgICAgICAgIGVsID0gdGhpcy5lbChcImdcIik7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgZmlyc3QgJiYgIWZpcnN0LnR5cGUpIHtcbiAgICAgICAgICAgIGVsLmF0dHIoZmlyc3QpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsLmFkZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuc3ZnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgbmVzdGVkIFNWRyBlbGVtZW50LlxuICAgICAtIHggKG51bWJlcikgQG9wdGlvbmFsIFggb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB5IChudW1iZXIpIEBvcHRpb25hbCBZIG9mIHRoZSBlbGVtZW50XG4gICAgIC0gd2lkdGggKG51bWJlcikgQG9wdGlvbmFsIHdpZHRoIG9mIHRoZSBlbGVtZW50XG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIEBvcHRpb25hbCBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB2YnggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggWFxuICAgICAtIHZieSAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBZXG4gICAgIC0gdmJ3IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IHdpZHRoXG4gICAgIC0gdmJoIChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IGhlaWdodFxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHRoZSBgc3ZnYCBlbGVtZW50XG4gICAgICoqXG4gICAgXFwqL1xuICAgIHByb3RvLnN2ZyA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB2YngsIHZieSwgdmJ3LCB2YmgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSAmJiB5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHJzID0geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRycy54ID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRycy55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YnggIT0gbnVsbCAmJiB2YnkgIT0gbnVsbCAmJiB2YncgIT0gbnVsbCAmJiB2YmggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLnZpZXdCb3ggPSBbdmJ4LCB2YnksIHZidywgdmJoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcInN2Z1wiLCBhdHRycyk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIubWFza1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRXF1aXZhbGVudCBpbiBiZWhhdmlvdXIgdG8gQFBhcGVyLmcsIGV4Y2VwdCBpdOKAmXMgYSBtYXNrLlxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHRoZSBgbWFza2AgZWxlbWVudFxuICAgICAqKlxuICAgIFxcKi9cbiAgICBwcm90by5tYXNrID0gZnVuY3Rpb24gKGZpcnN0KSB7XG4gICAgICAgIHZhciBhdHRyLFxuICAgICAgICAgICAgZWwgPSB0aGlzLmVsKFwibWFza1wiKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBmaXJzdCAmJiAhZmlyc3QudHlwZSkge1xuICAgICAgICAgICAgZWwuYXR0cihmaXJzdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWwuYWRkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wdHJuXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFcXVpdmFsZW50IGluIGJlaGF2aW91ciB0byBAUGFwZXIuZywgZXhjZXB0IGl04oCZcyBhIHBhdHRlcm4uXG4gICAgIC0geCAobnVtYmVyKSBAb3B0aW9uYWwgWCBvZiB0aGUgZWxlbWVudFxuICAgICAtIHkgKG51bWJlcikgQG9wdGlvbmFsIFkgb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB3aWR0aCAobnVtYmVyKSBAb3B0aW9uYWwgd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgICAgLSBoZWlnaHQgKG51bWJlcikgQG9wdGlvbmFsIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgICAtIHZieCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBYXG4gICAgIC0gdmJ5IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFlcbiAgICAgLSB2YncgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggd2lkdGhcbiAgICAgLSB2YmggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggaGVpZ2h0XG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgdGhlIGBwYXR0ZXJuYCBlbGVtZW50XG4gICAgICoqXG4gICAgXFwqL1xuICAgIHByb3RvLnB0cm4gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgdngsIHZ5LCB2dywgdmgpIHtcbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyID0ge3BhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwifTtcbiAgICAgICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICAgICAgYXR0ci54ID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgICAgICAgYXR0ci55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0ci53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0ci5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodnggIT0gbnVsbCAmJiB2eSAhPSBudWxsICYmIHZ3ICE9IG51bGwgJiYgdmggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHIudmlld0JveCA9IFt2eCwgdnksIHZ3LCB2aF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHIudmlld0JveCA9IFt4IHx8IDAsIHkgfHwgMCwgd2lkdGggfHwgMCwgaGVpZ2h0IHx8IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicGF0dGVyblwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci51c2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSA8dXNlPiBlbGVtZW50LlxuICAgICAtIGlkIChzdHJpbmcpIEBvcHRpb25hbCBpZCBvZiBlbGVtZW50IHRvIGxpbmtcbiAgICAgKiBvclxuICAgICAtIGlkIChFbGVtZW50KSBAb3B0aW9uYWwgZWxlbWVudCB0byBsaW5rXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgdGhlIGB1c2VgIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgcHJvdG8udXNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaWQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpZC5hdHRyKFwiaWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQuYXR0cih7aWQ6IFNuYXAuXy5pZChpZCl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQgPSBpZC5hdHRyKFwiaWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoU3RyaW5nKGlkKS5jaGFyQXQoKSA9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJ1c2VcIiwge1wieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUudXNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5zeW1ib2xcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSA8c3ltYm9sPiBlbGVtZW50LlxuICAgICAtIHZieCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBYXG4gICAgIC0gdmJ5IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFlcbiAgICAgLSB2YncgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggd2lkdGhcbiAgICAgLSB2YmggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggaGVpZ2h0XG4gICAgID0gKG9iamVjdCkgdGhlIGBzeW1ib2xgIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgcHJvdG8uc3ltYm9sID0gZnVuY3Rpb24gKHZ4LCB2eSwgdncsIHZoKSB7XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmICh2eCAhPSBudWxsICYmIHZ5ICE9IG51bGwgJiYgdncgIT0gbnVsbCAmJiB2aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyLnZpZXdCb3ggPSBbdngsIHZ5LCB2dywgdmhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJzeW1ib2xcIiwgYXR0cik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIudGV4dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSB0ZXh0IHN0cmluZ1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb25cbiAgICAgLSB0ZXh0IChzdHJpbmd8YXJyYXkpIFRoZSB0ZXh0IHN0cmluZyB0byBkcmF3IG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gbmVzdCB3aXRoaW4gc2VwYXJhdGUgYDx0c3Bhbj5gIGVsZW1lbnRzXG4gICAgID0gKG9iamVjdCkgdGhlIGB0ZXh0YCBlbGVtZW50XG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgdDEgPSBwYXBlci50ZXh0KDUwLCA1MCwgXCJTbmFwXCIpO1xuICAgICB8IHZhciB0MiA9IHBhcGVyLnRleHQoNTAsIDUwLCBbXCJTXCIsXCJuXCIsXCJhXCIsXCJwXCJdKTtcbiAgICAgfCAvLyBUZXh0IHBhdGggdXNhZ2VcbiAgICAgfCB0MS5hdHRyKHt0ZXh0cGF0aDogXCJNMTAsMTBMMTAwLDEwMFwifSk7XG4gICAgIHwgLy8gb3JcbiAgICAgfCB2YXIgcHRoID0gcGFwZXIucGF0aChcIk0xMCwxMEwxMDAsMTAwXCIpO1xuICAgICB8IHQxLmF0dHIoe3RleHRwYXRoOiBwdGh9KTtcbiAgICBcXCovXG4gICAgcHJvdG8udGV4dCA9IGZ1bmN0aW9uICh4LCB5LCB0ZXh0KSB7XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0IHx8IFwiXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJ0ZXh0XCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmxpbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERyYXdzIGEgbGluZVxuICAgICAqKlxuICAgICAtIHgxIChudW1iZXIpIHggY29vcmRpbmF0ZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnRcbiAgICAgLSB5MSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0XG4gICAgIC0geDIgKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uIG9mIHRoZSBlbmRcbiAgICAgLSB5MiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb24gb2YgdGhlIGVuZFxuICAgICA9IChvYmplY3QpIHRoZSBgbGluZWAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIHQxID0gcGFwZXIubGluZSg1MCwgNTAsIDEwMCwgMTAwKTtcbiAgICBcXCovXG4gICAgcHJvdG8ubGluZSA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICBpZiAoaXMoeDEsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBhdHRyID0geDE7XG4gICAgICAgIH0gZWxzZSBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0ciA9IHtcbiAgICAgICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgICAgICB5MjogeTJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJsaW5lXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnBvbHlsaW5lXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIHBvbHlsaW5lXG4gICAgICoqXG4gICAgIC0gcG9pbnRzIChhcnJheSkgYXJyYXkgb2YgcG9pbnRzXG4gICAgICogb3JcbiAgICAgLSB2YXJhcmdzICjigKYpIHBvaW50c1xuICAgICA9IChvYmplY3QpIHRoZSBgcG9seWxpbmVgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBwMSA9IHBhcGVyLnBvbHlsaW5lKFsxMCwgMTAsIDEwMCwgMTAwXSk7XG4gICAgIHwgdmFyIHAyID0gcGFwZXIucG9seWxpbmUoMTAsIDEwLCAxMDAsIDEwMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLnBvbHlsaW5lID0gZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgaWYgKGlzKHBvaW50cywgXCJvYmplY3RcIikgJiYgIWlzKHBvaW50cywgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgYXR0ciA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0ciA9IHtwb2ludHM6IHBvaW50c307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJwb2x5bGluZVwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wb2x5Z29uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIHBvbHlnb24uIFNlZSBAUGFwZXIucG9seWxpbmVcbiAgICBcXCovXG4gICAgcHJvdG8ucG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmIChpcyhwb2ludHMsIFwib2JqZWN0XCIpICYmICFpcyhwb2ludHMsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIGF0dHIgPSBwb2ludHM7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPSB7cG9pbnRzOiBwb2ludHN9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicG9seWdvblwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8vIGdyYWRpZW50c1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkID0gU25hcC5fLiQ7XG4gICAgICAgIC8vIGdyYWRpZW50cycgaGVscGVyc1xuICAgICAgICBmdW5jdGlvbiBHc3RvcHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RBbGwoXCJzdG9wXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEdhZGRTdG9wKGNvbG9yLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBzdG9wID0gJChcInN0b3BcIiksXG4gICAgICAgICAgICAgICAgYXR0ciA9IHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiArb2Zmc2V0ICsgXCIlXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29sb3IgPSBTbmFwLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgIGF0dHJbXCJzdG9wLWNvbG9yXCJdID0gY29sb3IuaGV4O1xuICAgICAgICAgICAgaWYgKGNvbG9yLm9wYWNpdHkgPCAxKSB7XG4gICAgICAgICAgICAgICAgYXR0cltcInN0b3Atb3BhY2l0eVwiXSA9IGNvbG9yLm9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKHN0b3AsIGF0dHIpO1xuICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHN0b3ApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gR2dldEJCb3goKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIikge1xuICAgICAgICAgICAgICAgIHZhciB4MSA9ICQodGhpcy5ub2RlLCBcIngxXCIpIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHgyID0gJCh0aGlzLm5vZGUsIFwieDJcIikgfHwgMSxcbiAgICAgICAgICAgICAgICAgICAgeTEgPSAkKHRoaXMubm9kZSwgXCJ5MVwiKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICB5MiA9ICQodGhpcy5ub2RlLCBcInkyXCIpIHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3goeDEsIHkxLCBtYXRoLmFicyh4MiAtIHgxKSwgbWF0aC5hYnMoeTIgLSB5MSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSB0aGlzLm5vZGUuY3ggfHwgLjUsXG4gICAgICAgICAgICAgICAgICAgIGN5ID0gdGhpcy5ub2RlLmN5IHx8IC41LFxuICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5ub2RlLnIgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveChjeCAtIHIsIGN5IC0gciwgciAqIDIsIHIgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBncmFkaWVudChkZWZzLCBzdHIpIHtcbiAgICAgICAgICAgIHZhciBncmFkID0gZXZlKFwic25hcC51dGlsLmdyYWQucGFyc2VcIiwgbnVsbCwgc3RyKS5maXJzdERlZmluZWQoKSxcbiAgICAgICAgICAgICAgICBlbDtcbiAgICAgICAgICAgIGlmICghZ3JhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhZC5wYXJhbXMudW5zaGlmdChkZWZzKTtcbiAgICAgICAgICAgIGlmIChncmFkLnR5cGUudG9Mb3dlckNhc2UoKSA9PSBcImxcIikge1xuICAgICAgICAgICAgICAgIGVsID0gZ3JhZGllbnRMaW5lYXIuYXBwbHkoMCwgZ3JhZC5wYXJhbXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IGdyYWRpZW50UmFkaWFsLmFwcGx5KDAsIGdyYWQucGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFkLnR5cGUgIT0gZ3JhZC50eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAkKGVsLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RvcHMgPSBncmFkLnN0b3BzLFxuICAgICAgICAgICAgICAgIGxlbiA9IHN0b3BzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzdGFydCA9IDAsXG4gICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICBmdW5jdGlvbiBzZWVkKGksIGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGVwID0gKGVuZCAtIHN0YXJ0KSAvIChpIC0gaik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGo7IGsgPCBpOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHNba10ub2Zmc2V0ID0gKygrc3RhcnQgKyBzdGVwICogKGsgLSBqKSkudG9GaXhlZCgyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGlmIChcIm9mZnNldFwiIGluIHN0b3BzW2ldKSB7XG4gICAgICAgICAgICAgICAgc2VlZChpLCBzdG9wc1tpXS5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcHNbbGVuXS5vZmZzZXQgPSBzdG9wc1tsZW5dLm9mZnNldCB8fCAxMDA7XG4gICAgICAgICAgICBzZWVkKGxlbiwgc3RvcHNbbGVuXS5vZmZzZXQpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgICAgICAgZWwuYWRkU3RvcChzdG9wLmNvbG9yLCBzdG9wLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ3JhZGllbnRMaW5lYXIoZGVmcywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IFNuYXAuXy5tYWtlKFwibGluZWFyR3JhZGllbnRcIiwgZGVmcyk7XG4gICAgICAgICAgICBlbC5zdG9wcyA9IEdzdG9wcztcbiAgICAgICAgICAgIGVsLmFkZFN0b3AgPSBHYWRkU3RvcDtcbiAgICAgICAgICAgIGVsLmdldEJCb3ggPSBHZ2V0QkJveDtcbiAgICAgICAgICAgIGlmICh4MSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgJChlbC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICAgICAgICAgIHkyOiB5MlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdyYWRpZW50UmFkaWFsKGRlZnMsIGN4LCBjeSwgciwgZngsIGZ5KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBTbmFwLl8ubWFrZShcInJhZGlhbEdyYWRpZW50XCIsIGRlZnMpO1xuICAgICAgICAgICAgZWwuc3RvcHMgPSBHc3RvcHM7XG4gICAgICAgICAgICBlbC5hZGRTdG9wID0gR2FkZFN0b3A7XG4gICAgICAgICAgICBlbC5nZXRCQm94ID0gR2dldEJCb3g7XG4gICAgICAgICAgICBpZiAoY3ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgcjogclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ4ICE9IG51bGwgJiYgZnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBmeDogZngsXG4gICAgICAgICAgICAgICAgICAgIGZ5OiBmeVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogUGFwZXIuZ3JhZGllbnRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBncmFkaWVudCBlbGVtZW50XG4gICAgICAgICAqKlxuICAgICAgICAgLSBncmFkaWVudCAoc3RyaW5nKSBncmFkaWVudCBkZXNjcmlwdG9yXG4gICAgICAgICA+IEdyYWRpZW50IERlc2NyaXB0b3JcbiAgICAgICAgICogVGhlIGdyYWRpZW50IGRlc2NyaXB0b3IgaXMgYW4gZXhwcmVzc2lvbiBmb3JtYXR0ZWQgYXNcbiAgICAgICAgICogZm9sbG93czogYDx0eXBlPig8Y29vcmRzPik8Y29sb3JzPmAuICBUaGUgYDx0eXBlPmAgY2FuIGJlXG4gICAgICAgICAqIGVpdGhlciBsaW5lYXIgb3IgcmFkaWFsLiAgVGhlIHVwcGVyY2FzZSBgTGAgb3IgYFJgIGxldHRlcnNcbiAgICAgICAgICogaW5kaWNhdGUgYWJzb2x1dGUgY29vcmRpbmF0ZXMgb2Zmc2V0IGZyb20gdGhlIFNWRyBzdXJmYWNlLlxuICAgICAgICAgKiBMb3dlcmNhc2UgYGxgIG9yIGByYCBsZXR0ZXJzIGluZGljYXRlIGNvb3JkaW5hdGVzXG4gICAgICAgICAqIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGdyYWRpZW50IGlzXG4gICAgICAgICAqIGFwcGxpZWQuICBDb29yZGluYXRlcyBzcGVjaWZ5IGEgbGluZWFyIGdyYWRpZW50IHZlY3RvciBhc1xuICAgICAgICAgKiBgeDFgLCBgeTFgLCBgeDJgLCBgeTJgLCBvciBhIHJhZGlhbCBncmFkaWVudCBhcyBgY3hgLCBgY3lgLFxuICAgICAgICAgKiBgcmAgYW5kIG9wdGlvbmFsIGBmeGAsIGBmeWAgc3BlY2lmeWluZyBhIGZvY2FsIHBvaW50IGF3YXlcbiAgICAgICAgICogZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuIFNwZWNpZnkgYDxjb2xvcnM+YCBhcyBhIGxpc3RcbiAgICAgICAgICogb2YgZGFzaC1zZXBhcmF0ZWQgQ1NTIGNvbG9yIHZhbHVlcy4gIEVhY2ggY29sb3IgbWF5IGJlXG4gICAgICAgICAqIGZvbGxvd2VkIGJ5IGEgY3VzdG9tIG9mZnNldCB2YWx1ZSwgc2VwYXJhdGVkIHdpdGggYSBjb2xvblxuICAgICAgICAgKiBjaGFyYWN0ZXIuXG4gICAgICAgICA+IEV4YW1wbGVzXG4gICAgICAgICAqIExpbmVhciBncmFkaWVudCwgcmVsYXRpdmUgZnJvbSB0b3AtbGVmdCBjb3JuZXIgdG8gYm90dG9tLXJpZ2h0XG4gICAgICAgICAqIGNvcm5lciwgZnJvbSBibGFjayB0aHJvdWdoIHJlZCB0byB3aGl0ZTpcbiAgICAgICAgIHwgdmFyIGcgPSBwYXBlci5ncmFkaWVudChcImwoMCwgMCwgMSwgMSkjMDAwLSNmMDAtI2ZmZlwiKTtcbiAgICAgICAgICogTGluZWFyIGdyYWRpZW50LCBhYnNvbHV0ZSBmcm9tICgwLCAwKSB0byAoMTAwLCAxMDApLCBmcm9tIGJsYWNrXG4gICAgICAgICAqIHRocm91Z2ggcmVkIGF0IDI1JSB0byB3aGl0ZTpcbiAgICAgICAgIHwgdmFyIGcgPSBwYXBlci5ncmFkaWVudChcIkwoMCwgMCwgMTAwLCAxMDApIzAwMC0jZjAwOjI1LSNmZmZcIik7XG4gICAgICAgICAqIFJhZGlhbCBncmFkaWVudCwgcmVsYXRpdmUgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50IHdpdGggcmFkaXVzXG4gICAgICAgICAqIGhhbGYgdGhlIHdpZHRoLCBmcm9tIGJsYWNrIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwicigwLjUsIDAuNSwgMC41KSMwMDAtI2ZmZlwiKTtcbiAgICAgICAgICogVG8gYXBwbHkgdGhlIGdyYWRpZW50OlxuICAgICAgICAgfCBwYXBlci5jaXJjbGUoNTAsIDUwLCA0MCkuYXR0cih7XG4gICAgICAgICB8ICAgICBmaWxsOiBnXG4gICAgICAgICB8IH0pO1xuICAgICAgICAgPSAob2JqZWN0KSB0aGUgYGdyYWRpZW50YCBlbGVtZW50XG4gICAgICAgIFxcKi9cbiAgICAgICAgcHJvdG8uZ3JhZGllbnQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnQodGhpcy5kZWZzLCBzdHIpO1xuICAgICAgICB9O1xuICAgICAgICBwcm90by5ncmFkaWVudExpbmVhciA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAgICAgcmV0dXJuIGdyYWRpZW50TGluZWFyKHRoaXMuZGVmcywgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICB9O1xuICAgICAgICBwcm90by5ncmFkaWVudFJhZGlhbCA9IGZ1bmN0aW9uIChjeCwgY3ksIHIsIGZ4LCBmeSkge1xuICAgICAgICAgICAgcmV0dXJuIGdyYWRpZW50UmFkaWFsKHRoaXMuZGVmcywgY3gsIGN5LCByLCBmeCwgZnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIFBhcGVyLnRvU3RyaW5nXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIFNWRyBjb2RlIGZvciB0aGUgQFBhcGVyXG4gICAgICAgICA9IChzdHJpbmcpIFNWRyBjb2RlIGZvciB0aGUgQFBhcGVyXG4gICAgICAgIFxcKi9cbiAgICAgICAgcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5ub2RlLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZiA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgICAgICAgICAgZCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgICAgICAgIHN2ZyA9IHRoaXMubm9kZS5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgICAgICAgcmVzO1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChkKTtcbiAgICAgICAgICAgIGQuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICAgICAgICAgIFNuYXAuXy4kKHN2Zywge3htbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9KTtcbiAgICAgICAgICAgIHJlcyA9IGQuaW5uZXJIVE1MO1xuICAgICAgICAgICAgZi5yZW1vdmVDaGlsZChmLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBQYXBlci50b0RhdGFVUkxcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgU1ZHIGNvZGUgZm9yIHRoZSBAUGFwZXIgYXMgRGF0YSBVUkkgc3RyaW5nLlxuICAgICAgICAgPSAoc3RyaW5nKSBEYXRhIFVSSSBzdHJpbmdcbiAgICAgICAgXFwqL1xuICAgICAgICBwcm90by50b0RhdGFVUkwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod2luZG93ICYmIHdpbmRvdy5idG9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogUGFwZXIuY2xlYXJcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGNoaWxkIG5vZGVzIG9mIHRoZSBwYXBlciwgZXhjZXB0IDxkZWZzPi5cbiAgICAgICAgXFwqL1xuICAgICAgICBwcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudGFnTmFtZSAhPSBcImRlZnNcIikge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8uY2xlYXIuY2FsbCh7bm9kZTogbm9kZX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KCkpO1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy8gXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vIFxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYikge1xuICAgIHZhciBlbHByb3RvID0gRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgIGlzID0gU25hcC5pcyxcbiAgICAgICAgY2xvbmUgPSBTbmFwLl8uY2xvbmUsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgcDJzID0gLyw/KFthLXpdKSw/L2dpLFxuICAgICAgICB0b0Zsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgICAgbWF0aCA9IE1hdGgsXG4gICAgICAgIFBJID0gbWF0aC5QSSxcbiAgICAgICAgbW1pbiA9IG1hdGgubWluLFxuICAgICAgICBtbWF4ID0gbWF0aC5tYXgsXG4gICAgICAgIHBvdyA9IG1hdGgucG93LFxuICAgICAgICBhYnMgPSBtYXRoLmFicztcbiAgICBmdW5jdGlvbiBwYXRocyhwcykge1xuICAgICAgICB2YXIgcCA9IHBhdGhzLnBzID0gcGF0aHMucHMgfHwge307XG4gICAgICAgIGlmIChwW3BzXSkge1xuICAgICAgICAgICAgcFtwc10uc2xlZXAgPSAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwW3BzXSA9IHtcbiAgICAgICAgICAgICAgICBzbGVlcDogMTAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHApIGlmIChwW2hhc10oa2V5KSAmJiBrZXkgIT0gcHMpIHtcbiAgICAgICAgICAgICAgICBwW2tleV0uc2xlZXAtLTtcbiAgICAgICAgICAgICAgICAhcFtrZXldLnNsZWVwICYmIGRlbGV0ZSBwW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcFtwc107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHggPSB5ID0gd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHkgPSB4Lnk7XG4gICAgICAgICAgICB3aWR0aCA9IHgud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB4LmhlaWdodDtcbiAgICAgICAgICAgIHggPSB4Lng7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgdzogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGg6IGhlaWdodCxcbiAgICAgICAgICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgICAgICAgICB5MjogeSArIGhlaWdodCxcbiAgICAgICAgICAgIGN4OiB4ICsgd2lkdGggLyAyLFxuICAgICAgICAgICAgY3k6IHkgKyBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgcjE6IG1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMixcbiAgICAgICAgICAgIHIyOiBtYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAvIDIsXG4gICAgICAgICAgICByMDogbWF0aC5zcXJ0KHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpIC8gMixcbiAgICAgICAgICAgIHBhdGg6IHJlY3RQYXRoKHgsIHksIHdpZHRoLCBoZWlnaHQpLFxuICAgICAgICAgICAgdmI6IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XS5qb2luKFwiIFwiKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pbihcIixcIikucmVwbGFjZShwMnMsIFwiJDFcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhDbG9uZShwYXRoQXJyYXkpIHtcbiAgICAgICAgdmFyIHJlcyA9IGNsb25lKHBhdGhBcnJheSk7XG4gICAgICAgIHJlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQb2ludEF0U2VnbWVudExlbmd0aChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJlemxlbihwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmluZERvdHNBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksXG4gICAgICAgICAgICAgICAgZ2V0VG90TGVuKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCBsZW5ndGgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMZW5ndGhGYWN0b3J5KGlzdG90YWwsIHN1YnBhdGgpIHtcbiAgICAgICAgZnVuY3Rpb24gTyh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiArKCt2YWwpLnRvRml4ZWQoMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNuYXAuXy5jYWNoZXIoZnVuY3Rpb24gKHBhdGgsIGxlbmd0aCwgb25seXN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAocGF0aCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5hdHRyKFwiZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGggPSBwYXRoMmN1cnZlKHBhdGgpO1xuICAgICAgICAgICAgdmFyIHgsIHksIHAsIGwsIHNwID0gXCJcIiwgc3VicGF0aHMgPSB7fSwgcG9pbnQsXG4gICAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgPSBwYXRoW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSArcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICtwWzJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBnZXRQb2ludEF0U2VnbWVudExlbmd0aCh4LCB5LCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCBwWzZdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiArIGwgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJwYXRoICYmICFzdWJwYXRocy5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gZ2V0UG9pbnRBdFNlZ21lbnRMZW5ndGgoeCwgeSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgcFs2XSwgbGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcCArPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ1wiICsgTyhwb2ludC5zdGFydC54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC5zdGFydC55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC5tLngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50Lm0ueSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQueSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5c3RhcnQpIHtyZXR1cm4gc3A7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnBhdGhzLnN0YXJ0ID0gc3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3AgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTVwiICsgTyhwb2ludC54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC55KSArIFwiQ1wiICsgTyhwb2ludC5uLngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50Lm4ueSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQuZW5kLngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LmVuZC55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwWzVdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwWzZdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0uam9pbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSBsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSArcFs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gK3BbNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzdG90YWwgJiYgIXN1YnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0sIGxlbmd0aCAtIGxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSBsO1xuICAgICAgICAgICAgICAgICAgICB4ID0gK3BbNV07XG4gICAgICAgICAgICAgICAgICAgIHkgPSArcFs2XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3AgKz0gcC5zaGlmdCgpICsgcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnBhdGhzLmVuZCA9IHNwO1xuICAgICAgICAgICAgcG9pbnQgPSBpc3RvdGFsID8gbGVuIDogc3VicGF0aCA/IHN1YnBhdGhzIDogZmluZERvdHNBdFNlZ21lbnQoeCwgeSwgcFswXSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sIG51bGwsIFNuYXAuXy5jbG9uZSk7XG4gICAgfVxuICAgIHZhciBnZXRUb3RhbExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoMSksXG4gICAgICAgIGdldFBvaW50QXRMZW5ndGggPSBnZXRMZW5ndGhGYWN0b3J5KCksXG4gICAgICAgIGdldFN1YnBhdGhzQXRMZW5ndGggPSBnZXRMZW5ndGhGYWN0b3J5KDAsIDEpO1xuICAgIGZ1bmN0aW9uIGZpbmREb3RzQXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0KSB7XG4gICAgICAgIHZhciB0MSA9IDEgLSB0LFxuICAgICAgICAgICAgdDEzID0gcG93KHQxLCAzKSxcbiAgICAgICAgICAgIHQxMiA9IHBvdyh0MSwgMiksXG4gICAgICAgICAgICB0MiA9IHQgKiB0LFxuICAgICAgICAgICAgdDMgPSB0MiAqIHQsXG4gICAgICAgICAgICB4ID0gdDEzICogcDF4ICsgdDEyICogMyAqIHQgKiBjMXggKyB0MSAqIDMgKiB0ICogdCAqIGMyeCArIHQzICogcDJ4LFxuICAgICAgICAgICAgeSA9IHQxMyAqIHAxeSArIHQxMiAqIDMgKiB0ICogYzF5ICsgdDEgKiAzICogdCAqIHQgKiBjMnkgKyB0MyAqIHAyeSxcbiAgICAgICAgICAgIG14ID0gcDF4ICsgMiAqIHQgKiAoYzF4IC0gcDF4KSArIHQyICogKGMyeCAtIDIgKiBjMXggKyBwMXgpLFxuICAgICAgICAgICAgbXkgPSBwMXkgKyAyICogdCAqIChjMXkgLSBwMXkpICsgdDIgKiAoYzJ5IC0gMiAqIGMxeSArIHAxeSksXG4gICAgICAgICAgICBueCA9IGMxeCArIDIgKiB0ICogKGMyeCAtIGMxeCkgKyB0MiAqIChwMnggLSAyICogYzJ4ICsgYzF4KSxcbiAgICAgICAgICAgIG55ID0gYzF5ICsgMiAqIHQgKiAoYzJ5IC0gYzF5KSArIHQyICogKHAyeSAtIDIgKiBjMnkgKyBjMXkpLFxuICAgICAgICAgICAgYXggPSB0MSAqIHAxeCArIHQgKiBjMXgsXG4gICAgICAgICAgICBheSA9IHQxICogcDF5ICsgdCAqIGMxeSxcbiAgICAgICAgICAgIGN4ID0gdDEgKiBjMnggKyB0ICogcDJ4LFxuICAgICAgICAgICAgY3kgPSB0MSAqIGMyeSArIHQgKiBwMnksXG4gICAgICAgICAgICBhbHBoYSA9ICg5MCAtIG1hdGguYXRhbjIobXggLSBueCwgbXkgLSBueSkgKiAxODAgLyBQSSk7XG4gICAgICAgIC8vIChteCA+IG54IHx8IG15IDwgbnkpICYmIChhbHBoYSArPSAxODApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBtOiB7eDogbXgsIHk6IG15fSxcbiAgICAgICAgICAgIG46IHt4OiBueCwgeTogbnl9LFxuICAgICAgICAgICAgc3RhcnQ6IHt4OiBheCwgeTogYXl9LFxuICAgICAgICAgICAgZW5kOiB7eDogY3gsIHk6IGN5fSxcbiAgICAgICAgICAgIGFscGhhOiBhbHBoYVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZXppZXJCQm94KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KSB7XG4gICAgICAgIGlmICghU25hcC5pcyhwMXgsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIHAxeCA9IFtwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJib3ggPSBjdXJ2ZURpbS5hcHBseShudWxsLCBwMXgpO1xuICAgICAgICByZXR1cm4gYm94KFxuICAgICAgICAgICAgYmJveC5taW4ueCxcbiAgICAgICAgICAgIGJib3gubWluLnksXG4gICAgICAgICAgICBiYm94Lm1heC54IC0gYmJveC5taW4ueCxcbiAgICAgICAgICAgIGJib3gubWF4LnkgLSBiYm94Lm1pbi55XG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVCQm94KGJib3gsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuICB4ID49IGJib3gueCAmJlxuICAgICAgICAgICAgICAgIHggPD0gYmJveC54ICsgYmJveC53aWR0aCAmJlxuICAgICAgICAgICAgICAgIHkgPj0gYmJveC55ICYmXG4gICAgICAgICAgICAgICAgeSA8PSBiYm94LnkgKyBiYm94LmhlaWdodDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCQm94SW50ZXJzZWN0KGJib3gxLCBiYm94Mikge1xuICAgICAgICBiYm94MSA9IGJveChiYm94MSk7XG4gICAgICAgIGJib3gyID0gYm94KGJib3gyKTtcbiAgICAgICAgcmV0dXJuIGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54LCBiYm94MS55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkyKVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55MilcbiAgICAgICAgICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54LCBiYm94Mi55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngsIGJib3gyLnkyKVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55MilcbiAgICAgICAgICAgIHx8IChiYm94MS54IDwgYmJveDIueDIgJiYgYmJveDEueCA+IGJib3gyLnhcbiAgICAgICAgICAgICAgICB8fCBiYm94Mi54IDwgYmJveDEueDIgJiYgYmJveDIueCA+IGJib3gxLngpXG4gICAgICAgICAgICAmJiAoYmJveDEueSA8IGJib3gyLnkyICYmIGJib3gxLnkgPiBiYm94Mi55XG4gICAgICAgICAgICAgICAgfHwgYmJveDIueSA8IGJib3gxLnkyICYmIGJib3gyLnkgPiBiYm94MS55KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFzZTModCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgdmFyIHQxID0gLTMgKiBwMSArIDkgKiBwMiAtIDkgKiBwMyArIDMgKiBwNCxcbiAgICAgICAgICAgIHQyID0gdCAqIHQxICsgNiAqIHAxIC0gMTIgKiBwMiArIDYgKiBwMztcbiAgICAgICAgcmV0dXJuIHQgKiB0MiAtIDMgKiBwMSArIDMgKiBwMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgeikge1xuICAgICAgICBpZiAoeiA9PSBudWxsKSB7XG4gICAgICAgICAgICB6ID0gMTtcbiAgICAgICAgfVxuICAgICAgICB6ID0geiA+IDEgPyAxIDogeiA8IDAgPyAwIDogejtcbiAgICAgICAgdmFyIHoyID0geiAvIDIsXG4gICAgICAgICAgICBuID0gMTIsXG4gICAgICAgICAgICBUdmFsdWVzID0gWy0uMTI1MiwuMTI1MiwtLjM2NzgsLjM2NzgsLS41ODczLC41ODczLC0uNzY5OSwuNzY5OSwtLjkwNDEsLjkwNDEsLS45ODE2LC45ODE2XSxcbiAgICAgICAgICAgIEN2YWx1ZXMgPSBbMC4yNDkxLDAuMjQ5MSwwLjIzMzUsMC4yMzM1LDAuMjAzMiwwLjIwMzIsMC4xNjAxLDAuMTYwMSwwLjEwNjksMC4xMDY5LDAuMDQ3MiwwLjA0NzJdLFxuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdCA9IHoyICogVHZhbHVlc1tpXSArIHoyLFxuICAgICAgICAgICAgICAgIHhiYXNlID0gYmFzZTMoY3QsIHgxLCB4MiwgeDMsIHg0KSxcbiAgICAgICAgICAgICAgICB5YmFzZSA9IGJhc2UzKGN0LCB5MSwgeTIsIHkzLCB5NCksXG4gICAgICAgICAgICAgICAgY29tYiA9IHhiYXNlICogeGJhc2UgKyB5YmFzZSAqIHliYXNlO1xuICAgICAgICAgICAgc3VtICs9IEN2YWx1ZXNbaV0gKiBtYXRoLnNxcnQoY29tYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoyICogc3VtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUb3RMZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBsbCkge1xuICAgICAgICBpZiAobGwgPCAwIHx8IGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIDwgbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdCA9IDEsXG4gICAgICAgICAgICBzdGVwID0gdCAvIDIsXG4gICAgICAgICAgICB0MiA9IHQgLSBzdGVwLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGUgPSAuMDE7XG4gICAgICAgIGwgPSBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0Mik7XG4gICAgICAgIHdoaWxlIChhYnMobCAtIGxsKSA+IGUpIHtcbiAgICAgICAgICAgIHN0ZXAgLz0gMjtcbiAgICAgICAgICAgIHQyICs9IChsIDwgbGwgPyAxIDogLTEpICogc3RlcDtcbiAgICAgICAgICAgIGwgPSBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0Mik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG1tYXgoeDEsIHgyKSA8IG1taW4oeDMsIHg0KSB8fFxuICAgICAgICAgICAgbW1pbih4MSwgeDIpID4gbW1heCh4MywgeDQpIHx8XG4gICAgICAgICAgICBtbWF4KHkxLCB5MikgPCBtbWluKHkzLCB5NCkgfHxcbiAgICAgICAgICAgIG1taW4oeTEsIHkyKSA+IG1tYXgoeTMsIHk0KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnggPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHgzIC0geDQpIC0gKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICAgICAgICAgIG55ID0gKHgxICogeTIgLSB5MSAqIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICAgICAgICBkZW5vbWluYXRvciA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcblxuICAgICAgICBpZiAoIWRlbm9taW5hdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHB4ID0gbnggLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIHB5ID0gbnkgLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIHB4MiA9ICtweC50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgcHkyID0gK3B5LnRvRml4ZWQoMik7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHB4MiA8ICttbWluKHgxLCB4MikudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHgyID4gK21tYXgoeDEsIHgyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweDIgPCArbW1pbih4MywgeDQpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB4MiA+ICttbWF4KHgzLCB4NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyIDwgK21taW4oeTEsIHkyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweTIgPiArbW1heCh5MSwgeTIpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB5MiA8ICttbWluKHkzLCB5NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyID4gK21tYXgoeTMsIHk0KS50b0ZpeGVkKDIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eDogcHgsIHk6IHB5fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXIoYmV6MSwgYmV6Mikge1xuICAgICAgICByZXR1cm4gaW50ZXJIZWxwZXIoYmV6MSwgYmV6Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyQ291bnQoYmV6MSwgYmV6Mikge1xuICAgICAgICByZXR1cm4gaW50ZXJIZWxwZXIoYmV6MSwgYmV6MiwgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCkge1xuICAgICAgICB2YXIgYmJveDEgPSBiZXppZXJCQm94KGJlejEpLFxuICAgICAgICAgICAgYmJveDIgPSBiZXppZXJCQm94KGJlejIpO1xuICAgICAgICBpZiAoIWlzQkJveEludGVyc2VjdChiYm94MSwgYmJveDIpKSB7XG4gICAgICAgICAgICByZXR1cm4ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsMSA9IGJlemxlbi5hcHBseSgwLCBiZXoxKSxcbiAgICAgICAgICAgIGwyID0gYmV6bGVuLmFwcGx5KDAsIGJlejIpLFxuICAgICAgICAgICAgbjEgPSB+fihsMSAvIDgpLFxuICAgICAgICAgICAgbjIgPSB+fihsMiAvIDgpLFxuICAgICAgICAgICAgZG90czEgPSBbXSxcbiAgICAgICAgICAgIGRvdHMyID0gW10sXG4gICAgICAgICAgICB4eSA9IHt9LFxuICAgICAgICAgICAgcmVzID0ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4xICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejEuY29uY2F0KGkgLyBuMSkpO1xuICAgICAgICAgICAgZG90czEucHVzaCh7eDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMX0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMiArIDE7IGkrKykge1xuICAgICAgICAgICAgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejIuY29uY2F0KGkgLyBuMikpO1xuICAgICAgICAgICAgZG90czIucHVzaCh7eDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMn0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGkgPSBkb3RzMVtpXSxcbiAgICAgICAgICAgICAgICAgICAgZGkxID0gZG90czFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICBkaiA9IGRvdHMyW2pdLFxuICAgICAgICAgICAgICAgICAgICBkajEgPSBkb3RzMltqICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGNpID0gYWJzKGRpMS54IC0gZGkueCkgPCAuMDAxID8gXCJ5XCIgOiBcInhcIixcbiAgICAgICAgICAgICAgICAgICAgY2ogPSBhYnMoZGoxLnggLSBkai54KSA8IC4wMDEgPyBcInlcIiA6IFwieFwiLFxuICAgICAgICAgICAgICAgICAgICBpcyA9IGludGVyc2VjdChkaS54LCBkaS55LCBkaTEueCwgZGkxLnksIGRqLngsIGRqLnksIGRqMS54LCBkajEueSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4eVtpcy54LnRvRml4ZWQoNCldID09IGlzLnkudG9GaXhlZCg0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeHlbaXMueC50b0ZpeGVkKDQpXSA9IGlzLnkudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gZGkudCArIGFicygoaXNbY2ldIC0gZGlbY2ldKSAvIChkaTFbY2ldIC0gZGlbY2ldKSkgKiAoZGkxLnQgLSBkaS50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gZGoudCArIGFicygoaXNbY2pdIC0gZGpbY2pdKSAvIChkajFbY2pdIC0gZGpbY2pdKSkgKiAoZGoxLnQgLSBkai50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSAmJiB0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqdXN0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MTogdDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQyOiB0MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhJbnRlcnNlY3Rpb24ocGF0aDEsIHBhdGgyKSB7XG4gICAgICAgIHJldHVybiBpbnRlclBhdGhIZWxwZXIocGF0aDEsIHBhdGgyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aEludGVyc2VjdGlvbk51bWJlcihwYXRoMSwgcGF0aDIpIHtcbiAgICAgICAgcmV0dXJuIGludGVyUGF0aEhlbHBlcihwYXRoMSwgcGF0aDIsIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlclBhdGhIZWxwZXIocGF0aDEsIHBhdGgyLCBqdXN0Q291bnQpIHtcbiAgICAgICAgcGF0aDEgPSBwYXRoMmN1cnZlKHBhdGgxKTtcbiAgICAgICAgcGF0aDIgPSBwYXRoMmN1cnZlKHBhdGgyKTtcbiAgICAgICAgdmFyIHgxLCB5MSwgeDIsIHkyLCB4MW0sIHkxbSwgeDJtLCB5Mm0sIGJlejEsIGJlejIsXG4gICAgICAgICAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwaSA9IHBhdGgxW2ldO1xuICAgICAgICAgICAgaWYgKHBpWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeDEgPSB4MW0gPSBwaVsxXTtcbiAgICAgICAgICAgICAgICB5MSA9IHkxbSA9IHBpWzJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGlbMF0gPT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmV6MSA9IFt4MSwgeTFdLmNvbmNhdChwaS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gYmV6MVs2XTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBiZXoxWzddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlejEgPSBbeDEsIHkxLCB4MSwgeTEsIHgxbSwgeTFtLCB4MW0sIHkxbV07XG4gICAgICAgICAgICAgICAgICAgIHgxID0geDFtO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkxbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcGF0aDIubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGogPSBwYXRoMltqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBqWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgybSA9IHBqWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5Mm0gPSBwalsyXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwalswXSA9PSBcIkNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyXS5jb25jYXQocGouc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gYmV6Mls2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGJlejJbN107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyLCB4MiwgeTIsIHgybSwgeTJtLCB4Mm0sIHkybV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4Mm07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5Mm07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ciA9IGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanVzdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IGludHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IGludHIubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQxID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50cltrXS5zZWdtZW50MiA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uYmV6MSA9IGJlejE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uYmV6MiA9IGJlejI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoaW50cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQb2ludEluc2lkZVBhdGgocGF0aCwgeCwgeSkge1xuICAgICAgICB2YXIgYmJveCA9IHBhdGhCQm94KHBhdGgpO1xuICAgICAgICByZXR1cm4gaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkgJiZcbiAgICAgICAgICAgICAgIGludGVyUGF0aEhlbHBlcihwYXRoLCBbW1wiTVwiLCB4LCB5XSwgW1wiSFwiLCBiYm94LngyICsgMTBdXSwgMSkgJSAyID09IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhCQm94KHBhdGgpIHtcbiAgICAgICAgdmFyIHB0aCA9IHBhdGhzKHBhdGgpO1xuICAgICAgICBpZiAocHRoLmJib3gpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZShwdGguYmJveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gYm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgIHZhciB4ID0gMCwgXG4gICAgICAgICAgICB5ID0gMCxcbiAgICAgICAgICAgIFggPSBbXSxcbiAgICAgICAgICAgIFkgPSBbXSxcbiAgICAgICAgICAgIHA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcCA9IHBhdGhbaV07XG4gICAgICAgICAgICBpZiAocFswXSA9PSBcIk1cIikge1xuICAgICAgICAgICAgICAgIHggPSBwWzFdO1xuICAgICAgICAgICAgICAgIHkgPSBwWzJdO1xuICAgICAgICAgICAgICAgIFgucHVzaCh4KTtcbiAgICAgICAgICAgICAgICBZLnB1c2goeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkaW0gPSBjdXJ2ZURpbSh4LCB5LCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCBwWzZdKTtcbiAgICAgICAgICAgICAgICBYID0gWC5jb25jYXQoZGltLm1pbi54LCBkaW0ubWF4LngpO1xuICAgICAgICAgICAgICAgIFkgPSBZLmNvbmNhdChkaW0ubWluLnksIGRpbS5tYXgueSk7XG4gICAgICAgICAgICAgICAgeCA9IHBbNV07XG4gICAgICAgICAgICAgICAgeSA9IHBbNl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHhtaW4gPSBtbWluLmFwcGx5KDAsIFgpLFxuICAgICAgICAgICAgeW1pbiA9IG1taW4uYXBwbHkoMCwgWSksXG4gICAgICAgICAgICB4bWF4ID0gbW1heC5hcHBseSgwLCBYKSxcbiAgICAgICAgICAgIHltYXggPSBtbWF4LmFwcGx5KDAsIFkpLFxuICAgICAgICAgICAgYmIgPSBib3goeG1pbiwgeW1pbiwgeG1heCAtIHhtaW4sIHltYXggLSB5bWluKTtcbiAgICAgICAgcHRoLmJib3ggPSBjbG9uZShiYik7XG4gICAgICAgIHJldHVybiBiYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdFBhdGgoeCwgeSwgdywgaCwgcikge1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBbXCJNXCIsICt4ICsgKCtyKSwgeV0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCB3IC0gciAqIDIsIDBdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCAwLCBoIC0gciAqIDJdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgLXIsIHJdLFxuICAgICAgICAgICAgICAgIFtcImxcIiwgciAqIDIgLSB3LCAwXSxcbiAgICAgICAgICAgICAgICBbXCJhXCIsIHIsIHIsIDAsIDAsIDEsIC1yLCAtcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCAwLCByICogMiAtIGhdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgLXJdLFxuICAgICAgICAgICAgICAgIFtcInpcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IFtbXCJNXCIsIHgsIHldLCBbXCJsXCIsIHcsIDBdLCBbXCJsXCIsIDAsIGhdLCBbXCJsXCIsIC13LCAwXSwgW1wielwiXV07XG4gICAgICAgIHJlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGxpcHNlUGF0aCh4LCB5LCByeCwgcnksIGEpIHtcbiAgICAgICAgaWYgKGEgPT0gbnVsbCAmJiByeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByeSA9IHJ4O1xuICAgICAgICB9XG4gICAgICAgIHggPSAreDtcbiAgICAgICAgeSA9ICt5O1xuICAgICAgICByeCA9ICtyeDtcbiAgICAgICAgcnkgPSArcnk7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgICAgICAgICAgIHgxID0geCArIHJ4ICogTWF0aC5jb3MoLXJ5ICogcmFkKSxcbiAgICAgICAgICAgICAgICB4MiA9IHggKyByeCAqIE1hdGguY29zKC1hICogcmFkKSxcbiAgICAgICAgICAgICAgICB5MSA9IHkgKyByeCAqIE1hdGguc2luKC1yeSAqIHJhZCksXG4gICAgICAgICAgICAgICAgeTIgPSB5ICsgcnggKiBNYXRoLnNpbigtYSAqIHJhZCksXG4gICAgICAgICAgICAgICAgcmVzID0gW1tcIk1cIiwgeDEsIHkxXSwgW1wiQVwiLCByeCwgcngsIDAsICsoYSAtIHJ5ID4gMTgwKSwgMCwgeDIsIHkyXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBbXG4gICAgICAgICAgICAgICAgW1wiTVwiLCB4LCB5XSxcbiAgICAgICAgICAgICAgICBbXCJtXCIsIDAsIC1yeV0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIDIgKiByeV0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIC0yICogcnldLFxuICAgICAgICAgICAgICAgIFtcInpcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHZhciB1bml0MnB4ID0gU25hcC5fdW5pdDJweCxcbiAgICAgICAgZ2V0UGF0aCA9IHtcbiAgICAgICAgcGF0aDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuYXR0cihcInBhdGhcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHVuaXQycHgoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2VQYXRoKGF0dHIuY3gsIGF0dHIuY3ksIGF0dHIucik7XG4gICAgICAgIH0sXG4gICAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiBlbGxpcHNlUGF0aChhdHRyLmN4IHx8IDAsIGF0dHIuY3kgfHwgMCwgYXR0ci5yeCwgYXR0ci5yeSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0UGF0aChhdHRyLnggfHwgMCwgYXR0ci55IHx8IDAsIGF0dHIud2lkdGgsIGF0dHIuaGVpZ2h0LCBhdHRyLnJ4LCBhdHRyLnJ5KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0UGF0aChhdHRyLnggfHwgMCwgYXR0ci55IHx8IDAsIGF0dHIud2lkdGgsIGF0dHIuaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNXCIgKyBbZWwuYXR0cihcIngxXCIpIHx8IDAsIGVsLmF0dHIoXCJ5MVwiKSB8fCAwLCBlbC5hdHRyKFwieDJcIiksIGVsLmF0dHIoXCJ5MlwiKV07XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlsaW5lOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk1cIiArIGVsLmF0dHIoXCJwb2ludHNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb246IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTVwiICsgZWwuYXR0cihcInBvaW50c1wiKSArIFwielwiO1xuICAgICAgICB9LFxuICAgICAgICBkZWZsdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IGVsLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhdGhUb1JlbGF0aXZlKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aEFycmF5KSxcbiAgICAgICAgICAgIGxvd2VyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2U7XG4gICAgICAgIGlmIChwdGgucmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5yZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghU25hcC5pcyhwYXRoQXJyYXksIFwiYXJyYXlcIikgfHwgIVNuYXAuaXMocGF0aEFycmF5ICYmIHBhdGhBcnJheVswXSwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgcGF0aEFycmF5ID0gU25hcC5wYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgbXggPSAwLFxuICAgICAgICAgICAgbXkgPSAwLFxuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBpZiAocGF0aEFycmF5WzBdWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICB4ID0gcGF0aEFycmF5WzBdWzFdO1xuICAgICAgICAgICAgeSA9IHBhdGhBcnJheVswXVsyXTtcbiAgICAgICAgICAgIG14ID0geDtcbiAgICAgICAgICAgIG15ID0geTtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgICAgICByZXMucHVzaChbXCJNXCIsIHgsIHldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gcGF0aEFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gcmVzW2ldID0gW10sXG4gICAgICAgICAgICAgICAgcGEgPSBwYXRoQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAocGFbMF0gIT0gbG93ZXJDYXNlLmNhbGwocGFbMF0pKSB7XG4gICAgICAgICAgICAgICAgclswXSA9IGxvd2VyQ2FzZS5jYWxsKHBhWzBdKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNl0gPSArKHBhWzZdIC0geCkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbN10gPSArKHBhWzddIC0geSkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICsocGFbMV0gLSB5KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxLCBqaiA9IHBhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2pdID0gKyhwYVtqXSAtICgoaiAlIDIpID8geCA6IHkpKS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgciA9IHJlc1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwYVswXSA9PSBcIm1cIikge1xuICAgICAgICAgICAgICAgICAgICBteCA9IHBhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgbXkgPSBwYVsyXSArIHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBhLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2ldW2tdID0gcGFba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IHJlc1tpXS5sZW5ndGg7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlc1tpXVswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgICAgICAgICAgIHggPSBteDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IG15O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgICAgICAgICB4ICs9ICtyZXNbaV1bbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gK3Jlc1tpXVtsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgeCArPSArcmVzW2ldW2xlbiAtIDJdO1xuICAgICAgICAgICAgICAgICAgICB5ICs9ICtyZXNbaV1bbGVuIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHB0aC5yZWwgPSBwYXRoQ2xvbmUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aFRvQWJzb2x1dGUocGF0aEFycmF5KSB7XG4gICAgICAgIHZhciBwdGggPSBwYXRocyhwYXRoQXJyYXkpO1xuICAgICAgICBpZiAocHRoLmFicykge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhDbG9uZShwdGguYWJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzKHBhdGhBcnJheSwgXCJhcnJheVwiKSB8fCAhaXMocGF0aEFycmF5ICYmIHBhdGhBcnJheVswXSwgXCJhcnJheVwiKSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgICAgICAgICBwYXRoQXJyYXkgPSBTbmFwLnBhcnNlUGF0aFN0cmluZyhwYXRoQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF0aEFycmF5IHx8ICFwYXRoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1tcIk1cIiwgMCwgMF1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIHggPSAwLFxuICAgICAgICAgICAgeSA9IDAsXG4gICAgICAgICAgICBteCA9IDAsXG4gICAgICAgICAgICBteSA9IDAsXG4gICAgICAgICAgICBzdGFydCA9IDAsXG4gICAgICAgICAgICBwYTA7XG4gICAgICAgIGlmIChwYXRoQXJyYXlbMF1bMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgIHggPSArcGF0aEFycmF5WzBdWzFdO1xuICAgICAgICAgICAgeSA9ICtwYXRoQXJyYXlbMF1bMl07XG4gICAgICAgICAgICBteCA9IHg7XG4gICAgICAgICAgICBteSA9IHk7XG4gICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICAgICAgcmVzWzBdID0gW1wiTVwiLCB4LCB5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3J6ID0gcGF0aEFycmF5Lmxlbmd0aCA9PSAzICYmXG4gICAgICAgICAgICBwYXRoQXJyYXlbMF1bMF0gPT0gXCJNXCIgJiZcbiAgICAgICAgICAgIHBhdGhBcnJheVsxXVswXS50b1VwcGVyQ2FzZSgpID09IFwiUlwiICYmXG4gICAgICAgICAgICBwYXRoQXJyYXlbMl1bMF0udG9VcHBlckNhc2UoKSA9PSBcIlpcIjtcbiAgICAgICAgZm9yICh2YXIgciwgcGEsIGkgPSBzdGFydCwgaWkgPSBwYXRoQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcmVzLnB1c2gociA9IFtdKTtcbiAgICAgICAgICAgIHBhID0gcGF0aEFycmF5W2ldO1xuICAgICAgICAgICAgcGEwID0gcGFbMF07XG4gICAgICAgICAgICBpZiAocGEwICE9IHBhMC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgclswXSA9IHBhMC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgclsyXSA9IHBhWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgclszXSA9IHBhWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls0XSA9IHBhWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls1XSA9IHBhWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls2XSA9ICtwYVs2XSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICByWzddID0gK3BhWzddICsgeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICtwYVsxXSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJSXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90cyA9IFt4LCB5XS5jb25jYXQocGEuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDIsIGpqID0gZG90cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90c1tqXSA9ICtkb3RzW2pdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RzWysral0gPSArZG90c1tqXSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGNhdG11bGxSb20yYmV6aWVyKGRvdHMsIGNyeikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJPXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzID0gZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdHMucHVzaChkb3RzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZG90cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdLCBwYVszXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IFtcIlVcIl0uY29uY2F0KHJlc1tyZXMubGVuZ3RoIC0gMV0uc2xpY2UoLTIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbXggPSArcGFbMV0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSArcGFbMl0gKyB5O1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMSwgamogPSBwYS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcltqXSA9ICtwYVtqXSArICgoaiAlIDIpID8geCA6IHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGEwID09IFwiUlwiKSB7XG4gICAgICAgICAgICAgICAgZG90cyA9IFt4LCB5XS5jb25jYXQocGEuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGNhdG11bGxSb20yYmV6aWVyKGRvdHMsIGNyeikpO1xuICAgICAgICAgICAgICAgIHIgPSBbXCJSXCJdLmNvbmNhdChwYS5zbGljZSgtMikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYTAgPT0gXCJPXCIpIHtcbiAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZG90cyA9IGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSk7XG4gICAgICAgICAgICAgICAgZG90cy5wdXNoKGRvdHNbMF0pO1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZG90cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhMCA9PSBcIlVcIikge1xuICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSwgcGFbM10pKTtcbiAgICAgICAgICAgICAgICByID0gW1wiVVwiXS5jb25jYXQocmVzW3Jlcy5sZW5ndGggLSAxXS5zbGljZSgtMikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwYS5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJba10gPSBwYVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYTAgPSBwYTAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChwYTAgIT0gXCJPXCIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSArbXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gK215O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gcltyLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcltyLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHB0aC5hYnMgPSBwYXRoQ2xvbmUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbDJjKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTIsIHgyLCB5Ml07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHEyYyh4MSwgeTEsIGF4LCBheSwgeDIsIHkyKSB7XG4gICAgICAgIHZhciBfMTMgPSAxIC8gMyxcbiAgICAgICAgICAgIF8yMyA9IDIgLyAzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIF8xMyAqIHgxICsgXzIzICogYXgsXG4gICAgICAgICAgICAgICAgXzEzICogeTEgKyBfMjMgKiBheSxcbiAgICAgICAgICAgICAgICBfMTMgKiB4MiArIF8yMyAqIGF4LFxuICAgICAgICAgICAgICAgIF8xMyAqIHkyICsgXzIzICogYXksXG4gICAgICAgICAgICAgICAgeDIsXG4gICAgICAgICAgICAgICAgeTJcbiAgICAgICAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEyYyh4MSwgeTEsIHJ4LCByeSwgYW5nbGUsIGxhcmdlX2FyY19mbGFnLCBzd2VlcF9mbGFnLCB4MiwgeTIsIHJlY3Vyc2l2ZSkge1xuICAgICAgICAvLyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvZiB3aGVyZSB0aGlzIG1hdGggY2FtZSBmcm9tIHZpc2l0OlxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgICAgICAgdmFyIF8xMjAgPSBQSSAqIDEyMCAvIDE4MCxcbiAgICAgICAgICAgIHJhZCA9IFBJIC8gMTgwICogKCthbmdsZSB8fCAwKSxcbiAgICAgICAgICAgIHJlcyA9IFtdLFxuICAgICAgICAgICAgeHksXG4gICAgICAgICAgICByb3RhdGUgPSBTbmFwLl8uY2FjaGVyKGZ1bmN0aW9uICh4LCB5LCByYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgWCA9IHggKiBtYXRoLmNvcyhyYWQpIC0geSAqIG1hdGguc2luKHJhZCksXG4gICAgICAgICAgICAgICAgICAgIFkgPSB4ICogbWF0aC5zaW4ocmFkKSArIHkgKiBtYXRoLmNvcyhyYWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7eDogWCwgeTogWX07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIHh5ID0gcm90YXRlKHgxLCB5MSwgLXJhZCk7XG4gICAgICAgICAgICB4MSA9IHh5Lng7XG4gICAgICAgICAgICB5MSA9IHh5Lnk7XG4gICAgICAgICAgICB4eSA9IHJvdGF0ZSh4MiwgeTIsIC1yYWQpO1xuICAgICAgICAgICAgeDIgPSB4eS54O1xuICAgICAgICAgICAgeTIgPSB4eS55O1xuICAgICAgICAgICAgdmFyIGNvcyA9IG1hdGguY29zKFBJIC8gMTgwICogYW5nbGUpLFxuICAgICAgICAgICAgICAgIHNpbiA9IG1hdGguc2luKFBJIC8gMTgwICogYW5nbGUpLFxuICAgICAgICAgICAgICAgIHggPSAoeDEgLSB4MikgLyAyLFxuICAgICAgICAgICAgICAgIHkgPSAoeTEgLSB5MikgLyAyO1xuICAgICAgICAgICAgdmFyIGggPSAoeCAqIHgpIC8gKHJ4ICogcngpICsgKHkgKiB5KSAvIChyeSAqIHJ5KTtcbiAgICAgICAgICAgIGlmIChoID4gMSkge1xuICAgICAgICAgICAgICAgIGggPSBtYXRoLnNxcnQoaCk7XG4gICAgICAgICAgICAgICAgcnggPSBoICogcng7XG4gICAgICAgICAgICAgICAgcnkgPSBoICogcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcngyID0gcnggKiByeCxcbiAgICAgICAgICAgICAgICByeTIgPSByeSAqIHJ5LFxuICAgICAgICAgICAgICAgIGsgPSAobGFyZ2VfYXJjX2ZsYWcgPT0gc3dlZXBfZmxhZyA/IC0xIDogMSkgKlxuICAgICAgICAgICAgICAgICAgICBtYXRoLnNxcnQoYWJzKChyeDIgKiByeTIgLSByeDIgKiB5ICogeSAtIHJ5MiAqIHggKiB4KSAvIChyeDIgKiB5ICogeSArIHJ5MiAqIHggKiB4KSkpLFxuICAgICAgICAgICAgICAgIGN4ID0gayAqIHJ4ICogeSAvIHJ5ICsgKHgxICsgeDIpIC8gMixcbiAgICAgICAgICAgICAgICBjeSA9IGsgKiAtcnkgKiB4IC8gcnggKyAoeTEgKyB5MikgLyAyLFxuICAgICAgICAgICAgICAgIGYxID0gbWF0aC5hc2luKCgoeTEgLSBjeSkgLyByeSkudG9GaXhlZCg5KSksXG4gICAgICAgICAgICAgICAgZjIgPSBtYXRoLmFzaW4oKCh5MiAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKTtcblxuICAgICAgICAgICAgZjEgPSB4MSA8IGN4ID8gUEkgLSBmMSA6IGYxO1xuICAgICAgICAgICAgZjIgPSB4MiA8IGN4ID8gUEkgLSBmMiA6IGYyO1xuICAgICAgICAgICAgZjEgPCAwICYmIChmMSA9IFBJICogMiArIGYxKTtcbiAgICAgICAgICAgIGYyIDwgMCAmJiAoZjIgPSBQSSAqIDIgKyBmMik7XG4gICAgICAgICAgICBpZiAoc3dlZXBfZmxhZyAmJiBmMSA+IGYyKSB7XG4gICAgICAgICAgICAgICAgZjEgPSBmMSAtIFBJICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3dlZXBfZmxhZyAmJiBmMiA+IGYxKSB7XG4gICAgICAgICAgICAgICAgZjIgPSBmMiAtIFBJICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGYxID0gcmVjdXJzaXZlWzBdO1xuICAgICAgICAgICAgZjIgPSByZWN1cnNpdmVbMV07XG4gICAgICAgICAgICBjeCA9IHJlY3Vyc2l2ZVsyXTtcbiAgICAgICAgICAgIGN5ID0gcmVjdXJzaXZlWzNdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZiA9IGYyIC0gZjE7XG4gICAgICAgIGlmIChhYnMoZGYpID4gXzEyMCkge1xuICAgICAgICAgICAgdmFyIGYyb2xkID0gZjIsXG4gICAgICAgICAgICAgICAgeDJvbGQgPSB4MixcbiAgICAgICAgICAgICAgICB5Mm9sZCA9IHkyO1xuICAgICAgICAgICAgZjIgPSBmMSArIF8xMjAgKiAoc3dlZXBfZmxhZyAmJiBmMiA+IGYxID8gMSA6IC0xKTtcbiAgICAgICAgICAgIHgyID0gY3ggKyByeCAqIG1hdGguY29zKGYyKTtcbiAgICAgICAgICAgIHkyID0gY3kgKyByeSAqIG1hdGguc2luKGYyKTtcbiAgICAgICAgICAgIHJlcyA9IGEyYyh4MiwgeTIsIHJ4LCByeSwgYW5nbGUsIDAsIHN3ZWVwX2ZsYWcsIHgyb2xkLCB5Mm9sZCwgW2YyLCBmMm9sZCwgY3gsIGN5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZGYgPSBmMiAtIGYxO1xuICAgICAgICB2YXIgYzEgPSBtYXRoLmNvcyhmMSksXG4gICAgICAgICAgICBzMSA9IG1hdGguc2luKGYxKSxcbiAgICAgICAgICAgIGMyID0gbWF0aC5jb3MoZjIpLFxuICAgICAgICAgICAgczIgPSBtYXRoLnNpbihmMiksXG4gICAgICAgICAgICB0ID0gbWF0aC50YW4oZGYgLyA0KSxcbiAgICAgICAgICAgIGh4ID0gNCAvIDMgKiByeCAqIHQsXG4gICAgICAgICAgICBoeSA9IDQgLyAzICogcnkgKiB0LFxuICAgICAgICAgICAgbTEgPSBbeDEsIHkxXSxcbiAgICAgICAgICAgIG0yID0gW3gxICsgaHggKiBzMSwgeTEgLSBoeSAqIGMxXSxcbiAgICAgICAgICAgIG0zID0gW3gyICsgaHggKiBzMiwgeTIgLSBoeSAqIGMyXSxcbiAgICAgICAgICAgIG00ID0gW3gyLCB5Ml07XG4gICAgICAgIG0yWzBdID0gMiAqIG0xWzBdIC0gbTJbMF07XG4gICAgICAgIG0yWzFdID0gMiAqIG0xWzFdIC0gbTJbMV07XG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBbbTIsIG0zLCBtNF0uY29uY2F0KHJlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBbbTIsIG0zLCBtNF0uY29uY2F0KHJlcykuam9pbigpLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIHZhciBuZXdyZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHJlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmV3cmVzW2ldID0gaSAlIDIgPyByb3RhdGUocmVzW2kgLSAxXSwgcmVzW2ldLCByYWQpLnkgOiByb3RhdGUocmVzW2ldLCByZXNbaSArIDFdLCByYWQpLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3cmVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmREb3RBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQpIHtcbiAgICAgICAgdmFyIHQxID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwb3codDEsIDMpICogcDF4ICsgcG93KHQxLCAyKSAqIDMgKiB0ICogYzF4ICsgdDEgKiAzICogdCAqIHQgKiBjMnggKyBwb3codCwgMykgKiBwMngsXG4gICAgICAgICAgICB5OiBwb3codDEsIDMpICogcDF5ICsgcG93KHQxLCAyKSAqIDMgKiB0ICogYzF5ICsgdDEgKiAzICogdCAqIHQgKiBjMnkgKyBwb3codCwgMykgKiBwMnlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmV0dXJucyBib3VuZGluZyBib3ggb2YgY3ViaWMgYmV6aWVyIGN1cnZlLlxuICAgIC8vIFNvdXJjZTogaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG4gICAgLy8gT3JpZ2luYWwgdmVyc2lvbjogTklTSElPIEhpcm9rYXp1XG4gICAgLy8gTW9kaWZpY2F0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL3RpbW8yMjM0NVxuICAgIGZ1bmN0aW9uIGN1cnZlRGltKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICB2YXIgdHZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICAgICAgICBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgICAgICAgICAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgICAgICAgICAgIGMgPSAzICogeDEgLSAzICogeDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgICAgICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICAgICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICAgICAgICBzcXJ0YjJhYyA9IG1hdGguc3FydChiMmFjKTtcbiAgICAgICAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgsIHksIGogPSB0dmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGpsZW4gPSBqLFxuICAgICAgICAgICAgbXQ7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgICAgICAgbXQgPSAxIC0gdDtcbiAgICAgICAgICAgIGJvdW5kc1swXVtqXSA9IChtdCAqIG10ICogbXQgKiB4MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeDEpICsgKDMgKiBtdCAqIHQgKiB0ICogeDIpICsgKHQgKiB0ICogdCAqIHgzKTtcbiAgICAgICAgICAgIGJvdW5kc1sxXVtqXSA9IChtdCAqIG10ICogbXQgKiB5MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeTEpICsgKDMgKiBtdCAqIHQgKiB0ICogeTIpICsgKHQgKiB0ICogdCAqIHkzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgICAgICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgICAgICAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHgzO1xuICAgICAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gICAgICAgIGJvdW5kc1swXS5sZW5ndGggPSBib3VuZHNbMV0ubGVuZ3RoID0gamxlbiArIDI7XG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1pbjoge3g6IG1taW4uYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogbW1pbi5hcHBseSgwLCBib3VuZHNbMV0pfSxcbiAgICAgICAgICBtYXg6IHt4OiBtbWF4LmFwcGx5KDAsIGJvdW5kc1swXSksIHk6IG1tYXguYXBwbHkoMCwgYm91bmRzWzFdKX1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXRoMmN1cnZlKHBhdGgsIHBhdGgyKSB7XG4gICAgICAgIHZhciBwdGggPSAhcGF0aDIgJiYgcGF0aHMocGF0aCk7XG4gICAgICAgIGlmICghcGF0aDIgJiYgcHRoLmN1cnZlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5jdXJ2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSBwYXRoVG9BYnNvbHV0ZShwYXRoKSxcbiAgICAgICAgICAgIHAyID0gcGF0aDIgJiYgcGF0aFRvQWJzb2x1dGUocGF0aDIpLFxuICAgICAgICAgICAgYXR0cnMgPSB7eDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGx9LFxuICAgICAgICAgICAgYXR0cnMyID0ge3g6IDAsIHk6IDAsIGJ4OiAwLCBieTogMCwgWDogMCwgWTogMCwgcXg6IG51bGwsIHF5OiBudWxsfSxcbiAgICAgICAgICAgIHByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKHBhdGgsIGQsIHBjb20pIHtcbiAgICAgICAgICAgICAgICB2YXIgbngsIG55O1xuICAgICAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiQ1wiLCBkLngsIGQueSwgZC54LCBkLnksIGQueCwgZC55XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIShwYXRoWzBdIGluIHtUOiAxLCBROiAxfSkgJiYgKGQucXggPSBkLnF5ID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkLlggPSBwYXRoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5ZID0gcGF0aFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGEyYy5hcHBseSgwLCBbZC54LCBkLnldLmNvbmNhdChwYXRoLnNsaWNlKDEpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGNvbSA9PSBcIkNcIiB8fCBwY29tID09IFwiU1wiKSB7IC8vIEluIFwiU1wiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgQy9TLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG54ID0gZC54ICogMiAtIGQuYng7ICAgICAgICAgIC8vIEFuZCByZWZsZWN0IHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG55ID0gZC55ICogMiAtIGQuYnk7ICAgICAgICAgIC8vIGNvbW1hbmQncyBjb250cm9sIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHNvbWUgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggPSBkLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSBkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiLCBueCwgbnldLmNvbmNhdChwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBjb20gPT0gXCJRXCIgfHwgcGNvbSA9PSBcIlRcIikgeyAvLyBJbiBcIlRcIiBjYXNlIHdlIGhhdmUgdG8gdGFrZSBpbnRvIGFjY291bnQsIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIGlzIFEvVC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnF4ID0gZC54ICogMiAtIGQucXg7ICAgICAgICAvLyBBbmQgbWFrZSBhIHJlZmxlY3Rpb24gc2ltaWxhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBkLnkgKiAyIC0gZC5xeTsgICAgICAgIC8vIHRvIGNhc2UgXCJTXCIuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igc29tZXRoaW5nIGVsc2Ugb3Igbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBkLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IGQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChxMmMoZC54LCBkLnksIGQucXgsIGQucXksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IHBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnF5ID0gcGF0aFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChxMmMoZC54LCBkLnksIHBhdGhbMV0sIHBhdGhbMl0sIHBhdGhbM10sIHBhdGhbNF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGwyYyhkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBwYXRoWzFdLCBkLnkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGwyYyhkLngsIGQueSwgZC54LCBwYXRoWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChsMmMoZC54LCBkLnksIGQuWCwgZC5ZKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml4QXJjID0gZnVuY3Rpb24gKHBwLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBwW2ldLmxlbmd0aCA+IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHBbaV0uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpID0gcHBbaV07XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwaS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBjb21zMVtpXSA9IFwiQVwiOyAvLyBpZiBjcmVhdGVkIG11bHRpcGxlIEM6cywgdGhlaXIgb3JpZ2luYWwgc2VnIGlzIHNhdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwMiAmJiAocGNvbXMyW2ldID0gXCJBXCIpOyAvLyB0aGUgc2FtZSBhcyBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHAuc3BsaWNlKGkrKywgMCwgW1wiQ1wiXS5jb25jYXQocGkuc3BsaWNlKDAsIDYpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml4TSA9IGZ1bmN0aW9uIChwYXRoMSwgcGF0aDIsIGExLCBhMiwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoMSAmJiBwYXRoMiAmJiBwYXRoMVtpXVswXSA9PSBcIk1cIiAmJiBwYXRoMltpXVswXSAhPSBcIk1cIikge1xuICAgICAgICAgICAgICAgICAgICBwYXRoMi5zcGxpY2UoaSwgMCwgW1wiTVwiLCBhMi54LCBhMi55XSk7XG4gICAgICAgICAgICAgICAgICAgIGExLmJ4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYTEuYnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBhMS54ID0gcGF0aDFbaV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGExLnkgPSBwYXRoMVtpXVsyXTtcbiAgICAgICAgICAgICAgICAgICAgaWkgPSBtbWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBjb21zMSA9IFtdLCAvLyBwYXRoIGNvbW1hbmRzIG9mIG9yaWdpbmFsIHBhdGggcFxuICAgICAgICAgICAgcGNvbXMyID0gW10sIC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwMlxuICAgICAgICAgICAgcGZpcnN0ID0gXCJcIiwgLy8gdGVtcG9yYXJ5IGhvbGRlciBmb3Igb3JpZ2luYWwgcGF0aCBjb21tYW5kXG4gICAgICAgICAgICBwY29tID0gXCJcIjsgLy8gaG9sZGVyIGZvciBwcmV2aW91cyBwYXRoIGNvbW1hbmQgb2Ygb3JpZ2luYWwgcGF0aFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBtbWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBwW2ldICYmIChwZmlyc3QgPSBwW2ldWzBdKTsgLy8gc2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuXG4gICAgICAgICAgICBpZiAocGZpcnN0ICE9IFwiQ1wiKSAvLyBDIGlzIG5vdCBzYXZlZCB5ZXQsIGJlY2F1c2UgaXQgbWF5IGJlIHJlc3VsdCBvZiBjb252ZXJzaW9uXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGNvbXMxW2ldID0gcGZpcnN0OyAvLyBTYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG4gICAgICAgICAgICAgICAgaSAmJiAoIHBjb20gPSBwY29tczFbaSAtIDFdKTsgLy8gR2V0IHByZXZpb3VzIHBhdGggY29tbWFuZCBwY29tXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwW2ldID0gcHJvY2Vzc1BhdGgocFtpXSwgYXR0cnMsIHBjb20pOyAvLyBQcmV2aW91cyBwYXRoIGNvbW1hbmQgaXMgaW5wdXR0ZWQgdG8gcHJvY2Vzc1BhdGhcblxuICAgICAgICAgICAgaWYgKHBjb21zMVtpXSAhPSBcIkFcIiAmJiBwZmlyc3QgPT0gXCJDXCIpIHBjb21zMVtpXSA9IFwiQ1wiOyAvLyBBIGlzIHRoZSBvbmx5IGNvbW1hbmRcbiAgICAgICAgICAgIC8vIHdoaWNoIG1heSBwcm9kdWNlIG11bHRpcGxlIEM6c1xuICAgICAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCBDIGlzIGFsc28gQyBpbiBvcmlnaW5hbCBwYXRoXG5cbiAgICAgICAgICAgIGZpeEFyYyhwLCBpKTsgLy8gZml4QXJjIGFkZHMgYWxzbyB0aGUgcmlnaHQgYW1vdW50IG9mIEE6cyB0byBwY29tczFcblxuICAgICAgICAgICAgaWYgKHAyKSB7IC8vIHRoZSBzYW1lIHByb2NlZHVyZXMgaXMgZG9uZSB0byBwMlxuICAgICAgICAgICAgICAgIHAyW2ldICYmIChwZmlyc3QgPSBwMltpXVswXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBmaXJzdCAhPSBcIkNcIikge1xuICAgICAgICAgICAgICAgICAgICBwY29tczJbaV0gPSBwZmlyc3Q7XG4gICAgICAgICAgICAgICAgICAgIGkgJiYgKHBjb20gPSBwY29tczJbaSAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcDJbaV0gPSBwcm9jZXNzUGF0aChwMltpXSwgYXR0cnMyLCBwY29tKTtcblxuICAgICAgICAgICAgICAgIGlmIChwY29tczJbaV0gIT0gXCJBXCIgJiYgcGZpcnN0ID09IFwiQ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBjb21zMltpXSA9IFwiQ1wiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpeEFyYyhwMiwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXhNKHAsIHAyLCBhdHRycywgYXR0cnMyLCBpKTtcbiAgICAgICAgICAgIGZpeE0ocDIsIHAsIGF0dHJzMiwgYXR0cnMsIGkpO1xuICAgICAgICAgICAgdmFyIHNlZyA9IHBbaV0sXG4gICAgICAgICAgICAgICAgc2VnMiA9IHAyICYmIHAyW2ldLFxuICAgICAgICAgICAgICAgIHNlZ2xlbiA9IHNlZy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgc2VnMmxlbiA9IHAyICYmIHNlZzIubGVuZ3RoO1xuICAgICAgICAgICAgYXR0cnMueCA9IHNlZ1tzZWdsZW4gLSAyXTtcbiAgICAgICAgICAgIGF0dHJzLnkgPSBzZWdbc2VnbGVuIC0gMV07XG4gICAgICAgICAgICBhdHRycy5ieCA9IHRvRmxvYXQoc2VnW3NlZ2xlbiAtIDRdKSB8fCBhdHRycy54O1xuICAgICAgICAgICAgYXR0cnMuYnkgPSB0b0Zsb2F0KHNlZ1tzZWdsZW4gLSAzXSkgfHwgYXR0cnMueTtcbiAgICAgICAgICAgIGF0dHJzMi5ieCA9IHAyICYmICh0b0Zsb2F0KHNlZzJbc2VnMmxlbiAtIDRdKSB8fCBhdHRyczIueCk7XG4gICAgICAgICAgICBhdHRyczIuYnkgPSBwMiAmJiAodG9GbG9hdChzZWcyW3NlZzJsZW4gLSAzXSkgfHwgYXR0cnMyLnkpO1xuICAgICAgICAgICAgYXR0cnMyLnggPSBwMiAmJiBzZWcyW3NlZzJsZW4gLSAyXTtcbiAgICAgICAgICAgIGF0dHJzMi55ID0gcDIgJiYgc2VnMltzZWcybGVuIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwMikge1xuICAgICAgICAgICAgcHRoLmN1cnZlID0gcGF0aENsb25lKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwMiA/IFtwLCBwMl0gOiBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXBQYXRoKHBhdGgsIG1hdHJpeCkge1xuICAgICAgICBpZiAoIW1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHgsIHksIGksIGosIGlpLCBqaiwgcGF0aGk7XG4gICAgICAgIHBhdGggPSBwYXRoMmN1cnZlKHBhdGgpO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcGF0aGkgPSBwYXRoW2ldO1xuICAgICAgICAgICAgZm9yIChqID0gMSwgamogPSBwYXRoaS5sZW5ndGg7IGogPCBqajsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgeCA9IG1hdHJpeC54KHBhdGhpW2pdLCBwYXRoaVtqICsgMV0pO1xuICAgICAgICAgICAgICAgIHkgPSBtYXRyaXgueShwYXRoaVtqXSwgcGF0aGlbaiArIDFdKTtcbiAgICAgICAgICAgICAgICBwYXRoaVtqXSA9IHg7XG4gICAgICAgICAgICAgICAgcGF0aGlbaiArIDFdID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvLyBodHRwOi8vc2NoZXBlcnMuY2MvZ2V0dGluZy10by10aGUtcG9pbnRcbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tMmJlemllcihjcnAsIHopIHtcbiAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBjcnAubGVuZ3RoOyBpTGVuIC0gMiAqICF6ID4gaTsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgLSAyXSwgeTogK2NycFtpIC0gMV19LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaV0sICAgICB5OiArY3JwW2kgKyAxXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogK2NycFtpICsgMl0sIHk6ICtjcnBbaSArIDNdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgKyA0XSwgeTogK2NycFtpICsgNV19XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgICAgICBwWzBdID0ge3g6ICtjcnBbaUxlbiAtIDJdLCB5OiArY3JwW2lMZW4gLSAxXX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpTGVuIC0gNCA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSB7eDogK2NycFswXSwgeTogK2NycFsxXX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpTGVuIC0gMiA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMl0gPSB7eDogK2NycFswXSwgeTogK2NycFsxXX07XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSB7eDogK2NycFsyXSwgeTogK2NycFszXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaUxlbiAtIDQgPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBwWzNdID0gcFsyXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSB7eDogK2NycFtpXSwgeTogK2NycFtpICsgMV19O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQucHVzaChbXCJDXCIsXG4gICAgICAgICAgICAgICAgICAoLXBbMF0ueCArIDYgKiBwWzFdLnggKyBwWzJdLngpIC8gNixcbiAgICAgICAgICAgICAgICAgICgtcFswXS55ICsgNiAqIHBbMV0ueSArIHBbMl0ueSkgLyA2LFxuICAgICAgICAgICAgICAgICAgKHBbMV0ueCArIDYgKiBwWzJdLnggLSBwWzNdLngpIC8gNixcbiAgICAgICAgICAgICAgICAgIChwWzFdLnkgKyA2KnBbMl0ueSAtIHBbM10ueSkgLyA2LFxuICAgICAgICAgICAgICAgICAgcFsyXS54LFxuICAgICAgICAgICAgICAgICAgcFsyXS55XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIC8vIGV4cG9ydFxuICAgIFNuYXAucGF0aCA9IHBhdGhzO1xuXG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5nZXRUb3RhbExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBnaXZlbiBwYXRoIGluIHBpeGVsc1xuICAgICAqKlxuICAgICAtIHBhdGggKHN0cmluZykgU1ZHIHBhdGggc3RyaW5nXG4gICAgICoqXG4gICAgID0gKG51bWJlcikgbGVuZ3RoXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRUb3RhbExlbmd0aCA9IGdldFRvdGFsTGVuZ3RoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0UG9pbnRBdExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGxvY2F0ZWQgYXQgdGhlIGdpdmVuIGxlbmd0aCBhbG9uZyB0aGUgZ2l2ZW4gcGF0aFxuICAgICAqKlxuICAgICAtIHBhdGggKHN0cmluZykgU1ZHIHBhdGggc3RyaW5nXG4gICAgIC0gbGVuZ3RoIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCwgZXhjbHVkaW5nIG5vbi1yZW5kZXJpbmcganVtcHNcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSxcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIGRlcml2YXRpdmVcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRQb2ludEF0TGVuZ3RoID0gZ2V0UG9pbnRBdExlbmd0aDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmdldFN1YnBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIHN1YnBhdGggb2YgYSBnaXZlbiBwYXRoIGJldHdlZW4gZ2l2ZW4gc3RhcnQgYW5kIGVuZCBsZW5ndGhzXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgLSBmcm9tIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgc3RhcnQgb2YgdGhlIHNlZ21lbnRcbiAgICAgLSB0byAobnVtYmVyKSBsZW5ndGgsIGluIHBpeGVscywgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhdGggdG8gdGhlIGVuZCBvZiB0aGUgc2VnbWVudFxuICAgICAqKlxuICAgICA9IChzdHJpbmcpIHBhdGggc3RyaW5nIGRlZmluaXRpb24gZm9yIHRoZSBzZWdtZW50XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRTdWJwYXRoID0gZnVuY3Rpb24gKHBhdGgsIGZyb20sIHRvKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFRvdGFsTGVuZ3RoKHBhdGgpIC0gdG8gPCAxZS02KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3VicGF0aHNBdExlbmd0aChwYXRoLCBmcm9tKS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBnZXRTdWJwYXRoc0F0TGVuZ3RoKHBhdGgsIHRvLCAxKTtcbiAgICAgICAgcmV0dXJuIGZyb20gPyBnZXRTdWJwYXRoc0F0TGVuZ3RoKGEsIGZyb20pLmVuZCA6IGE7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXRUb3RhbExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoIGluIHBpeGVscyAob25seSB3b3JrcyBmb3IgYHBhdGhgIGVsZW1lbnRzKVxuICAgICA9IChudW1iZXIpIGxlbmd0aFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmdldFRvdGFsTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFNJRVJSQSBFbGVtZW50LmdldFBvaW50QXRMZW5ndGgoKS9FbGVtZW50LmdldFRvdGFsTGVuZ3RoKCk6IElmIGEgPHBhdGg+IGlzIGJyb2tlbiBpbnRvIGRpZmZlcmVudCBzZWdtZW50cywgaXMgdGhlIGp1bXAgZGlzdGFuY2UgdG8gdGhlIG5ldyBjb29yZGluYXRlcyBzZXQgYnkgdGhlIF9NXyBvciBfbV8gY29tbWFuZHMgY2FsY3VsYXRlZCBhcyBwYXJ0IG9mIHRoZSBwYXRoJ3MgdG90YWwgbGVuZ3RoP1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFBvaW50QXRMZW5ndGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGxvY2F0ZWQgYXQgdGhlIGdpdmVuIGxlbmd0aCBvbiB0aGUgZ2l2ZW4gcGF0aCAob25seSB3b3JrcyBmb3IgYHBhdGhgIGVsZW1lbnRzKVxuICAgICAqKlxuICAgICAtIGxlbmd0aCAobnVtYmVyKSBsZW5ndGgsIGluIHBpeGVscywgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhdGgsIGV4Y2x1ZGluZyBub24tcmVuZGVyaW5nIGp1bXBzXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50OlxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlLFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUsXG4gICAgIG8gICAgIGFscGhhOiAobnVtYmVyKSBhbmdsZSBvZiBkZXJpdmF0aXZlXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmdldFBvaW50QXRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBnZXRQb2ludEF0TGVuZ3RoKHRoaXMuYXR0cihcImRcIiksIGxlbmd0aCk7XG4gICAgfTtcbiAgICAvLyBTSUVSUkEgRWxlbWVudC5nZXRTdWJwYXRoKCk6IFNpbWlsYXIgdG8gdGhlIHByb2JsZW0gZm9yIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aCgpLiBVbmNsZWFyIGhvdyB0aGlzIHdvdWxkIHdvcmsgZm9yIGEgc2VnbWVudGVkIHBhdGguIE92ZXJhbGwsIHRoZSBjb25jZXB0IG9mIF9zdWJwYXRoXyBhbmQgd2hhdCBJJ20gY2FsbGluZyBhIF9zZWdtZW50XyAoc2VyaWVzIG9mIG5vbi1fTV8gb3IgX1pfIGNvbW1hbmRzKSBpcyB1bmNsZWFyLlxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFN1YnBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgc3VicGF0aCBvZiBhIGdpdmVuIGVsZW1lbnQgZnJvbSBnaXZlbiBzdGFydCBhbmQgZW5kIGxlbmd0aHMgKG9ubHkgd29ya3MgZm9yIGBwYXRoYCBlbGVtZW50cylcbiAgICAgKipcbiAgICAgLSBmcm9tIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgc3RhcnQgb2YgdGhlIHNlZ21lbnRcbiAgICAgLSB0byAobnVtYmVyKSBsZW5ndGgsIGluIHBpeGVscywgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhdGggdG8gdGhlIGVuZCBvZiB0aGUgc2VnbWVudFxuICAgICAqKlxuICAgICA9IChzdHJpbmcpIHBhdGggc3RyaW5nIGRlZmluaXRpb24gZm9yIHRoZSBzZWdtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0U3VicGF0aCA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gU25hcC5wYXRoLmdldFN1YnBhdGgodGhpcy5hdHRyKFwiZFwiKSwgZnJvbSwgdG8pO1xuICAgIH07XG4gICAgU25hcC5fLmJveCA9IGJveDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmZpbmREb3RzQXRTZWdtZW50XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIEZpbmRzIGRvdCBjb29yZGluYXRlcyBvbiB0aGUgZ2l2ZW4gY3ViaWMgYmV6acOpciBjdXJ2ZSBhdCB0aGUgZ2l2ZW4gdFxuICAgICAtIHAxeCAobnVtYmVyKSB4IG9mIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBwMXkgKG51bWJlcikgeSBvZiB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gYzF4IChudW1iZXIpIHggb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMXkgKG51bWJlcikgeSBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMyeCAobnVtYmVyKSB4IG9mIHRoZSBzZWNvbmQgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMyeSAobnVtYmVyKSB5IG9mIHRoZSBzZWNvbmQgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAyeCAobnVtYmVyKSB4IG9mIHRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gcDJ5IChudW1iZXIpIHkgb2YgdGhlIHNlY29uZCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSB0IChudW1iZXIpIHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZSAoMC4uMSlcbiAgICAgPSAob2JqZWN0KSBwb2ludCBpbmZvcm1hdGlvbiBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LFxuICAgICBvICAgICBtOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgYW5jaG9yLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IGFuY2hvclxuICAgICBvICAgICB9LFxuICAgICBvICAgICBuOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGFuY2hvcixcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYW5jaG9yXG4gICAgIG8gICAgIH0sXG4gICAgIG8gICAgIHN0YXJ0OiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZSxcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlXG4gICAgIG8gICAgIH0sXG4gICAgIG8gICAgIGVuZDoge1xuICAgICBvICAgICAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlXG4gICAgIG8gICAgIH0sXG4gICAgIG8gICAgIGFscGhhOiAobnVtYmVyKSBhbmdsZSBvZiB0aGUgY3VydmUgZGVyaXZhdGl2ZSBhdCB0aGUgcG9pbnRcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5maW5kRG90c0F0U2VnbWVudCA9IGZpbmREb3RzQXRTZWdtZW50O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguYmV6aWVyQkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggb2YgYSBnaXZlbiBjdWJpYyBiZXppw6lyIGN1cnZlXG4gICAgIC0gcDF4IChudW1iZXIpIHggb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBjMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ5IChudW1iZXIpIHkgb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gcDJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAqIG9yXG4gICAgIC0gYmV6IChhcnJheSkgYXJyYXkgb2Ygc2l4IHBvaW50cyBmb3IgYmV6acOpciBjdXJ2ZVxuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveFxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHRvcCBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHgyOiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5MjogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBib3R0b20gcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgd2lkdGg6IChudW1iZXIpIHdpZHRoIG9mIHRoZSBib3gsXG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0IG9mIHRoZSBib3hcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5iZXppZXJCQm94ID0gYmV6aWVyQkJveDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmlzUG9pbnRJbnNpZGVCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIHBvaW50IGlzIGluc2lkZSBib3VuZGluZyBib3hcbiAgICAgLSBiYm94IChzdHJpbmcpIGJvdW5kaW5nIGJveFxuICAgICAtIHggKHN0cmluZykgeCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAtIHkgKHN0cmluZykgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAgaWYgcG9pbnQgaXMgaW5zaWRlXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5pc1BvaW50SW5zaWRlQkJveCA9IGlzUG9pbnRJbnNpZGVCQm94O1xuICAgIFNuYXAuY2xvc2VzdCA9IGZ1bmN0aW9uICh4LCB5LCBYLCBZKSB7XG4gICAgICAgIHZhciByID0gMTAwLFxuICAgICAgICAgICAgYiA9IGJveCh4IC0gciAvIDIsIHkgLSByIC8gMiwgciwgciksXG4gICAgICAgICAgICBpbnNpZGUgPSBbXSxcbiAgICAgICAgICAgIGdldHRlciA9IFhbMF0uaGFzT3duUHJvcGVydHkoXCJ4XCIpID8gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiBYW2ldLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IFhbaV0ueVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiBYW2ldLFxuICAgICAgICAgICAgICAgICAgICB5OiBZW2ldXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3VuZCA9IDA7XG4gICAgICAgIHdoaWxlIChyIDw9IDFlNiAmJiAhZm91bmQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IFgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB4eSA9IGdldHRlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQb2ludEluc2lkZUJCb3goYiwgeHkueCwgeHkueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQrKztcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlLnB1c2goeHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgciAqPSAyO1xuICAgICAgICAgICAgICAgIGIgPSBib3goeCAtIHIgLyAyLCB5IC0gciAvIDIsIHIsIHIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgPT0gMWU2KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IEluZmluaXR5LFxuICAgICAgICAgICAgcmVzO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGluc2lkZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbCA9IFNuYXAubGVuKHgsIHksIGluc2lkZVtpXS54LCBpbnNpZGVbaV0ueSk7XG4gICAgICAgICAgICBpZiAobGVuID4gbCkge1xuICAgICAgICAgICAgICAgIGxlbiA9IGw7XG4gICAgICAgICAgICAgICAgaW5zaWRlW2ldLmxlbiA9IGw7XG4gICAgICAgICAgICAgICAgcmVzID0gaW5zaWRlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmlzQkJveEludGVyc2VjdFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0d28gYm91bmRpbmcgYm94ZXMgaW50ZXJzZWN0XG4gICAgIC0gYmJveDEgKHN0cmluZykgZmlyc3QgYm91bmRpbmcgYm94XG4gICAgIC0gYmJveDIgKHN0cmluZykgc2Vjb25kIGJvdW5kaW5nIGJveFxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAgaWYgYm91bmRpbmcgYm94ZXMgaW50ZXJzZWN0XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5pc0JCb3hJbnRlcnNlY3QgPSBpc0JCb3hJbnRlcnNlY3Q7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5pbnRlcnNlY3Rpb25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogRmluZHMgaW50ZXJzZWN0aW9ucyBvZiB0d28gcGF0aHNcbiAgICAgLSBwYXRoMSAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICAtIHBhdGgyIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgID0gKGFycmF5KSBkb3RzIG9mIGludGVyc2VjdGlvblxuICAgICBvIFtcbiAgICAgbyAgICAge1xuICAgICBvICAgICAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCxcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQsXG4gICAgIG8gICAgICAgICB0MTogKG51bWJlcikgdCB2YWx1ZSBmb3Igc2VnbWVudCBvZiBwYXRoMSxcbiAgICAgbyAgICAgICAgIHQyOiAobnVtYmVyKSB0IHZhbHVlIGZvciBzZWdtZW50IG9mIHBhdGgyLFxuICAgICBvICAgICAgICAgc2VnbWVudDE6IChudW1iZXIpIG9yZGVyIG51bWJlciBmb3Igc2VnbWVudCBvZiBwYXRoMSxcbiAgICAgbyAgICAgICAgIHNlZ21lbnQyOiAobnVtYmVyKSBvcmRlciBudW1iZXIgZm9yIHNlZ21lbnQgb2YgcGF0aDIsXG4gICAgIG8gICAgICAgICBiZXoxOiAoYXJyYXkpIGVpZ2h0IGNvb3JkaW5hdGVzIHJlcHJlc2VudGluZyBiZXppw6lyIGN1cnZlIGZvciB0aGUgc2VnbWVudCBvZiBwYXRoMSxcbiAgICAgbyAgICAgICAgIGJlejI6IChhcnJheSkgZWlnaHQgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIGJlemnDqXIgY3VydmUgZm9yIHRoZSBzZWdtZW50IG9mIHBhdGgyXG4gICAgIG8gICAgIH1cbiAgICAgbyBdXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5pbnRlcnNlY3Rpb24gPSBwYXRoSW50ZXJzZWN0aW9uO1xuICAgIFNuYXAucGF0aC5pbnRlcnNlY3Rpb25OdW1iZXIgPSBwYXRoSW50ZXJzZWN0aW9uTnVtYmVyO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguaXNQb2ludEluc2lkZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBnaXZlbiBwb2ludCBpcyBpbnNpZGUgYSBnaXZlbiBjbG9zZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGZpbGwgbW9kZSBkb2VzbuKAmXQgYWZmZWN0IHRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QuXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICAtIHggKG51bWJlcikgeCBvZiB0aGUgcG9pbnRcbiAgICAgLSB5IChudW1iZXIpIHkgb2YgdGhlIHBvaW50XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBwb2ludCBpcyBpbnNpZGUgdGhlIHBhdGhcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmlzUG9pbnRJbnNpZGUgPSBpc1BvaW50SW5zaWRlUGF0aDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmdldEJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IG9mIGEgZ2l2ZW4gcGF0aFxuICAgICAtIHBhdGggKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgPSAob2JqZWN0KSBib3VuZGluZyBib3hcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCB0b3AgcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHRvcCBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB4MjogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSByaWdodCBib3R0b20gcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgeTI6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYm90dG9tIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHdpZHRoOiAobnVtYmVyKSB3aWR0aCBvZiB0aGUgYm94LFxuICAgICBvICAgICBoZWlnaHQ6IChudW1iZXIpIGhlaWdodCBvZiB0aGUgYm94XG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBTbmFwLnBhdGguZ2V0QkJveCA9IHBhdGhCQm94O1xuICAgIFNuYXAucGF0aC5nZXQgPSBnZXRQYXRoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGgudG9SZWxhdGl2ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBwYXRoIGNvb3JkaW5hdGVzIGludG8gcmVsYXRpdmUgdmFsdWVzXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChhcnJheSkgcGF0aCBzdHJpbmdcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLnRvUmVsYXRpdmUgPSBwYXRoVG9SZWxhdGl2ZTtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLnRvQWJzb2x1dGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogQ29udmVydHMgcGF0aCBjb29yZGluYXRlcyBpbnRvIGFic29sdXRlIHZhbHVlc1xuICAgICAtIHBhdGggKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgPSAoYXJyYXkpIHBhdGggc3RyaW5nXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC50b0Fic29sdXRlID0gcGF0aFRvQWJzb2x1dGU7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC50b0N1YmljXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIHBhdGggdG8gYSBuZXcgcGF0aCB3aGVyZSBhbGwgc2VnbWVudHMgYXJlIGN1YmljIGJlemnDqXIgY3VydmVzXG4gICAgIC0gcGF0aFN0cmluZyAoc3RyaW5nfGFycmF5KSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBzZWdtZW50c1xuICAgICA9IChhcnJheSkgYXJyYXkgb2Ygc2VnbWVudHNcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLnRvQ3ViaWMgPSBwYXRoMmN1cnZlO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGgubWFwXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIHBhdGggc3RyaW5nIHdpdGggdGhlIGdpdmVuIG1hdHJpeFxuICAgICAtIHBhdGggKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgLSBtYXRyaXggKG9iamVjdCkgc2VlIEBNYXRyaXhcbiAgICAgPSAoc3RyaW5nKSB0cmFuc2Zvcm1lZCBwYXRoIHN0cmluZ1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgubWFwID0gbWFwUGF0aDtcbiAgICBTbmFwLnBhdGgudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBTbmFwLnBhdGguY2xvbmUgPSBwYXRoQ2xvbmU7XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLyBcbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iKSB7XG4gICAgdmFyIG1tYXggPSBNYXRoLm1heCxcbiAgICAgICAgbW1pbiA9IE1hdGgubWluO1xuXG4gICAgLy8gU2V0XG4gICAgdmFyIFNldCA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG5cdHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnR5cGUgPSBcInNldFwiO1xuICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1t0aGlzLml0ZW1zLmxlbmd0aF0gPSB0aGlzLml0ZW1zW3RoaXMuaXRlbXMubGVuZ3RoXSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0cHJvdG8gPSBTZXQucHJvdG90eXBlO1xuICAgIC8qXFxcbiAgICAgKiBTZXQucHVzaFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBlYWNoIGFyZ3VtZW50IHRvIHRoZSBjdXJyZW50IHNldFxuICAgICA9IChvYmplY3QpIG9yaWdpbmFsIGVsZW1lbnRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8ucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZW0sXG4gICAgICAgICAgICBsZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzW2xlbl0gPSB0aGlzLml0ZW1zW2xlbl0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LnBvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBsYXN0IGVsZW1lbnQgYW5kIHJldHVybnMgaXRcbiAgICAgPSAob2JqZWN0KSBlbGVtZW50XG4gICAgXFwqL1xuICAgIHNldHByb3RvLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggJiYgZGVsZXRlIHRoaXNbdGhpcy5sZW5ndGgtLV07XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnBvcCgpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5mb3JFYWNoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFeGVjdXRlcyBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXRcbiAgICAgKlxuICAgICAqIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAsIHRoZSBsb29wIHN0b3BzIHJ1bm5pbmcuXG4gICAgICoqXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSBmdW5jdGlvbiB0byBydW5cbiAgICAgLSB0aGlzQXJnIChvYmplY3QpIGNvbnRleHQgb2JqZWN0IGZvciB0aGUgY2FsbGJhY2tcbiAgICAgPSAob2JqZWN0KSBTZXQgb2JqZWN0XG4gICAgXFwqL1xuICAgIHNldHByb3RvLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLml0ZW1zW2ldLCBpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuYW5pbWF0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQW5pbWF0ZXMgZWFjaCBlbGVtZW50IGluIHNldCBpbiBzeW5jLlxuICAgICAqXG4gICAgICoqXG4gICAgIC0gYXR0cnMgKG9iamVjdCkga2V5LXZhbHVlIHBhaXJzIG9mIGRlc3RpbmF0aW9uIGF0dHJpYnV0ZXNcbiAgICAgLSBkdXJhdGlvbiAobnVtYmVyKSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgICAtIGVhc2luZyAoZnVuY3Rpb24pICNvcHRpb25hbCBlYXNpbmcgZnVuY3Rpb24gZnJvbSBAbWluYSBvciBjdXN0b21cbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pICNvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzXG4gICAgICogb3JcbiAgICAgLSBhbmltYXRpb24gKGFycmF5KSBhcnJheSBvZiBhbmltYXRpb24gcGFyYW1ldGVyIGZvciBlYWNoIGVsZW1lbnQgaW4gc2V0IGluIGZvcm1hdCBgW2F0dHJzLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFja11gXG4gICAgID4gVXNhZ2VcbiAgICAgfCAvLyBhbmltYXRlIGFsbCBlbGVtZW50cyBpbiBzZXQgdG8gcmFkaXVzIDEwXG4gICAgIHwgc2V0LmFuaW1hdGUoe3I6IDEwfSwgNTAwLCBtaW5hLmVhc2Vpbik7XG4gICAgIHwgLy8gb3JcbiAgICAgfCAvLyBhbmltYXRlIGZpcnN0IGVsZW1lbnQgdG8gcmFkaXVzIDEwLCBidXQgc2Vjb25kIHRvIHJhZGl1cyAyMCBhbmQgaW4gZGlmZmVyZW50IHRpbWVcbiAgICAgfCBzZXQuYW5pbWF0ZShbe3I6IDEwfSwgNTAwLCBtaW5hLmVhc2Vpbl0sIFt7cjogMjB9LCAxNTAwLCBtaW5hLmVhc2Vpbl0pO1xuICAgICA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIHNldHByb3RvLmFuaW1hdGUgPSBmdW5jdGlvbiAoYXR0cnMsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWFzaW5nID09IFwiZnVuY3Rpb25cIiAmJiAhZWFzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICBlYXNpbmcgPSBtaW5hLmxpbmVhcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMgaW5zdGFuY2VvZiBTbmFwLl8uQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGF0dHJzLmNhbGxiYWNrO1xuICAgICAgICAgICAgZWFzaW5nID0gYXR0cnMuZWFzaW5nO1xuICAgICAgICAgICAgbXMgPSBlYXNpbmcuZHVyO1xuICAgICAgICAgICAgYXR0cnMgPSBhdHRycy5hdHRyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAoU25hcC5pcyhhdHRycywgXCJhcnJheVwiKSAmJiBTbmFwLmlzKGFyZ3NbYXJncy5sZW5ndGggLSAxXSwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgdmFyIGVhY2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWdpbixcbiAgICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYiA9IGJlZ2luO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gdGhpcy5iO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYiA9IDAsXG4gICAgICAgICAgICBzZXQgPSB0aGlzLFxuICAgICAgICAgICAgY2FsbGJhY2tlciA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytjYiA9PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGkpIHtcbiAgICAgICAgICAgIGV2ZS5vbmNlKFwic25hcC5hbmltY3JlYXRlZC5cIiArIGVsLmlkLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tpXSAmJiBlbC5hbmltYXRlLmFwcGx5KGVsLCBhcmdzW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuYW5pbWF0ZShhdHRycywgbXMsIGVhc2luZywgY2FsbGJhY2tlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgc2V0cHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucG9wKCkucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmJpbmRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNwZWNpZmllcyBob3cgdG8gaGFuZGxlIGEgc3BlY2lmaWMgYXR0cmlidXRlIHdoZW4gYXBwbGllZFxuICAgICAqIHRvIGEgc2V0LlxuICAgICAqXG4gICAgICoqXG4gICAgIC0gYXR0ciAoc3RyaW5nKSBhdHRyaWJ1dGUgbmFtZVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgZnVuY3Rpb24gdG8gcnVuXG4gICAgICogb3JcbiAgICAgLSBhdHRyIChzdHJpbmcpIGF0dHJpYnV0ZSBuYW1lXG4gICAgIC0gZWxlbWVudCAoRWxlbWVudCkgc3BlY2lmaWMgZWxlbWVudCBpbiB0aGUgc2V0IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGUgdG9cbiAgICAgKiBvclxuICAgICAtIGF0dHIgKHN0cmluZykgYXR0cmlidXRlIG5hbWVcbiAgICAgLSBlbGVtZW50IChFbGVtZW50KSBzcGVjaWZpYyBlbGVtZW50IGluIHRoZSBzZXQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZSB0b1xuICAgICAtIGVhdHRyIChzdHJpbmcpIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudCB0byBiaW5kIHRoZSBhdHRyaWJ1dGUgdG9cbiAgICAgPSAob2JqZWN0KSBTZXQgb2JqZWN0XG4gICAgXFwqL1xuICAgIHNldHByb3RvLmJpbmQgPSBmdW5jdGlvbiAoYXR0ciwgYSwgYikge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2F0dHJdID0gYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhbmFtZSA9IGIgfHwgYXR0cjtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbYXR0cl0gPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGRhdGFbYW5hbWVdID0gdjtcbiAgICAgICAgICAgICAgICBhLmF0dHIoZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgc2V0cHJvdG8uYXR0ciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdW5ib3VuZCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1trXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ3Nba10odmFsdWVba10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmJvdW5kW2tdID0gdmFsdWVba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLmF0dHIodW5ib3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmNsZWFyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBzZXRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5zcGxpY2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgcmFuZ2Ugb2YgZWxlbWVudHMgZnJvbSB0aGUgc2V0XG4gICAgICoqXG4gICAgIC0gaW5kZXggKG51bWJlcikgcG9zaXRpb24gb2YgdGhlIGRlbGV0aW9uXG4gICAgIC0gY291bnQgKG51bWJlcikgbnVtYmVyIG9mIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgIC0gaW5zZXJ0aW9u4oCmIChvYmplY3QpICNvcHRpb25hbCBlbGVtZW50cyB0byBpbnNlcnRcbiAgICAgPSAob2JqZWN0KSBzZXQgZWxlbWVudHMgdGhhdCB3ZXJlIGRlbGV0ZWRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uc3BsaWNlID0gZnVuY3Rpb24gKGluZGV4LCBjb3VudCwgaW5zZXJ0aW9uKSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbW1heCh0aGlzLmxlbmd0aCArIGluZGV4LCAwKSA6IGluZGV4O1xuICAgICAgICBjb3VudCA9IG1tYXgoMCwgbW1pbih0aGlzLmxlbmd0aCAtIGluZGV4LCBjb3VudCkpO1xuICAgICAgICB2YXIgdGFpbCA9IFtdLFxuICAgICAgICAgICAgdG9kZWwgPSBbXSxcbiAgICAgICAgICAgIGFyZ3MgPSBbXSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB0b2RlbC5wdXNoKHRoaXNbaW5kZXggKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHRhaWwucHVzaCh0aGlzW2luZGV4ICsgaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2xlbiArIHRhaWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaW5kZXggKyBpXSA9IHRoaXNbaW5kZXggKyBpXSA9IGkgPCBhcmdsZW4gPyBhcmdzW2ldIDogdGFpbFtpIC0gYXJnbGVuXTtcbiAgICAgICAgfVxuICAgICAgICBpID0gdGhpcy5pdGVtcy5sZW5ndGggPSB0aGlzLmxlbmd0aCAtPSBjb3VudCAtIGFyZ2xlbjtcbiAgICAgICAgd2hpbGUgKHRoaXNbaV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2krK107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodG9kZWwpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5leGNsdWRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGdpdmVuIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG4gICAgICoqXG4gICAgIC0gZWxlbWVudCAob2JqZWN0KSBlbGVtZW50IHRvIHJlbW92ZVxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAgaWYgb2JqZWN0IHdhcyBmb3VuZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBzZXRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uZXhjbHVkZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmxlbmd0aDsgaSA8IGlpOyBpKyspIGlmICh0aGlzW2ldID09IGVsKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHNldHByb3RvLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0uaW5zZXJ0QWZ0ZXIoZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgc2V0cHJvdG8uZ2V0QkJveCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHggPSBbXSxcbiAgICAgICAgICAgIHkgPSBbXSxcbiAgICAgICAgICAgIHgyID0gW10sXG4gICAgICAgICAgICB5MiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGg7IGktLTspIGlmICghdGhpcy5pdGVtc1tpXS5yZW1vdmVkKSB7XG4gICAgICAgICAgICB2YXIgYm94ID0gdGhpcy5pdGVtc1tpXS5nZXRCQm94KCk7XG4gICAgICAgICAgICB4LnB1c2goYm94LngpO1xuICAgICAgICAgICAgeS5wdXNoKGJveC55KTtcbiAgICAgICAgICAgIHgyLnB1c2goYm94LnggKyBib3gud2lkdGgpO1xuICAgICAgICAgICAgeTIucHVzaChib3gueSArIGJveC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHggPSBtbWluLmFwcGx5KDAsIHgpO1xuICAgICAgICB5ID0gbW1pbi5hcHBseSgwLCB5KTtcbiAgICAgICAgeDIgPSBtbWF4LmFwcGx5KDAsIHgyKTtcbiAgICAgICAgeTIgPSBtbWF4LmFwcGx5KDAsIHkyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgeTI6IHkyLFxuICAgICAgICAgICAgd2lkdGg6IHgyIC0geCxcbiAgICAgICAgICAgIGhlaWdodDogeTIgLSB5LFxuICAgICAgICAgICAgY3g6IHggKyAoeDIgLSB4KSAvIDIsXG4gICAgICAgICAgICBjeTogeSArICh5MiAtIHkpIC8gMlxuICAgICAgICB9O1xuICAgIH07XG4gICAgc2V0cHJvdG8uY2xvbmUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICBzID0gbmV3IFNldDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBzLnB1c2godGhpcy5pdGVtc1tpXS5jbG9uZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIHNldHByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTbmFwXFx1MjAxOHMgc2V0XCI7XG4gICAgfTtcbiAgICBzZXRwcm90by50eXBlID0gXCJzZXRcIjtcbiAgICAvLyBleHBvcnRcbiAgICBTbmFwLlNldCA9IFNldDtcbiAgICBTbmFwLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNldCA9IG5ldyBTZXQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXQucHVzaC5hcHBseShzZXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgbmFtZXMgPSB7fSxcbiAgICAgICAgcmVVbml0ID0gL1thLXpdKyQvaSxcbiAgICAgICAgU3RyID0gU3RyaW5nO1xuICAgIG5hbWVzLnN0cm9rZSA9IG5hbWVzLmZpbGwgPSBcImNvbG91clwiO1xuICAgIGZ1bmN0aW9uIGdldEVtcHR5KGl0ZW0pIHtcbiAgICAgICAgdmFyIGwgPSBpdGVtWzBdO1xuICAgICAgICBzd2l0Y2ggKGwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcInRcIjogcmV0dXJuIFtsLCAwLCAwXTtcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6IHJldHVybiBbbCwgMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICAgICAgICBjYXNlIFwiclwiOiBpZiAoaXRlbS5sZW5ndGggPT0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMCwgaXRlbVsyXSwgaXRlbVszXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic1wiOiBpZiAoaXRlbS5sZW5ndGggPT0gNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMSwgMSwgaXRlbVszXSwgaXRlbVs0XV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDEsIDFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVxdWFsaXNlVHJhbnNmb3JtKHQxLCB0MiwgZ2V0QkJveCkge1xuICAgICAgICB0MiA9IFN0cih0MikucmVwbGFjZSgvXFwuezN9fFxcdTIwMjYvZywgdDEpO1xuICAgICAgICB0MSA9IFNuYXAucGFyc2VUcmFuc2Zvcm1TdHJpbmcodDEpIHx8IFtdO1xuICAgICAgICB0MiA9IFNuYXAucGFyc2VUcmFuc2Zvcm1TdHJpbmcodDIpIHx8IFtdO1xuICAgICAgICB2YXIgbWF4bGVuZ3RoID0gTWF0aC5tYXgodDEubGVuZ3RoLCB0Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZnJvbSA9IFtdLFxuICAgICAgICAgICAgdG8gPSBbXSxcbiAgICAgICAgICAgIGkgPSAwLCBqLCBqaixcbiAgICAgICAgICAgIHR0MSwgdHQyO1xuICAgICAgICBmb3IgKDsgaSA8IG1heGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0dDEgPSB0MVtpXSB8fCBnZXRFbXB0eSh0MltpXSk7XG4gICAgICAgICAgICB0dDIgPSB0MltpXSB8fCBnZXRFbXB0eSh0dDEpO1xuICAgICAgICAgICAgaWYgKCh0dDFbMF0gIT0gdHQyWzBdKSB8fFxuICAgICAgICAgICAgICAgICh0dDFbMF0udG9Mb3dlckNhc2UoKSA9PSBcInJcIiAmJiAodHQxWzJdICE9IHR0MlsyXSB8fCB0dDFbM10gIT0gdHQyWzNdKSkgfHxcbiAgICAgICAgICAgICAgICAodHQxWzBdLnRvTG93ZXJDYXNlKCkgPT0gXCJzXCIgJiYgKHR0MVszXSAhPSB0dDJbM10gfHwgdHQxWzRdICE9IHR0Mls0XSkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHQxID0gU25hcC5fLnRyYW5zZm9ybTJtYXRyaXgodDEsIGdldEJCb3goKSk7XG4gICAgICAgICAgICAgICAgICAgIHQyID0gU25hcC5fLnRyYW5zZm9ybTJtYXRyaXgodDIsIGdldEJCb3goKSk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBbW1wibVwiLCB0MS5hLCB0MS5iLCB0MS5jLCB0MS5kLCB0MS5lLCB0MS5mXV07XG4gICAgICAgICAgICAgICAgICAgIHRvID0gW1tcIm1cIiwgdDIuYSwgdDIuYiwgdDIuYywgdDIuZCwgdDIuZSwgdDIuZl1dO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21baV0gPSBbXTtcbiAgICAgICAgICAgIHRvW2ldID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IE1hdGgubWF4KHR0MS5sZW5ndGgsIHR0Mi5sZW5ndGgpOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIGogaW4gdHQxICYmIChmcm9tW2ldW2pdID0gdHQxW2pdKTtcbiAgICAgICAgICAgICAgICBqIGluIHR0MiAmJiAodG9baV1bal0gPSB0dDJbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBwYXRoMmFycmF5KGZyb20pLFxuICAgICAgICAgICAgdG86IHBhdGgyYXJyYXkodG8pLFxuICAgICAgICAgICAgZjogZ2V0UGF0aChmcm9tKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROdW1iZXIodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFVuaXQodW5pdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICt2YWwudG9GaXhlZCgzKSArIHVuaXQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZpZXdCb3godmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwuam9pbihcIiBcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbG91cihjbHIpIHtcbiAgICAgICAgcmV0dXJuIFNuYXAucmdiKGNsclswXSwgY2xyWzFdLCBjbHJbMl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQYXRoKHBhdGgpIHtcbiAgICAgICAgdmFyIGsgPSAwLCBpLCBpaSwgaiwgamosIG91dCwgYSwgYiA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgb3V0ID0gXCJbXCI7XG4gICAgICAgICAgICBhID0gWydcIicgKyBwYXRoW2ldWzBdICsgJ1wiJ107XG4gICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhdGhbaV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIGFbal0gPSBcInZhbFtcIiArIChrKyspICsgXCJdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gYSArIFwiXVwiO1xuICAgICAgICAgICAgYltpXSA9IG91dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnVuY3Rpb24oXCJ2YWxcIiwgXCJyZXR1cm4gU25hcC5wYXRoLnRvU3RyaW5nLmNhbGwoW1wiICsgYiArIFwiXSlcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGgyYXJyYXkocGF0aCkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDEsIGpqID0gcGF0aFtpXS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gocGF0aFtpXVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOdW1lcmljKG9iaikge1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUocGFyc2VGbG9hdChvYmopKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJyYXlFcXVhbChhcnIxLCBhcnIyKSB7XG4gICAgICAgIGlmICghU25hcC5pcyhhcnIxLCBcImFycmF5XCIpIHx8ICFTbmFwLmlzKGFycjIsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyMS50b1N0cmluZygpID09IGFycjIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgRWxlbWVudC5wcm90b3R5cGUuZXF1YWwgPSBmdW5jdGlvbiAobmFtZSwgYikge1xuICAgICAgICByZXR1cm4gZXZlKFwic25hcC51dGlsLmVxdWFsXCIsIHRoaXMsIG5hbWUsIGIpLmZpcnN0RGVmaW5lZCgpO1xuICAgIH07XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmVxdWFsXCIsIGZ1bmN0aW9uIChuYW1lLCBiKSB7XG4gICAgICAgIHZhciBBLCBCLCBhID0gU3RyKHRoaXMuYXR0cihuYW1lKSB8fCBcIlwiKSxcbiAgICAgICAgICAgIGVsID0gdGhpcztcbiAgICAgICAgaWYgKGlzTnVtZXJpYyhhKSAmJiBpc051bWVyaWMoYikpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogcGFyc2VGbG9hdChhKSxcbiAgICAgICAgICAgICAgICB0bzogcGFyc2VGbG9hdChiKSxcbiAgICAgICAgICAgICAgICBmOiBnZXROdW1iZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzW25hbWVdID09IFwiY29sb3VyXCIpIHtcbiAgICAgICAgICAgIEEgPSBTbmFwLmNvbG9yKGEpO1xuICAgICAgICAgICAgQiA9IFNuYXAuY29sb3IoYik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IFtBLnIsIEEuZywgQS5iLCBBLm9wYWNpdHldLFxuICAgICAgICAgICAgICAgIHRvOiBbQi5yLCBCLmcsIEIuYiwgQi5vcGFjaXR5XSxcbiAgICAgICAgICAgICAgICBmOiBnZXRDb2xvdXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJ2aWV3Qm94XCIpIHtcbiAgICAgICAgICAgIEEgPSB0aGlzLmF0dHIobmFtZSkudmIuc3BsaXQoXCIgXCIpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgQiA9IGIuc3BsaXQoXCIgXCIpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBBLFxuICAgICAgICAgICAgICAgIHRvOiBCLFxuICAgICAgICAgICAgICAgIGY6IGdldFZpZXdCb3hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJ0cmFuc2Zvcm1cIiB8fCBuYW1lID09IFwiZ3JhZGllbnRUcmFuc2Zvcm1cIiB8fCBuYW1lID09IFwicGF0dGVyblRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIFNuYXAuTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgYiA9IGIudG9UcmFuc2Zvcm1TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghU25hcC5fLnJnVHJhbnNmb3JtLnRlc3QoYikpIHtcbiAgICAgICAgICAgICAgICBiID0gU25hcC5fLnN2Z1RyYW5zZm9ybTJzdHJpbmcoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXF1YWxpc2VUcmFuc2Zvcm0oYSwgYiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRCQm94KDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJkXCIgfHwgbmFtZSA9PSBcInBhdGhcIikge1xuICAgICAgICAgICAgQSA9IFNuYXAucGF0aC50b0N1YmljKGEsIGIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBwYXRoMmFycmF5KEFbMF0pLFxuICAgICAgICAgICAgICAgIHRvOiBwYXRoMmFycmF5KEFbMV0pLFxuICAgICAgICAgICAgICAgIGY6IGdldFBhdGgoQVswXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJwb2ludHNcIikge1xuICAgICAgICAgICAgQSA9IFN0cihhKS5zcGxpdChTbmFwLl8uc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIEIgPSBTdHIoYikuc3BsaXQoU25hcC5fLnNlcGFyYXRvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IEEsXG4gICAgICAgICAgICAgICAgdG86IEIsXG4gICAgICAgICAgICAgICAgZjogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBhVW5pdCA9IGEubWF0Y2gocmVVbml0KSxcbiAgICAgICAgICAgIGJVbml0ID0gU3RyKGIpLm1hdGNoKHJlVW5pdCk7XG4gICAgICAgIGlmIChhVW5pdCAmJiBhcnJheUVxdWFsKGFVbml0LCBiVW5pdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogcGFyc2VGbG9hdChhKSxcbiAgICAgICAgICAgICAgICB0bzogcGFyc2VGbG9hdChiKSxcbiAgICAgICAgICAgICAgICBmOiBnZXRVbml0KGFVbml0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogdGhpcy5hc1BYKG5hbWUpLFxuICAgICAgICAgICAgICAgIHRvOiB0aGlzLmFzUFgobmFtZSwgYiksXG4gICAgICAgICAgICAgICAgZjogZ2V0TnVtYmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLyBcbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iKSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICBoYXMgPSBcImhhc093blByb3BlcnR5XCIsXG4gICAgc3VwcG9ydHNUb3VjaCA9IFwiY3JlYXRlVG91Y2hcIiBpbiBnbG9iLmRvYyxcbiAgICBldmVudHMgPSBbXG4gICAgICAgIFwiY2xpY2tcIiwgXCJkYmxjbGlja1wiLCBcIm1vdXNlZG93blwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNlb3V0XCIsXG4gICAgICAgIFwibW91c2VvdmVyXCIsIFwibW91c2V1cFwiLCBcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGVuZFwiLFxuICAgICAgICBcInRvdWNoY2FuY2VsXCJcbiAgICBdLFxuICAgIHRvdWNoTWFwID0ge1xuICAgICAgICBtb3VzZWRvd246IFwidG91Y2hzdGFydFwiLFxuICAgICAgICBtb3VzZW1vdmU6IFwidG91Y2htb3ZlXCIsXG4gICAgICAgIG1vdXNldXA6IFwidG91Y2hlbmRcIlxuICAgIH0sXG4gICAgZ2V0U2Nyb2xsID0gZnVuY3Rpb24gKHh5LCBlbCkge1xuICAgICAgICB2YXIgbmFtZSA9IHh5ID09IFwieVwiID8gXCJzY3JvbGxUb3BcIiA6IFwic2Nyb2xsTGVmdFwiLFxuICAgICAgICAgICAgZG9jID0gZWwgJiYgZWwubm9kZSA/IGVsLm5vZGUub3duZXJEb2N1bWVudCA6IGdsb2IuZG9jO1xuICAgICAgICByZXR1cm4gZG9jW25hbWUgaW4gZG9jLmRvY3VtZW50RWxlbWVudCA/IFwiZG9jdW1lbnRFbGVtZW50XCIgOiBcImJvZHlcIl1bbmFtZV07XG4gICAgfSxcbiAgICBwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgcHJldmVudFRvdWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcbiAgICBzdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9LFxuICAgIHN0b3BUb3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlYWxOYW1lID0gc3VwcG9ydHNUb3VjaCAmJiB0b3VjaE1hcFt0eXBlXSA/IHRvdWNoTWFwW3R5cGVdIDogdHlwZSxcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxZID0gZ2V0U2Nyb2xsKFwieVwiLCBlbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWCA9IGdldFNjcm9sbChcInhcIiwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzVG91Y2ggJiYgdG91Y2hNYXBbaGFzXSh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXNbaV0udGFyZ2V0ID09IG9iaiB8fCBvYmouY29udGFpbnMoZS50YXJnZXRUb3VjaGVzW2ldLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkZSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGUudGFyZ2V0VG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQgPSBvbGRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgPSBwcmV2ZW50VG91Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24gPSBzdG9wVG91Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHggPSBlLmNsaWVudFggKyBzY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgICB5ID0gZS5jbGllbnRZICsgc2Nyb2xsWTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbChlbGVtZW50LCBlLCB4LCB5KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGUgIT09IHJlYWxOYW1lKSB7XG4gICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcihyZWFsTmFtZSwgZiwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gcmVhbE5hbWUpIHtcbiAgICAgICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHJlYWxOYW1lLCBmLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGRyYWcgPSBbXSxcbiAgICBkcmFnTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB4ID0gZS5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IGUuY2xpZW50WSxcbiAgICAgICAgICAgIHNjcm9sbFkgPSBnZXRTY3JvbGwoXCJ5XCIpLFxuICAgICAgICAgICAgc2Nyb2xsWCA9IGdldFNjcm9sbChcInhcIiksXG4gICAgICAgICAgICBkcmFnaSxcbiAgICAgICAgICAgIGogPSBkcmFnLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgZHJhZ2kgPSBkcmFnW2pdO1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB0b3VjaDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoID0gZS50b3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PSBkcmFnaS5lbC5fZHJhZy5pZCB8fCBkcmFnaS5lbC5ub2RlLmNvbnRhaW5zKHRvdWNoLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB0b3VjaC5jbGllbnRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZS5vcmlnaW5hbEV2ZW50ID8gZS5vcmlnaW5hbEV2ZW50IDogZSkucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRyYWdpLmVsLm5vZGUsXG4gICAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IG5vZGUuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgIC8vIGdsb2Iud2luLm9wZXJhICYmIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIC8vIG5vZGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgLy8gbyA9IGRyYWdpLmVsLnBhcGVyLmdldEVsZW1lbnRCeVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgLy8gbm9kZS5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgICAgICAgIC8vIGdsb2Iud2luLm9wZXJhICYmIChuZXh0ID8gcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBuZXh0KSA6IHBhcmVudC5hcHBlbmRDaGlsZChub2RlKSk7XG4gICAgICAgICAgICAvLyBvICYmIGV2ZShcInNuYXAuZHJhZy5vdmVyLlwiICsgZHJhZ2kuZWwuaWQsIGRyYWdpLmVsLCBvKTtcbiAgICAgICAgICAgIHggKz0gc2Nyb2xsWDtcbiAgICAgICAgICAgIHkgKz0gc2Nyb2xsWTtcbiAgICAgICAgICAgIGV2ZShcInNuYXAuZHJhZy5tb3ZlLlwiICsgZHJhZ2kuZWwuaWQsIGRyYWdpLm1vdmVfc2NvcGUgfHwgZHJhZ2kuZWwsIHggLSBkcmFnaS5lbC5fZHJhZy54LCB5IC0gZHJhZ2kuZWwuX2RyYWcueSwgeCwgeSwgZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdVcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIFNuYXAudW5tb3VzZW1vdmUoZHJhZ01vdmUpLnVubW91c2V1cChkcmFnVXApO1xuICAgICAgICB2YXIgaSA9IGRyYWcubGVuZ3RoLFxuICAgICAgICAgICAgZHJhZ2k7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGRyYWdpID0gZHJhZ1tpXTtcbiAgICAgICAgICAgIGRyYWdpLmVsLl9kcmFnID0ge307XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRyYWcuZW5kLlwiICsgZHJhZ2kuZWwuaWQsIGRyYWdpLmVuZF9zY29wZSB8fCBkcmFnaS5zdGFydF9zY29wZSB8fCBkcmFnaS5tb3ZlX3Njb3BlIHx8IGRyYWdpLmVsLCBlKTtcbiAgICAgICAgICAgIGV2ZS5vZmYoXCJzbmFwLmRyYWcuKi5cIiArIGRyYWdpLmVsLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBkcmFnID0gW107XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5jbGlja1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIGNsaWNrIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5jbGlja1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIGNsaWNrIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5kYmxjbGlja1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIGRvdWJsZSBjbGljayBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuZGJsY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBkb3VibGUgY2xpY2sgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlZG93blxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIG1vdXNlZG93biBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2Vkb3duXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgbW91c2Vkb3duIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBtb3VzZW1vdmUgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlbW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNlbW92ZSBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2VvdXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBtb3VzZW91dCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2VvdXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBtb3VzZW91dCBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2VvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2VvdmVyIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZW92ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBtb3VzZW92ZXIgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNldXBcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBtb3VzZXVwIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZXVwXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgbW91c2V1cCBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG91Y2hzdGFydFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIHRvdWNoc3RhcnQgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoc3RhcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSB0b3VjaHN0YXJ0IGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b3VjaG1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSB0b3VjaG1vdmUgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNobW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIHRvdWNobW92ZSBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG91Y2hlbmRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSB0b3VjaGVuZCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVudG91Y2hlbmRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSB0b3VjaGVuZCBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG91Y2hjYW5jZWxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSB0b3VjaGNhbmNlbCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVudG91Y2hjYW5jZWxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSB0b3VjaGNhbmNlbCBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZm9yICh2YXIgaSA9IGV2ZW50cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIFNuYXBbZXZlbnROYW1lXSA9IGVscHJvdG9bZXZlbnROYW1lXSA9IGZ1bmN0aW9uIChmbiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoU25hcC5pcyhmbiwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGY6IGZuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5iaW5kOiBhZGRFdmVudCh0aGlzLm5vZGUgfHwgZG9jdW1lbnQsIGV2ZW50TmFtZSwgZm4sIHNjb3BlIHx8IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIGlmICh0aGlzLmV2ZW50c1tpXS5uYW1lID09IGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1tpXS5mLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNuYXBbXCJ1blwiICsgZXZlbnROYW1lXSA9XG4gICAgICAgICAgICBlbHByb3RvW1widW5cIiArIGV2ZW50TmFtZV0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIGwgPSBldmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChsLS0pIGlmIChldmVudHNbbF0ubmFtZSA9PSBldmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXZlbnRzW2xdLmYgPT0gZm4gfHwgIWZuKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudHNbbF0udW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5zcGxpY2UobCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICFldmVudHMubGVuZ3RoICYmIGRlbGV0ZSB0aGlzLmV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoZXZlbnRzW2ldKTtcbiAgICB9XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaG92ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgaG92ZXIgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBmX2luIChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgaW5cbiAgICAgLSBmX291dCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGhvdmVyIG91dFxuICAgICAtIGljb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBob3ZlciBpbiBoYW5kbGVyXG4gICAgIC0gb2NvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGhvdmVyIG91dCBoYW5kbGVyXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5ob3ZlciA9IGZ1bmN0aW9uIChmX2luLCBmX291dCwgc2NvcGVfaW4sIHNjb3BlX291dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZW92ZXIoZl9pbiwgc2NvcGVfaW4pLm1vdXNlb3V0KGZfb3V0LCBzY29wZV9vdXQgfHwgc2NvcGVfaW4pO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5ob3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBob3ZlciBldmVudCBoYW5kbGVycyBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gZl9pbiAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGhvdmVyIGluXG4gICAgIC0gZl9vdXQgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBvdXRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnVuaG92ZXIgPSBmdW5jdGlvbiAoZl9pbiwgZl9vdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5tb3VzZW92ZXIoZl9pbikudW5tb3VzZW91dChmX291dCk7XG4gICAgfTtcbiAgICB2YXIgZHJhZ2dhYmxlID0gW107XG4gICAgLy8gU0lFUlJBIHVuY2xlYXIgd2hhdCBfY29udGV4dF8gcmVmZXJzIHRvIGZvciBzdGFydGluZywgZW5kaW5nLCBtb3ZpbmcgdGhlIGRyYWcgZ2VzdHVyZS5cbiAgICAvLyBTSUVSUkEgRWxlbWVudC5kcmFnKCk6IF94IHBvc2l0aW9uIG9mIHRoZSBtb3VzZV86IFdoZXJlIGFyZSB0aGUgeC95IHZhbHVlcyBvZmZzZXQgZnJvbT9cbiAgICAvLyBTSUVSUkEgRWxlbWVudC5kcmFnKCk6IG11Y2ggb2YgdGhpcyBtZW1iZXIncyBkb2MgYXBwZWFycyB0byBiZSBkdXBsaWNhdGVkIGZvciBzb21lIHJlYXNvbi5cbiAgICAvLyBTSUVSUkEgVW5jbGVhciBhYm91dCB0aGlzIHNlbnRlbmNlOiBfQWRkaXRpb25hbGx5IGZvbGxvd2luZyBkcmFnIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZDogZHJhZy5zdGFydC48aWQ+IG9uIHN0YXJ0LCBkcmFnLmVuZC48aWQ+IG9uIGVuZCBhbmQgZHJhZy5tb3ZlLjxpZD4gb24gZXZlcnkgbW92ZS5fIElzIHRoZXJlIGEgZ2xvYmFsIF9kcmFnXyBvYmplY3QgdG8gd2hpY2ggeW91IGNhbiBhc3NpZ24gaGFuZGxlcnMga2V5ZWQgYnkgYW4gZWxlbWVudCdzIElEP1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmRyYWdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGFuIGVsZW1lbnQncyBkcmFnIGdlc3R1cmVcbiAgICAgKipcbiAgICAgLSBvbm1vdmUgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBtb3ZpbmdcbiAgICAgLSBvbnN0YXJ0IChmdW5jdGlvbikgaGFuZGxlciBmb3IgZHJhZyBzdGFydFxuICAgICAtIG9uZW5kIChmdW5jdGlvbikgaGFuZGxlciBmb3IgZHJhZyBlbmRcbiAgICAgLSBtY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgbW92aW5nIGhhbmRsZXJcbiAgICAgLSBzY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgZHJhZyBzdGFydCBoYW5kbGVyXG4gICAgIC0gZWNvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGRyYWcgZW5kIGhhbmRsZXJcbiAgICAgKiBBZGRpdGlvbmFseSBmb2xsb3dpbmcgYGRyYWdgIGV2ZW50cyBhcmUgdHJpZ2dlcmVkOiBgZHJhZy5zdGFydC48aWQ+YCBvbiBzdGFydCwgXG4gICAgICogYGRyYWcuZW5kLjxpZD5gIG9uIGVuZCBhbmQgYGRyYWcubW92ZS48aWQ+YCBvbiBldmVyeSBtb3ZlLiBXaGVuIGVsZW1lbnQgaXMgZHJhZ2dlZCBvdmVyIGFub3RoZXIgZWxlbWVudCBcbiAgICAgKiBgZHJhZy5vdmVyLjxpZD5gIGZpcmVzIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBTdGFydCBldmVudCBhbmQgc3RhcnQgaGFuZGxlciBhcmUgY2FsbGVkIGluIHNwZWNpZmllZCBjb250ZXh0IG9yIGluIGNvbnRleHQgb2YgdGhlIGVsZW1lbnQgd2l0aCBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgbyB4IChudW1iZXIpIHggcG9zaXRpb24gb2YgdGhlIG1vdXNlXG4gICAgIG8geSAobnVtYmVyKSB5IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIGV2ZW50IChvYmplY3QpIERPTSBldmVudCBvYmplY3RcbiAgICAgKiBNb3ZlIGV2ZW50IGFuZCBtb3ZlIGhhbmRsZXIgYXJlIGNhbGxlZCBpbiBzcGVjaWZpZWQgY29udGV4dCBvciBpbiBjb250ZXh0IG9mIHRoZSBlbGVtZW50IHdpdGggZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgIG8gZHggKG51bWJlcikgc2hpZnQgYnkgeCBmcm9tIHRoZSBzdGFydCBwb2ludFxuICAgICBvIGR5IChudW1iZXIpIHNoaWZ0IGJ5IHkgZnJvbSB0aGUgc3RhcnQgcG9pbnRcbiAgICAgbyB4IChudW1iZXIpIHggcG9zaXRpb24gb2YgdGhlIG1vdXNlXG4gICAgIG8geSAobnVtYmVyKSB5IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIGV2ZW50IChvYmplY3QpIERPTSBldmVudCBvYmplY3RcbiAgICAgKiBFbmQgZXZlbnQgYW5kIGVuZCBoYW5kbGVyIGFyZSBjYWxsZWQgaW4gc3BlY2lmaWVkIGNvbnRleHQgb3IgaW4gY29udGV4dCBvZiB0aGUgZWxlbWVudCB3aXRoIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgICBvIGV2ZW50IChvYmplY3QpIERPTSBldmVudCBvYmplY3RcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmRyYWcgPSBmdW5jdGlvbiAob25tb3ZlLCBvbnN0YXJ0LCBvbmVuZCwgbW92ZV9zY29wZSwgc3RhcnRfc2NvcGUsIGVuZF9zY29wZSkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBvcmlnVHJhbnNmb3JtO1xuICAgICAgICAgICAgcmV0dXJuIGVsLmRyYWcoZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogb3JpZ1RyYW5zZm9ybSArIChvcmlnVHJhbnNmb3JtID8gXCJUXCIgOiBcInRcIikgKyBbZHgsIGR5XVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9yaWdUcmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybSgpLmxvY2FsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhcnQoZSwgeCwgeSkge1xuICAgICAgICAgICAgKGUub3JpZ2luYWxFdmVudCB8fCBlKS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZWwuX2RyYWcueCA9IHg7XG4gICAgICAgICAgICBlbC5fZHJhZy55ID0geTtcbiAgICAgICAgICAgIGVsLl9kcmFnLmlkID0gZS5pZGVudGlmaWVyO1xuICAgICAgICAgICAgIWRyYWcubGVuZ3RoICYmIFNuYXAubW91c2Vtb3ZlKGRyYWdNb3ZlKS5tb3VzZXVwKGRyYWdVcCk7XG4gICAgICAgICAgICBkcmFnLnB1c2goe2VsOiBlbCwgbW92ZV9zY29wZTogbW92ZV9zY29wZSwgc3RhcnRfc2NvcGU6IHN0YXJ0X3Njb3BlLCBlbmRfc2NvcGU6IGVuZF9zY29wZX0pO1xuICAgICAgICAgICAgb25zdGFydCAmJiBldmUub24oXCJzbmFwLmRyYWcuc3RhcnQuXCIgKyBlbC5pZCwgb25zdGFydCk7XG4gICAgICAgICAgICBvbm1vdmUgJiYgZXZlLm9uKFwic25hcC5kcmFnLm1vdmUuXCIgKyBlbC5pZCwgb25tb3ZlKTtcbiAgICAgICAgICAgIG9uZW5kICYmIGV2ZS5vbihcInNuYXAuZHJhZy5lbmQuXCIgKyBlbC5pZCwgb25lbmQpO1xuICAgICAgICAgICAgZXZlKFwic25hcC5kcmFnLnN0YXJ0LlwiICsgZWwuaWQsIHN0YXJ0X3Njb3BlIHx8IG1vdmVfc2NvcGUgfHwgZWwsIHgsIHksIGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluaXQoZSwgeCwgeSkge1xuICAgICAgICAgICAgZXZlKFwic25hcC5kcmFnaW5pdC5cIiArIGVsLmlkLCBlbCwgZSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlLm9uKFwic25hcC5kcmFnaW5pdC5cIiArIGVsLmlkLCBzdGFydCk7XG4gICAgICAgIGVsLl9kcmFnID0ge307XG4gICAgICAgIGRyYWdnYWJsZS5wdXNoKHtlbDogZWwsIHN0YXJ0OiBzdGFydCwgaW5pdDogaW5pdH0pO1xuICAgICAgICBlbC5tb3VzZWRvd24oaW5pdCk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qXG4gICAgICogRWxlbWVudC5vbkRyYWdPdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTaG9ydGN1dCB0byBhc3NpZ24gZXZlbnQgaGFuZGxlciBmb3IgYGRyYWcub3Zlci48aWQ+YCBldmVudCwgd2hlcmUgYGlkYCBpcyB0aGUgZWxlbWVudCdzIGBpZGAgKHNlZSBARWxlbWVudC5pZClcbiAgICAgLSBmIChmdW5jdGlvbikgaGFuZGxlciBmb3IgZXZlbnQsIGZpcnN0IGFyZ3VtZW50IHdvdWxkIGJlIHRoZSBlbGVtZW50IHlvdSBhcmUgZHJhZ2dpbmcgb3ZlclxuICAgIFxcKi9cbiAgICAvLyBlbHByb3RvLm9uRHJhZ092ZXIgPSBmdW5jdGlvbiAoZikge1xuICAgIC8vICAgICBmID8gZXZlLm9uKFwic25hcC5kcmFnLm92ZXIuXCIgKyB0aGlzLmlkLCBmKSA6IGV2ZS51bmJpbmQoXCJzbmFwLmRyYWcub3Zlci5cIiArIHRoaXMuaWQpO1xuICAgIC8vIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5kcmFnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGFsbCBkcmFnIGV2ZW50IGhhbmRsZXJzIGZyb20gdGhlIGdpdmVuIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by51bmRyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gZHJhZ2dhYmxlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgaWYgKGRyYWdnYWJsZVtpXS5lbCA9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLnVubW91c2Vkb3duKGRyYWdnYWJsZVtpXS5pbml0KTtcbiAgICAgICAgICAgIGRyYWdnYWJsZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBldmUudW5iaW5kKFwic25hcC5kcmFnLiouXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgICAgIGV2ZS51bmJpbmQoXCJzbmFwLmRyYWdpbml0LlwiICsgdGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgIWRyYWdnYWJsZS5sZW5ndGggJiYgU25hcC51bm1vdXNlbW92ZShkcmFnTW92ZSkudW5tb3VzZXVwKGRyYWdVcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLyBcbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iKSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgcHByb3RvID0gUGFwZXIucHJvdG90eXBlLFxuICAgICAgICByZ3VybCA9IC9eXFxzKnVybFxcKCguKylcXCkvLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgICQgPSBTbmFwLl8uJDtcbiAgICBTbmFwLmZpbHRlciA9IHt9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5maWx0ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPGZpbHRlcj5gIGVsZW1lbnRcbiAgICAgKipcbiAgICAgLSBmaWxzdHIgKHN0cmluZykgU1ZHIGZyYWdtZW50IG9mIGZpbHRlciBwcm92aWRlZCBhcyBhIHN0cmluZ1xuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgICogTm90ZTogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGZpbHRlcnMgZW1iZWRkZWQgaW50byB0aGUgcGFnZSBpbnNpZGUgYW4gZW1wdHkgU1ZHIGVsZW1lbnQuXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgZiA9IHBhcGVyLmZpbHRlcignPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj1cIjJcIi8+JyksXG4gICAgIHwgICAgIGMgPSBwYXBlci5jaXJjbGUoMTAsIDEwLCAxMCkuYXR0cih7XG4gICAgIHwgICAgICAgICBmaWx0ZXI6IGZcbiAgICAgfCAgICAgfSk7XG4gICAgXFwqL1xuICAgIHBwcm90by5maWx0ZXIgPSBmdW5jdGlvbiAoZmlsc3RyKSB7XG4gICAgICAgIHZhciBwYXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChwYXBlci50eXBlICE9IFwic3ZnXCIpIHtcbiAgICAgICAgICAgIHBhcGVyID0gcGFwZXIucGFwZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGYgPSBTbmFwLnBhcnNlKFN0cihmaWxzdHIpKSxcbiAgICAgICAgICAgIGlkID0gU25hcC5fLmlkKCksXG4gICAgICAgICAgICB3aWR0aCA9IHBhcGVyLm5vZGUub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBwYXBlci5ub2RlLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIGZpbHRlciA9ICQoXCJmaWx0ZXJcIik7XG4gICAgICAgICQoZmlsdGVyLCB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBmaWx0ZXJVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZi5ub2RlKTtcbiAgICAgICAgcGFwZXIuZGVmcy5hcHBlbmRDaGlsZChmaWx0ZXIpO1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZmlsdGVyKTtcbiAgICB9O1xuICAgIFxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZpbHRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhciBwID0gJCh0aGlzLm5vZGUsIFwiZmlsdGVyXCIpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gU3RyKHApLm1hdGNoKHJndXJsKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBTbmFwLnNlbGVjdChtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5maWx0ZXJcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgdmFsdWUudHlwZSA9PSBcImZpbHRlclwiKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgdmFyIGlkID0gdmFsdWUubm9kZS5pZDtcbiAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAkKHZhbHVlLm5vZGUsIHtpZDogdmFsdWUuaWR9KTtcbiAgICAgICAgICAgICAgICBpZCA9IHZhbHVlLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IFNuYXAudXJsKGlkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuYmx1clxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGJsdXIgZmlsdGVyXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSBhbW91bnQgb2YgaG9yaXpvbnRhbCBibHVyLCBpbiBwaXhlbHNcbiAgICAgLSB5IChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgb2YgdmVydGljYWwgYmx1ciwgaW4gcGl4ZWxzXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgZiA9IHBhcGVyLmZpbHRlcihTbmFwLmZpbHRlci5ibHVyKDUsIDEwKSksXG4gICAgIHwgICAgIGMgPSBwYXBlci5jaXJjbGUoMTAsIDEwLCAxMCkuYXR0cih7XG4gICAgIHwgICAgICAgICBmaWx0ZXI6IGZcbiAgICAgfCAgICAgfSk7XG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmJsdXIgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICB4ID0gMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmID0geSA9PSBudWxsID8geCA6IFt4LCB5XTtcbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCdcXDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCJ7ZGVmfVwiLz4nLCB7XG4gICAgICAgICAgICBkZWY6IGRlZlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmJsdXIudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuc2hhZG93XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgc2hhZG93IGZpbHRlclxuICAgICAqKlxuICAgICAtIGR4IChudW1iZXIpICNvcHRpb25hbCBob3Jpem9udGFsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIGR5IChudW1iZXIpICNvcHRpb25hbCB2ZXJ0aWNhbCBzaGlmdCBvZiB0aGUgc2hhZG93LCBpbiBwaXhlbHNcbiAgICAgLSBibHVyIChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgb2YgYmx1clxuICAgICAtIGNvbG9yIChzdHJpbmcpICNvcHRpb25hbCBjb2xvciBvZiB0aGUgc2hhZG93XG4gICAgIC0gb3BhY2l0eSAobnVtYmVyKSAjb3B0aW9uYWwgYDAuLjFgIG9wYWNpdHkgb2YgdGhlIHNoYWRvd1xuICAgICAqIG9yXG4gICAgIC0gZHggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gZHkgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIGNvbG9yIChzdHJpbmcpICNvcHRpb25hbCBjb2xvciBvZiB0aGUgc2hhZG93XG4gICAgIC0gb3BhY2l0eSAobnVtYmVyKSAjb3B0aW9uYWwgYDAuLjFgIG9wYWNpdHkgb2YgdGhlIHNoYWRvd1xuICAgICAqIHdoaWNoIG1ha2VzIGJsdXIgZGVmYXVsdCB0byBgNGAuIE9yXG4gICAgIC0gZHggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gZHkgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIG9wYWNpdHkgKG51bWJlcikgI29wdGlvbmFsIGAwLi4xYCBvcGFjaXR5IG9mIHRoZSBzaGFkb3dcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBmID0gcGFwZXIuZmlsdGVyKFNuYXAuZmlsdGVyLnNoYWRvdygwLCAyLCAzKSksXG4gICAgIHwgICAgIGMgPSBwYXBlci5jaXJjbGUoMTAsIDEwLCAxMCkuYXR0cih7XG4gICAgIHwgICAgICAgICBmaWx0ZXI6IGZcbiAgICAgfCAgICAgfSk7XG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLnNoYWRvdyA9IGZ1bmN0aW9uIChkeCwgZHksIGJsdXIsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgYmx1ciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb2xvciA9IGJsdXI7XG4gICAgICAgICAgICBvcGFjaXR5ID0gY29sb3I7XG4gICAgICAgICAgICBibHVyID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbG9yICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9wYWNpdHkgPSBjb2xvcjtcbiAgICAgICAgICAgIGNvbG9yID0gXCIjMDAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29sb3IgPSBjb2xvciB8fCBcIiMwMDBcIjtcbiAgICAgICAgaWYgKGJsdXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgYmx1ciA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wYWNpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgIGR5ID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgZHkgPSBkeDtcbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IFNuYXAuY29sb3IoY29sb3IpO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwie2JsdXJ9XCIvPjxmZU9mZnNldCBkeD1cIntkeH1cIiBkeT1cIntkeX1cIiByZXN1bHQ9XCJvZmZzZXRibHVyXCIvPjxmZUZsb29kIGZsb29kLWNvbG9yPVwie2NvbG9yfVwiLz48ZmVDb21wb3NpdGUgaW4yPVwib2Zmc2V0Ymx1clwiIG9wZXJhdG9yPVwiaW5cIi8+PGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY0EgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie29wYWNpdHl9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVNZXJnZT48ZmVNZXJnZU5vZGUvPjxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIi8+PC9mZU1lcmdlPicsIHtcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGR4OiBkeCxcbiAgICAgICAgICAgIGR5OiBkeSxcbiAgICAgICAgICAgIGJsdXI6IGJsdXIsXG4gICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2hhZG93LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmdyYXlzY2FsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGdyYXlzY2FsZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5ncmF5c2NhbGUgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCJ7YX0ge2J9IHtjfSAwIDAge2R9IHtlfSB7Zn0gMCAwIHtnfSB7Yn0ge2h9IDAgMCAwIDAgMCAxIDBcIi8+Jywge1xuICAgICAgICAgICAgYTogMC4yMTI2ICsgMC43ODc0ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYjogMC43MTUyIC0gMC43MTUyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYzogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZTogMC43MTUyICsgMC4yODQ4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZjogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgaDogMC4wNzIyICsgMC45Mjc4ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuZ3JheXNjYWxlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLnNlcGlhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgc2VwaWEgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuc2VwaWEgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCJ7YX0ge2J9IHtjfSAwIDAge2R9IHtlfSB7Zn0gMCAwIHtnfSB7aH0ge2l9IDAgMCAwIDAgMCAxIDBcIi8+Jywge1xuICAgICAgICAgICAgYTogMC4zOTMgKyAwLjYwNyAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGI6IDAuNzY5IC0gMC43NjkgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBjOiAwLjE4OSAtIDAuMTg5ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4zNDkgLSAwLjM0OSAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGU6IDAuNjg2ICsgMC4zMTQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBmOiAwLjE2OCAtIDAuMTY4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yNzIgLSAwLjI3MiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGg6IDAuNTM0IC0gMC41MzQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBpOiAwLjEzMSArIDAuODY5ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2VwaWEudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuc2F0dXJhdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBzYXR1cmF0ZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29sb3JNYXRyaXggdHlwZT1cInNhdHVyYXRlXCIgdmFsdWVzPVwie2Ftb3VudH1cIi8+Jywge1xuICAgICAgICAgICAgYW1vdW50OiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2F0dXJhdGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuaHVlUm90YXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgaHVlLXJvdGF0ZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbmdsZSAobnVtYmVyKSBhbmdsZSBvZiByb3RhdGlvblxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5odWVSb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgYW5nbGUgPSBhbmdsZSB8fCAwO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJodWVSb3RhdGVcIiB2YWx1ZXM9XCJ7YW5nbGV9XCIvPicsIHtcbiAgICAgICAgICAgIGFuZ2xlOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmh1ZVJvdGF0ZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5pbnZlcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBpbnZlcnQgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuaW52ZXJ0ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFtb3VudCA9IDE7XG4gICAgICAgIH1cbi8vICAgICAgICA8ZmVDb2xvck1hdHJpeCB0eXBlPVwibWF0cml4XCIgdmFsdWVzPVwiLTEgMCAwIDAgMSAgMCAtMSAwIDAgMSAgMCAwIC0xIDAgMSAgMCAwIDAgMSAwXCIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPVwic1JHQlwiLz5cbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCc8ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48ZmVGdW5jRyB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48ZmVGdW5jQiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48L2ZlQ29tcG9uZW50VHJhbnNmZXI+Jywge1xuICAgICAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICAgICAgICBhbW91bnQyOiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuaW52ZXJ0LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmJyaWdodG5lc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBicmlnaHRuZXNzIGZpbHRlclxuICAgICAqKlxuICAgICAtIGFtb3VudCAobnVtYmVyKSBhbW91bnQgb2YgZmlsdGVyIChgMC4uMWApXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmJyaWdodG5lc3MgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbXBvbmVudFRyYW5zZmVyPjxmZUZ1bmNSIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjxmZUZ1bmNHIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjxmZUZ1bmNCIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj4nLCB7XG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmJyaWdodG5lc3MudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuY29udHJhc3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBjb250cmFzdCBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5jb250cmFzdCA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY1IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PGZlRnVuY0cgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PGZlRnVuY0IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPicsIHtcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgYW1vdW50MjogLjUgLSBhbW91bnQgLyAyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuY29udHJhc3QudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGJveCA9IFNuYXAuXy5ib3gsXG4gICAgICAgIGlzID0gU25hcC5pcyxcbiAgICAgICAgZmlyc3RMZXR0ZXIgPSAvXlteYS16XSooW3RibWxyY10pL2ksXG4gICAgICAgIHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVFwiICsgdGhpcy5keCArIFwiLFwiICsgdGhpcy5keTtcbiAgICAgICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXRBbGlnblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBzaGlmdCBuZWVkZWQgdG8gYWxpZ24gdGhlIGVsZW1lbnQgcmVsYXRpdmVseSB0byBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIG5vIGVsZW1lbnRzIHNwZWNpZmllZCwgcGFyZW50IGA8c3ZnPmAgY29udGFpbmVyIHdpbGwgYmUgdXNlZC5cbiAgICAgLSBlbCAob2JqZWN0KSBAb3B0aW9uYWwgYWxpZ25tZW50IGVsZW1lbnRcbiAgICAgLSB3YXkgKHN0cmluZykgb25lIG9mIHNpeCB2YWx1ZXM6IGBcInRvcFwiYCwgYFwibWlkZGxlXCJgLCBgXCJib3R0b21cImAsIGBcImxlZnRcImAsIGBcImNlbnRlclwiYCwgYFwicmlnaHRcImBcbiAgICAgPSAob2JqZWN0fHN0cmluZykgT2JqZWN0IGluIGZvcm1hdCBge2R4OiAsIGR5OiB9YCBhbHNvIGhhcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBhIHRyYW5zZm9ybWF0aW9uIHN0cmluZ1xuICAgICA+IFVzYWdlXG4gICAgIHwgZWwudHJhbnNmb3JtKGVsLmdldEFsaWduKGVsMiwgXCJ0b3BcIikpO1xuICAgICAqIG9yXG4gICAgIHwgdmFyIGR5ID0gZWwuZ2V0QWxpZ24oZWwyLCBcInRvcFwiKS5keTtcbiAgICBcXCovXG4gICAgRWxlbWVudC5wcm90b3R5cGUuZ2V0QWxpZ24gPSBmdW5jdGlvbiAoZWwsIHdheSkge1xuICAgICAgICBpZiAod2F5ID09IG51bGwgJiYgaXMoZWwsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICB3YXkgPSBlbDtcbiAgICAgICAgICAgIGVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsIHx8IHRoaXMucGFwZXI7XG4gICAgICAgIHZhciBieCA9IGVsLmdldEJCb3ggPyBlbC5nZXRCQm94KCkgOiBib3goZWwpLFxuICAgICAgICAgICAgYmIgPSB0aGlzLmdldEJCb3goKSxcbiAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICB3YXkgPSB3YXkgJiYgd2F5Lm1hdGNoKGZpcnN0TGV0dGVyKTtcbiAgICAgICAgd2F5ID0gd2F5ID8gd2F5WzFdLnRvTG93ZXJDYXNlKCkgOiBcImNcIjtcbiAgICAgICAgc3dpdGNoICh3YXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gMDtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSBieC55IC0gYmIueTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgICAgICAgICBvdXQuZHggPSAwO1xuICAgICAgICAgICAgICAgIG91dC5keSA9IGJ4LnkyIC0gYmIueTI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gMDtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSBieC5jeSAtIGJiLmN5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibFwiOlxuICAgICAgICAgICAgICAgIG91dC5keCA9IGJ4LnggLSBiYi54O1xuICAgICAgICAgICAgICAgIG91dC5keSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gYngueDIgLSBiYi54MjtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG91dC5keCA9IGJ4LmN4IC0gYmIuY3g7XG4gICAgICAgICAgICAgICAgb3V0LmR5ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG91dC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWxpZ25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFsaWducyB0aGUgZWxlbWVudCByZWxhdGl2ZWx5IHRvIGdpdmVuIG9uZSB2aWEgdHJhbnNmb3JtYXRpb24uXG4gICAgICogSWYgbm8gZWxlbWVudHMgc3BlY2lmaWVkLCBwYXJlbnQgYDxzdmc+YCBjb250YWluZXIgd2lsbCBiZSB1c2VkLlxuICAgICAtIGVsIChvYmplY3QpIEBvcHRpb25hbCBhbGlnbm1lbnQgZWxlbWVudFxuICAgICAtIHdheSAoc3RyaW5nKSBvbmUgb2Ygc2l4IHZhbHVlczogYFwidG9wXCJgLCBgXCJtaWRkbGVcImAsIGBcImJvdHRvbVwiYCwgYFwibGVmdFwiYCwgYFwiY2VudGVyXCJgLCBgXCJyaWdodFwiYFxuICAgICA9IChvYmplY3QpIHRoaXMgZWxlbWVudFxuICAgICA+IFVzYWdlXG4gICAgIHwgZWwuYWxpZ24oZWwyLCBcInRvcFwiKTtcbiAgICAgKiBvclxuICAgICB8IGVsLmFsaWduKFwibWlkZGxlXCIpO1xuICAgIFxcKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5hbGlnbiA9IGZ1bmN0aW9uIChlbCwgd2F5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShcIi4uLlwiICsgdGhpcy5nZXRBbGlnbihlbCwgd2F5KSk7XG4gICAgfTtcbn0pO1xuXG5yZXR1cm4gU25hcDtcbn0pKTtcbiIsIi8vLy8vICAgIC8vLy8vICAgIC8vLy8vICAgIC8vLy8vXG4vLy8vLyAgICAvLy8vLyAgICAvLy8vLyAgICAvLy8vL1xuLy8vLy8gICAgLy8vLy8gICAgLy8vLy8gICAgLy8vLy9cbi8vLy8vICAgIC8vLy8vICAgIC8vLy8vICAgIC8vLy8vXG4vLy8vLyAgICAgICAgICAgICAvLy8vLyAgICAvLy8vL1xuLy8vLy8gICAgICAgICAgICAgLy8vLy8gICAgLy8vLy9cbi8vLy8vICAgIC8vLy8vICAgIC8vLy8vICAgIC8vLy8vXG4vLy8vLyAgICAvLy8vLyAgICAvLy8vLyAgICAvLy8vL1xuICAgICAgICAgLy8vLy8gICAgLy8vLy9cbiAgICAgICAgIC8vLy8vICAgIC8vLy8vXG4vLy8vLyAgICAvLy8vLyAgICAvLy8vLyAgICAvLy8vL1xuLy8vLy8gICAgLy8vLy8gICAgLy8vLy8gICAgLy8vLy9cbi8vLy8vICAgIC8vLy8vICAgIC8vLy8vICAgIC8vLy8vXG4vLy8vLyAgICAvLy8vLyAgICAvLy8vLyAgICAvLy8vL1xuXG4vKipcbiAqIFNjcm9sbFJldmVhbFxuICogLS0tLS0tLS0tLS0tXG4gKiBWZXJzaW9uIDogMy4zLjFcbiAqIFdlYnNpdGUgOiBzY3JvbGxyZXZlYWxqcy5vcmdcbiAqIFJlcG8gICAgOiBnaXRodWIuY29tL2psbWFrZXMvc2Nyb2xscmV2ZWFsLmpzXG4gKiBBdXRob3IgIDogSnVsaWFuIExsb3lkIChAamxtYWtlcylcbiAqL1xuXG47KGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgdmFyIHNyXG4gIHZhciBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cbiAgZnVuY3Rpb24gU2Nyb2xsUmV2ZWFsIChjb25maWcpIHtcbiAgICAvLyBTdXBwb3J0IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgYG5ld2Aga2V5d29yZC5cbiAgICBpZiAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gU2Nyb2xsUmV2ZWFsLnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuIG5ldyBTY3JvbGxSZXZlYWwoY29uZmlnKVxuICAgIH1cblxuICAgIHNyID0gdGhpcyAvLyBTYXZlIHJlZmVyZW5jZSB0byBpbnN0YW5jZS5cbiAgICBzci52ZXJzaW9uID0gJzMuMy4xJ1xuICAgIHNyLnRvb2xzID0gbmV3IFRvb2xzKCkgLy8gKnJlcXVpcmVkIHV0aWxpdGllc1xuXG4gICAgaWYgKHNyLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIHNyLnRvb2xzLmV4dGVuZChzci5kZWZhdWx0cywgY29uZmlnIHx8IHt9KVxuXG4gICAgICBfcmVzb2x2ZUNvbnRhaW5lcihzci5kZWZhdWx0cylcblxuICAgICAgc3Iuc3RvcmUgPSB7XG4gICAgICAgIGVsZW1lbnRzOiB7fSxcbiAgICAgICAgY29udGFpbmVyczogW11cbiAgICAgIH1cblxuICAgICAgc3Iuc2VxdWVuY2VzID0ge31cbiAgICAgIHNyLmhpc3RvcnkgPSBbXVxuICAgICAgc3IudWlkID0gMFxuICAgICAgc3IuaW5pdGlhbGl6ZWQgPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUgIT09IG51bGwpIHtcbiAgICAgIC8vIE5vdGU6IElFOSBvbmx5IHN1cHBvcnRzIGNvbnNvbGUgaWYgZGV2dG9vbHMgYXJlIG9wZW4uXG4gICAgICBjb25zb2xlLmxvZygnU2Nyb2xsUmV2ZWFsIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLicpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNyXG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tXG4gICAqIFRoaXMgb2JqZWN0IHNpZ25hdHVyZSBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBTY3JvbGxSZXZlYWwgY29uc3RydWN0b3IsXG4gICAqIG9yIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgdGhlIGByZXZlYWwoKWAgbWV0aG9kLlxuICAgKi9cblxuICBTY3JvbGxSZXZlYWwucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICAgIC8vICdib3R0b20nLCAnbGVmdCcsICd0b3AnLCAncmlnaHQnXG4gICAgb3JpZ2luOiAnYm90dG9tJyxcblxuICAgIC8vIENhbiBiZSBhbnkgdmFsaWQgQ1NTIGRpc3RhbmNlLCBlLmcuICc1cmVtJywgJzEwJScsICcyMHZ3JywgZXRjLlxuICAgIGRpc3RhbmNlOiAnMjBweCcsXG5cbiAgICAvLyBUaW1lIGluIG1pbGxpc2Vjb25kcy5cbiAgICBkdXJhdGlvbjogNTAwLFxuICAgIGRlbGF5OiAwLFxuXG4gICAgLy8gU3RhcnRpbmcgYW5nbGVzIGluIGRlZ3JlZXMsIHdpbGwgdHJhbnNpdGlvbiBmcm9tIHRoZXNlIHZhbHVlcyB0byAwIGluIGFsbCBheGVzLlxuICAgIHJvdGF0ZTogeyB4OiAwLCB5OiAwLCB6OiAwIH0sXG5cbiAgICAvLyBTdGFydGluZyBvcGFjaXR5IHZhbHVlLCBiZWZvcmUgdHJhbnNpdGlvbmluZyB0byB0aGUgY29tcHV0ZWQgb3BhY2l0eS5cbiAgICBvcGFjaXR5OiAwLFxuXG4gICAgLy8gU3RhcnRpbmcgc2NhbGUgdmFsdWUsIHdpbGwgdHJhbnNpdGlvbiBmcm9tIHRoaXMgdmFsdWUgdG8gMVxuICAgIHNjYWxlOiAwLjksXG5cbiAgICAvLyBBY2NlcHRzIGFueSB2YWxpZCBDU1MgZWFzaW5nLCBlLmcuICdlYXNlJywgJ2Vhc2UtaW4tb3V0JywgJ2xpbmVhcicsIGV0Yy5cbiAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMC42LCAwLjIsIDAuMSwgMSknLFxuXG4gICAgLy8gYDxodG1sPmAgaXMgdGhlIGRlZmF1bHQgcmV2ZWFsIGNvbnRhaW5lci4gWW91IGNhbiBwYXNzIGVpdGhlcjpcbiAgICAvLyBET00gTm9kZSwgZS5nLiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9vQ29udGFpbmVyJylcbiAgICAvLyBTZWxlY3RvciwgZS5nLiAnLmZvb0NvbnRhaW5lcidcbiAgICBjb250YWluZXI6IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cbiAgICAvLyB0cnVlL2ZhbHNlIHRvIGNvbnRyb2wgcmV2ZWFsIGFuaW1hdGlvbnMgb24gbW9iaWxlLlxuICAgIG1vYmlsZTogdHJ1ZSxcblxuICAgIC8vIHRydWU6ICByZXZlYWxzIG9jY3VyIGV2ZXJ5IHRpbWUgZWxlbWVudHMgYmVjb21lIHZpc2libGVcbiAgICAvLyBmYWxzZTogcmV2ZWFscyBvY2N1ciBvbmNlIGFzIGVsZW1lbnRzIGJlY29tZSB2aXNpYmxlXG4gICAgcmVzZXQ6IGZhbHNlLFxuXG4gICAgLy8gJ2Fsd2F5cycg4oCUIGRlbGF5IGZvciBhbGwgcmV2ZWFsIGFuaW1hdGlvbnNcbiAgICAvLyAnb25jZScgICDigJQgZGVsYXkgb25seSB0aGUgZmlyc3QgdGltZSByZXZlYWxzIG9jY3VyXG4gICAgLy8gJ29ubG9hZCcgLSBkZWxheSBvbmx5IGZvciBhbmltYXRpb25zIHRyaWdnZXJlZCBieSBmaXJzdCBsb2FkXG4gICAgdXNlRGVsYXk6ICdhbHdheXMnLFxuXG4gICAgLy8gQ2hhbmdlIHdoZW4gYW4gZWxlbWVudCBpcyBjb25zaWRlcmVkIGluIHRoZSB2aWV3cG9ydC4gVGhlIGRlZmF1bHQgdmFsdWVcbiAgICAvLyBvZiAwLjIwIG1lYW5zIDIwJSBvZiBhbiBlbGVtZW50IG11c3QgYmUgdmlzaWJsZSBmb3IgaXRzIHJldmVhbCB0byBvY2N1ci5cbiAgICB2aWV3RmFjdG9yOiAwLjIsXG5cbiAgICAvLyBQaXhlbCB2YWx1ZXMgdGhhdCBhbHRlciB0aGUgY29udGFpbmVyIGJvdW5kYXJpZXMuXG4gICAgLy8gZS5nLiBTZXQgYHsgdG9wOiA0OCB9YCwgaWYgeW91IGhhdmUgYSA0OHB4IHRhbGwgZml4ZWQgdG9vbGJhci5cbiAgICAvLyAtLVxuICAgIC8vIFZpc3VhbCBBaWQ6IGh0dHBzOi8vc2Nyb2xscmV2ZWFsanMub3JnL2Fzc2V0cy92aWV3b2Zmc2V0LnBuZ1xuICAgIHZpZXdPZmZzZXQ6IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwIH0sXG5cbiAgICAvLyBDYWxsYmFja3MgdGhhdCBmaXJlIGZvciBlYWNoIGNvbXBsZXRlZCBlbGVtZW50IHJldmVhbCwgYW5kIGlmXG4gICAgLy8gYGNvbmZpZy5yZXNldCA9IHRydWVgLCBmb3IgZWFjaCBjb21wbGV0ZWQgZWxlbWVudCByZXNldC4gV2hlbiBjcmVhdGluZyB5b3VyXG4gICAgLy8gY2FsbGJhY2tzLCByZW1lbWJlciB0aGV5IGFyZSBwYXNzZWQgdGhlIGVsZW1lbnTigJlzIERPTSBub2RlIHRoYXQgdHJpZ2dlcmVkXG4gICAgLy8gaXQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgIGJlZm9yZVJldmVhbDogZnVuY3Rpb24gKGRvbUVsKSB7fSxcbiAgICBhZnRlclJldmVhbDogZnVuY3Rpb24gKGRvbUVsKSB7fSxcbiAgICBiZWZvcmVSZXNldDogZnVuY3Rpb24gKGRvbUVsKSB7fSxcbiAgICBhZnRlclJlc2V0OiBmdW5jdGlvbiAoZG9tRWwpIHt9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgY2xpZW50IHN1cHBvcnRzIENTUyBUcmFuc2Zvcm0gYW5kIENTUyBUcmFuc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgU2Nyb2xsUmV2ZWFsLnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVcbiAgICByZXR1cm4gJ1dlYmtpdFRyYW5zaXRpb24nIGluIHN0eWxlICYmICdXZWJraXRUcmFuc2Zvcm0nIGluIHN0eWxlIHx8XG4gICAgICAndHJhbnNpdGlvbicgaW4gc3R5bGUgJiYgJ3RyYW5zZm9ybScgaW4gc3R5bGVcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmV2ZWFsIHNldCwgYSBncm91cCBvZiBlbGVtZW50cyB0aGF0IHdpbGwgYW5pbWF0ZSB3aGVuIHRoZXlcbiAgICogYmVjb21lIHZpc2libGUuIElmIFtpbnRlcnZhbF0gaXMgcHJvdmlkZWQsIGEgbmV3IHNlcXVlbmNlIGlzIGNyZWF0ZWRcbiAgICogdGhhdCB3aWxsIGVuc3VyZSBlbGVtZW50cyByZXZlYWwgaW4gdGhlIG9yZGVyIHRoZXkgYXBwZWFyIGluIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZXxOb2RlTGlzdHxzdHJpbmd9IFt0YXJnZXRdICAgVGhlIG5vZGUsIG5vZGUgbGlzdCBvciBzZWxlY3RvciB0byB1c2UgZm9yIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgW2NvbmZpZ10gICBPdmVycmlkZSB0aGUgZGVmYXVsdHMgZm9yIHRoaXMgcmV2ZWFsIHNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgW2ludGVydmFsXSBUaW1lIGJldHdlZW4gc2VxdWVuY2VkIGVsZW1lbnQgYW5pbWF0aW9ucyAobWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgW3N5bmNdICAgICBVc2VkIGludGVybmFsbHkgd2hlbiB1cGRhdGluZyByZXZlYWxzIGZvciBhc3luYyBjb250ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjdXJyZW50IFNjcm9sbFJldmVhbCBpbnN0YW5jZS5cbiAgICovXG4gIFNjcm9sbFJldmVhbC5wcm90b3R5cGUucmV2ZWFsID0gZnVuY3Rpb24gKHRhcmdldCwgY29uZmlnLCBpbnRlcnZhbCwgc3luYykge1xuICAgIHZhciBjb250YWluZXJcbiAgICB2YXIgZWxlbWVudHNcbiAgICB2YXIgZWxlbVxuICAgIHZhciBlbGVtSWRcbiAgICB2YXIgc2VxdWVuY2VcbiAgICB2YXIgc2VxdWVuY2VJZFxuXG4gICAgLy8gTm8gY3VzdG9tIGNvbmZpZ3VyYXRpb24gd2FzIHBhc3NlZCwgYnV0IGEgc2VxdWVuY2UgaW50ZXJ2YWwgaW5zdGVhZC5cbiAgICAvLyBsZXTigJlzIHNodWZmbGUgdGhpbmdzIGFyb3VuZCB0byBtYWtlIHN1cmUgZXZlcnl0aGluZyB3b3Jrcy5cbiAgICBpZiAoY29uZmlnICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNvbmZpZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGludGVydmFsID0gY29uZmlnXG4gICAgICBjb25maWcgPSB7fVxuICAgIH0gZWxzZSBpZiAoY29uZmlnID09PSB1bmRlZmluZWQgfHwgY29uZmlnID09PSBudWxsKSB7XG4gICAgICBjb25maWcgPSB7fVxuICAgIH1cblxuICAgIGNvbnRhaW5lciA9IF9yZXNvbHZlQ29udGFpbmVyKGNvbmZpZylcbiAgICBlbGVtZW50cyA9IF9nZXRSZXZlYWxFbGVtZW50cyh0YXJnZXQsIGNvbnRhaW5lcilcblxuICAgIGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygnU2Nyb2xsUmV2ZWFsOiByZXZlYWwgb24gXCInICsgdGFyZ2V0ICsgJ1wiIGZhaWxlZCwgbm8gZWxlbWVudHMgZm91bmQuJylcbiAgICAgIHJldHVybiBzclxuICAgIH1cblxuICAgIC8vIFByZXBhcmUgYSBuZXcgc2VxdWVuY2UgaWYgYW4gaW50ZXJ2YWwgaXMgcGFzc2VkLlxuICAgIGlmIChpbnRlcnZhbCAmJiB0eXBlb2YgaW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICBzZXF1ZW5jZUlkID0gX25leHRVaWQoKVxuXG4gICAgICBzZXF1ZW5jZSA9IHNyLnNlcXVlbmNlc1tzZXF1ZW5jZUlkXSA9IHtcbiAgICAgICAgaWQ6IHNlcXVlbmNlSWQsXG4gICAgICAgIGludGVydmFsOiBpbnRlcnZhbCxcbiAgICAgICAgZWxlbUlkczogW10sXG4gICAgICAgIGFjdGl2ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCZWdpbiBtYWluIGxvb3AgdG8gY29uZmlndXJlIFNjcm9sbFJldmVhbCBlbGVtZW50cy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGNvbmZpZ3VyZWQgYW5kIGdyYWIgaXQgZnJvbSB0aGUgc3RvcmUuXG4gICAgICBlbGVtSWQgPSBlbGVtZW50c1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3ItaWQnKVxuICAgICAgaWYgKGVsZW1JZCkge1xuICAgICAgICBlbGVtID0gc3Iuc3RvcmUuZWxlbWVudHNbZWxlbUlkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBsZXTigJlzIGRvIHNvbWUgYmFzaWMgc2V0dXAuXG4gICAgICAgIGVsZW0gPSB7XG4gICAgICAgICAgaWQ6IF9uZXh0VWlkKCksXG4gICAgICAgICAgZG9tRWw6IGVsZW1lbnRzW2ldLFxuICAgICAgICAgIHNlZW46IGZhbHNlLFxuICAgICAgICAgIHJldmVhbGluZzogZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBlbGVtLmRvbUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zci1pZCcsIGVsZW0uaWQpXG4gICAgICB9XG5cbiAgICAgIC8vIFNlcXVlbmNlIG9ubHkgc2V0dXBcbiAgICAgIGlmIChzZXF1ZW5jZSkge1xuICAgICAgICBlbGVtLnNlcXVlbmNlID0ge1xuICAgICAgICAgIGlkOiBzZXF1ZW5jZS5pZCxcbiAgICAgICAgICBpbmRleDogc2VxdWVuY2UuZWxlbUlkcy5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcXVlbmNlLmVsZW1JZHMucHVzaChlbGVtLmlkKVxuICAgICAgfVxuXG4gICAgICAvLyBOZXcgb3IgZXhpc3RpbmcgZWxlbWVudCwgaXTigJlzIHRpbWUgdG8gdXBkYXRlIGl0cyBjb25maWd1cmF0aW9uLCBzdHlsZXMsXG4gICAgICAvLyBhbmQgc2VuZCB0aGUgdXBkYXRlcyB0byBvdXIgc3RvcmUuXG4gICAgICBfY29uZmlndXJlKGVsZW0sIGNvbmZpZywgY29udGFpbmVyKVxuICAgICAgX3N0eWxlKGVsZW0pXG4gICAgICBfdXBkYXRlU3RvcmUoZWxlbSlcblxuICAgICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgZWxlbWVudHMgYXJlIHNldCB0byB2aXNpYmlsaXR5OiB2aXNpYmxlLCBldmVuIHdoZW5cbiAgICAgIC8vIG9uIG1vYmlsZSBhbmQgYGNvbmZpZy5tb2JpbGUgPT09IGZhbHNlYCwgb3IgaWYgdW5zdXBwb3J0ZWQuXG4gICAgICBpZiAoc3IudG9vbHMuaXNNb2JpbGUoKSAmJiAhZWxlbS5jb25maWcubW9iaWxlIHx8ICFzci5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGVsZW0uZG9tRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIGVsZW0uc3R5bGVzLmlubGluZSlcbiAgICAgICAgZWxlbS5kaXNhYmxlZCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW0ucmV2ZWFsaW5nKSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgcHJvY2VlZCBub3JtYWxseS5cbiAgICAgICAgZWxlbS5kb21FbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJyxcbiAgICAgICAgICBlbGVtLnN0eWxlcy5pbmxpbmUgK1xuICAgICAgICAgIGVsZW0uc3R5bGVzLnRyYW5zZm9ybS5pbml0aWFsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFYWNoIGByZXZlYWwoKWAgaXMgcmVjb3JkZWQgc28gdGhhdCB3aGVuIGNhbGxpbmcgYHN5bmMoKWAgd2hpbGUgd29ya2luZ1xuICAgIC8vIHdpdGggYXN5bmNocm9ub3VzbHkgbG9hZGVkIGNvbnRlbnQsIGl0IGNhbiByZS10cmFjZSB5b3VyIHN0ZXBzIGJ1dCB3aXRoXG4gICAgLy8gYWxsIHlvdXIgbmV3IGVsZW1lbnRzIG5vdyBpbiB0aGUgRE9NLlxuXG4gICAgLy8gU2luY2UgYHJldmVhbCgpYCBpcyBjYWxsZWQgaW50ZXJuYWxseSBieSBgc3luYygpYCwgd2UgZG9u4oCZdCB3YW50IHRvXG4gICAgLy8gcmVjb3JkIG9yIGludGlpYWxpemUgZWFjaCByZXZlYWwgZHVyaW5nIHN5bmNpbmcuXG4gICAgaWYgKCFzeW5jICYmIHNyLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIF9yZWNvcmQodGFyZ2V0LCBjb25maWcsIGludGVydmFsKVxuXG4gICAgICAvLyBXZSBwdXNoIGluaXRpYWxpemF0aW9uIHRvIHRoZSBldmVudCBxdWV1ZSB1c2luZyBzZXRUaW1lb3V0LCBzbyB0aGF0IHdlIGNhblxuICAgICAgLy8gZ2l2ZSBTY3JvbGxSZXZlYWwgcm9vbSB0byBwcm9jZXNzIGFsbCByZXZlYWwgY2FsbHMgYmVmb3JlIHB1dHRpbmcgdGhpbmdzIGludG8gbW90aW9uLlxuICAgICAgLy8gLS1cbiAgICAgIC8vIFBoaWxpcCBSb2JlcnRzIC0gV2hhdCB0aGUgaGVjayBpcyB0aGUgZXZlbnQgbG9vcCBhbnl3YXk/IChKU0NvbmYgRVUgMjAxNClcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9OGFHaFpRa29GYlFcbiAgICAgIGlmIChzci5pbml0VGltZW91dCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHNyLmluaXRUaW1lb3V0KVxuICAgICAgfVxuICAgICAgc3IuaW5pdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChfaW5pdCwgMClcbiAgICB9XG5cbiAgICByZXR1cm4gc3JcbiAgfVxuXG4gIC8qKlxuICAgKiBSZS1ydW5zIGByZXZlYWwoKWAgZm9yIGVhY2ggcmVjb3JkIHN0b3JlZCBpbiBoaXN0b3J5LCBlZmZlY3RpdmVseSBjYXB0dXJpbmdcbiAgICogYW55IGNvbnRlbnQgbG9hZGVkIGFzeW5jaHJvbm91c2x5IHRoYXQgbWF0Y2hlcyBleGlzdGluZyByZXZlYWwgc2V0IHRhcmdldHMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGN1cnJlbnQgU2Nyb2xsUmV2ZWFsIGluc3RhbmNlLlxuICAgKi9cbiAgU2Nyb2xsUmV2ZWFsLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzci5oaXN0b3J5Lmxlbmd0aCAmJiBzci5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyLmhpc3RvcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IHNyLmhpc3RvcnlbaV1cbiAgICAgICAgc3IucmV2ZWFsKHJlY29yZC50YXJnZXQsIHJlY29yZC5jb25maWcsIHJlY29yZC5pbnRlcnZhbCwgdHJ1ZSlcbiAgICAgIH1cbiAgICAgIF9pbml0KClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ1Njcm9sbFJldmVhbDogc3luYyBmYWlsZWQsIG5vIHJldmVhbHMgZm91bmQuJylcbiAgICB9XG4gICAgcmV0dXJuIHNyXG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBNZXRob2RzXG4gICAqIC0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBmdW5jdGlvbiBfcmVzb2x2ZUNvbnRhaW5lciAoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcuY29udGFpbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoY29uZmlnLmNvbnRhaW5lcilcbiAgICAgIH0gZWxzZSBpZiAoc3IudG9vbHMuaXNOb2RlKGNvbmZpZy5jb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuY29udGFpbmVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnU2Nyb2xsUmV2ZWFsOiBpbnZhbGlkIGNvbnRhaW5lciBcIicgKyBjb25maWcuY29udGFpbmVyICsgJ1wiIHByb3ZpZGVkLicpXG4gICAgICAgIGNvbnNvbGUubG9nKCdTY3JvbGxSZXZlYWw6IGZhbGxpbmcgYmFjayB0byBkZWZhdWx0IGNvbnRhaW5lci4nKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3IuZGVmYXVsdHMuY29udGFpbmVyXG4gIH1cblxuICAvKipcbiAgICogY2hlY2sgdG8gc2VlIGlmIGEgbm9kZSBvciBub2RlIGxpc3Qgd2FzIHBhc3NlZCBpbiBhcyB0aGUgdGFyZ2V0LFxuICAgKiBvdGhlcndpc2UgcXVlcnkgdGhlIGNvbnRhaW5lciB1c2luZyB0YXJnZXQgYXMgYSBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfE5vZGVMaXN0fHN0cmluZ30gW3RhcmdldF0gICAgY2xpZW50IGlucHV0IGZvciByZXZlYWwgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge05vZGV9ICAgICAgICAgICAgICAgICBbY29udGFpbmVyXSBwYXJlbnQgZWxlbWVudCBmb3Igc2VsZWN0b3IgcXVlcmllcy5cbiAgICpcbiAgICogQHJldHVybiB7YXJyYXl9IGVsZW1lbnRzIHRvIGJlIHJldmVhbGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFJldmVhbEVsZW1lbnRzICh0YXJnZXQsIGNvbnRhaW5lcikge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCkpXG4gICAgfSBlbHNlIGlmIChzci50b29scy5pc05vZGUodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIFt0YXJnZXRdXG4gICAgfSBlbHNlIGlmIChzci50b29scy5pc05vZGVMaXN0KHRhcmdldCkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0YXJnZXQpXG4gICAgfVxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEEgY29uc2lzdGVudCB3YXkgb2YgY3JlYXRpbmcgdW5pcXVlIElEcy5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIF9uZXh0VWlkICgpIHtcbiAgICByZXR1cm4gKytzci51aWRcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jb25maWd1cmUgKGVsZW0sIGNvbmZpZywgY29udGFpbmVyKSB7XG4gICAgLy8gSWYgYSBjb250YWluZXIgd2FzIHBhc3NlZCBhcyBhIHBhcnQgb2YgdGhlIGNvbmZpZyBvYmplY3QsXG4gICAgLy8gbGV04oCZcyBvdmVyd3JpdGUgaXQgd2l0aCB0aGUgcmVzb2x2ZWQgY29udGFpbmVyIHBhc3NlZCBpbi5cbiAgICBpZiAoY29uZmlnLmNvbnRhaW5lcikgY29uZmlnLmNvbnRhaW5lciA9IGNvbnRhaW5lclxuICAgIC8vIElmIHRoZSBlbGVtZW50IGhhc27igJl0IGFscmVhZHkgYmVlbiBjb25maWd1cmVkLCBsZXTigJlzIHVzZSBhIGNsb25lIG9mIHRoZVxuICAgIC8vIGRlZmF1bHRzIGV4dGVuZGVkIGJ5IHRoZSBjb25maWd1cmF0aW9uIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgIGlmICghZWxlbS5jb25maWcpIHtcbiAgICAgIGVsZW0uY29uZmlnID0gc3IudG9vbHMuZXh0ZW5kQ2xvbmUoc3IuZGVmYXVsdHMsIGNvbmZpZylcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCBsZXTigJlzIHVzZSBhIGNsb25lIG9mIHRoZSBleGlzdGluZyBlbGVtZW50IGNvbmZpZ3VyYXRpb24gZXh0ZW5kZWRcbiAgICAgIC8vIGJ5IHRoZSBjb25maWd1cmF0aW9uIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgICAgZWxlbS5jb25maWcgPSBzci50b29scy5leHRlbmRDbG9uZShlbGVtLmNvbmZpZywgY29uZmlnKVxuICAgIH1cblxuICAgIC8vIEluZmVyIENTUyBUcmFuc2Zvcm0gYXhpcyBmcm9tIG9yaWdpbiBzdHJpbmcuXG4gICAgaWYgKGVsZW0uY29uZmlnLm9yaWdpbiA9PT0gJ3RvcCcgfHwgZWxlbS5jb25maWcub3JpZ2luID09PSAnYm90dG9tJykge1xuICAgICAgZWxlbS5jb25maWcuYXhpcyA9ICdZJ1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmNvbmZpZy5heGlzID0gJ1gnXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3N0eWxlIChlbGVtKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbS5kb21FbClcblxuICAgIGlmICghZWxlbS5zdHlsZXMpIHtcbiAgICAgIGVsZW0uc3R5bGVzID0ge1xuICAgICAgICB0cmFuc2l0aW9uOiB7fSxcbiAgICAgICAgdHJhbnNmb3JtOiB7fSxcbiAgICAgICAgY29tcHV0ZWQ6IHt9XG4gICAgICB9XG5cbiAgICAgIC8vIENhcHR1cmUgYW55IGV4aXN0aW5nIGlubGluZSBzdHlsZXMsIGFuZCBhZGQgb3VyIHZpc2liaWxpdHkgb3ZlcnJpZGUuXG4gICAgICAvLyAtLVxuICAgICAgLy8gU2VlIHNlY3Rpb24gNC4yLiBpbiB0aGUgRG9jdW1lbnRhdGlvbjpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qbG1ha2VzL3Njcm9sbHJldmVhbC5qcyM0Mi1pbXByb3ZlLXVzZXItZXhwZXJpZW5jZVxuICAgICAgZWxlbS5zdHlsZXMuaW5saW5lID0gZWxlbS5kb21FbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJydcbiAgICAgIGVsZW0uc3R5bGVzLmlubGluZSArPSAnOyB2aXNpYmlsaXR5OiB2aXNpYmxlOyAnXG5cbiAgICAgIC8vIGdyYWIgdGhlIGVsZW1lbnRzIGV4aXN0aW5nIG9wYWNpdHkuXG4gICAgICBlbGVtLnN0eWxlcy5jb21wdXRlZC5vcGFjaXR5ID0gY29tcHV0ZWQub3BhY2l0eVxuXG4gICAgICAvLyBncmFiIHRoZSBlbGVtZW50cyBleGlzdGluZyB0cmFuc2l0aW9ucy5cbiAgICAgIGlmICghY29tcHV0ZWQudHJhbnNpdGlvbiB8fCBjb21wdXRlZC50cmFuc2l0aW9uID09PSAnYWxsIDBzIGVhc2UgMHMnKSB7XG4gICAgICAgIGVsZW0uc3R5bGVzLmNvbXB1dGVkLnRyYW5zaXRpb24gPSAnJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5zdHlsZXMuY29tcHV0ZWQudHJhbnNpdGlvbiA9IGNvbXB1dGVkLnRyYW5zaXRpb24gKyAnLCAnXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRyYW5zaXRpb24gc3R5bGVzXG4gICAgZWxlbS5zdHlsZXMudHJhbnNpdGlvbi5pbnN0YW50ID0gX2dlbmVyYXRlVHJhbnNpdGlvbihlbGVtLCAwKVxuICAgIGVsZW0uc3R5bGVzLnRyYW5zaXRpb24uZGVsYXllZCA9IF9nZW5lcmF0ZVRyYW5zaXRpb24oZWxlbSwgZWxlbS5jb25maWcuZGVsYXkpXG5cbiAgICAvLyBHZW5lcmF0ZSB0cmFuc2Zvcm0gc3R5bGVzLCBmaXJzdCB3aXRoIHRoZSB3ZWJraXQgcHJlZml4LlxuICAgIGVsZW0uc3R5bGVzLnRyYW5zZm9ybS5pbml0aWFsID0gJyAtd2Via2l0LXRyYW5zZm9ybTonXG4gICAgZWxlbS5zdHlsZXMudHJhbnNmb3JtLnRhcmdldCA9ICcgLXdlYmtpdC10cmFuc2Zvcm06J1xuICAgIF9nZW5lcmF0ZVRyYW5zZm9ybShlbGVtKVxuXG4gICAgLy8gQW5kIGFnYWluIHdpdGhvdXQgYW55IHByZWZpeC5cbiAgICBlbGVtLnN0eWxlcy50cmFuc2Zvcm0uaW5pdGlhbCArPSAndHJhbnNmb3JtOidcbiAgICBlbGVtLnN0eWxlcy50cmFuc2Zvcm0udGFyZ2V0ICs9ICd0cmFuc2Zvcm06J1xuICAgIF9nZW5lcmF0ZVRyYW5zZm9ybShlbGVtKVxuICB9XG5cbiAgZnVuY3Rpb24gX2dlbmVyYXRlVHJhbnNpdGlvbiAoZWxlbSwgZGVsYXkpIHtcbiAgICB2YXIgY29uZmlnID0gZWxlbS5jb25maWdcblxuICAgIHJldHVybiAnLXdlYmtpdC10cmFuc2l0aW9uOiAnICsgZWxlbS5zdHlsZXMuY29tcHV0ZWQudHJhbnNpdGlvbiArXG4gICAgICAnLXdlYmtpdC10cmFuc2Zvcm0gJyArIGNvbmZpZy5kdXJhdGlvbiAvIDEwMDAgKyAncyAnICtcbiAgICAgIGNvbmZpZy5lYXNpbmcgKyAnICcgK1xuICAgICAgZGVsYXkgLyAxMDAwICsgJ3MsIG9wYWNpdHkgJyArXG4gICAgICBjb25maWcuZHVyYXRpb24gLyAxMDAwICsgJ3MgJyArXG4gICAgICBjb25maWcuZWFzaW5nICsgJyAnICtcbiAgICAgIGRlbGF5IC8gMTAwMCArICdzOyAnICtcblxuICAgICAgJ3RyYW5zaXRpb246ICcgKyBlbGVtLnN0eWxlcy5jb21wdXRlZC50cmFuc2l0aW9uICtcbiAgICAgICd0cmFuc2Zvcm0gJyArIGNvbmZpZy5kdXJhdGlvbiAvIDEwMDAgKyAncyAnICtcbiAgICAgIGNvbmZpZy5lYXNpbmcgKyAnICcgK1xuICAgICAgZGVsYXkgLyAxMDAwICsgJ3MsIG9wYWNpdHkgJyArXG4gICAgICBjb25maWcuZHVyYXRpb24gLyAxMDAwICsgJ3MgJyArXG4gICAgICBjb25maWcuZWFzaW5nICsgJyAnICtcbiAgICAgIGRlbGF5IC8gMTAwMCArICdzOyAnXG4gIH1cblxuICBmdW5jdGlvbiBfZ2VuZXJhdGVUcmFuc2Zvcm0gKGVsZW0pIHtcbiAgICB2YXIgY29uZmlnID0gZWxlbS5jb25maWdcbiAgICB2YXIgY3NzRGlzdGFuY2VcbiAgICB2YXIgdHJhbnNmb3JtID0gZWxlbS5zdHlsZXMudHJhbnNmb3JtXG5cbiAgICAvLyBMZXTigJlzIG1ha2Ugc3VyZSBvdXIgb3VyIHBpeGVsIGRpc3RhbmNlcyBhcmUgbmVnYXRpdmUgZm9yIHRvcCBhbmQgbGVmdC5cbiAgICAvLyBlLmcuIG9yaWdpbiA9ICd0b3AnIGFuZCBkaXN0YW5jZSA9ICcyNXB4JyBzdGFydHMgYXQgYHRvcDogLTI1cHhgIGluIENTUy5cbiAgICBpZiAoY29uZmlnLm9yaWdpbiA9PT0gJ3RvcCcgfHwgY29uZmlnLm9yaWdpbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBjc3NEaXN0YW5jZSA9IC9eLS8udGVzdChjb25maWcuZGlzdGFuY2UpXG4gICAgICAgID8gY29uZmlnLmRpc3RhbmNlLnN1YnN0cigxKVxuICAgICAgICA6ICctJyArIGNvbmZpZy5kaXN0YW5jZVxuICAgIH0gZWxzZSB7XG4gICAgICBjc3NEaXN0YW5jZSA9IGNvbmZpZy5kaXN0YW5jZVxuICAgIH1cblxuICAgIGlmIChwYXJzZUludChjb25maWcuZGlzdGFuY2UpKSB7XG4gICAgICB0cmFuc2Zvcm0uaW5pdGlhbCArPSAnIHRyYW5zbGF0ZScgKyBjb25maWcuYXhpcyArICcoJyArIGNzc0Rpc3RhbmNlICsgJyknXG4gICAgICB0cmFuc2Zvcm0udGFyZ2V0ICs9ICcgdHJhbnNsYXRlJyArIGNvbmZpZy5heGlzICsgJygwKSdcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5zY2FsZSkge1xuICAgICAgdHJhbnNmb3JtLmluaXRpYWwgKz0gJyBzY2FsZSgnICsgY29uZmlnLnNjYWxlICsgJyknXG4gICAgICB0cmFuc2Zvcm0udGFyZ2V0ICs9ICcgc2NhbGUoMSknXG4gICAgfVxuICAgIGlmIChjb25maWcucm90YXRlLngpIHtcbiAgICAgIHRyYW5zZm9ybS5pbml0aWFsICs9ICcgcm90YXRlWCgnICsgY29uZmlnLnJvdGF0ZS54ICsgJ2RlZyknXG4gICAgICB0cmFuc2Zvcm0udGFyZ2V0ICs9ICcgcm90YXRlWCgwKSdcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5yb3RhdGUueSkge1xuICAgICAgdHJhbnNmb3JtLmluaXRpYWwgKz0gJyByb3RhdGVZKCcgKyBjb25maWcucm90YXRlLnkgKyAnZGVnKSdcbiAgICAgIHRyYW5zZm9ybS50YXJnZXQgKz0gJyByb3RhdGVZKDApJ1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnJvdGF0ZS56KSB7XG4gICAgICB0cmFuc2Zvcm0uaW5pdGlhbCArPSAnIHJvdGF0ZVooJyArIGNvbmZpZy5yb3RhdGUueiArICdkZWcpJ1xuICAgICAgdHJhbnNmb3JtLnRhcmdldCArPSAnIHJvdGF0ZVooMCknXG4gICAgfVxuICAgIHRyYW5zZm9ybS5pbml0aWFsICs9ICc7IG9wYWNpdHk6ICcgKyBjb25maWcub3BhY2l0eSArICc7J1xuICAgIHRyYW5zZm9ybS50YXJnZXQgKz0gJzsgb3BhY2l0eTogJyArIGVsZW0uc3R5bGVzLmNvbXB1dGVkLm9wYWNpdHkgKyAnOydcbiAgfVxuXG4gIGZ1bmN0aW9uIF91cGRhdGVTdG9yZSAoZWxlbSkge1xuICAgIHZhciBjb250YWluZXIgPSBlbGVtLmNvbmZpZy5jb250YWluZXJcblxuICAgIC8vIElmIHRoaXMgZWxlbWVudOKAmXMgY29udGFpbmVyIGlzbuKAmXQgYWxyZWFkeSBpbiB0aGUgc3RvcmUsIGxldOKAmXMgYWRkIGl0LlxuICAgIGlmIChjb250YWluZXIgJiYgc3Iuc3RvcmUuY29udGFpbmVycy5pbmRleE9mKGNvbnRhaW5lcikgPT09IC0xKSB7XG4gICAgICBzci5zdG9yZS5jb250YWluZXJzLnB1c2goZWxlbS5jb25maWcuY29udGFpbmVyKVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZWxlbWVudCBzdG9yZWQgd2l0aCBvdXIgbmV3IGVsZW1lbnQuXG4gICAgc3Iuc3RvcmUuZWxlbWVudHNbZWxlbS5pZF0gPSBlbGVtXG4gIH1cblxuICBmdW5jdGlvbiBfcmVjb3JkICh0YXJnZXQsIGNvbmZpZywgaW50ZXJ2YWwpIHtcbiAgICAvLyBTYXZlIHRoZSBgcmV2ZWFsKClgIGFyZ3VtZW50cyB0aGF0IHRyaWdnZXJlZCB0aGlzIGBfcmVjb3JkKClgIGNhbGwsIHNvIHdlXG4gICAgLy8gY2FuIHJlLXRyYWNlIG91ciBzdGVwcyB3aGVuIGNhbGxpbmcgdGhlIGBzeW5jKClgIG1ldGhvZC5cbiAgICB2YXIgcmVjb3JkID0ge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIGludGVydmFsOiBpbnRlcnZhbFxuICAgIH1cbiAgICBzci5oaXN0b3J5LnB1c2gocmVjb3JkKVxuICB9XG5cbiAgZnVuY3Rpb24gX2luaXQgKCkge1xuICAgIGlmIChzci5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAvLyBJbml0aWFsIGFuaW1hdGUgY2FsbCB0cmlnZ2VycyB2YWxpZCByZXZlYWwgYW5pbWF0aW9ucyBvbiBmaXJzdCBsb2FkLlxuICAgICAgLy8gU3Vic2VxdWVudCBhbmltYXRlIGNhbGxzIGFyZSBtYWRlIGluc2lkZSB0aGUgZXZlbnQgaGFuZGxlci5cbiAgICAgIF9hbmltYXRlKClcblxuICAgICAgLy8gVGhlbiB3ZSBsb29wIHRocm91Z2ggYWxsIGNvbnRhaW5lciBub2RlcyBpbiB0aGUgc3RvcmUgYW5kIGJpbmQgZXZlbnRcbiAgICAgIC8vIGxpc3RlbmVycyB0byBlYWNoLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzci5zdG9yZS5jb250YWluZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNyLnN0b3JlLmNvbnRhaW5lcnNbaV0uYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX2hhbmRsZXIpXG4gICAgICAgIHNyLnN0b3JlLmNvbnRhaW5lcnNbaV0uYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgX2hhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIC8vIExldOKAmXMgYWxzbyBkbyBhIG9uZS10aW1lIGJpbmRpbmcgb2Ygd2luZG93IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgIGlmICghc3IuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF9oYW5kbGVyKVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgX2hhbmRsZXIpXG4gICAgICAgIHNyLmluaXRpYWxpemVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3JcbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYW5kbGVyICgpIHtcbiAgICBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9hbmltYXRlKVxuICB9XG5cbiAgZnVuY3Rpb24gX3NldEFjdGl2ZVNlcXVlbmNlcyAoKSB7XG4gICAgdmFyIGFjdGl2ZVxuICAgIHZhciBlbGVtXG4gICAgdmFyIGVsZW1JZFxuICAgIHZhciBzZXF1ZW5jZVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBzZXF1ZW5jZXNcbiAgICBzci50b29scy5mb3JPd24oc3Iuc2VxdWVuY2VzLCBmdW5jdGlvbiAoc2VxdWVuY2VJZCkge1xuICAgICAgc2VxdWVuY2UgPSBzci5zZXF1ZW5jZXNbc2VxdWVuY2VJZF1cbiAgICAgIGFjdGl2ZSA9IGZhbHNlXG5cbiAgICAgIC8vIEZvciBlYWNoIHNlcXVlbmNlZCBlbGVtZW5ldCwgbGV04oCZcyBjaGVjayB2aXNpYmlsaXR5IGFuZCBpZlxuICAgICAgLy8gYW55IGFyZSB2aXNpYmxlLCBzZXQgaXTigJlzIHNlcXVlbmNlIHRvIGFjdGl2ZS5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UuZWxlbUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtSWQgPSBzZXF1ZW5jZS5lbGVtSWRzW2ldXG4gICAgICAgIGVsZW0gPSBzci5zdG9yZS5lbGVtZW50c1tlbGVtSWRdXG4gICAgICAgIGlmIChfaXNFbGVtVmlzaWJsZShlbGVtKSAmJiAhYWN0aXZlKSB7XG4gICAgICAgICAgYWN0aXZlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlcXVlbmNlLmFjdGl2ZSA9IGFjdGl2ZVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBfYW5pbWF0ZSAoKSB7XG4gICAgdmFyIGRlbGF5ZWRcbiAgICB2YXIgZWxlbVxuXG4gICAgX3NldEFjdGl2ZVNlcXVlbmNlcygpXG5cbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIGVsZW1lbnRzIGluIHRoZSBzdG9yZVxuICAgIHNyLnRvb2xzLmZvck93bihzci5zdG9yZS5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1JZCkge1xuICAgICAgZWxlbSA9IHNyLnN0b3JlLmVsZW1lbnRzW2VsZW1JZF1cbiAgICAgIGRlbGF5ZWQgPSBfc2hvdWxkVXNlRGVsYXkoZWxlbSlcblxuICAgICAgLy8gTGV04oCZcyBzZWUgaWYgd2Ugc2hvdWxkIHJldmVhbGFuZCBpZiBzbyxcbiAgICAgIC8vIHRyaWdnZXIgdGhlIGBiZWZvcmVSZXZlYWxgIGNhbGxiYWNrIGFuZFxuICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIHVzZSBkZWxheS5cbiAgICAgIGlmIChfc2hvdWxkUmV2ZWFsKGVsZW0pKSB7XG4gICAgICAgIGVsZW0uY29uZmlnLmJlZm9yZVJldmVhbChlbGVtLmRvbUVsKVxuICAgICAgICBpZiAoZGVsYXllZCkge1xuICAgICAgICAgIGVsZW0uZG9tRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsXG4gICAgICAgICAgICBlbGVtLnN0eWxlcy5pbmxpbmUgK1xuICAgICAgICAgICAgZWxlbS5zdHlsZXMudHJhbnNmb3JtLnRhcmdldCArXG4gICAgICAgICAgICBlbGVtLnN0eWxlcy50cmFuc2l0aW9uLmRlbGF5ZWRcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbS5kb21FbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJyxcbiAgICAgICAgICAgIGVsZW0uc3R5bGVzLmlubGluZSArXG4gICAgICAgICAgICBlbGVtLnN0eWxlcy50cmFuc2Zvcm0udGFyZ2V0ICtcbiAgICAgICAgICAgIGVsZW0uc3R5bGVzLnRyYW5zaXRpb24uaW5zdGFudFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExldOKAmXMgcXVldWUgdGhlIGBhZnRlclJldmVhbGAgY2FsbGJhY2tcbiAgICAgICAgLy8gYW5kIG1hcmsgdGhlIGVsZW1lbnQgYXMgc2VlbiBhbmQgcmV2ZWFsaW5nLlxuICAgICAgICBfcXVldWVDYWxsYmFjaygncmV2ZWFsJywgZWxlbSwgZGVsYXllZClcbiAgICAgICAgZWxlbS5yZXZlYWxpbmcgPSB0cnVlXG4gICAgICAgIGVsZW0uc2VlbiA9IHRydWVcblxuICAgICAgICBpZiAoZWxlbS5zZXF1ZW5jZSkge1xuICAgICAgICAgIF9xdWV1ZU5leHRJblNlcXVlbmNlKGVsZW0sIGRlbGF5ZWQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3Nob3VsZFJlc2V0KGVsZW0pKSB7XG4gICAgICAgIC8vT3RoZXJ3aXNlIHJlc2V0IG91ciBlbGVtZW50IGFuZFxuICAgICAgICAvLyB0cmlnZ2VyIHRoZSBgYmVmb3JlUmVzZXRgIGNhbGxiYWNrLlxuICAgICAgICBlbGVtLmNvbmZpZy5iZWZvcmVSZXNldChlbGVtLmRvbUVsKVxuICAgICAgICBlbGVtLmRvbUVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLFxuICAgICAgICAgIGVsZW0uc3R5bGVzLmlubGluZSArXG4gICAgICAgICAgZWxlbS5zdHlsZXMudHJhbnNmb3JtLmluaXRpYWwgK1xuICAgICAgICAgIGVsZW0uc3R5bGVzLnRyYW5zaXRpb24uaW5zdGFudFxuICAgICAgICApXG4gICAgICAgIC8vIEFuZCBxdWV1ZSB0aGUgYGFmdGVyUmVzZXRgIGNhbGxiYWNrLlxuICAgICAgICBfcXVldWVDYWxsYmFjaygncmVzZXQnLCBlbGVtKVxuICAgICAgICBlbGVtLnJldmVhbGluZyA9IGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIF9xdWV1ZU5leHRJblNlcXVlbmNlIChlbGVtLCBkZWxheWVkKSB7XG4gICAgdmFyIGVsYXBzZWQgPSAwXG4gICAgdmFyIGRlbGF5ID0gMFxuICAgIHZhciBzZXF1ZW5jZSA9IHNyLnNlcXVlbmNlc1tlbGVtLnNlcXVlbmNlLmlkXVxuXG4gICAgLy8gV2XigJlyZSBwcm9jZXNzaW5nIGEgc2VxdWVuY2VkIGVsZW1lbnQsIHNvIGxldCdzIGJsb2NrIG90aGVyIGVsZW1lbnRzIGluIHRoaXMgc2VxdWVuY2UuXG4gICAgc2VxdWVuY2UuYmxvY2tlZCA9IHRydWVcblxuICAgIC8vIFNpbmNlIHdl4oCZcmUgdHJpZ2dlcmluZyBhbmltYXRpb25zIGEgcGFydCBvZiBhIHNlcXVlbmNlIGFmdGVyIGFuaW1hdGlvbnMgb24gZmlyc3QgbG9hZCxcbiAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGZvciB0aGF0IGNvbmRpdGlvbiBhbmQgZXhwbGljaXRseSBhZGQgdGhlIGRlbGF5IHRvIG91ciB0aW1lci5cbiAgICBpZiAoZGVsYXllZCAmJiBlbGVtLmNvbmZpZy51c2VEZWxheSA9PT0gJ29ubG9hZCcpIHtcbiAgICAgIGRlbGF5ID0gZWxlbS5jb25maWcuZGVsYXlcbiAgICB9XG5cbiAgICAvLyBJZiBhIHNlcXVlbmNlIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZywgY2FwdHVyZSB0aGUgZWxhcHNlZCB0aW1lIGFuZCBjbGVhciBpdC5cbiAgICBpZiAoZWxlbS5zZXF1ZW5jZS50aW1lcikge1xuICAgICAgZWxhcHNlZCA9IE1hdGguYWJzKGVsZW0uc2VxdWVuY2UudGltZXIuc3RhcnRlZCAtIG5ldyBEYXRlKCkpXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGVsZW0uc2VxdWVuY2UudGltZXIpXG4gICAgfVxuXG4gICAgLy8gU3RhcnQgYSBuZXcgdGltZXIuXG4gICAgZWxlbS5zZXF1ZW5jZS50aW1lciA9IHsgc3RhcnRlZDogbmV3IERhdGUoKSB9XG4gICAgZWxlbS5zZXF1ZW5jZS50aW1lci5jbG9jayA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFNlcXVlbmNlIGludGVydmFsIGhhcyBwYXNzZWQsIHNvIHVuYmxvY2sgdGhlIHNlcXVlbmNlIGFuZCByZS1ydW4gdGhlIGhhbmRsZXIuXG4gICAgICBzZXF1ZW5jZS5ibG9ja2VkID0gZmFsc2VcbiAgICAgIGVsZW0uc2VxdWVuY2UudGltZXIgPSBudWxsXG4gICAgICBfaGFuZGxlcigpXG4gICAgfSwgTWF0aC5hYnMoc2VxdWVuY2UuaW50ZXJ2YWwpICsgZGVsYXkgLSBlbGFwc2VkKVxuICB9XG5cbiAgZnVuY3Rpb24gX3F1ZXVlQ2FsbGJhY2sgKHR5cGUsIGVsZW0sIGRlbGF5ZWQpIHtcbiAgICB2YXIgZWxhcHNlZCA9IDBcbiAgICB2YXIgZHVyYXRpb24gPSAwXG4gICAgdmFyIGNhbGxiYWNrID0gJ2FmdGVyJ1xuXG4gICAgLy8gQ2hlY2sgd2hpY2ggY2FsbGJhY2sgd2XigJlyZSB3b3JraW5nIHdpdGguXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdyZXZlYWwnOlxuICAgICAgICBkdXJhdGlvbiA9IGVsZW0uY29uZmlnLmR1cmF0aW9uXG4gICAgICAgIGlmIChkZWxheWVkKSB7XG4gICAgICAgICAgZHVyYXRpb24gKz0gZWxlbS5jb25maWcuZGVsYXlcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayArPSAnUmV2ZWFsJ1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgIGR1cmF0aW9uID0gZWxlbS5jb25maWcuZHVyYXRpb25cbiAgICAgICAgY2FsbGJhY2sgKz0gJ1Jlc2V0J1xuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIElmIGEgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nLCBjYXB0dXJlIHRoZSBlbGFwc2VkIHRpbWUgYW5kIGNsZWFyIGl0LlxuICAgIGlmIChlbGVtLnRpbWVyKSB7XG4gICAgICBlbGFwc2VkID0gTWF0aC5hYnMoZWxlbS50aW1lci5zdGFydGVkIC0gbmV3IERhdGUoKSlcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZWxlbS50aW1lci5jbG9jaylcbiAgICB9XG5cbiAgICAvLyBTdGFydCBhIG5ldyB0aW1lci5cbiAgICBlbGVtLnRpbWVyID0geyBzdGFydGVkOiBuZXcgRGF0ZSgpIH1cbiAgICBlbGVtLnRpbWVyLmNsb2NrID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVGhlIHRpbWVyIGNvbXBsZXRlZCwgc28gbGV04oCZcyBmaXJlIHRoZSBjYWxsYmFjayBhbmQgbnVsbCB0aGUgdGltZXIuXG4gICAgICBlbGVtLmNvbmZpZ1tjYWxsYmFja10oZWxlbS5kb21FbClcbiAgICAgIGVsZW0udGltZXIgPSBudWxsXG4gICAgfSwgZHVyYXRpb24gLSBlbGFwc2VkKVxuICB9XG5cbiAgZnVuY3Rpb24gX3Nob3VsZFJldmVhbCAoZWxlbSkge1xuICAgIGlmIChlbGVtLnNlcXVlbmNlKSB7XG4gICAgICB2YXIgc2VxdWVuY2UgPSBzci5zZXF1ZW5jZXNbZWxlbS5zZXF1ZW5jZS5pZF1cbiAgICAgIHJldHVybiBzZXF1ZW5jZS5hY3RpdmUgJiZcbiAgICAgICAgIXNlcXVlbmNlLmJsb2NrZWQgJiZcbiAgICAgICAgIWVsZW0ucmV2ZWFsaW5nICYmXG4gICAgICAgICFlbGVtLmRpc2FibGVkXG4gICAgfVxuICAgIHJldHVybiBfaXNFbGVtVmlzaWJsZShlbGVtKSAmJlxuICAgICAgIWVsZW0ucmV2ZWFsaW5nICYmXG4gICAgICAhZWxlbS5kaXNhYmxlZFxuICB9XG5cbiAgZnVuY3Rpb24gX3Nob3VsZFVzZURlbGF5IChlbGVtKSB7XG4gICAgdmFyIGNvbmZpZyA9IGVsZW0uY29uZmlnLnVzZURlbGF5XG4gICAgcmV0dXJuIGNvbmZpZyA9PT0gJ2Fsd2F5cycgfHxcbiAgICAgIChjb25maWcgPT09ICdvbmxvYWQnICYmICFzci5pbml0aWFsaXplZCkgfHxcbiAgICAgIChjb25maWcgPT09ICdvbmNlJyAmJiAhZWxlbS5zZWVuKVxuICB9XG5cbiAgZnVuY3Rpb24gX3Nob3VsZFJlc2V0IChlbGVtKSB7XG4gICAgaWYgKGVsZW0uc2VxdWVuY2UpIHtcbiAgICAgIHZhciBzZXF1ZW5jZSA9IHNyLnNlcXVlbmNlc1tlbGVtLnNlcXVlbmNlLmlkXVxuICAgICAgcmV0dXJuICFzZXF1ZW5jZS5hY3RpdmUgJiZcbiAgICAgICAgZWxlbS5jb25maWcucmVzZXQgJiZcbiAgICAgICAgZWxlbS5yZXZlYWxpbmcgJiZcbiAgICAgICAgIWVsZW0uZGlzYWJsZWRcbiAgICB9XG4gICAgcmV0dXJuICFfaXNFbGVtVmlzaWJsZShlbGVtKSAmJlxuICAgICAgZWxlbS5jb25maWcucmVzZXQgJiZcbiAgICAgIGVsZW0ucmV2ZWFsaW5nICYmXG4gICAgICAhZWxlbS5kaXNhYmxlZFxuICB9XG5cbiAgZnVuY3Rpb24gX2dldENvbnRhaW5lciAoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjb250YWluZXIuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IGNvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0U2Nyb2xsZWQgKGNvbnRhaW5lcikge1xuICAgIC8vIFJldHVybiB0aGUgY29udGFpbmVyIHNjcm9sbCB2YWx1ZXMsIHBsdXMgdGhlIGl0cyBvZmZzZXQuXG4gICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIgIT09IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBfZ2V0T2Zmc2V0KGNvbnRhaW5lcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNvbnRhaW5lci5zY3JvbGxMZWZ0ICsgb2Zmc2V0LmxlZnQsXG4gICAgICAgIHk6IGNvbnRhaW5lci5zY3JvbGxUb3AgKyBvZmZzZXQudG9wXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgZGVmYXVsdCB0byB0aGUgd2luZG93IG9iamVjdOKAmXMgc2Nyb2xsIHZhbHVlcy5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2dldE9mZnNldCAoZG9tRWwpIHtcbiAgICB2YXIgb2Zmc2V0VG9wID0gMFxuICAgIHZhciBvZmZzZXRMZWZ0ID0gMFxuXG4gICAgICAvLyBHcmFiIHRoZSBlbGVtZW504oCZcyBkaW1lbnNpb25zLlxuICAgIHZhciBvZmZzZXRIZWlnaHQgPSBkb21FbC5vZmZzZXRIZWlnaHRcbiAgICB2YXIgb2Zmc2V0V2lkdGggPSBkb21FbC5vZmZzZXRXaWR0aFxuXG4gICAgLy8gTm93IGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgaXRzIHBhcmVudCwgdGhlblxuICAgIC8vIGFnYWluIGZvciB0aGUgcGFyZW50IHRvIGl0cyBwYXJlbnQsIGFuZCBhZ2FpbiBldGMuLi4gdW50aWwgd2UgaGF2ZSB0aGVcbiAgICAvLyB0b3RhbCBkaXN0YW5jZSBvZiB0aGUgZWxlbWVudCB0byB0aGUgZG9jdW1lbnTigJlzIHRvcCBhbmQgbGVmdCBvcmlnaW4uXG4gICAgZG8ge1xuICAgICAgaWYgKCFpc05hTihkb21FbC5vZmZzZXRUb3ApKSB7XG4gICAgICAgIG9mZnNldFRvcCArPSBkb21FbC5vZmZzZXRUb3BcbiAgICAgIH1cbiAgICAgIGlmICghaXNOYU4oZG9tRWwub2Zmc2V0TGVmdCkpIHtcbiAgICAgICAgb2Zmc2V0TGVmdCArPSBkb21FbC5vZmZzZXRMZWZ0XG4gICAgICB9XG4gICAgICBkb21FbCA9IGRvbUVsLm9mZnNldFBhcmVudFxuICAgIH0gd2hpbGUgKGRvbUVsKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgbGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgIGhlaWdodDogb2Zmc2V0SGVpZ2h0LFxuICAgICAgd2lkdGg6IG9mZnNldFdpZHRoXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2lzRWxlbVZpc2libGUgKGVsZW0pIHtcbiAgICB2YXIgb2Zmc2V0ID0gX2dldE9mZnNldChlbGVtLmRvbUVsKVxuICAgIHZhciBjb250YWluZXIgPSBfZ2V0Q29udGFpbmVyKGVsZW0uY29uZmlnLmNvbnRhaW5lcilcbiAgICB2YXIgc2Nyb2xsZWQgPSBfZ2V0U2Nyb2xsZWQoZWxlbS5jb25maWcuY29udGFpbmVyKVxuICAgIHZhciB2RiA9IGVsZW0uY29uZmlnLnZpZXdGYWN0b3JcblxuICAgICAgLy8gRGVmaW5lIHRoZSBlbGVtZW50IGdlb21ldHJ5LlxuICAgIHZhciBlbGVtSGVpZ2h0ID0gb2Zmc2V0LmhlaWdodFxuICAgIHZhciBlbGVtV2lkdGggPSBvZmZzZXQud2lkdGhcbiAgICB2YXIgZWxlbVRvcCA9IG9mZnNldC50b3BcbiAgICB2YXIgZWxlbUxlZnQgPSBvZmZzZXQubGVmdFxuICAgIHZhciBlbGVtQm90dG9tID0gZWxlbVRvcCArIGVsZW1IZWlnaHRcbiAgICB2YXIgZWxlbVJpZ2h0ID0gZWxlbUxlZnQgKyBlbGVtV2lkdGhcblxuICAgIHJldHVybiBjb25maXJtQm91bmRzKCkgfHwgaXNQb3NpdGlvbkZpeGVkKClcblxuICAgIGZ1bmN0aW9uIGNvbmZpcm1Cb3VuZHMgKCkge1xuICAgICAgLy8gRGVmaW5lIHRoZSBlbGVtZW504oCZcyBmdW5jdGlvbmFsIGJvdW5kYXJpZXMgdXNpbmcgaXRzIHZpZXcgZmFjdG9yLlxuICAgICAgdmFyIHRvcCA9IGVsZW1Ub3AgKyBlbGVtSGVpZ2h0ICogdkZcbiAgICAgIHZhciBsZWZ0ID0gZWxlbUxlZnQgKyBlbGVtV2lkdGggKiB2RlxuICAgICAgdmFyIGJvdHRvbSA9IGVsZW1Cb3R0b20gLSBlbGVtSGVpZ2h0ICogdkZcbiAgICAgIHZhciByaWdodCA9IGVsZW1SaWdodCAtIGVsZW1XaWR0aCAqIHZGXG5cbiAgICAgIC8vIERlZmluZSB0aGUgY29udGFpbmVyIGZ1bmN0aW9uYWwgYm91bmRhcmllcyB1c2luZyBpdHMgdmlldyBvZmZzZXQuXG4gICAgICB2YXIgdmlld1RvcCA9IHNjcm9sbGVkLnkgKyBlbGVtLmNvbmZpZy52aWV3T2Zmc2V0LnRvcFxuICAgICAgdmFyIHZpZXdMZWZ0ID0gc2Nyb2xsZWQueCArIGVsZW0uY29uZmlnLnZpZXdPZmZzZXQubGVmdFxuICAgICAgdmFyIHZpZXdCb3R0b20gPSBzY3JvbGxlZC55IC0gZWxlbS5jb25maWcudmlld09mZnNldC5ib3R0b20gKyBjb250YWluZXIuaGVpZ2h0XG4gICAgICB2YXIgdmlld1JpZ2h0ID0gc2Nyb2xsZWQueCAtIGVsZW0uY29uZmlnLnZpZXdPZmZzZXQucmlnaHQgKyBjb250YWluZXIud2lkdGhcblxuICAgICAgcmV0dXJuIHRvcCA8IHZpZXdCb3R0b20gJiZcbiAgICAgICAgYm90dG9tID4gdmlld1RvcCAmJlxuICAgICAgICBsZWZ0ID4gdmlld0xlZnQgJiZcbiAgICAgICAgcmlnaHQgPCB2aWV3UmlnaHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Bvc2l0aW9uRml4ZWQgKCkge1xuICAgICAgcmV0dXJuICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLmRvbUVsKS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0aWVzXG4gICAqIC0tLS0tLS0tLVxuICAgKi9cblxuICBmdW5jdGlvbiBUb29scyAoKSB7fVxuXG4gIFRvb2xzLnByb3RvdHlwZS5pc09iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XG4gIH1cblxuICBUb29scy5wcm90b3R5cGUuaXNOb2RlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93Lk5vZGUgPT09ICdvYmplY3QnXG4gICAgICA/IG9iamVjdCBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlXG4gICAgICA6IG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJ1xuICB9XG5cbiAgVG9vbHMucHJvdG90eXBlLmlzTm9kZUxpc3QgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIHByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdClcbiAgICB2YXIgcmVnZXggPSAvXlxcW29iamVjdCAoSFRNTENvbGxlY3Rpb258Tm9kZUxpc3R8T2JqZWN0KVxcXSQvXG5cbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdy5Ob2RlTGlzdCA9PT0gJ29iamVjdCdcbiAgICAgID8gb2JqZWN0IGluc3RhbmNlb2Ygd2luZG93Lk5vZGVMaXN0XG4gICAgICA6IG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICByZWdleC50ZXN0KHByb3RvdHlwZVRvU3RyaW5nKSAmJlxuICAgICAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgKG9iamVjdC5sZW5ndGggPT09IDAgfHwgdGhpcy5pc05vZGUob2JqZWN0WzBdKSlcbiAgfVxuXG4gIFRvb2xzLnByb3RvdHlwZS5mb3JPd24gPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5pc09iamVjdChvYmplY3QpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIm9iamVjdFwiLCBidXQgcmVjZWl2ZWQgXCInICsgdHlwZW9mIG9iamVjdCArICdcIi4nKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFRvb2xzLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICB0aGlzLmZvck93bihzb3VyY2UsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgaWYgKHRoaXMuaXNPYmplY3Qoc291cmNlW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgaWYgKCF0YXJnZXRbcHJvcGVydHldIHx8ICF0aGlzLmlzT2JqZWN0KHRhcmdldFtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHt9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHRlbmQodGFyZ2V0W3Byb3BlcnR5XSwgc291cmNlW3Byb3BlcnR5XSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldXG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIFRvb2xzLnByb3RvdHlwZS5leHRlbmRDbG9uZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh0aGlzLmV4dGVuZCh7fSwgdGFyZ2V0KSwgc291cmNlKVxuICB9XG5cbiAgVG9vbHMucHJvdG90eXBlLmlzTW9iaWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5ZmlsbHNcbiAgICogLS0tLS0tLS1cbiAgICovXG5cbiAgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MClcbiAgICB9XG5cbiAgLyoqXG4gICAqIE1vZHVsZSBXcmFwcGVyXG4gICAqIC0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gU2Nyb2xsUmV2ZWFsXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gU2Nyb2xsUmV2ZWFsXG4gIH0gZWxzZSB7XG4gICAgd2luZG93LlNjcm9sbFJldmVhbCA9IFNjcm9sbFJldmVhbFxuICB9XG59KCkpXG4iLCJ2YXIgQlIgPSB7XG5cdGFkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gJCgnYS5saW5rJykuaG92ZXIoIFxuXHRcdC8vIFx0ZnVuY3Rpb24oKXtcblx0XHQvLyBcdFx0dmFyIHJlZEhvdmVyID0gJCh0aGlzKS5maW5kKCdzcGFuJyk7XG5cdFx0Ly8gXHRcdCQocmVkSG92ZXIpLmFuaW1hdGUoe1wibWFyZ2luQm90dG9tXCI6XCIxMHB4XCJ9LCAzMDApO1xuXHRcdC8vIFx0XHQkKHJlZEhvdmVyKS5hbmltYXRlKHtcIm9wYWNpdHlcIjpcIjFcIn0sIDMwMCk7XG5cblx0XHQvLyBcdH0sXG5cdFx0Ly8gXHRmdW5jdGlvbigpe1xuXHRcdC8vIFx0XHR2YXIgcmVkSG92ZXIgPSAkKHRoaXMpLmZpbmQoJ3NwYW4nKTtcblx0XHQvLyBcdFx0JChyZWRIb3ZlcikuYW5pbWF0ZSh7XCJtYXJnaW5Cb3R0b21cIjpcIjBcIn0sIDMwMCk7XG5cdFx0Ly8gXHRcdCQocmVkSG92ZXIpLmFuaW1hdGUoe1wib3BhY2l0eVwiOlwiMFwifSwgMzAwKTtcblx0XHQvLyBcdH1cblx0XHQvLyApXG5cdFx0JCgnLmNsb3NlX19tb2RhbCcpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHQkKHRoaXMpLmNsb3Nlc3QoJy5tb2RhbF9fYmFja2dyb3VuZCcpLmZhZGVPdXQoJzMwMCcpLmFkZENsYXNzKCdoaWRkZW4nKTtcblx0XHR9KTtcblx0XHQkKCcuYWNjb3JkaW9uX190cmlnZ2VyJykuY2xpY2soIGZ1bmN0aW9uKGUpe1xuXHRcdFx0dmFyIHRyaWdnZXJJZCA9ICQodGhpcykuZGF0YSgndHJpZ2dlci10YXJnZXQnKTtcblx0XHRcdHZhciBhY2NvcmRpb24gPSAkKCcjJyt0cmlnZ2VySWQpO1xuXHRcdFx0JChhY2NvcmRpb24pLnNsaWRlVG9nZ2xlKDQwMCk7XG5cdFx0XHQvLyAkKGFjY29yZGlvbikuc2xpZGVUb2dnbGUoMzAwLCBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gXHQkKHRoaXMpLnRvZ2dsZUNsYXNzKCdoaWRkZW4nKTtcblx0XHRcdC8vIH0pXG5cdFx0fSlcblxuXHRcdCQoJyNkaXZlcnNpdHlNb2RhbFRyaWdnZXInKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuXHRcdFx0QlJfQ09PS0lFUy52aXNpdERpdmVyc2l0eSgpO1xuXHRcdFx0QlJfQ09PS0lFUy5zaG93RGl2ZXJzaXR5TW9kYWwoKTtcblx0XHR9KTtcblx0fVxufVxuXG5cblxuJChmdW5jdGlvbigpe1xuXHRCUi5hZGRMaXN0ZW5lcnMoKTtcbn0pOyIsInZhciBCUl9DT09LSUVTID0ge1xuXHRvbkxvYWQ6IGZ1bmN0aW9uKCl7XG5cdFx0Y29uc29sZS5sb2coXCJCUiBDb29raWUgU2NyaXB0cyBsb2FkZWQhXCIpO1xuXHR9LFxuICAgIGNyZWF0ZUNvb2tpZTogZnVuY3Rpb24obmFtZSwgdmFsdWUsIGRheXMpIHtcbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgdmFyIGV4cGlyZXMgPSBcIjsgZXhwaXJlcz1cIiArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHZhciBleHBpcmVzID0gXCJcIjsgICAgICAgICAgICAgICBcblxuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBuYW1lICsgXCI9XCIgKyB2YWx1ZSArIGV4cGlyZXMgKyBcIjsgcGF0aD0vXCI7XG4gICAgfSxcblx0cmVhZENvb2tpZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgbmFtZUVRID0gbmFtZSArIFwiPVwiO1xuICAgICAgICB2YXIgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSByZXR1cm4gYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCwgYy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBlcmFzZUNvb2tpZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBCUl9DT09LSUVTLmNyZWF0ZUNvb2tpZShuYW1lLCBcIlwiLCAtMSk7XG4gICAgfSxcblx0dmlzaXREaXZlcnNpdHk6IGZ1bmN0aW9uKCl7XG5cdFx0QlJfQ09PS0lFUy5jcmVhdGVDb29raWUoXCJ2aXNpdGVkRGl2ZXJzaXR5XCIsIFwidHJ1ZVwiKTtcblx0XHR2YXIgdmlzaXRlZERpdmVyc2l0eSA9IEJSX0NPT0tJRVMucmVhZENvb2tpZShcInZpc2l0ZWREaXZlcnNpdHlcIik7XG5cdFx0Y29uc29sZS5sb2codmlzaXRlZERpdmVyc2l0eSk7XG5cdH0sXG5cdHNob3dEaXZlcnNpdHlNb2RhbDogZnVuY3Rpb24oKSB7XG5cdFx0Y29uc29sZS5sb2coXCJTaG93aW5nIEVPRSBNb2RhbCFcIik7XG5cdFx0dmFyIGRpdmVyc2l0eU1vZGFsID0gJCgnLm1vZGFsX19iYWNrZ3JvdW5kLmRpdmVyc2l0eScpO1xuXHRcdGRpdmVyc2l0eU1vZGFsLnJlbW92ZUNsYXNzKCdoaWRkZW4nKS5mYWRlSW4oJ3Nsb3cnKTtcblx0fVxufVxuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuXHRCUl9DT09LSUVTLm9uTG9hZCgpO1xufSkiLCJ2YXIgRVhQQU5ERVIgPSB7XG5cdGFkZExpc3RlbmVyczogZnVuY3Rpb24oKXtcblx0XHQkKCcjc2hvd01vcmVSZWxhdGVkRXhwZXJpZW5jZXMsIC5leHBlcmllbmNlX2V4cGFuZGVyJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdCQoZG9jdW1lbnQuYm9keSkudHJpZ2dlcihcInN0aWNreV9raXQ6cmVjYWxjXCIpO1xuXHRcdFx0dmFyIGhpZGRlbkV4cGVyaWVuY2VzID0gJCgnLnNpZGViYXJfX2NvbG9yLWJsb2NrLS1vdXRlci13cmFwcGVyLmhpZGRlbl9fZXhwJyk7XG5cdFx0XHQkKGhpZGRlbkV4cGVyaWVuY2VzKS50b2dnbGVDbGFzcygnaGlkZGVuJyk7XG5cdFx0XHR2YXIgaGlkZGVuTWVudUl0ZW1zID0gJCgnLnNpZGViYXItaXRlbXNfX3dyYXBwZXInKTtcblx0XHRcdCQoaGlkZGVuTWVudUl0ZW1zKS5zbGlkZVRvZ2dsZSgnMzAwJyk7XG5cdFx0XHR2YXIgZXhwYW5kZXIgPSAkKCcuZXhwZXJpZW5jZV9leHBhbmRlcicpO1xuXHRcdFx0JChleHBhbmRlcikudG9nZ2xlQ2xhc3MoJ2V4cGFuZGVkJyk7XG5cdFx0XHRpZiAoJCgnI3Nob3dNb3JlUmVsYXRlZEV4cGVyaWVuY2VzJykuaGFzQ2xhc3MoJ21vcmUnKSl7XG5cdFx0XHRcdCQoJyNzaG93TW9yZVJlbGF0ZWRFeHBlcmllbmNlcycpLnJlbW92ZUNsYXNzKCdtb3JlJykuYWRkQ2xhc3MoJ2xlc3MnKS50ZXh0KFwiU0hPVyBMRVNTXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCgnI3Nob3dNb3JlUmVsYXRlZEV4cGVyaWVuY2VzJykucmVtb3ZlQ2xhc3MoJ2xlc3MnKS5hZGRDbGFzcygnbW9yZScpLnRleHQoXCJTSE9XIE1PUkVcIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0JCgnLmpvYl9leHBhbmRlcicpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgZXhwYW5kZXIgPSAkKHRoaXMpO1xuXHRcdFx0dmFyIGhpZGRlbkpvYkRlc2NyaXB0b24gPSAkKGV4cGFuZGVyKS5wYXJlbnQoKS5wYXJlbnQoKS5uZXh0KCd0cicpLmZpbmQoJ3RkJyk7XG5cdFx0XHQkKGhpZGRlbkpvYkRlc2NyaXB0b24pLnNsaWRlVG9nZ2xlKCdmYXN0Jyk7XG5cdFx0XHQkKGV4cGFuZGVyKS50b2dnbGVDbGFzcygnZXhwYW5kZWQnKTtcblx0XHR9KTtcblx0fVxufVxuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuXHRFWFBBTkRFUi5hZGRMaXN0ZW5lcnMoKTtcbn0pO1xuXG4gIiwialF1ZXJ5KCAnaWZyYW1lW3NyYyo9XCJ5b3V0dWJlLmNvbVwiXScpLndyYXAoXCI8ZGl2IGNsYXNzPSdmbGV4LXZpZGVvIHdpZGVzY3JlZW4nLz5cIik7XG5qUXVlcnkoICdpZnJhbWVbc3JjKj1cInZpbWVvLmNvbVwiXScpLndyYXAoXCI8ZGl2IGNsYXNzPSdmbGV4LXZpZGVvIHdpZGVzY3JlZW4gdmltZW8nLz5cIik7XG4iLCIkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuXHRpZiAoICQoXCJib2R5XCIpLmhhc0NsYXNzKFwicGFnZS10ZW1wbGF0ZS1ob21lcGFnZVwiKSApe1xuXHRcdC8vIGFuaW1hdGUgZ3JpZCBlbGVtZW50cyBvbiBob21lcGFnZVxuXHRcdHdpbmRvdy5zciA9IFNjcm9sbFJldmVhbCh7ZGlzdGFuY2U6JzEwJScsIGR1cmF0aW9uOiA5MDAsIGRlbGF5OiAxLCByZXNldDp0cnVlLCBzY2FsZTowLjk5LCBlYXNpbmc6ICdsaW5lYXInfSk7XG5cdFx0c3IucmV2ZWFsKCcuaG9tZXBhZ2UtZ3JpZC1lbGVtZW50Jyk7XG5cdH1cbn0pO1xuIiwialF1ZXJ5KGRvY3VtZW50KS5mb3VuZGF0aW9uKCk7XG4iLCJ2YXIgSU5TSUdIVFMgPSB7XG5cdGxpc3RlbmVyczogZnVuY3Rpb24oKXtcblx0XHRjb25zb2xlLmxvZygnSW5zaWdodHMgbGlzdGVuZXJzIGpzIGxvYWRlZCcpO1xuXHRcdCQoJ3NlbGVjdC5pbnNpZ2h0JykuY2hhbmdlKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgc2VsZWN0cyA9ICQoJ3NlbGVjdCcpO1xuXHRcdFx0dmFyIHF1ZXJ5U3RyaW5nQmFzZSA9IGxvY2F0aW9uLm9yaWdpbiArIGxvY2F0aW9uLnBhdGhuYW1lO1xuXHRcdFx0dmFyIHF1ZXJ5U3RyaW5nID0gXCJcIjtcblx0XHRcdHZhciBmaWx0ZXJzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gc2VsZWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgc2VsZWN0ID0gc2VsZWN0c1tpXTtcblx0XHRcdFx0aWYgKCAkKHNlbGVjdCkudmFsKCkubGVuZ3RoID4gMCAmJiAgJChzZWxlY3QpLnZhbCgpICE9PSBcIlwiICkge1xuXHRcdFx0XHRcdGZpbHRlcnMucHVzaCgkKHNlbGVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZyhcImZpbHRlcnNcIiArIGZpbHRlcnMpO1xuXHRcdFx0Zm9yKHZhciBpID0gZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgcGFyYW1OYW1lID0gJChmaWx0ZXJzW2ldKS5hdHRyKCduYW1lJyk7XG5cdFx0XHRcdHZhciBwYXJhbVZhbHVlID0gJChmaWx0ZXJzW2ldKS52YWwoKTtcblx0XHRcdFx0aWYgKCBwYXJhbVZhbHVlLmxlbmd0aCA+IDAgJiYgaSA9PT0gZmlsdGVycy5sZW5ndGggLSAxICkge1xuXHRcdFx0XHRcdHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmdCYXNlICsgXCI/XCIgKyBwYXJhbU5hbWUgKyBcIj1cIiArIHBhcmFtVmFsdWU7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cocXVlcnlTdHJpbmcpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJhbVZhbHVlLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0cXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZyArIFwiJlwiICsgcGFyYW1OYW1lICsgXCI9XCIgKyBwYXJhbVZhbHVlO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKHF1ZXJ5U3RyaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2cocXVlcnlTdHJpbmcpO1xuXHRcdFx0d2luZG93LmxvY2F0aW9uLnJlcGxhY2UocXVlcnlTdHJpbmcpO1xuXHRcdH0pO1xuXHR9LFxuXHRvbkxvYWQ6IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gR2V0IHNlYXJjaCBwYXJhbSB2YWx1ZXMgZnJvbSB1cmxcblx0XHR2YXIgc2VsZWN0ZWRHZW9ncmFwaHkgPSAkLnVybCgpLnBhcmFtKCdnZW9ncmFwaHlfcXVlcnknLCAnc3RyaWN0JykgfHwgXCJcIjtcblx0XHR2YXIgc2VsZWN0ZWRJbmR1c3RyeSA9ICQudXJsKCkucGFyYW0oJ2luZHVzdHJ5X3F1ZXJ5JywgJ3N0cmljdCcpIHx8IFwiXCI7XG5cdFx0dmFyIHNlbGVjdGVkUHJhY3RpY2UgPSAkLnVybCgpLnBhcmFtKCdwcmFjdGljZV9xdWVyeScsICdzdHJpY3QnKSB8fCBcIlwiO1xuXHRcdHZhciBzZWxlY3RlZExhbmd1YWdlID0gJC51cmwoKS5wYXJhbSgnbGFuZ3VhZ2VfcXVlcnknLCAnc3RyaWN0JykgfHwgXCJcIjtcblx0XHR2YXIgc2VsZWN0ZWRMb2NhdGlvbnMgPSAkLnVybCgpLnBhcmFtKCdsb2NhdGlvbl9xdWVyeScsICdzdHJpY3QnKSB8fCBcIlwiO1xuXHRcdHZhciBzZWxlY3RlZEFkbWlzc2lvbiA9ICQudXJsKCkucGFyYW0oJ2FkbWlzc2lvbl9xdWVyeScsICdzdHJpY3QnKSB8fCBcIlwiO1xuXHRcdHZhciBzZWxlY3RlZEVkdWNhdGlvbiA9ICQudXJsKCkucGFyYW0oJ2VkdWNhdGlvbl9xdWVyeScsICdzdHJpY3QnKSB8fCBcIlwiO1xuXHRcdHZhciBzZWxlY3RlZEtleXdvcmQgPSAkLnVybCgpLnBhcmFtKCdrZXl3b3JkJywgJ3N0cmljdCcpIHx8IFwiXCI7XG5cblxuXHRcdC8vIFNldCB2YXJzIGZvciBzZWxlY3RzIGZvciBhbGwgc2VhcmNoIHBhcmFtc1xuXHRcdHZhciBnZW9ncmFwaHlTZWxlY3QgPSAkKCdzZWxlY3QjZ2VvZ3JhcGh5U2VsZWN0Jyk7XG5cdFx0dmFyIGluZHVzdHJ5U2VsZWN0ID0gJCgnc2VsZWN0I2luZHVzdHJ5U2VsZWN0Jyk7XG5cdFx0dmFyIHByYWN0aWNlU2VsZWN0ID0gJCgnc2VsZWN0I3ByYWN0aWNlU2VsZWN0Jyk7XG5cdFx0dmFyIGxhbmd1YWdlU2VsZWN0ID0gJCgnc2VsZWN0I2xhbmd1YWdlU2VsZWN0Jyk7XG5cdFx0dmFyIGxvY2F0aW9uU2VsZWN0ID0gJCgnc2VsZWN0I2xvY2F0aW9uU2VsZWN0Jyk7XG5cdFx0dmFyIGFkbWlzc2lvblNlbGVjdCA9ICQoJ3NlbGVjdCNhZG1pc3Npb25TZWxlY3QnKTtcblx0XHR2YXIgZWR1Y2F0aW9uU2VsZWN0ID0gJCgnc2VsZWN0I2VkdWNhdGlvblNlbGVjdCcpO1xuXHRcdHZhciBrZXl3b3JkSW5wdXQgPSAkKCdpbnB1dCNrZXl3b3JkSW5wdXQnKTtcblxuXG5cdFx0Ly8gQ2hhbmdlIHZhbHVlIG9mIHNlbGVjdHMgYmFzZWQgb24gdXJsIHBhcmFtc1xuXHRcdGdlb2dyYXBoeVNlbGVjdC52YWwoZGVjb2RlVVJJQ29tcG9uZW50KHNlbGVjdGVkR2VvZ3JhcGh5KSk7XG5cdFx0aW5kdXN0cnlTZWxlY3QudmFsKGRlY29kZVVSSUNvbXBvbmVudChzZWxlY3RlZEluZHVzdHJ5KSk7XG5cdFx0cHJhY3RpY2VTZWxlY3QudmFsKGRlY29kZVVSSUNvbXBvbmVudChzZWxlY3RlZFByYWN0aWNlKSk7XG5cdFx0bGFuZ3VhZ2VTZWxlY3QudmFsKGRlY29kZVVSSUNvbXBvbmVudChzZWxlY3RlZExhbmd1YWdlKSk7XG5cdFx0bG9jYXRpb25TZWxlY3QudmFsKGRlY29kZVVSSUNvbXBvbmVudChzZWxlY3RlZExvY2F0aW9ucykpO1xuXHRcdGFkbWlzc2lvblNlbGVjdC52YWwoZGVjb2RlVVJJQ29tcG9uZW50KHNlbGVjdGVkQWRtaXNzaW9uKSk7XG5cdFx0ZWR1Y2F0aW9uU2VsZWN0LnZhbChkZWNvZGVVUklDb21wb25lbnQoc2VsZWN0ZWRFZHVjYXRpb24pKTtcblx0XHRrZXl3b3JkSW5wdXQudmFsKGRlY29kZVVSSUNvbXBvbmVudChzZWxlY3RlZEtleXdvcmQpKTtcblx0fVxufVxuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuXHRJTlNJR0hUUy5saXN0ZW5lcnMoKTtcblx0SU5TSUdIVFMub25Mb2FkKCk7XG59KVxuIiwiLy8gSm95cmlkZSBkZW1vXG4kKCcjc3RhcnQtanInKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgJChkb2N1bWVudCkuZm91bmRhdGlvbignam95cmlkZScsJ3N0YXJ0Jyk7XG59KTsiLCJ2YXIgTE9DQVRJT05TRUFSQ0hFUiA9IHtcblx0ZGV0ZWN0Q2hhbmdlOiBmdW5jdGlvbigpe1xuXHRcdCQoJyNsb2NhdGlvblNlbGVjdCcpLmNoYW5nZShmdW5jdGlvbihldmVudCl7XG5cdFx0XHQvLyBidWlsZCBxdWVyeSBzdHJpbmdcblx0XHRcdHZhciBrZXl3b3JkID0gJCgnI2xvY2F0aW9uU2VsZWN0JykudmFsKCkgfHwgXCJcIjtcblx0XHRcdGNvbnNvbGUubG9nKGtleXdvcmQpO1xuXHRcdFx0dmFyIHF1ZXJ5U3RyaW5nQmFzZSA9IGxvY2F0aW9uLm9yaWdpbiArIGxvY2F0aW9uLnBhdGhuYW1lO1xuXHRcdFx0dmFyIHF1ZXJ5U3RyaW5nID0gXCJcIiArIFwiP2pvYl9sb2NhdGlvbl9xdWVyeT1cIitrZXl3b3JkO1xuXHRcdFx0Y29uc29sZS5sb2cocXVlcnlTdHJpbmcpO1xuXHRcdFx0d2luZG93LmxvY2F0aW9uLnJlcGxhY2UocXVlcnlTdHJpbmcpO1xuXHRcdH0pO1xuXHR9XG59XG5cbiQoJ2RvY3VtZW50JykucmVhZHkoZnVuY3Rpb24oKXtcblx0TE9DQVRJT05TRUFSQ0hFUi5kZXRlY3RDaGFuZ2UoKTsgXG59KTsiLCIvLyBkZXNrdG9wIG5hdmlnYXRpb24gaG92ZXIgaW50ZXJhY3Rpb25zXG5cbi8vIGVkaXRlZCBmb3VuZGF0aW9uLmRyb3Bkb3duTWVudS5qcyBsaW5lIDM2OCB0byBtYWtlIGRlbGF5IG9uIGNsb3NpbmcgdGltZSBhZnRlciBtb3VzZW91dCBldmVudCBzaG9ydGVyIFxuLy8gdG8gcmVzdG9yZSB0byBkZWZhdWx0LCBzZXQgdGhpcyBudW1iZXIgdG8gJzUwMCdcblxudmFyIE5BViA9IHtcblx0bGlzdGVuZXJzOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gbWVkaXVtIGJyZWFrcG9pbnQgaG92ZXIgaW50ZXJhY3Rpb25cblx0XHRpZiAoJCh3aW5kb3cpLmlubmVyV2lkdGgoKSA+IDcwMCApIHtcblx0XHRcdFx0JCgnLm1lbnUtaXRlbS1oYXMtY2hpbGRyZW4nKS5vbih7XG5cdFx0XHRcdFx0bW91c2VvdmVyOiBmdW5jdGlvbigpe1x0XHRcdFx0XHRcblx0XHRcdFx0XHRcdCQoJy5zdWJuYXZfX2NvbG9yLWJsb2NrJykuc3RvcCgpLnNob3coNDEwKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG1vdXNlb3V0OiBmdW5jdGlvbigpe1x0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0JCgnLnN1Ym5hdl9fY29sb3ItYmxvY2snKS5zdG9wKCkuaGlkZSg0MTApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XHRcblx0XHRcdH1cblx0fSxcblx0ZGVza3RvcE1lbnU6ICQoJyNtYXN0aGVhZCcpLFxuXHRzY3JvbGxFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdFx0aWYgKCAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgPj0gTkFWLmRlc2t0b3BNZW51LmhlaWdodCgpICkge1xuXHRcdFx0JChOQVYuZGVza3RvcE1lbnUpLmNzcygnb3BhY2l0eScsICcwJyk7XG5cdFx0XHQkKCcuc3VibmF2X19jb2xvci1ibG9jaycpLmNzcyh7J3dpZHRoJzogJzQwMCUnfSk7XG5cdFx0XHQkKCcubWVudV9fb3V0ZXItd3JhcHBlci0tZGVza3RvcC1vbi1zY3JvbGwnKS5zbGlkZURvd24oJzMwMCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkKE5BVi5kZXNrdG9wTWVudSkuY3NzKCdvcGFjaXR5JywgJzEnKTtcblx0XHRcdCQoJy5tZW51X19vdXRlci13cmFwcGVyLS1kZXNrdG9wLW9uLXNjcm9sbCcpLnNsaWRlVXAoJzMwMCcpO1xuXHRcdH1cblx0fVx0XG59XG5cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG5cdE5BVi5saXN0ZW5lcnMoKTtcblx0aWYgKCAkKGRvY3VtZW50KS53aWR0aCgpID4gNjQwKSB7XG5cdFx0JChkb2N1bWVudCkuc2Nyb2xsKCBmdW5jdGlvbigpe1xuXHRcdFx0TkFWLnNjcm9sbEV2ZW50cygpO1xuXHRcdH0pXG5cdH1cblx0aWYgKCAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgPj0gTkFWLmRlc2t0b3BNZW51LmhlaWdodCgpICYmICQoZG9jdW1lbnQpLndpZHRoKCkgPiA2NDApIHtcblx0XHQkKE5BVi5kZXNrdG9wTWVudSkuaGlkZSgpO1xuXHR9XG59KVxuXG5cblxuXG5cblxuXG5cbi8vIHZhciBuYXZiYXIgPSB7XG4vLyBcdG9uSG92ZXI6IGZ1bmN0aW9uKCl7XG4vLyBcdFx0Ly8gbWVkaXVtIGJyZWFrcG9pbnRcbi8vIFx0XHRpZiAoJCh3aW5kb3cpLmlubmVyV2lkdGgoKSA+IDcwMCApIHtcbi8vIFx0XHRcdFx0JCgnLm1lbnUtaXRlbS1oYXMtY2hpbGRyZW4nKS5vbih7XG4vLyBcdFx0XHRcdFx0bW91c2VvdmVyOiBmdW5jdGlvbigpe1xuLy8gXHRcdFx0XHRcdFx0JCgnLnN1Ym5hdl9fY29sb3ItYmxvY2snKS5zdG9wKCkuc2hvdyg0MTApO1xuLy8gXHRcdFx0XHRcdH0sXG4vLyBcdFx0XHRcdFx0bW91c2VvdXQ6IGZ1bmN0aW9uKCl7XG4vLyBcdFx0XHRcdFx0XHQkKCcuc3VibmF2X19jb2xvci1ibG9jaycpLnN0b3AoKS5oaWRlKDQxMCk7XG4vLyBcdFx0XHRcdFx0fVxuLy8gXHRcdFx0XHR9KTtcdFxuLy8gXHRcdFx0fVxuLy8gXHRcdH0sXG4vLyBcdFx0ZGVza3RvcE1lbnU6ICQoJyNtYXN0aGVhZCcpXG5cdFxuLy8gXHR9XG5cbi8vICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG5cbi8vIFx0XHRuYXZiYXIub25Ib3ZlcigpO1xuXG5cbi8vIFx0XHRcdGlmICggJCh3aW5kb3cpLnNjcm9sbFRvcCgpID49IG5hdmJhci5kZXNrdG9wTWVudS5oZWlnaHQoKSApIHtcbi8vIFx0XHRcdFx0bmF2YmFyLmRlc2t0b3BNZW51LmhpZGUoKTtcbi8vIFx0XHRcdFx0JCgnLm1lbnVfX291dGVyLXdyYXBwZXItLWRlc2t0b3Atb24tc2Nyb2xsJykuZmFkZUluKCk7XG4vLyBcdFx0XHRcdGNvbnNvbGUubG9nKCduYXYgaXMgaGlkZGVuJylcbi8vIFx0XHRcdH0gZWxzZSB7XG4vLyBcdFx0XHRcdG5hdmJhci5kZXNrdG9wTWVudS5zaG93KCk7XG4vLyBcdFx0XHRcdCQoJy5tZW51X19vdXRlci13cmFwcGVyLS1kZXNrdG9wLW9uLXNjcm9sbCcpLmhpZGUoKTtcbi8vIFx0XHRcdH1cblx0XHRcdFx0XG5cbi8vIFx0Ly8gaWYgKCAkKGRvY3VtZW50KS53aWR0aCgpID4gNjQwKSB7XG4vLyBcdC8vIFx0XHQkKGRvY3VtZW50KS5zY3JvbGwoIGZ1bmN0aW9uKCl7XG4vLyBcdC8vIFx0XHRcdG5hdmJhci5vblNjcm9sbCgpO1xuLy8gXHQvLyBcdFx0fSlcbi8vIFx0Ly8gXHR9XG4vLyBcdGlmICggJCh3aW5kb3cpLnNjcm9sbFRvcCgpID49IG5hdmJhci5kZXNrdG9wTWVudS5oZWlnaHQoKSAmJiAkKGRvY3VtZW50KS53aWR0aCgpID4gNjQwKSB7XG4vLyBcdFx0bmF2YmFyLmRlc2t0b3BNZW51LmhpZGUoKTtcbi8vIFx0fVxuLy8gXHQvLyB9XG4vLyB9KTsiLCIiLCJ2YXIgUEVPUExFID0ge1xuXHRsaXN0ZW5lcnM6IGZ1bmN0aW9uKCl7XG5cdFx0Y29uc29sZS5sb2coJ1Blb3BsZSBqcyBsb2FkZWQnKTtcblx0XHQkKCcubGV0dGVyX19saW5rJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBsZXR0ZXJsTGlua0lubmVyV3JhcHBlcnMgPSAkKCcubGV0dGVyX19saW5rLS1pbm5lci13cmFwcGVyJyk7XG5cdFx0XHR2YXIgbGV0dGVyID0gJCh0aGlzKS5kYXRhKCdsZXR0ZXInKTtcblx0XHRcdHZhciBsZXR0ZXJBbmNob3IgPSAkKFwiZGl2W2RhdGEtbGV0dGVyLWFuY2hvcj1cIisgbGV0dGVyICtcIl1cIik7XG5cdFx0XHRsZXR0ZXJsTGlua0lubmVyV3JhcHBlcnMucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0dmFyIHNlbGVjdGVkbGV0dGVybExpbmtJbm5lcldyYXBwZXIgPSAkKHRoaXMpLnBhcmVudCgpO1xuXHRcdFx0c2VsZWN0ZWRsZXR0ZXJsTGlua0lubmVyV3JhcHBlci5hZGRDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHQkKCdodG1sLGJvZHknKS5hbmltYXRlKHtcblx0ICAgICAgICAgIHNjcm9sbFRvcDogbGV0dGVyQW5jaG9yLm9mZnNldCgpLnRvcCAtIDIwMFxuXHQgICAgICAgIH0sIDEwMDApO1xuXHQgICAgICAgIGNvbnNvbGUubG9nKFwiU2Nyb2xsaW5nIHRvIFwiICsgbGV0dGVyICk7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdH0pO1xuXHRcdC8vICQoZG9jdW1lbnQpLnJlc2l6ZShmdW5jdGlvbihldmVudCkge1xuXHRcdC8vIFx0aWYgKCAkKGRvY3VtZW50KS53aWR0aCgpID4gNjQwKSB7XG5cdFx0Ly8gXHRcdFBFT1BMRS5zY3JvbGxFdmVudHMoKTtcblx0XHQvLyBcdFx0JChkb2N1bWVudCkuc2Nyb2xsKCBmdW5jdGlvbigpe1xuXHRcdC8vIFx0XHRcdFBFT1BMRS5zY3JvbGxFdmVudHMoKTtcblx0XHQvLyBcdFx0fSk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfSk7XG5cdFx0JCgnI2FkdmFuY2VkUGVvcGxlU2VhcmNoJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFBFT1BMRS5yZXZlYWxBZHZhbmNlZFNlYXJjaCgpO1xuXHRcdH0pO1xuXHRcdCQoJyNwZW9wbGVBZHZhbmNlZFNlYXJjaEJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Y29uc29sZS5sb2coXCJwcmV2ZW50ZWQhXCIpO1xuXHRcdFx0dmFyIHNlbGVjdHMgPSAkKCdzZWxlY3QnKTtcblx0XHRcdHZhciBrZXl3b3JkID0gJChcIiNrZXl3b3JkSW5wdXRcIikudmFsKCkgfHwgXCJcIjtcblx0XHRcdHZhciBxdWVyeVN0cmluZ0Jhc2UgPSBsb2NhdGlvbi5vcmlnaW4gKyBsb2NhdGlvbi5wYXRobmFtZTtcblx0XHRcdHZhciBxdWVyeVN0cmluZyA9IFwiXCI7XG5cdFx0XHR2YXIgZmlsdGVycyA9IFtdO1xuXHRcdFx0Ly8gc2VsZWN0cyB2YWx1ZXMgZnJvbSBkcm9wZG93biBvcHRpb25zIGFuZCBkZXRlcm1pbmVzIG51bWJlciBvZiBmaWx0ZXJzIGZyb20gdGhlc2Vcblx0XHRcdGZvciAodmFyIGkgPSBzZWxlY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBzZWxlY3QgPSBzZWxlY3RzW2ldO1xuXHRcdFx0XHRpZiAoICQoc2VsZWN0KS52YWwoKS5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRcdGZpbHRlcnMucHVzaCgkKHNlbGVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZyhmaWx0ZXJzKTtcblx0XHRcdC8vIHBhc3NlcyB0aGUgcGFyYW1ldGVycyBmcm9tIGVhY2ggb2YgdGhlIHNlbGVjdGVkIGZpbHRlcnNcblx0XHRcdGZvcih2YXIgaSA9IGZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIHBhcmFtTmFtZSA9ICQoZmlsdGVyc1tpXSkuYXR0cignbmFtZScpO1xuXHRcdFx0XHR2YXIgcGFyYW1WYWx1ZSA9ICQoZmlsdGVyc1tpXSkudmFsKCk7XG5cdFx0XHRcdGlmICggcGFyYW1WYWx1ZS5sZW5ndGggPiAwICYmIGkgPT09IGZpbHRlcnMubGVuZ3RoIC0gMSApIHtcblx0XHRcdFx0XHRxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nQmFzZSArIFwiP1wiICsgcGFyYW1OYW1lICsgXCI9XCIgKyBwYXJhbVZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJhbVZhbHVlLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0cXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZyArIFwiJlwiICsgcGFyYW1OYW1lICsgXCI9XCIgKyBwYXJhbVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHF1ZXJ5U3RyaW5nLmxlbmd0aCA+IDAgKXtcblx0XHRcdFx0aWYgKCBrZXl3b3JkLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0cXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZyArIFwiJmtleXdvcmQ9XCIgKyBrZXl3b3JkO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGtleXdvcmQubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0XHRxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nICsgXCI/a2V5d29yZD1cIiArIGtleXdvcmQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGRlYnVnZ2VyO1xuXHRcdFx0d2luZG93LmxvY2F0aW9uLnJlcGxhY2UocXVlcnlTdHJpbmcpO1xuXHRcdH0pO1xuXHR9LFxuXHRzdGlja3lTaWRlQmFyOiAkKCcuc2lkZWJhcl9fb24tc2Nyb2xsLS1maXhlZCcpLFxuXHQvLyBzY3JvbGxFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdC8vIFx0dmFyIGhlaWdodEFkanVzdG1lbnQ7XG5cdC8vIFx0aWYgKCAkKCcucGFnZS10ZW1wbGF0ZS1wZW9wbGUnKS5sZW5ndGggPiAwICYmICAkKCcucGVvcGxlX19kZXRhaWxzLS1jb250YWluZXInKS5oZWlnaHQoKSA+ICQoJy5zaWRlYmFyX19vbi1zY3JvbGwtLWZpeGVkJykuaGVpZ2h0KCkgKXtcblx0Ly8gXHRcdGhlaWdodEFkanVzdG1lbnQgPSA4MDA7XG5cdC8vIFx0fSBlbHNlIHtcblx0Ly8gXHRcdGhlaWdodEFkanVzdG1lbnQgPSAyNjM7XG5cdC8vIFx0fVxuXHQvLyBcdHZhciBzY3JvbGxTdG9wcGVyT2Zmc2V0ID0gJCgnI21hc3RoZWFkJykuaGVpZ2h0KCkgKyAkKCcuYm9keV9fd3JhcHBlcicpLmhlaWdodCgpIC0gaGVpZ2h0QWRqdXN0bWVudDtcblx0Ly8gXHRpZiAoICQod2luZG93KS5zY3JvbGxUb3AoKSA+PSAoJCgnI2ZlYXR1cmVkSW1hZ2UnKS5oZWlnaHQoKSkgJiYgJCh3aW5kb3cpLnNjcm9sbFRvcCgpIDw9IHNjcm9sbFN0b3BwZXJPZmZzZXQgKSB7XG5cdC8vIFx0XHRQRU9QTEUuc3RpY2tTaWRlQmFyKCd0b3AnKTtcblx0Ly8gXHR9IGVsc2UgaWYgKCAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgPj0gc2Nyb2xsU3RvcHBlck9mZnNldCApIHtcblx0Ly8gXHRcdFBFT1BMRS5zdGlja1NpZGVCYXIoJ2JvdHRvbScpO1xuXHQvLyBcdFx0Y29uc29sZS5sb2coJ2JvdHRvbSBzdGlja2VyJyk7XG5cdC8vIFx0fSBlbHNlIHtcblx0Ly8gXHRcdFBFT1BMRS51bnN0aWNrU2lkZUJhcigpO1xuXHQvLyBcdH1cblx0Ly8gfSxcblx0Ly8gc3RpY2tTaWRlQmFyOiBmdW5jdGlvbihsb2NhdGlvbikge1xuXHQvLyBcdHZhciBzaWRlQmFyV2lkdGg7XG5cdC8vIFx0aWYgKCBsb2NhdGlvbiA9PT0gJ3RvcCcgKSB7XHRcblx0Ly8gXHRcdGlmICggJCh3aW5kb3cpLndpZHRoKCkgPCAxMDAwICkge1xuXHQvLyBcdFx0XHRzaWRlQmFyV2lkdGggPSAnY2FsYyg3NWVtIC8gNCknO1xuXHQvLyBcdFx0fSBlbHNlIHtcblx0Ly8gXHRcdFx0c2lkZUJhcldpZHRoID0gJ2NhbGMoNzVlbSAvIDYpJztcblx0Ly8gXHRcdH1cblx0Ly8gXHRcdFBFT1BMRS5zdGlja3lTaWRlQmFyLmNzcyh7XG5cdC8vIFx0XHRcdHBvc2l0aW9uOiAnZml4ZWQnLFxuXHQvLyBcdFx0XHR3aWR0aDogc2lkZUJhcldpZHRoLFxuXHQvLyBcdFx0XHR0b3A6ICcxNjBweCdcblx0Ly8gXHRcdH0pO1xuXHQvLyBcdH0gZWxzZSB7XG5cdC8vIFx0XHRpZiAoICQod2luZG93KS53aWR0aCgpIDwgMTAwMCApIHtcblx0Ly8gXHRcdFx0c2lkZUJhcldpZHRoID0gJzI1JSc7XG5cdC8vIFx0XHR9IGVsc2Uge1xuXHQvLyBcdFx0XHRzaWRlQmFyV2lkdGggPSAnMTYuNjY2NjclJztcblx0Ly8gXHRcdH1cblx0Ly8gXHRcdFBFT1BMRS5zdGlja3lTaWRlQmFyLmNzcyh7XG5cdC8vIFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHQvLyBcdFx0XHR3aWR0aDogc2lkZUJhcldpZHRoLFxuXHQvLyBcdFx0XHR0b3A6ICdpbml0aWFsJyxcblx0Ly8gXHRcdFx0Ym90dG9tOiAnNjBweCdcblx0Ly8gXHRcdH0pO1xuXHQvLyBcdH1cdFxuXHQvLyB9LFxuXHQvLyB1bnN0aWNrU2lkZUJhcjogZnVuY3Rpb24oKSB7XG5cdC8vIFx0dmFyIHNpZGVCYXJXaWR0aDtcblx0Ly8gXHRpZiAoICQod2luZG93KS53aWR0aCgpIDwgMTAwMCApIHtcblx0Ly8gXHRcdHNpZGVCYXJXaWR0aCA9ICcyNSUnO1xuXHQvLyBcdH0gZWxzZSB7XG5cdC8vIFx0XHRzaWRlQmFyV2lkdGggPSAnMTYuNjY2NjclJztcblx0Ly8gXHR9XG5cdC8vIFx0UEVPUExFLnN0aWNreVNpZGVCYXIuY3NzKHtcblx0Ly8gXHRcdHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuXHQvLyBcdFx0d2lkdGg6IHNpZGVCYXJXaWR0aCxcblx0Ly8gXHRcdHRvcDogJ2luaXRpYWwnXHRcdFx0XG5cdC8vIFx0fSk7XG5cdC8vIH0sXG5cdHJldmVhbEFkdmFuY2VkU2VhcmNoOiBmdW5jdGlvbigpe1xuXHRcdCQoJyNhZHZhbmNlZFNlYXJjaE1vZGFsJykucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpLmZhZGVJbignc2xvdycpO1xuXHRcdGNvbnNvbGUubG9nKFwiYWR2YW5jZWQgc2VhcmNoIHJldmVhbGVkIVwiKVxuXHR9LFxuXHRoaWRlQWR2YW5jZWRTZWFyY2g6IGZ1bmN0aW9uKCl7XG5cdFx0JCgnI2FkdmFuY2VkU2VhcmNoTW9kYWwnKS5hZGRDbGFzcygnaGlkZGVuJykuZmFkZU91dCgnc2xvdycpO1xuXHRcdGNvbnNvbGUubG9nKFwiYWR2YW5jZWQgc2VhcmNoIGhpZGRlbiFcIilcblx0fVxufTtcblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcblx0UEVPUExFLmxpc3RlbmVycygpO1xuXHQvLyBpZiAoICQoZG9jdW1lbnQpLndpZHRoKCkgPiA2NDApIHtcblx0Ly8gXHRQRU9QTEUuc2Nyb2xsRXZlbnRzKCk7XG5cdC8vIFx0JChkb2N1bWVudCkuc2Nyb2xsKCBmdW5jdGlvbigpe1xuXHQvLyBcdFx0UEVPUExFLnNjcm9sbEV2ZW50cygpO1xuXHQvLyBcdH0pO1xuXHQvLyB9XG5cdHZhciBoZWFkZXJIZWlnaHQgPSAkKCcjbWFzdGhlYWRPblNjcm9sbCcpLmhlaWdodCgpICsgMTQwO1xuXHRjb25zb2xlLmxvZyhoZWFkZXJIZWlnaHQpO1xuXHRpZiAoICQoJy5zaWRlYmFyX19vbi1zY3JvbGwtLWZpeGVkJykubGVuZ3RoID4gMCl7XG5cdFx0Y29uc29sZS5sb2coXCJTVElDS1lcIik7XG5cdFx0JCgnLnNpZGViYXJfX29uLXNjcm9sbC0tZml4ZWQnKS5zdGlja19pbl9wYXJlbnQoeyBvZmZzZXRfdG9wOiBoZWFkZXJIZWlnaHQgfSk7XG5cdH1cdFxufSk7IiwidmFyIGhvbWVwYWdlID0geyBcblx0aW5pdGlhbGl6ZVNsaWRlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gY3JlYXRlIFNWR1xuXHRcdHZhciBzID0gU25hcChcIiNzbGlkZXItc3ZnXCIpO1xuXHRcdHZhciBsaW5lID0gcy5wYXBlci5saW5lKDAsIDAsIDI1MDAsIDApO1xuXG5cdFx0Ly8gc2V0IFNWRyBhdHRyaWJ1dGVzXG5cdFx0dmFyIGFuaW1hdGVTdmcgPSBmdW5jdGlvbigpIHtcblx0XHRcdGxpbmUuYXR0cih7XG5cdFx0XHRcdHN0cm9rZTogJ3RyYW5zcGFyZW50Jyxcblx0XHRcdFx0ZmlsbDogJ25vbmUnLFxuXHRcdFx0XHRzdHJva2VXaWR0aDogNSxcblx0XHRcdFx0XCJmaWxsLW9wYWNpdHlcIiA6IDBcblx0XHRcdH0pO1xuXHRcdFx0Ly8gYW5pbWF0ZSBTVkcgbGluZVx0XG5cdFx0XHRsaW5lLmFuaW1hdGUoe3N0cm9rZTogJyNjMTA4MTknLCBmaWxsOidub25lJ30sIDE5MDAgLCBtaW5hLmxpbmVhcik7XG5cdFx0XG5cdFx0fTtcblx0XHRhbmltYXRlU3ZnKCk7XG5cdFx0Ly8gYW5pbWF0ZSBTVkcgb24gc2xpZGUgY2hhbmdlXG5cdFx0JCgnLnNsaWRlci1jb250YWluZXInKS5vbignYmVmb3JlQ2hhbmdlJywgZnVuY3Rpb24oc2xpY2ssIGN1cnJlbnRTbGlkZSwgbmV4dFNsaWRlKXtcblx0XHRcdGFuaW1hdGVTdmcoKTtcblx0XHR9KTtcblxuXHRcdGlmICggJChcImJvZHlcIikuaGFzQ2xhc3MoXCJwYWdlLXRlbXBsYXRlLWhvbWVwYWdlXCIpICl7XG5cdFx0XHQvLyBzdGFydCBTbGljayBzbGlkZXJcblx0XHRcdCQoJy5zbGlkZXItY29udGFpbmVyJykuc2xpY2soe1xuXHRcdFx0XHRzbGlkZTogJy5zbGlkZScsXG5cdFx0XHRcdHNsaWRlc1RvU2hvdzogMSxcblx0XHRcdFx0c2xpZGVzVG9TY3JvbGw6IDEsXG5cdFx0XHRcdGF1dG9wbGF5OiB0cnVlLFxuXHRcdFx0XHRhdXRvcGxheVNwZWVkOiAyMDAwLFxuXHRcdFx0XHRhcnJvd3M6IHRydWUsXG5cdFx0XHRcdGZhZGU6IHRydWUsXG5cdFx0XHRcdGluZmluaXRlOiB0cnVlLFxuXHRcdFx0XHRwcmV2QXJyb3c6ICQoJy5wcmV2LXNsaWRlci1ob21lJyksXG5cdFx0XHRcdG5leHRBcnJvdzogJCgnLm5leHQtc2xpZGVyLWhvbWUnKVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59XG5cblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcblx0aWYoICQoJyNzbGlkZXItc3ZnJykubGVuZ3RoICl7XG5cdFx0aG9tZXBhZ2UuaW5pdGlhbGl6ZVNsaWRlcigpO1xuXHR9XHRcbn0pO1xuXHQiLCIkKHdpbmRvdykuYmluZCgnIGxvYWQgcmVzaXplIG9yaWVudGF0aW9uQ2hhbmdlICcsIGZ1bmN0aW9uICgpIHtcbiAgIHZhciBmb290ZXIgPSAkKFwiI2Zvb3Rlci1jb250YWluZXJcIik7XG4gICB2YXIgcG9zID0gZm9vdGVyLnBvc2l0aW9uKCk7XG4gICB2YXIgaGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcG9zLnRvcDtcbiAgIGhlaWdodCA9IGhlaWdodCAtIGZvb3Rlci5oZWlnaHQoKSAtMTtcblxuICAgZnVuY3Rpb24gc3RpY2t5Rm9vdGVyKCkge1xuICAgICBmb290ZXIuY3NzKHtcbiAgICAgICAgICdtYXJnaW4tdG9wJzogaGVpZ2h0ICsgJ3B4J1xuICAgICB9KTtcbiAgIH1cbiAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgIHN0aWNreUZvb3RlcigpO1xuICAgfVxufSk7XG4iLCIvKlxuIFN0aWNreS1raXQgdjEuMS4yIHwgV1RGUEwgfCBMZWFmIENvcmNvcmFuIDIwMTUgfCBodHRwOi8vbGVhZm8ubmV0XG4qL1xuKGZ1bmN0aW9uKCl7dmFyIGIsZjtiPXRoaXMualF1ZXJ5fHx3aW5kb3cualF1ZXJ5O2Y9Yih3aW5kb3cpO2IuZm4uc3RpY2tfaW5fcGFyZW50PWZ1bmN0aW9uKGQpe3ZhciBBLHcsSixuLEIsSyxwLHEsayxFLHQ7bnVsbD09ZCYmKGQ9e30pO3Q9ZC5zdGlja3lfY2xhc3M7Qj1kLmlubmVyX3Njcm9sbGluZztFPWQucmVjYWxjX2V2ZXJ5O2s9ZC5wYXJlbnQ7cT1kLm9mZnNldF90b3A7cD1kLnNwYWNlcjt3PWQuYm90dG9taW5nO251bGw9PXEmJihxPTApO251bGw9PWsmJihrPXZvaWQgMCk7bnVsbD09QiYmKEI9ITApO251bGw9PXQmJih0PVwiaXNfc3R1Y2tcIik7QT1iKGRvY3VtZW50KTtudWxsPT13JiYodz0hMCk7Sj1mdW5jdGlvbihhLGQsbixDLEYsdSxyLEcpe3ZhciB2LEgsbSxELEksYyxnLHgseSx6LGgsbDtpZighYS5kYXRhKFwic3RpY2t5X2tpdFwiKSl7YS5kYXRhKFwic3RpY2t5X2tpdFwiLCEwKTtJPUEuaGVpZ2h0KCk7Zz1hLnBhcmVudCgpO251bGwhPWsmJihnPWcuY2xvc2VzdChrKSk7XG5pZighZy5sZW5ndGgpdGhyb3dcImZhaWxlZCB0byBmaW5kIHN0aWNrIHBhcmVudFwiO3Y9bT0hMTsoaD1udWxsIT1wP3AmJmEuY2xvc2VzdChwKTpiKFwiPGRpdiAvPlwiKSkmJmguY3NzKFwicG9zaXRpb25cIixhLmNzcyhcInBvc2l0aW9uXCIpKTt4PWZ1bmN0aW9uKCl7dmFyIGMsZixlO2lmKCFHJiYoST1BLmhlaWdodCgpLGM9cGFyc2VJbnQoZy5jc3MoXCJib3JkZXItdG9wLXdpZHRoXCIpLDEwKSxmPXBhcnNlSW50KGcuY3NzKFwicGFkZGluZy10b3BcIiksMTApLGQ9cGFyc2VJbnQoZy5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiKSwxMCksbj1nLm9mZnNldCgpLnRvcCtjK2YsQz1nLmhlaWdodCgpLG0mJih2PW09ITEsbnVsbD09cCYmKGEuaW5zZXJ0QWZ0ZXIoaCksaC5kZXRhY2goKSksYS5jc3Moe3Bvc2l0aW9uOlwiXCIsdG9wOlwiXCIsd2lkdGg6XCJcIixib3R0b206XCJcIn0pLnJlbW92ZUNsYXNzKHQpLGU9ITApLEY9YS5vZmZzZXQoKS50b3AtKHBhcnNlSW50KGEuY3NzKFwibWFyZ2luLXRvcFwiKSwxMCl8fDApLXEsXG51PWEub3V0ZXJIZWlnaHQoITApLHI9YS5jc3MoXCJmbG9hdFwiKSxoJiZoLmNzcyh7d2lkdGg6YS5vdXRlcldpZHRoKCEwKSxoZWlnaHQ6dSxkaXNwbGF5OmEuY3NzKFwiZGlzcGxheVwiKSxcInZlcnRpY2FsLWFsaWduXCI6YS5jc3MoXCJ2ZXJ0aWNhbC1hbGlnblwiKSxcImZsb2F0XCI6cn0pLGUpKXJldHVybiBsKCl9O3goKTtpZih1IT09QylyZXR1cm4gRD12b2lkIDAsYz1xLHo9RSxsPWZ1bmN0aW9uKCl7dmFyIGIsbCxlLGs7aWYoIUcmJihlPSExLG51bGwhPXomJigtLXosMD49eiYmKHo9RSx4KCksZT0hMCkpLGV8fEEuaGVpZ2h0KCk9PT1JfHx4KCksZT1mLnNjcm9sbFRvcCgpLG51bGwhPUQmJihsPWUtRCksRD1lLG0/KHcmJihrPWUrdStjPkMrbix2JiYhayYmKHY9ITEsYS5jc3Moe3Bvc2l0aW9uOlwiZml4ZWRcIixib3R0b206XCJcIix0b3A6Y30pLnRyaWdnZXIoXCJzdGlja3lfa2l0OnVuYm90dG9tXCIpKSksZTxGJiYobT0hMSxjPXEsbnVsbD09cCYmKFwibGVmdFwiIT09ciYmXCJyaWdodFwiIT09cnx8YS5pbnNlcnRBZnRlcihoKSxcbmguZGV0YWNoKCkpLGI9e3Bvc2l0aW9uOlwiXCIsd2lkdGg6XCJcIix0b3A6XCJcIn0sYS5jc3MoYikucmVtb3ZlQ2xhc3ModCkudHJpZ2dlcihcInN0aWNreV9raXQ6dW5zdGlja1wiKSksQiYmKGI9Zi5oZWlnaHQoKSx1K3E+YiYmIXYmJihjLT1sLGM9TWF0aC5tYXgoYi11LGMpLGM9TWF0aC5taW4ocSxjKSxtJiZhLmNzcyh7dG9wOmMrXCJweFwifSkpKSk6ZT5GJiYobT0hMCxiPXtwb3NpdGlvbjpcImZpeGVkXCIsdG9wOmN9LGIud2lkdGg9XCJib3JkZXItYm94XCI9PT1hLmNzcyhcImJveC1zaXppbmdcIik/YS5vdXRlcldpZHRoKCkrXCJweFwiOmEud2lkdGgoKStcInB4XCIsYS5jc3MoYikuYWRkQ2xhc3ModCksbnVsbD09cCYmKGEuYWZ0ZXIoaCksXCJsZWZ0XCIhPT1yJiZcInJpZ2h0XCIhPT1yfHxoLmFwcGVuZChhKSksYS50cmlnZ2VyKFwic3RpY2t5X2tpdDpzdGlja1wiKSksbSYmdyYmKG51bGw9PWsmJihrPWUrdStjPkMrbiksIXYmJmspKSlyZXR1cm4gdj0hMCxcInN0YXRpY1wiPT09Zy5jc3MoXCJwb3NpdGlvblwiKSYmZy5jc3Moe3Bvc2l0aW9uOlwicmVsYXRpdmVcIn0pLFxuYS5jc3Moe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixib3R0b206ZCx0b3A6XCJhdXRvXCJ9KS50cmlnZ2VyKFwic3RpY2t5X2tpdDpib3R0b21cIil9LHk9ZnVuY3Rpb24oKXt4KCk7cmV0dXJuIGwoKX0sSD1mdW5jdGlvbigpe0c9ITA7Zi5vZmYoXCJ0b3VjaG1vdmVcIixsKTtmLm9mZihcInNjcm9sbFwiLGwpO2Yub2ZmKFwicmVzaXplXCIseSk7Yihkb2N1bWVudC5ib2R5KS5vZmYoXCJzdGlja3lfa2l0OnJlY2FsY1wiLHkpO2Eub2ZmKFwic3RpY2t5X2tpdDpkZXRhY2hcIixIKTthLnJlbW92ZURhdGEoXCJzdGlja3lfa2l0XCIpO2EuY3NzKHtwb3NpdGlvbjpcIlwiLGJvdHRvbTpcIlwiLHRvcDpcIlwiLHdpZHRoOlwiXCJ9KTtnLnBvc2l0aW9uKFwicG9zaXRpb25cIixcIlwiKTtpZihtKXJldHVybiBudWxsPT1wJiYoXCJsZWZ0XCIhPT1yJiZcInJpZ2h0XCIhPT1yfHxhLmluc2VydEFmdGVyKGgpLGgucmVtb3ZlKCkpLGEucmVtb3ZlQ2xhc3ModCl9LGYub24oXCJ0b3VjaG1vdmVcIixsKSxmLm9uKFwic2Nyb2xsXCIsbCksZi5vbihcInJlc2l6ZVwiLFxueSksYihkb2N1bWVudC5ib2R5KS5vbihcInN0aWNreV9raXQ6cmVjYWxjXCIseSksYS5vbihcInN0aWNreV9raXQ6ZGV0YWNoXCIsSCksc2V0VGltZW91dChsLDApfX07bj0wO2ZvcihLPXRoaXMubGVuZ3RoO248SztuKyspZD10aGlzW25dLEooYihkKSk7cmV0dXJuIHRoaXN9fSkuY2FsbCh0aGlzKTsiLCIvKiEgQmFja3N0cmV0Y2ggLSB2Mi4wLjQgLSAyMDEzLTA2LTE5XG4qIGh0dHA6Ly9zcm9iYmluLmNvbS9qcXVlcnktcGx1Z2lucy9iYWNrc3RyZXRjaC9cbiogQ29weXJpZ2h0IChjKSAyMDEzIFNjb3R0IFJvYmJpbjsgTGljZW5zZWQgTUlUICovXG4oZnVuY3Rpb24oYSxkLHApe2EuZm4uYmFja3N0cmV0Y2g9ZnVuY3Rpb24oYyxiKXsoYz09PXB8fDA9PT1jLmxlbmd0aCkmJmEuZXJyb3IoXCJObyBpbWFnZXMgd2VyZSBzdXBwbGllZCBmb3IgQmFja3N0cmV0Y2hcIik7MD09PWEoZCkuc2Nyb2xsVG9wKCkmJmQuc2Nyb2xsVG8oMCwwKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxnPWQuZGF0YShcImJhY2tzdHJldGNoXCIpO2lmKGcpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBjJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBnW2NdKXtnW2NdKGIpO3JldHVybn1iPWEuZXh0ZW5kKGcub3B0aW9ucyxiKTtnLmRlc3Ryb3koITApfWc9bmV3IHEodGhpcyxjLGIpO2QuZGF0YShcImJhY2tzdHJldGNoXCIsZyl9KX07YS5iYWNrc3RyZXRjaD1mdW5jdGlvbihjLGIpe3JldHVybiBhKFwiYm9keVwiKS5iYWNrc3RyZXRjaChjLGIpLmRhdGEoXCJiYWNrc3RyZXRjaFwiKX07YS5leHByW1wiOlwiXS5iYWNrc3RyZXRjaD1mdW5jdGlvbihjKXtyZXR1cm4gYShjKS5kYXRhKFwiYmFja3N0cmV0Y2hcIikhPT1wfTthLmZuLmJhY2tzdHJldGNoLmRlZmF1bHRzPXtjZW50ZXJlZFg6ITAsY2VudGVyZWRZOiEwLGR1cmF0aW9uOjVFMyxmYWRlOjB9O3ZhciByPXtsZWZ0OjAsdG9wOjAsb3ZlcmZsb3c6XCJoaWRkZW5cIixtYXJnaW46MCxwYWRkaW5nOjAsaGVpZ2h0OlwiMTAwJVwiLHdpZHRoOlwiMTAwJVwiLHpJbmRleDotOTk5OTk5fSxzPXtwb3NpdGlvbjpcImFic29sdXRlXCIsZGlzcGxheTpcIm5vbmVcIixtYXJnaW46MCxwYWRkaW5nOjAsYm9yZGVyOlwibm9uZVwiLHdpZHRoOlwiYXV0b1wiLGhlaWdodDpcImF1dG9cIixtYXhIZWlnaHQ6XCJub25lXCIsbWF4V2lkdGg6XCJub25lXCIsekluZGV4Oi05OTk5OTl9LHE9ZnVuY3Rpb24oYyxiLGUpe3RoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxhLmZuLmJhY2tzdHJldGNoLmRlZmF1bHRzLGV8fHt9KTt0aGlzLmltYWdlcz1hLmlzQXJyYXkoYik/YjpbYl07YS5lYWNoKHRoaXMuaW1hZ2VzLGZ1bmN0aW9uKCl7YShcIjxpbWcgLz5cIilbMF0uc3JjPXRoaXN9KTt0aGlzLmlzQm9keT1jPT09ZG9jdW1lbnQuYm9keTt0aGlzLiRjb250YWluZXI9YShjKTt0aGlzLiRyb290PXRoaXMuaXNCb2R5P2w/YShkKTphKGRvY3VtZW50KTp0aGlzLiRjb250YWluZXI7Yz10aGlzLiRjb250YWluZXIuY2hpbGRyZW4oXCIuYmFja3N0cmV0Y2hcIikuZmlyc3QoKTt0aGlzLiR3cmFwPWMubGVuZ3RoP2M6YSgnPGRpdiBjbGFzcz1cImJhY2tzdHJldGNoXCI+PC9kaXY+JykuY3NzKHIpLmFwcGVuZFRvKHRoaXMuJGNvbnRhaW5lcik7dGhpcy5pc0JvZHl8fChjPXRoaXMuJGNvbnRhaW5lci5jc3MoXCJwb3NpdGlvblwiKSxiPXRoaXMuJGNvbnRhaW5lci5jc3MoXCJ6SW5kZXhcIiksdGhpcy4kY29udGFpbmVyLmNzcyh7cG9zaXRpb246XCJzdGF0aWNcIj09PWM/XCJyZWxhdGl2ZVwiOmMsekluZGV4OlwiYXV0b1wiPT09Yj8wOmIsYmFja2dyb3VuZDpcIm5vbmVcIn0pLHRoaXMuJHdyYXAuY3NzKHt6SW5kZXg6LTk5OTk5OH0pKTt0aGlzLiR3cmFwLmNzcyh7cG9zaXRpb246dGhpcy5pc0JvZHkmJmw/XCJmaXhlZFwiOlwiYWJzb2x1dGVcIn0pO3RoaXMuaW5kZXg9MDt0aGlzLnNob3codGhpcy5pbmRleCk7YShkKS5vbihcInJlc2l6ZS5iYWNrc3RyZXRjaFwiLGEucHJveHkodGhpcy5yZXNpemUsdGhpcykpLm9uKFwib3JpZW50YXRpb25jaGFuZ2UuYmFja3N0cmV0Y2hcIixhLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy5pc0JvZHkmJjA9PT1kLnBhZ2VZT2Zmc2V0JiYoZC5zY3JvbGxUbygwLDEpLHRoaXMucmVzaXplKCkpfSx0aGlzKSl9O3EucHJvdG90eXBlPXtyZXNpemU6ZnVuY3Rpb24oKXt0cnl7dmFyIGE9e2xlZnQ6MCx0b3A6MH0sYj10aGlzLmlzQm9keT90aGlzLiRyb290LndpZHRoKCk6dGhpcy4kcm9vdC5pbm5lcldpZHRoKCksZT1iLGc9dGhpcy5pc0JvZHk/ZC5pbm5lckhlaWdodD9kLmlubmVySGVpZ2h0OnRoaXMuJHJvb3QuaGVpZ2h0KCk6dGhpcy4kcm9vdC5pbm5lckhlaWdodCgpLGo9ZS90aGlzLiRpbWcuZGF0YShcInJhdGlvXCIpLGY7aj49Zz8oZj0oai1nKS8yLHRoaXMub3B0aW9ucy5jZW50ZXJlZFkmJihhLnRvcD1cIi1cIitmK1wicHhcIikpOihqPWcsZT1qKnRoaXMuJGltZy5kYXRhKFwicmF0aW9cIiksZj0oZS1iKS8yLHRoaXMub3B0aW9ucy5jZW50ZXJlZFgmJihhLmxlZnQ9XCItXCIrZitcInB4XCIpKTt0aGlzLiR3cmFwLmNzcyh7d2lkdGg6YixoZWlnaHQ6Z30pLmZpbmQoXCJpbWc6bm90KC5kZWxldGVhYmxlKVwiKS5jc3Moe3dpZHRoOmUsaGVpZ2h0Omp9KS5jc3MoYSl9Y2F0Y2goaCl7fXJldHVybiB0aGlzfSxzaG93OmZ1bmN0aW9uKGMpe2lmKCEoTWF0aC5hYnMoYyk+dGhpcy5pbWFnZXMubGVuZ3RoLTEpKXt2YXIgYj10aGlzLGU9Yi4kd3JhcC5maW5kKFwiaW1nXCIpLmFkZENsYXNzKFwiZGVsZXRlYWJsZVwiKSxkPXtyZWxhdGVkVGFyZ2V0OmIuJGNvbnRhaW5lclswXX07Yi4kY29udGFpbmVyLnRyaWdnZXIoYS5FdmVudChcImJhY2tzdHJldGNoLmJlZm9yZVwiLGQpLFtiLGNdKTt0aGlzLmluZGV4PWM7Y2xlYXJJbnRlcnZhbChiLmludGVydmFsKTtiLiRpbWc9YShcIjxpbWcgLz5cIikuY3NzKHMpLmJpbmQoXCJsb2FkXCIsZnVuY3Rpb24oZil7dmFyIGg9dGhpcy53aWR0aHx8YShmLnRhcmdldCkud2lkdGgoKTtmPXRoaXMuaGVpZ2h0fHxhKGYudGFyZ2V0KS5oZWlnaHQoKTthKHRoaXMpLmRhdGEoXCJyYXRpb1wiLGgvZik7YSh0aGlzKS5mYWRlSW4oYi5vcHRpb25zLnNwZWVkfHxiLm9wdGlvbnMuZmFkZSxmdW5jdGlvbigpe2UucmVtb3ZlKCk7Yi5wYXVzZWR8fGIuY3ljbGUoKTthKFtcImFmdGVyXCIsXCJzaG93XCJdKS5lYWNoKGZ1bmN0aW9uKCl7Yi4kY29udGFpbmVyLnRyaWdnZXIoYS5FdmVudChcImJhY2tzdHJldGNoLlwiK3RoaXMsZCksW2IsY10pfSl9KTtiLnJlc2l6ZSgpfSkuYXBwZW5kVG8oYi4kd3JhcCk7Yi4kaW1nLmF0dHIoXCJzcmNcIixiLmltYWdlc1tjXSk7cmV0dXJuIGJ9fSxuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hvdyh0aGlzLmluZGV4PHRoaXMuaW1hZ2VzLmxlbmd0aC0xP3RoaXMuaW5kZXgrMTowKX0scHJldjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNob3coMD09PXRoaXMuaW5kZXg/dGhpcy5pbWFnZXMubGVuZ3RoLTE6dGhpcy5pbmRleC0xKX0scGF1c2U6ZnVuY3Rpb24oKXt0aGlzLnBhdXNlZD0hMDtyZXR1cm4gdGhpc30scmVzdW1lOmZ1bmN0aW9uKCl7dGhpcy5wYXVzZWQ9ITE7dGhpcy5uZXh0KCk7cmV0dXJuIHRoaXN9LGN5Y2xlOmZ1bmN0aW9uKCl7MTx0aGlzLmltYWdlcy5sZW5ndGgmJihjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpLHRoaXMuaW50ZXJ2YWw9c2V0SW50ZXJ2YWwoYS5wcm94eShmdW5jdGlvbigpe3RoaXMucGF1c2VkfHx0aGlzLm5leHQoKX0sdGhpcyksdGhpcy5vcHRpb25zLmR1cmF0aW9uKSk7cmV0dXJuIHRoaXN9LGRlc3Ryb3k6ZnVuY3Rpb24oYyl7YShkKS5vZmYoXCJyZXNpemUuYmFja3N0cmV0Y2ggb3JpZW50YXRpb25jaGFuZ2UuYmFja3N0cmV0Y2hcIik7Y2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtjfHx0aGlzLiR3cmFwLnJlbW92ZSgpO3RoaXMuJGNvbnRhaW5lci5yZW1vdmVEYXRhKFwiYmFja3N0cmV0Y2hcIil9fTt2YXIgbCxmPW5hdmlnYXRvci51c2VyQWdlbnQsbT1uYXZpZ2F0b3IucGxhdGZvcm0sZT1mLm1hdGNoKC9BcHBsZVdlYktpdFxcLyhbMC05XSspLyksZT0hIWUmJmVbMV0saD1mLm1hdGNoKC9GZW5uZWNcXC8oWzAtOV0rKS8pLGg9ISFoJiZoWzFdLG49Zi5tYXRjaCgvT3BlcmEgTW9iaVxcLyhbMC05XSspLyksdD0hIW4mJm5bMV0saz1mLm1hdGNoKC9NU0lFIChbMC05XSspLyksaz0hIWsmJmtbMV07bD0hKCgtMTxtLmluZGV4T2YoXCJpUGhvbmVcIil8fC0xPG0uaW5kZXhPZihcImlQYWRcIil8fC0xPG0uaW5kZXhPZihcImlQb2RcIikpJiZlJiY1MzQ+ZXx8ZC5vcGVyYW1pbmkmJlwiW29iamVjdCBPcGVyYU1pbmldXCI9PT17fS50b1N0cmluZy5jYWxsKGQub3BlcmFtaW5pKXx8biYmNzQ1OD50fHwtMTxmLmluZGV4T2YoXCJBbmRyb2lkXCIpJiZlJiY1MzM+ZXx8aCYmNj5ofHxcInBhbG1HZXRSZXNvdXJjZVwiaW4gZCYmZSYmNTM0PmV8fC0xPGYuaW5kZXhPZihcIk1lZUdvXCIpJiYtMTxmLmluZGV4T2YoXCJOb2tpYUJyb3dzZXIvOC41LjBcIil8fGsmJjY+PWspfSkoalF1ZXJ5LHdpbmRvdyk7IiwiLypcbiAgICAgXyBfICAgICAgXyAgICAgICBfXG4gX19ffCAoXykgX19ffCB8IF9fICAoXylfX19cbi8gX198IHwgfC8gX198IHwvIC8gIHwgLyBfX3xcblxcX18gXFwgfCB8IChfX3wgICA8IF8gfCBcXF9fIFxcXG58X19fL198X3xcXF9fX3xffFxcXyhfKS8gfF9fXy9cbiAgICAgICAgICAgICAgICAgICB8X18vXG5cbiBWZXJzaW9uOiAxLjYuMFxuICBBdXRob3I6IEtlbiBXaGVlbGVyXG4gV2Vic2l0ZTogaHR0cDovL2tlbndoZWVsZXIuZ2l0aHViLmlvXG4gICAgRG9jczogaHR0cDovL2tlbndoZWVsZXIuZ2l0aHViLmlvL3NsaWNrXG4gICAgUmVwbzogaHR0cDovL2dpdGh1Yi5jb20va2Vud2hlZWxlci9zbGlja1xuICBJc3N1ZXM6IGh0dHA6Ly9naXRodWIuY29tL2tlbndoZWVsZXIvc2xpY2svaXNzdWVzXG5cbiAqL1xuLyogZ2xvYmFsIHdpbmRvdywgZG9jdW1lbnQsIGRlZmluZSwgalF1ZXJ5LCBzZXRJbnRlcnZhbCwgY2xlYXJJbnRlcnZhbCAqL1xuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KGpRdWVyeSk7XG4gICAgfVxuXG59KGZ1bmN0aW9uKCQpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIFNsaWNrID0gd2luZG93LlNsaWNrIHx8IHt9O1xuXG4gICAgU2xpY2sgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGluc3RhbmNlVWlkID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBTbGljayhlbGVtZW50LCBzZXR0aW5ncykge1xuXG4gICAgICAgICAgICB2YXIgXyA9IHRoaXMsIGRhdGFTZXR0aW5ncztcblxuICAgICAgICAgICAgXy5kZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGFkYXB0aXZlSGVpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhcHBlbmRBcnJvd3M6ICQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgYXBwZW5kRG90czogJChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBhcnJvd3M6IHRydWUsXG4gICAgICAgICAgICAgICAgYXNOYXZGb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldkFycm93OiAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1yb2xlPVwibm9uZVwiIGNsYXNzPVwic2xpY2stcHJldlwiIGFyaWEtbGFiZWw9XCJQcmV2aW91c1wiIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJidXR0b25cIj5QcmV2aW91czwvYnV0dG9uPicsXG4gICAgICAgICAgICAgICAgbmV4dEFycm93OiAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1yb2xlPVwibm9uZVwiIGNsYXNzPVwic2xpY2stbmV4dFwiIGFyaWEtbGFiZWw9XCJOZXh0XCIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImJ1dHRvblwiPk5leHQ8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdXRvcGxheVNwZWVkOiAzMDAwLFxuICAgICAgICAgICAgICAgIGNlbnRlck1vZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNlbnRlclBhZGRpbmc6ICc1MHB4JyxcbiAgICAgICAgICAgICAgICBjc3NFYXNlOiAnZWFzZScsXG4gICAgICAgICAgICAgICAgY3VzdG9tUGFnaW5nOiBmdW5jdGlvbihzbGlkZXIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtcm9sZT1cIm5vbmVcIiByb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgLz4nKS50ZXh0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRvdHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRvdHNDbGFzczogJ3NsaWNrLWRvdHMnLFxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgICAgICAgIGVkZ2VGcmljdGlvbjogMC4zNSxcbiAgICAgICAgICAgICAgICBmYWRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb2N1c09uU2VsZWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbmZpbml0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbml0aWFsU2xpZGU6IDAsXG4gICAgICAgICAgICAgICAgbGF6eUxvYWQ6ICdvbmRlbWFuZCcsXG4gICAgICAgICAgICAgICAgbW9iaWxlRmlyc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhdXNlT25Ib3ZlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXVzZU9uRm9jdXM6IHRydWUsXG4gICAgICAgICAgICAgICAgcGF1c2VPbkRvdHNIb3ZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVzcG9uZFRvOiAnd2luZG93JyxcbiAgICAgICAgICAgICAgICByZXNwb25zaXZlOiBudWxsLFxuICAgICAgICAgICAgICAgIHJvd3M6IDEsXG4gICAgICAgICAgICAgICAgcnRsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzbGlkZTogJycsXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyUm93OiAxLFxuICAgICAgICAgICAgICAgIHNsaWRlc1RvU2hvdzogMSxcbiAgICAgICAgICAgICAgICBzbGlkZXNUb1Njcm9sbDogMSxcbiAgICAgICAgICAgICAgICBzcGVlZDogNTAwLFxuICAgICAgICAgICAgICAgIHN3aXBlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN3aXBlVG9TbGlkZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdG91Y2hNb3ZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRvdWNoVGhyZXNob2xkOiA1LFxuICAgICAgICAgICAgICAgIHVzZUNTUzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1c2VUcmFuc2Zvcm06IHRydWUsXG4gICAgICAgICAgICAgICAgdmFyaWFibGVXaWR0aDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsU3dpcGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FpdEZvckFuaW1hdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgekluZGV4OiAxMDAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfLmluaXRpYWxzID0ge1xuICAgICAgICAgICAgICAgIGFuaW1hdGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF1dG9QbGF5VGltZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudERpcmVjdGlvbjogMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVmdDogbnVsbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50U2xpZGU6IDAsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAxLFxuICAgICAgICAgICAgICAgICRkb3RzOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpc3RXaWR0aDogbnVsbCxcbiAgICAgICAgICAgICAgICBsaXN0SGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgICAgIGxvYWRJbmRleDogMCxcbiAgICAgICAgICAgICAgICAkbmV4dEFycm93OiBudWxsLFxuICAgICAgICAgICAgICAgICRwcmV2QXJyb3c6IG51bGwsXG4gICAgICAgICAgICAgICAgc2xpZGVDb3VudDogbnVsbCxcbiAgICAgICAgICAgICAgICBzbGlkZVdpZHRoOiBudWxsLFxuICAgICAgICAgICAgICAgICRzbGlkZVRyYWNrOiBudWxsLFxuICAgICAgICAgICAgICAgICRzbGlkZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgc2xpZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2xpZGVPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgc3dpcGVMZWZ0OiBudWxsLFxuICAgICAgICAgICAgICAgICRsaXN0OiBudWxsLFxuICAgICAgICAgICAgICAgIHRvdWNoT2JqZWN0OiB7fSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdW5zbGlja2VkOiBmYWxzZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgJC5leHRlbmQoXywgXy5pbml0aWFscyk7XG5cbiAgICAgICAgICAgIF8uYWN0aXZlQnJlYWtwb2ludCA9IG51bGw7XG4gICAgICAgICAgICBfLmFuaW1UeXBlID0gbnVsbDtcbiAgICAgICAgICAgIF8uYW5pbVByb3AgPSBudWxsO1xuICAgICAgICAgICAgXy5icmVha3BvaW50cyA9IFtdO1xuICAgICAgICAgICAgXy5icmVha3BvaW50U2V0dGluZ3MgPSBbXTtcbiAgICAgICAgICAgIF8uY3NzVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgIF8uZm9jdXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIF8uaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIF8uaGlkZGVuID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBfLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICBfLnBvc2l0aW9uUHJvcCA9IG51bGw7XG4gICAgICAgICAgICBfLnJlc3BvbmRUbyA9IG51bGw7XG4gICAgICAgICAgICBfLnJvd0NvdW50ID0gMTtcbiAgICAgICAgICAgIF8uc2hvdWxkQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgXy4kc2xpZGVyID0gJChlbGVtZW50KTtcbiAgICAgICAgICAgIF8uJHNsaWRlc0NhY2hlID0gbnVsbDtcbiAgICAgICAgICAgIF8udHJhbnNmb3JtVHlwZSA9IG51bGw7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gbnVsbDtcbiAgICAgICAgICAgIF8udmlzaWJpbGl0eUNoYW5nZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICAgICAgICAgIF8ud2luZG93V2lkdGggPSAwO1xuICAgICAgICAgICAgXy53aW5kb3dUaW1lciA9IG51bGw7XG5cbiAgICAgICAgICAgIGRhdGFTZXR0aW5ncyA9ICQoZWxlbWVudCkuZGF0YSgnc2xpY2snKSB8fCB7fTtcblxuICAgICAgICAgICAgXy5vcHRpb25zID0gJC5leHRlbmQoe30sIF8uZGVmYXVsdHMsIHNldHRpbmdzLCBkYXRhU2V0dGluZ3MpO1xuXG4gICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IF8ub3B0aW9ucy5pbml0aWFsU2xpZGU7XG5cbiAgICAgICAgICAgIF8ub3JpZ2luYWxTZXR0aW5ncyA9IF8ub3B0aW9ucztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5tb3pIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgXy5oaWRkZW4gPSAnbW96SGlkZGVuJztcbiAgICAgICAgICAgICAgICBfLnZpc2liaWxpdHlDaGFuZ2UgPSAnbW96dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgXy5oaWRkZW4gPSAnd2Via2l0SGlkZGVuJztcbiAgICAgICAgICAgICAgICBfLnZpc2liaWxpdHlDaGFuZ2UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uYXV0b1BsYXkgPSAkLnByb3h5KF8uYXV0b1BsYXksIF8pO1xuICAgICAgICAgICAgXy5hdXRvUGxheUNsZWFyID0gJC5wcm94eShfLmF1dG9QbGF5Q2xlYXIsIF8pO1xuICAgICAgICAgICAgXy5hdXRvUGxheUl0ZXJhdG9yID0gJC5wcm94eShfLmF1dG9QbGF5SXRlcmF0b3IsIF8pO1xuICAgICAgICAgICAgXy5jaGFuZ2VTbGlkZSA9ICQucHJveHkoXy5jaGFuZ2VTbGlkZSwgXyk7XG4gICAgICAgICAgICBfLmNsaWNrSGFuZGxlciA9ICQucHJveHkoXy5jbGlja0hhbmRsZXIsIF8pO1xuICAgICAgICAgICAgXy5zZWxlY3RIYW5kbGVyID0gJC5wcm94eShfLnNlbGVjdEhhbmRsZXIsIF8pO1xuICAgICAgICAgICAgXy5zZXRQb3NpdGlvbiA9ICQucHJveHkoXy5zZXRQb3NpdGlvbiwgXyk7XG4gICAgICAgICAgICBfLnN3aXBlSGFuZGxlciA9ICQucHJveHkoXy5zd2lwZUhhbmRsZXIsIF8pO1xuICAgICAgICAgICAgXy5kcmFnSGFuZGxlciA9ICQucHJveHkoXy5kcmFnSGFuZGxlciwgXyk7XG4gICAgICAgICAgICBfLmtleUhhbmRsZXIgPSAkLnByb3h5KF8ua2V5SGFuZGxlciwgXyk7XG5cbiAgICAgICAgICAgIF8uaW5zdGFuY2VVaWQgPSBpbnN0YW5jZVVpZCsrO1xuXG4gICAgICAgICAgICAvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuICAgICAgICAgICAgLy8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKG11c3Qgc3RhcnQgd2l0aCA8KVxuICAgICAgICAgICAgLy8gRXh0cmFjdGVkIGZyb20galF1ZXJ5IHYxLjExIHNvdXJjZVxuICAgICAgICAgICAgXy5odG1sRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKikkLztcblxuXG4gICAgICAgICAgICBfLnJlZ2lzdGVyQnJlYWtwb2ludHMoKTtcbiAgICAgICAgICAgIF8uaW5pdCh0cnVlKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFNsaWNrO1xuXG4gICAgfSgpKTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hY3RpdmF0ZUFEQSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5maW5kKCcuc2xpY2stYWN0aXZlJykuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAnZmFsc2UnXG4gICAgICAgIH0pLmZpbmQoJ2EsIGlucHV0LCBidXR0b24sIHNlbGVjdCcpLmF0dHIoe1xuICAgICAgICAgICAgJ3RhYmluZGV4JzogJzAnXG4gICAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hZGRTbGlkZSA9IFNsaWNrLnByb3RvdHlwZS5zbGlja0FkZCA9IGZ1bmN0aW9uKG1hcmt1cCwgaW5kZXgsIGFkZEJlZm9yZSkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAodHlwZW9mKGluZGV4KSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBhZGRCZWZvcmUgPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IDAgfHwgKGluZGV4ID49IF8uc2xpZGVDb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8udW5sb2FkKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZihpbmRleCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgXy4kc2xpZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICQobWFya3VwKS5hcHBlbmRUbyhfLiRzbGlkZVRyYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgJChtYXJrdXApLmluc2VydEJlZm9yZShfLiRzbGlkZXMuZXEoaW5kZXgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChtYXJrdXApLmluc2VydEFmdGVyKF8uJHNsaWRlcy5lcShpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFkZEJlZm9yZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICQobWFya3VwKS5wcmVwZW5kVG8oXy4kc2xpZGVUcmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQobWFya3VwKS5hcHBlbmRUbyhfLiRzbGlkZVRyYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlcyA9IF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKTtcblxuICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5hcHBlbmQoXy4kc2xpZGVzKTtcblxuICAgICAgICBfLiRzbGlkZXMuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgICAgJChlbGVtZW50KS5hdHRyKCdkYXRhLXNsaWNrLWluZGV4JywgaW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfLiRzbGlkZXNDYWNoZSA9IF8uJHNsaWRlcztcblxuICAgICAgICBfLnJlaW5pdCgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hbmltYXRlSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcztcbiAgICAgICAgaWYgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPT09IDEgJiYgXy5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0ID09PSB0cnVlICYmIF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRIZWlnaHQgPSBfLiRzbGlkZXMuZXEoXy5jdXJyZW50U2xpZGUpLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgICAgXy4kbGlzdC5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRhcmdldEhlaWdodFxuICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYW5pbWF0ZVNsaWRlID0gZnVuY3Rpb24odGFyZ2V0TGVmdCwgY2FsbGJhY2spIHtcblxuICAgICAgICB2YXIgYW5pbVByb3BzID0ge30sXG4gICAgICAgICAgICBfID0gdGhpcztcblxuICAgICAgICBfLmFuaW1hdGVIZWlnaHQoKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0YXJnZXRMZWZ0ID0gLXRhcmdldExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8udHJhbnNmb3Jtc0VuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRhcmdldExlZnRcbiAgICAgICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQsIF8ub3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0YXJnZXRMZWZ0XG4gICAgICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkLCBfLm9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKF8uY3NzVHJhbnNpdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5ydGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50TGVmdCA9IC0oXy5jdXJyZW50TGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQoe1xuICAgICAgICAgICAgICAgICAgICBhbmltU3RhcnQ6IF8uY3VycmVudExlZnRcbiAgICAgICAgICAgICAgICB9KS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbVN0YXJ0OiB0YXJnZXRMZWZ0XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogXy5vcHRpb25zLnNwZWVkLFxuICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IF8ub3B0aW9ucy5lYXNpbmcsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gTWF0aC5jZWlsKG5vdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyArICdweCwgMHB4KSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MoYW5pbVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BzW18uYW5pbVR5cGVdID0gJ3RyYW5zbGF0ZSgwcHgsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyArICdweCknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKGFuaW1Qcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgXy5hcHBseVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gTWF0aC5jZWlsKHRhcmdldExlZnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BzW18uYW5pbVR5cGVdID0gJ3RyYW5zbGF0ZTNkKCcgKyB0YXJnZXRMZWZ0ICsgJ3B4LCAwcHgsIDBweCknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUzZCgwcHgsJyArIHRhcmdldExlZnQgKyAncHgsIDBweCknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyhhbmltUHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZGlzYWJsZVRyYW5zaXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0TmF2VGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgYXNOYXZGb3IgPSBfLm9wdGlvbnMuYXNOYXZGb3I7XG5cbiAgICAgICAgaWYgKCBhc05hdkZvciAmJiBhc05hdkZvciAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgIGFzTmF2Rm9yID0gJChhc05hdkZvcikubm90KF8uJHNsaWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNOYXZGb3I7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmFzTmF2Rm9yID0gZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBhc05hdkZvciA9IF8uZ2V0TmF2VGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKCBhc05hdkZvciAhPT0gbnVsbCAmJiB0eXBlb2YgYXNOYXZGb3IgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgYXNOYXZGb3IuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gJCh0aGlzKS5zbGljaygnZ2V0U2xpY2snKTtcbiAgICAgICAgICAgICAgICBpZighdGFyZ2V0LnVuc2xpY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2xpZGVIYW5kbGVyKGluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hcHBseVRyYW5zaXRpb24gPSBmdW5jdGlvbihzbGlkZSkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSB7fTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uW18udHJhbnNpdGlvblR5cGVdID0gXy50cmFuc2Zvcm1UeXBlICsgJyAnICsgXy5vcHRpb25zLnNwZWVkICsgJ21zICcgKyBfLm9wdGlvbnMuY3NzRWFzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25bXy50cmFuc2l0aW9uVHlwZV0gPSAnb3BhY2l0eSAnICsgXy5vcHRpb25zLnNwZWVkICsgJ21zICcgKyBfLm9wdGlvbnMuY3NzRWFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKHRyYW5zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlKS5jc3ModHJhbnNpdGlvbik7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYXV0b1BsYXkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5hdXRvUGxheUNsZWFyKCk7XG5cbiAgICAgICAgaWYgKCBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICkge1xuICAgICAgICAgICAgXy5hdXRvUGxheVRpbWVyID0gc2V0SW50ZXJ2YWwoIF8uYXV0b1BsYXlJdGVyYXRvciwgXy5vcHRpb25zLmF1dG9wbGF5U3BlZWQgKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hdXRvUGxheUNsZWFyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLmF1dG9QbGF5VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoXy5hdXRvUGxheVRpbWVyKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hdXRvUGxheUl0ZXJhdG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgc2xpZGVUbyA9IF8uY3VycmVudFNsaWRlICsgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuXG4gICAgICAgIGlmICggIV8ucGF1c2VkICYmICFfLmludGVycnVwdGVkICYmICFfLmZvY3Vzc2VkICkge1xuXG4gICAgICAgICAgICBpZiAoIF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIF8uZGlyZWN0aW9uID09PSAxICYmICggXy5jdXJyZW50U2xpZGUgKyAxICkgPT09ICggXy5zbGlkZUNvdW50IC0gMSApKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZGlyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggXy5kaXJlY3Rpb24gPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2xpZGVUbyA9IF8uY3VycmVudFNsaWRlIC0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggXy5jdXJyZW50U2xpZGUgLSAxID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5kaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoIHNsaWRlVG8gKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmJ1aWxkQXJyb3dzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYXJyb3dzID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cgPSAkKF8ub3B0aW9ucy5wcmV2QXJyb3cpLmFkZENsYXNzKCdzbGljay1hcnJvdycpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93ID0gJChfLm9wdGlvbnMubmV4dEFycm93KS5hZGRDbGFzcygnc2xpY2stYXJyb3cnKTtcblxuICAgICAgICAgICAgaWYoIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKSB7XG5cbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWhpZGRlbicpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuIHRhYmluZGV4Jyk7XG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LnJlbW92ZUNsYXNzKCdzbGljay1oaWRkZW4nKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiB0YWJpbmRleCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF8uaHRtbEV4cHIudGVzdChfLm9wdGlvbnMucHJldkFycm93KSkge1xuICAgICAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cucHJlcGVuZFRvKF8ub3B0aW9ucy5hcHBlbmRBcnJvd3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfLmh0bWxFeHByLnRlc3QoXy5vcHRpb25zLm5leHRBcnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LmFwcGVuZFRvKF8ub3B0aW9ucy5hcHBlbmRBcnJvd3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgXy4kcHJldkFycm93XG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cuYWRkKCBfLiRuZXh0QXJyb3cgKVxuXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2staGlkZGVuJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtZGlzYWJsZWQnOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAnLTEnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5idWlsZERvdHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBpLCBkb3Q7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVyLmFkZENsYXNzKCdzbGljay1kb3R0ZWQnKTtcblxuICAgICAgICAgICAgZG90ID0gJCgnPHVsIC8+JykuYWRkQ2xhc3MoXy5vcHRpb25zLmRvdHNDbGFzcyk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gXy5nZXREb3RDb3VudCgpOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBkb3QuYXBwZW5kKCQoJzxsaSAvPicpLmFwcGVuZChfLm9wdGlvbnMuY3VzdG9tUGFnaW5nLmNhbGwodGhpcywgXywgaSkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy4kZG90cyA9IGRvdC5hcHBlbmRUbyhfLm9wdGlvbnMuYXBwZW5kRG90cyk7XG5cbiAgICAgICAgICAgIF8uJGRvdHMuZmluZCgnbGknKS5maXJzdCgpLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKS5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYnVpbGRPdXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy4kc2xpZGVzID1cbiAgICAgICAgICAgIF8uJHNsaWRlclxuICAgICAgICAgICAgICAgIC5jaGlsZHJlbiggXy5vcHRpb25zLnNsaWRlICsgJzpub3QoLnNsaWNrLWNsb25lZCknKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stc2xpZGUnKTtcblxuICAgICAgICBfLnNsaWRlQ291bnQgPSBfLiRzbGlkZXMubGVuZ3RoO1xuXG4gICAgICAgIF8uJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RhdGEtc2xpY2staW5kZXgnLCBpbmRleClcbiAgICAgICAgICAgICAgICAuZGF0YSgnb3JpZ2luYWxTdHlsaW5nJywgJChlbGVtZW50KS5hdHRyKCdzdHlsZScpIHx8ICcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy4kc2xpZGVyLmFkZENsYXNzKCdzbGljay1zbGlkZXInKTtcblxuICAgICAgICBfLiRzbGlkZVRyYWNrID0gKF8uc2xpZGVDb3VudCA9PT0gMCkgP1xuICAgICAgICAgICAgJCgnPGRpdiBjbGFzcz1cInNsaWNrLXRyYWNrXCIvPicpLmFwcGVuZFRvKF8uJHNsaWRlcikgOlxuICAgICAgICAgICAgXy4kc2xpZGVzLndyYXBBbGwoJzxkaXYgY2xhc3M9XCJzbGljay10cmFja1wiLz4nKS5wYXJlbnQoKTtcblxuICAgICAgICBfLiRsaXN0ID0gXy4kc2xpZGVUcmFjay53cmFwKFxuICAgICAgICAgICAgJzxkaXYgYXJpYS1saXZlPVwicG9saXRlXCIgY2xhc3M9XCJzbGljay1saXN0XCIvPicpLnBhcmVudCgpO1xuICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcygnb3BhY2l0eScsIDApO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSB8fCBfLm9wdGlvbnMuc3dpcGVUb1NsaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgJCgnaW1nW2RhdGEtbGF6eV0nLCBfLiRzbGlkZXIpLm5vdCgnW3NyY10nKS5hZGRDbGFzcygnc2xpY2stbG9hZGluZycpO1xuXG4gICAgICAgIF8uc2V0dXBJbmZpbml0ZSgpO1xuXG4gICAgICAgIF8uYnVpbGRBcnJvd3MoKTtcblxuICAgICAgICBfLmJ1aWxkRG90cygpO1xuXG4gICAgICAgIF8udXBkYXRlRG90cygpO1xuXG5cbiAgICAgICAgXy5zZXRTbGlkZUNsYXNzZXModHlwZW9mIF8uY3VycmVudFNsaWRlID09PSAnbnVtYmVyJyA/IF8uY3VycmVudFNsaWRlIDogMCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kcmFnZ2FibGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uJGxpc3QuYWRkQ2xhc3MoJ2RyYWdnYWJsZScpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmJ1aWxkUm93cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcywgYSwgYiwgYywgbmV3U2xpZGVzLCBudW1PZlNsaWRlcywgb3JpZ2luYWxTbGlkZXMsc2xpZGVzUGVyU2VjdGlvbjtcblxuICAgICAgICBuZXdTbGlkZXMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIG9yaWdpbmFsU2xpZGVzID0gXy4kc2xpZGVyLmNoaWxkcmVuKCk7XG5cbiAgICAgICAgaWYoXy5vcHRpb25zLnJvd3MgPiAxKSB7XG5cbiAgICAgICAgICAgIHNsaWRlc1BlclNlY3Rpb24gPSBfLm9wdGlvbnMuc2xpZGVzUGVyUm93ICogXy5vcHRpb25zLnJvd3M7XG4gICAgICAgICAgICBudW1PZlNsaWRlcyA9IE1hdGguY2VpbChcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFNsaWRlcy5sZW5ndGggLyBzbGlkZXNQZXJTZWN0aW9uXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmb3IoYSA9IDA7IGEgPCBudW1PZlNsaWRlczsgYSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgc2xpZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBmb3IoYiA9IDA7IGIgPCBfLm9wdGlvbnMucm93czsgYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGMgPSAwOyBjIDwgXy5vcHRpb25zLnNsaWRlc1BlclJvdzsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gKGEgKiBzbGlkZXNQZXJTZWN0aW9uICsgKChiICogXy5vcHRpb25zLnNsaWRlc1BlclJvdykgKyBjKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxTbGlkZXMuZ2V0KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQob3JpZ2luYWxTbGlkZXMuZ2V0KHRhcmdldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlLmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1NsaWRlcy5hcHBlbmRDaGlsZChzbGlkZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uJHNsaWRlci5lbXB0eSgpLmFwcGVuZChuZXdTbGlkZXMpO1xuICAgICAgICAgICAgXy4kc2xpZGVyLmNoaWxkcmVuKCkuY2hpbGRyZW4oKS5jaGlsZHJlbigpXG4gICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCc6KDEwMCAvIF8ub3B0aW9ucy5zbGlkZXNQZXJSb3cpICsgJyUnLFxuICAgICAgICAgICAgICAgICAgICAnZGlzcGxheSc6ICdpbmxpbmUtYmxvY2snXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jaGVja1Jlc3BvbnNpdmUgPSBmdW5jdGlvbihpbml0aWFsLCBmb3JjZVVwZGF0ZSkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGJyZWFrcG9pbnQsIHRhcmdldEJyZWFrcG9pbnQsIHJlc3BvbmRUb1dpZHRoLCB0cmlnZ2VyQnJlYWtwb2ludCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2xpZGVyV2lkdGggPSBfLiRzbGlkZXIud2lkdGgoKTtcbiAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgJCh3aW5kb3cpLndpZHRoKCk7XG5cbiAgICAgICAgaWYgKF8ucmVzcG9uZFRvID09PSAnd2luZG93Jykge1xuICAgICAgICAgICAgcmVzcG9uZFRvV2lkdGggPSB3aW5kb3dXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChfLnJlc3BvbmRUbyA9PT0gJ3NsaWRlcicpIHtcbiAgICAgICAgICAgIHJlc3BvbmRUb1dpZHRoID0gc2xpZGVyV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5yZXNwb25kVG8gPT09ICdtaW4nKSB7XG4gICAgICAgICAgICByZXNwb25kVG9XaWR0aCA9IE1hdGgubWluKHdpbmRvd1dpZHRoLCBzbGlkZXJXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5yZXNwb25zaXZlICYmXG4gICAgICAgICAgICBfLm9wdGlvbnMucmVzcG9uc2l2ZS5sZW5ndGggJiZcbiAgICAgICAgICAgIF8ub3B0aW9ucy5yZXNwb25zaXZlICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKGJyZWFrcG9pbnQgaW4gXy5icmVha3BvaW50cykge1xuICAgICAgICAgICAgICAgIGlmIChfLmJyZWFrcG9pbnRzLmhhc093blByb3BlcnR5KGJyZWFrcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLm9yaWdpbmFsU2V0dGluZ3MubW9iaWxlRmlyc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uZFRvV2lkdGggPCBfLmJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnJlYWtwb2ludCA9IF8uYnJlYWtwb2ludHNbYnJlYWtwb2ludF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uZFRvV2lkdGggPiBfLmJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnJlYWtwb2ludCA9IF8uYnJlYWtwb2ludHNbYnJlYWtwb2ludF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRCcmVha3BvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uYWN0aXZlQnJlYWtwb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0QnJlYWtwb2ludCAhPT0gXy5hY3RpdmVCcmVha3BvaW50IHx8IGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmFjdGl2ZUJyZWFrcG9pbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5icmVha3BvaW50U2V0dGluZ3NbdGFyZ2V0QnJlYWtwb2ludF0gPT09ICd1bnNsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8udW5zbGljayh0YXJnZXRCcmVha3BvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zID0gJC5leHRlbmQoe30sIF8ub3JpZ2luYWxTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5icmVha3BvaW50U2V0dGluZ3NbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCcmVha3BvaW50XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBfLm9wdGlvbnMuaW5pdGlhbFNsaWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLnJlZnJlc2goaW5pdGlhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQnJlYWtwb2ludCA9IHRhcmdldEJyZWFrcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfLmFjdGl2ZUJyZWFrcG9pbnQgPSB0YXJnZXRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5icmVha3BvaW50U2V0dGluZ3NbdGFyZ2V0QnJlYWtwb2ludF0gPT09ICd1bnNsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy51bnNsaWNrKHRhcmdldEJyZWFrcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zID0gJC5leHRlbmQoe30sIF8ub3JpZ2luYWxTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmJyZWFrcG9pbnRTZXR0aW5nc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnJlYWtwb2ludF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IF8ub3B0aW9ucy5pbml0aWFsU2xpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnJlZnJlc2goaW5pdGlhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckJyZWFrcG9pbnQgPSB0YXJnZXRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uYWN0aXZlQnJlYWtwb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfLmFjdGl2ZUJyZWFrcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMgPSBfLm9yaWdpbmFsU2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IF8ub3B0aW9ucy5pbml0aWFsU2xpZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXy5yZWZyZXNoKGluaXRpYWwpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQnJlYWtwb2ludCA9IHRhcmdldEJyZWFrcG9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvbmx5IHRyaWdnZXIgYnJlYWtwb2ludHMgZHVyaW5nIGFuIGFjdHVhbCBicmVhay4gbm90IG9uIGluaXRpYWxpemUuXG4gICAgICAgICAgICBpZiggIWluaXRpYWwgJiYgdHJpZ2dlckJyZWFrcG9pbnQgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdicmVha3BvaW50JywgW18sIHRyaWdnZXJCcmVha3BvaW50XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2hhbmdlU2xpZGUgPSBmdW5jdGlvbihldmVudCwgZG9udEFuaW1hdGUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KSxcbiAgICAgICAgICAgIGluZGV4T2Zmc2V0LCBzbGlkZU9mZnNldCwgdW5ldmVuT2Zmc2V0O1xuXG4gICAgICAgIC8vIElmIHRhcmdldCBpcyBhIGxpbmssIHByZXZlbnQgZGVmYXVsdCBhY3Rpb24uXG4gICAgICAgIGlmKCR0YXJnZXQuaXMoJ2EnKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRhcmdldCBpcyBub3QgdGhlIDxsaT4gZWxlbWVudCAoaWU6IGEgY2hpbGQpLCBmaW5kIHRoZSA8bGk+LlxuICAgICAgICBpZighJHRhcmdldC5pcygnbGknKSkge1xuICAgICAgICAgICAgJHRhcmdldCA9ICR0YXJnZXQuY2xvc2VzdCgnbGknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVuZXZlbk9mZnNldCA9IChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgIT09IDApO1xuICAgICAgICBpbmRleE9mZnNldCA9IHVuZXZlbk9mZnNldCA/IDAgOiAoXy5zbGlkZUNvdW50IC0gXy5jdXJyZW50U2xpZGUpICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGF0YS5tZXNzYWdlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3ByZXZpb3VzJzpcbiAgICAgICAgICAgICAgICBzbGlkZU9mZnNldCA9IGluZGV4T2Zmc2V0ID09PSAwID8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAtIGluZGV4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKF8uY3VycmVudFNsaWRlIC0gc2xpZGVPZmZzZXQsIGZhbHNlLCBkb250QW5pbWF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICBzbGlkZU9mZnNldCA9IGluZGV4T2Zmc2V0ID09PSAwID8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogaW5kZXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoXy5jdXJyZW50U2xpZGUgKyBzbGlkZU9mZnNldCwgZmFsc2UsIGRvbnRBbmltYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2luZGV4JzpcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBldmVudC5kYXRhLmluZGV4ID09PSAwID8gMCA6XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXggfHwgJHRhcmdldC5pbmRleCgpICogXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuXG4gICAgICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoXy5jaGVja05hdmlnYWJsZShpbmRleCksIGZhbHNlLCBkb250QW5pbWF0ZSk7XG4gICAgICAgICAgICAgICAgJHRhcmdldC5jaGlsZHJlbigpLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNoZWNrTmF2aWdhYmxlID0gZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBuYXZpZ2FibGVzLCBwcmV2TmF2aWdhYmxlO1xuXG4gICAgICAgIG5hdmlnYWJsZXMgPSBfLmdldE5hdmlnYWJsZUluZGV4ZXMoKTtcbiAgICAgICAgcHJldk5hdmlnYWJsZSA9IDA7XG4gICAgICAgIGlmIChpbmRleCA+IG5hdmlnYWJsZXNbbmF2aWdhYmxlcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgaW5kZXggPSBuYXZpZ2FibGVzW25hdmlnYWJsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuIGluIG5hdmlnYWJsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBuYXZpZ2FibGVzW25dKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcHJldk5hdmlnYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZOYXZpZ2FibGUgPSBuYXZpZ2FibGVzW25dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2xlYW5VcEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmRvdHMgJiYgXy4kZG90cyAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICAkKCdsaScsIF8uJGRvdHMpXG4gICAgICAgICAgICAgICAgLm9mZignY2xpY2suc2xpY2snLCBfLmNoYW5nZVNsaWRlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ21vdXNlZW50ZXIuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCB0cnVlKSlcbiAgICAgICAgICAgICAgICAub2ZmKCdtb3VzZWxlYXZlLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgZmFsc2UpKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgXy4kc2xpZGVyLm9mZignZm9jdXMuc2xpY2sgYmx1ci5zbGljaycpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYXJyb3dzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8uJHByZXZBcnJvdyAmJiBfLiRwcmV2QXJyb3cub2ZmKCdjbGljay5zbGljaycsIF8uY2hhbmdlU2xpZGUpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93ICYmIF8uJG5leHRBcnJvdy5vZmYoJ2NsaWNrLnNsaWNrJywgXy5jaGFuZ2VTbGlkZSk7XG4gICAgICAgIH1cblxuICAgICAgICBfLiRsaXN0Lm9mZigndG91Y2hzdGFydC5zbGljayBtb3VzZWRvd24uc2xpY2snLCBfLnN3aXBlSGFuZGxlcik7XG4gICAgICAgIF8uJGxpc3Qub2ZmKCd0b3VjaG1vdmUuc2xpY2sgbW91c2Vtb3ZlLnNsaWNrJywgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9mZigndG91Y2hlbmQuc2xpY2sgbW91c2V1cC5zbGljaycsIF8uc3dpcGVIYW5kbGVyKTtcbiAgICAgICAgXy4kbGlzdC5vZmYoJ3RvdWNoY2FuY2VsLnNsaWNrIG1vdXNlbGVhdmUuc2xpY2snLCBfLnN3aXBlSGFuZGxlcik7XG5cbiAgICAgICAgXy4kbGlzdC5vZmYoJ2NsaWNrLnNsaWNrJywgXy5jbGlja0hhbmRsZXIpO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLm9mZihfLnZpc2liaWxpdHlDaGFuZ2UsIF8udmlzaWJpbGl0eSk7XG5cbiAgICAgICAgXy5jbGVhblVwU2xpZGVFdmVudHMoKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uJGxpc3Qub2ZmKCdrZXlkb3duLnNsaWNrJywgXy5rZXlIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZm9jdXNPblNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgJChfLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9mZignY2xpY2suc2xpY2snLCBfLnNlbGVjdEhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh3aW5kb3cpLm9mZignb3JpZW50YXRpb25jaGFuZ2Uuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsIF8ub3JpZW50YXRpb25DaGFuZ2UpO1xuXG4gICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgXy5yZXNpemUpO1xuXG4gICAgICAgICQoJ1tkcmFnZ2FibGUhPXRydWVdJywgXy4kc2xpZGVUcmFjaykub2ZmKCdkcmFnc3RhcnQnLCBfLnByZXZlbnREZWZhdWx0KTtcblxuICAgICAgICAkKHdpbmRvdykub2ZmKCdsb2FkLnNsaWNrLnNsaWNrLScgKyBfLmluc3RhbmNlVWlkLCBfLnNldFBvc2l0aW9uKTtcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKCdyZWFkeS5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgXy5zZXRQb3NpdGlvbik7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNsZWFuVXBTbGlkZUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLiRsaXN0Lm9mZignbW91c2VlbnRlci5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIHRydWUpKTtcbiAgICAgICAgXy4kbGlzdC5vZmYoJ21vdXNlbGVhdmUuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCBmYWxzZSkpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jbGVhblVwUm93cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcywgb3JpZ2luYWxTbGlkZXM7XG5cbiAgICAgICAgaWYoXy5vcHRpb25zLnJvd3MgPiAxKSB7XG4gICAgICAgICAgICBvcmlnaW5hbFNsaWRlcyA9IF8uJHNsaWRlcy5jaGlsZHJlbigpLmNoaWxkcmVuKCk7XG4gICAgICAgICAgICBvcmlnaW5hbFNsaWRlcy5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgXy4kc2xpZGVyLmVtcHR5KCkuYXBwZW5kKG9yaWdpbmFsU2xpZGVzKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jbGlja0hhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5zaG91bGRDbGljayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihyZWZyZXNoKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uYXV0b1BsYXlDbGVhcigpO1xuXG4gICAgICAgIF8udG91Y2hPYmplY3QgPSB7fTtcblxuICAgICAgICBfLmNsZWFuVXBFdmVudHMoKTtcblxuICAgICAgICAkKCcuc2xpY2stY2xvbmVkJywgXy4kc2xpZGVyKS5kZXRhY2goKTtcblxuICAgICAgICBpZiAoXy4kZG90cykge1xuICAgICAgICAgICAgXy4kZG90cy5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKCBfLiRwcmV2QXJyb3cgJiYgXy4kcHJldkFycm93Lmxlbmd0aCApIHtcblxuICAgICAgICAgICAgXy4kcHJldkFycm93XG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCBzbGljay1hcnJvdyBzbGljay1oaWRkZW4nKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4JylcbiAgICAgICAgICAgICAgICAuY3NzKCdkaXNwbGF5JywnJyk7XG5cbiAgICAgICAgICAgIGlmICggXy5odG1sRXhwci50ZXN0KCBfLm9wdGlvbnMucHJldkFycm93ICkpIHtcbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8uJG5leHRBcnJvdyAmJiBfLiRuZXh0QXJyb3cubGVuZ3RoICkge1xuXG4gICAgICAgICAgICBfLiRuZXh0QXJyb3dcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkIHNsaWNrLWFycm93IHNsaWNrLWhpZGRlbicpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuIGFyaWEtZGlzYWJsZWQgdGFiaW5kZXgnKVxuICAgICAgICAgICAgICAgIC5jc3MoJ2Rpc3BsYXknLCcnKTtcblxuICAgICAgICAgICAgaWYgKCBfLmh0bWxFeHByLnRlc3QoIF8ub3B0aW9ucy5uZXh0QXJyb3cgKSkge1xuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoXy4kc2xpZGVzKSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stc2xpZGUgc2xpY2stYWN0aXZlIHNsaWNrLWNlbnRlciBzbGljay12aXNpYmxlIHNsaWNrLWN1cnJlbnQnKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtc2xpY2staW5kZXgnKVxuICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYXR0cignc3R5bGUnLCAkKHRoaXMpLmRhdGEoJ29yaWdpbmFsU3R5bGluZycpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmRldGFjaCgpO1xuXG4gICAgICAgICAgICBfLiRsaXN0LmRldGFjaCgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZXIuYXBwZW5kKF8uJHNsaWRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBfLmNsZWFuVXBSb3dzKCk7XG5cbiAgICAgICAgXy4kc2xpZGVyLnJlbW92ZUNsYXNzKCdzbGljay1zbGlkZXInKTtcbiAgICAgICAgXy4kc2xpZGVyLnJlbW92ZUNsYXNzKCdzbGljay1pbml0aWFsaXplZCcpO1xuICAgICAgICBfLiRzbGlkZXIucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRvdHRlZCcpO1xuXG4gICAgICAgIF8udW5zbGlja2VkID0gdHJ1ZTtcblxuICAgICAgICBpZighcmVmcmVzaCkge1xuICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2Rlc3Ryb3knLCBbX10pO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmRpc2FibGVUcmFuc2l0aW9uID0gZnVuY3Rpb24oc2xpZGUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICB0cmFuc2l0aW9uID0ge307XG5cbiAgICAgICAgdHJhbnNpdGlvbltfLnRyYW5zaXRpb25UeXBlXSA9ICcnO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKHRyYW5zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlKS5jc3ModHJhbnNpdGlvbik7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZmFkZVNsaWRlID0gZnVuY3Rpb24oc2xpZGVJbmRleCwgY2FsbGJhY2spIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8uY3NzVHJhbnNpdGlvbnMgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZUluZGV4KS5jc3Moe1xuICAgICAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZUluZGV4KS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQsIF8ub3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBfLmFwcGx5VHJhbnNpdGlvbihzbGlkZUluZGV4KTtcblxuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlSW5kZXgpLmNzcyh7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIF8uZGlzYWJsZVRyYW5zaXRpb24oc2xpZGVJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCgpO1xuICAgICAgICAgICAgICAgIH0sIF8ub3B0aW9ucy5zcGVlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5mYWRlU2xpZGVPdXQgPSBmdW5jdGlvbihzbGlkZUluZGV4KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLmNzc1RyYW5zaXRpb25zID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGVJbmRleCkuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXggLSAyXG4gICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQsIF8ub3B0aW9ucy5lYXNpbmcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF8uYXBwbHlUcmFuc2l0aW9uKHNsaWRlSW5kZXgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGVJbmRleCkuY3NzKHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleCAtIDJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZmlsdGVyU2xpZGVzID0gU2xpY2sucHJvdG90eXBlLnNsaWNrRmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChmaWx0ZXIgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVzQ2FjaGUgPSBfLiRzbGlkZXM7XG5cbiAgICAgICAgICAgIF8udW5sb2FkKCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKTtcblxuICAgICAgICAgICAgXy4kc2xpZGVzQ2FjaGUuZmlsdGVyKGZpbHRlcikuYXBwZW5kVG8oXy4kc2xpZGVUcmFjayk7XG5cbiAgICAgICAgICAgIF8ucmVpbml0KCk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5mb2N1c0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy4kc2xpZGVyXG4gICAgICAgICAgICAub2ZmKCdmb2N1cy5zbGljayBibHVyLnNsaWNrJylcbiAgICAgICAgICAgIC5vbignZm9jdXMuc2xpY2sgYmx1ci5zbGljaycsXG4gICAgICAgICAgICAgICAgJyo6bm90KC5zbGljay1hcnJvdyknLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHZhciAkc2YgPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgaWYoIF8ub3B0aW9ucy5wYXVzZU9uRm9jdXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZm9jdXNzZWQgPSAkc2YuaXMoJzpmb2N1cycpO1xuICAgICAgICAgICAgICAgICAgICBfLmF1dG9QbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldEN1cnJlbnQgPSBTbGljay5wcm90b3R5cGUuc2xpY2tDdXJyZW50U2xpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfLmN1cnJlbnRTbGlkZTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0RG90Q291bnQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGJyZWFrUG9pbnQgPSAwO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgIHZhciBwYWdlclF0eSA9IDA7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd2hpbGUgKGJyZWFrUG9pbnQgPCBfLnNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICArK3BhZ2VyUXR5O1xuICAgICAgICAgICAgICAgIGJyZWFrUG9pbnQgPSBjb3VudGVyICsgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICAgICAgICAgICAgICAgIGNvdW50ZXIgKz0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgOiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwYWdlclF0eSA9IF8uc2xpZGVDb3VudDtcbiAgICAgICAgfSBlbHNlIGlmKCFfLm9wdGlvbnMuYXNOYXZGb3IpIHtcbiAgICAgICAgICAgIHBhZ2VyUXR5ID0gMSArIE1hdGguY2VpbCgoXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykgLyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoYnJlYWtQb2ludCA8IF8uc2xpZGVDb3VudCkge1xuICAgICAgICAgICAgICAgICsrcGFnZXJRdHk7XG4gICAgICAgICAgICAgICAgYnJlYWtQb2ludCA9IGNvdW50ZXIgKyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgICAgICAgICAgY291bnRlciArPSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA6IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFnZXJRdHkgLSAxO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24oc2xpZGVJbmRleCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHRhcmdldExlZnQsXG4gICAgICAgICAgICB2ZXJ0aWNhbEhlaWdodCxcbiAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIHRhcmdldFNsaWRlO1xuXG4gICAgICAgIF8uc2xpZGVPZmZzZXQgPSAwO1xuICAgICAgICB2ZXJ0aWNhbEhlaWdodCA9IF8uJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KHRydWUpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9IChfLnNsaWRlV2lkdGggKiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSAqIC0xO1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gKHZlcnRpY2FsSGVpZ2h0ICogXy5vcHRpb25zLnNsaWRlc1RvU2hvdykgKiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA+IF8uc2xpZGVDb3VudCAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGlkZUluZGV4ID4gXy5zbGlkZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gKChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC0gKHNsaWRlSW5kZXggLSBfLnNsaWRlQ291bnQpKSAqIF8uc2xpZGVXaWR0aCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gKChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC0gKHNsaWRlSW5kZXggLSBfLnNsaWRlQ291bnQpKSAqIHZlcnRpY2FsSGVpZ2h0KSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9ICgoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSAqIF8uc2xpZGVXaWR0aCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gKChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpICogdmVydGljYWxIZWlnaHQpICogLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPiBfLnNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gKChzbGlkZUluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdykgLSBfLnNsaWRlQ291bnQpICogXy5zbGlkZVdpZHRoO1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gKChzbGlkZUluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdykgLSBfLnNsaWRlQ291bnQpICogdmVydGljYWxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmVydGljYWxPZmZzZXQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlICYmIF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5zbGlkZU9mZnNldCArPSBfLnNsaWRlV2lkdGggKiBNYXRoLmZsb29yKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyKSAtIF8uc2xpZGVXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9IDA7XG4gICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ICs9IF8uc2xpZGVXaWR0aCAqIE1hdGguZmxvb3IoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRhcmdldExlZnQgPSAoKHNsaWRlSW5kZXggKiBfLnNsaWRlV2lkdGgpICogLTEpICsgXy5zbGlkZU9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldExlZnQgPSAoKHNsaWRlSW5kZXggKiB2ZXJ0aWNhbEhlaWdodCkgKiAtMSkgKyB2ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmFyaWFibGVXaWR0aCA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgfHwgXy5vcHRpb25zLmluZmluaXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykuZXEoc2xpZGVJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykuZXEoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTbGlkZVswXSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gKF8uJHNsaWRlVHJhY2sud2lkdGgoKSAtIHRhcmdldFNsaWRlWzBdLm9mZnNldExlZnQgLSB0YXJnZXRTbGlkZS53aWR0aCgpKSAqIC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSB0YXJnZXRTbGlkZVswXSA/IHRhcmdldFNsaWRlWzBdLm9mZnNldExlZnQgKiAtMSA6IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyB8fCBfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykuZXEoc2xpZGVJbmRleCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2xpZGUgPSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCcuc2xpY2stc2xpZGUnKS5lcShzbGlkZUluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMucnRsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTbGlkZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IChfLiRzbGlkZVRyYWNrLndpZHRoKCkgLSB0YXJnZXRTbGlkZVswXS5vZmZzZXRMZWZ0IC0gdGFyZ2V0U2xpZGUud2lkdGgoKSkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSB0YXJnZXRTbGlkZVswXSA/IHRhcmdldFNsaWRlWzBdLm9mZnNldExlZnQgKiAtMSA6IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCArPSAoXy4kbGlzdC53aWR0aCgpIC0gdGFyZ2V0U2xpZGUub3V0ZXJXaWR0aCgpKSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0TGVmdDtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0T3B0aW9uID0gU2xpY2sucHJvdG90eXBlLnNsaWNrR2V0T3B0aW9uID0gZnVuY3Rpb24ob3B0aW9uKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfLm9wdGlvbnNbb3B0aW9uXTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0TmF2aWdhYmxlSW5kZXhlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGJyZWFrUG9pbnQgPSAwLFxuICAgICAgICAgICAgY291bnRlciA9IDAsXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgICBtYXg7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1heCA9IF8uc2xpZGVDb3VudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrUG9pbnQgPSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgKiAtMTtcbiAgICAgICAgICAgIGNvdW50ZXIgPSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgKiAtMTtcbiAgICAgICAgICAgIG1heCA9IF8uc2xpZGVDb3VudCAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYnJlYWtQb2ludCA8IG1heCkge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGJyZWFrUG9pbnQpO1xuICAgICAgICAgICAgYnJlYWtQb2ludCA9IGNvdW50ZXIgKyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgICAgICBjb3VudGVyICs9IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogXy5vcHRpb25zLnNsaWRlc1RvU2hvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleGVzO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXRTbGljayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXRTbGlkZUNvdW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgc2xpZGVzVHJhdmVyc2VkLCBzd2lwZWRTbGlkZSwgY2VudGVyT2Zmc2V0O1xuXG4gICAgICAgIGNlbnRlck9mZnNldCA9IF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlID8gXy5zbGlkZVdpZHRoICogTWF0aC5mbG9vcihfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMikgOiAwO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuc3dpcGVUb1NsaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmZpbmQoJy5zbGljay1zbGlkZScpLmVhY2goZnVuY3Rpb24oaW5kZXgsIHNsaWRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlLm9mZnNldExlZnQgLSBjZW50ZXJPZmZzZXQgKyAoJChzbGlkZSkub3V0ZXJXaWR0aCgpIC8gMikgPiAoXy5zd2lwZUxlZnQgKiAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVkU2xpZGUgPSBzbGlkZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzbGlkZXNUcmF2ZXJzZWQgPSBNYXRoLmFicygkKHN3aXBlZFNsaWRlKS5hdHRyKCdkYXRhLXNsaWNrLWluZGV4JykgLSBfLmN1cnJlbnRTbGlkZSkgfHwgMTtcblxuICAgICAgICAgICAgcmV0dXJuIHNsaWRlc1RyYXZlcnNlZDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nb1RvID0gU2xpY2sucHJvdG90eXBlLnNsaWNrR29UbyA9IGZ1bmN0aW9uKHNsaWRlLCBkb250QW5pbWF0ZSkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJzZUludChzbGlkZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZG9udEFuaW1hdGUpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oY3JlYXRpb24pIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCEkKF8uJHNsaWRlcikuaGFzQ2xhc3MoJ3NsaWNrLWluaXRpYWxpemVkJykpIHtcblxuICAgICAgICAgICAgJChfLiRzbGlkZXIpLmFkZENsYXNzKCdzbGljay1pbml0aWFsaXplZCcpO1xuXG4gICAgICAgICAgICBfLmJ1aWxkUm93cygpO1xuICAgICAgICAgICAgXy5idWlsZE91dCgpO1xuICAgICAgICAgICAgXy5zZXRQcm9wcygpO1xuICAgICAgICAgICAgXy5zdGFydExvYWQoKTtcbiAgICAgICAgICAgIF8ubG9hZFNsaWRlcigpO1xuICAgICAgICAgICAgXy5pbml0aWFsaXplRXZlbnRzKCk7XG4gICAgICAgICAgICBfLnVwZGF0ZUFycm93cygpO1xuICAgICAgICAgICAgXy51cGRhdGVEb3RzKCk7XG4gICAgICAgICAgICBfLmNoZWNrUmVzcG9uc2l2ZSh0cnVlKTtcbiAgICAgICAgICAgIF8uZm9jdXNIYW5kbGVyKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcmVhdGlvbikge1xuICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2luaXQnLCBbX10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLmluaXRBREEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmF1dG9wbGF5ICkge1xuXG4gICAgICAgICAgICBfLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgXy5hdXRvUGxheSgpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdEFEQSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXM7XG4gICAgICAgIF8uJHNsaWRlcy5hZGQoXy4kc2xpZGVUcmFjay5maW5kKCcuc2xpY2stY2xvbmVkJykpLmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnLFxuICAgICAgICAgICAgJ3RhYmluZGV4JzogJy0xJ1xuICAgICAgICB9KS5maW5kKCdhLCBpbnB1dCwgYnV0dG9uLCBzZWxlY3QnKS5hdHRyKHtcbiAgICAgICAgICAgICd0YWJpbmRleCc6ICctMSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5hdHRyKCdyb2xlJywgJ2xpc3Rib3gnKTtcblxuICAgICAgICBfLiRzbGlkZXMubm90KF8uJHNsaWRlVHJhY2suZmluZCgnLnNsaWNrLWNsb25lZCcpKS5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICQodGhpcykuYXR0cih7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAnb3B0aW9uJyxcbiAgICAgICAgICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6ICdzbGljay1zbGlkZScgKyBfLmluc3RhbmNlVWlkICsgaSArICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKF8uJGRvdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF8uJGRvdHMuYXR0cigncm9sZScsICd0YWJsaXN0JykuZmluZCgnbGknKS5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6ICdmYWxzZScsXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogJ25hdmlnYXRpb24nICsgXy5pbnN0YW5jZVVpZCArIGkgKyAnJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogJ3NsaWNrLXNsaWRlJyArIF8uaW5zdGFuY2VVaWQgKyBpICsgJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpcnN0KCkuYXR0cignYXJpYS1zZWxlY3RlZCcsICd0cnVlJykuZW5kKClcbiAgICAgICAgICAgICAgICAuZmluZCgnYnV0dG9uJykuYXR0cigncm9sZScsICdidXR0b24nKS5lbmQoKVxuICAgICAgICAgICAgICAgIC5jbG9zZXN0KCdkaXYnKS5hdHRyKCdyb2xlJywgJ3Rvb2xiYXInKTtcbiAgICAgICAgfVxuICAgICAgICBfLmFjdGl2YXRlQURBKCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXRBcnJvd0V2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBfLiRwcmV2QXJyb3dcbiAgICAgICAgICAgICAgIC5vZmYoJ2NsaWNrLnNsaWNrJylcbiAgICAgICAgICAgICAgIC5vbignY2xpY2suc2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdwcmV2aW91cydcbiAgICAgICAgICAgICAgIH0sIF8uY2hhbmdlU2xpZGUpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93XG4gICAgICAgICAgICAgICAub2ZmKCdjbGljay5zbGljaycpXG4gICAgICAgICAgICAgICAub24oJ2NsaWNrLnNsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbmV4dCdcbiAgICAgICAgICAgICAgIH0sIF8uY2hhbmdlU2xpZGUpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXREb3RFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICQoJ2xpJywgXy4kZG90cykub24oJ2NsaWNrLnNsaWNrJywge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpbmRleCdcbiAgICAgICAgICAgIH0sIF8uY2hhbmdlU2xpZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMuZG90cyA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMucGF1c2VPbkRvdHNIb3ZlciA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgJCgnbGknLCBfLiRkb3RzKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VlbnRlci5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIHRydWUpKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VsZWF2ZS5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIGZhbHNlKSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0U2xpZGVFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMucGF1c2VPbkhvdmVyICkge1xuXG4gICAgICAgICAgICBfLiRsaXN0Lm9uKCdtb3VzZWVudGVyLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgdHJ1ZSkpO1xuICAgICAgICAgICAgXy4kbGlzdC5vbignbW91c2VsZWF2ZS5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIGZhbHNlKSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0aWFsaXplRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uaW5pdEFycm93RXZlbnRzKCk7XG5cbiAgICAgICAgXy5pbml0RG90RXZlbnRzKCk7XG4gICAgICAgIF8uaW5pdFNsaWRlRXZlbnRzKCk7XG5cbiAgICAgICAgXy4kbGlzdC5vbigndG91Y2hzdGFydC5zbGljayBtb3VzZWRvd24uc2xpY2snLCB7XG4gICAgICAgICAgICBhY3Rpb246ICdzdGFydCdcbiAgICAgICAgfSwgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9uKCd0b3VjaG1vdmUuc2xpY2sgbW91c2Vtb3ZlLnNsaWNrJywge1xuICAgICAgICAgICAgYWN0aW9uOiAnbW92ZSdcbiAgICAgICAgfSwgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9uKCd0b3VjaGVuZC5zbGljayBtb3VzZXVwLnNsaWNrJywge1xuICAgICAgICAgICAgYWN0aW9uOiAnZW5kJ1xuICAgICAgICB9LCBfLnN3aXBlSGFuZGxlcik7XG4gICAgICAgIF8uJGxpc3Qub24oJ3RvdWNoY2FuY2VsLnNsaWNrIG1vdXNlbGVhdmUuc2xpY2snLCB7XG4gICAgICAgICAgICBhY3Rpb246ICdlbmQnXG4gICAgICAgIH0sIF8uc3dpcGVIYW5kbGVyKTtcblxuICAgICAgICBfLiRsaXN0Lm9uKCdjbGljay5zbGljaycsIF8uY2xpY2tIYW5kbGVyKTtcblxuICAgICAgICAkKGRvY3VtZW50KS5vbihfLnZpc2liaWxpdHlDaGFuZ2UsICQucHJveHkoXy52aXNpYmlsaXR5LCBfKSk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRsaXN0Lm9uKCdrZXlkb3duLnNsaWNrJywgXy5rZXlIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZm9jdXNPblNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgJChfLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9uKCdjbGljay5zbGljaycsIF8uc2VsZWN0SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICAkKHdpbmRvdykub24oJ29yaWVudGF0aW9uY2hhbmdlLnNsaWNrLnNsaWNrLScgKyBfLmluc3RhbmNlVWlkLCAkLnByb3h5KF8ub3JpZW50YXRpb25DaGFuZ2UsIF8pKTtcblxuICAgICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgJC5wcm94eShfLnJlc2l6ZSwgXykpO1xuXG4gICAgICAgICQoJ1tkcmFnZ2FibGUhPXRydWVdJywgXy4kc2xpZGVUcmFjaykub24oJ2RyYWdzdGFydCcsIF8ucHJldmVudERlZmF1bHQpO1xuXG4gICAgICAgICQod2luZG93KS5vbignbG9hZC5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgXy5zZXRQb3NpdGlvbik7XG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdyZWFkeS5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgXy5zZXRQb3NpdGlvbik7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXRVSSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgIF8uJHByZXZBcnJvdy5zaG93KCk7XG4gICAgICAgICAgICBfLiRuZXh0QXJyb3cuc2hvdygpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmRvdHMgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLiRkb3RzLnNob3coKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmtleUhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcbiAgICAgICAgIC8vRG9udCBzbGlkZSBpZiB0aGUgY3Vyc29yIGlzIGluc2lkZSB0aGUgZm9ybSBmaWVsZHMgYW5kIGFycm93IGtleXMgYXJlIHByZXNzZWRcbiAgICAgICAgaWYoIWV2ZW50LnRhcmdldC50YWdOYW1lLm1hdGNoKCdURVhUQVJFQXxJTlBVVHxTRUxFQ1QnKSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDM3ICYmIF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF8ub3B0aW9ucy5ydGwgPT09IHRydWUgPyAnbmV4dCcgOiAgJ3ByZXZpb3VzJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDM5ICYmIF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF8ub3B0aW9ucy5ydGwgPT09IHRydWUgPyAncHJldmlvdXMnIDogJ25leHQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5sYXp5TG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGxvYWRSYW5nZSwgY2xvbmVSYW5nZSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQ7XG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlcyhpbWFnZXNTY29wZSkge1xuXG4gICAgICAgICAgICAkKCdpbWdbZGF0YS1sYXp5XScsIGltYWdlc1Njb3BlKS5lYWNoKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTb3VyY2UgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtbGF6eScpLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVRvTG9hZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXG4gICAgICAgICAgICAgICAgaW1hZ2VUb0xvYWQub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hbmltYXRlKHsgb3BhY2l0eTogMCB9LCAxMDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzcmMnLCBpbWFnZVNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFuaW1hdGUoeyBvcGFjaXR5OiAxIH0sIDIwMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLWxhenknKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stbG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignbGF6eUxvYWRlZCcsIFtfLCBpbWFnZSwgaW1hZ2VTb3VyY2VdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGltYWdlVG9Mb2FkLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoICdkYXRhLWxhenknIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyggJ3NsaWNrLWxvYWRpbmcnIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyggJ3NsaWNrLWxhenlsb2FkLWVycm9yJyApO1xuXG4gICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdsYXp5TG9hZEVycm9yJywgWyBfLCBpbWFnZSwgaW1hZ2VTb3VyY2UgXSk7XG5cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaW1hZ2VUb0xvYWQuc3JjID0gaW1hZ2VTb3VyY2U7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByYW5nZVN0YXJ0ID0gXy5jdXJyZW50U2xpZGUgKyAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIgKyAxKTtcbiAgICAgICAgICAgICAgICByYW5nZUVuZCA9IHJhbmdlU3RhcnQgKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VTdGFydCA9IE1hdGgubWF4KDAsIF8uY3VycmVudFNsaWRlIC0gKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyICsgMSkpO1xuICAgICAgICAgICAgICAgIHJhbmdlRW5kID0gMiArIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMiArIDEpICsgXy5jdXJyZW50U2xpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYW5nZVN0YXJ0ID0gXy5vcHRpb25zLmluZmluaXRlID8gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIF8uY3VycmVudFNsaWRlIDogXy5jdXJyZW50U2xpZGU7XG4gICAgICAgICAgICByYW5nZUVuZCA9IE1hdGguY2VpbChyYW5nZVN0YXJ0ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdyk7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VTdGFydCA+IDApIHJhbmdlU3RhcnQtLTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VFbmQgPD0gXy5zbGlkZUNvdW50KSByYW5nZUVuZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9hZFJhbmdlID0gXy4kc2xpZGVyLmZpbmQoJy5zbGljay1zbGlkZScpLnNsaWNlKHJhbmdlU3RhcnQsIHJhbmdlRW5kKTtcbiAgICAgICAgbG9hZEltYWdlcyhsb2FkUmFuZ2UpO1xuXG4gICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgY2xvbmVSYW5nZSA9IF8uJHNsaWRlci5maW5kKCcuc2xpY2stc2xpZGUnKTtcbiAgICAgICAgICAgIGxvYWRJbWFnZXMoY2xvbmVSYW5nZSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICBpZiAoXy5jdXJyZW50U2xpZGUgPj0gXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgY2xvbmVSYW5nZSA9IF8uJHNsaWRlci5maW5kKCcuc2xpY2stY2xvbmVkJykuc2xpY2UoMCwgXy5vcHRpb25zLnNsaWRlc1RvU2hvdyk7XG4gICAgICAgICAgICBsb2FkSW1hZ2VzKGNsb25lUmFuZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKF8uY3VycmVudFNsaWRlID09PSAwKSB7XG4gICAgICAgICAgICBjbG9uZVJhbmdlID0gXy4kc2xpZGVyLmZpbmQoJy5zbGljay1jbG9uZWQnKS5zbGljZShfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICogLTEpO1xuICAgICAgICAgICAgbG9hZEltYWdlcyhjbG9uZVJhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5sb2FkU2xpZGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uc2V0UG9zaXRpb24oKTtcblxuICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uJHNsaWRlci5yZW1vdmVDbGFzcygnc2xpY2stbG9hZGluZycpO1xuXG4gICAgICAgIF8uaW5pdFVJKCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5sYXp5TG9hZCA9PT0gJ3Byb2dyZXNzaXZlJykge1xuICAgICAgICAgICAgXy5wcm9ncmVzc2l2ZUxhenlMb2FkKCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUubmV4dCA9IFNsaWNrLnByb3RvdHlwZS5zbGlja05leHQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ25leHQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5vcmllbnRhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmNoZWNrUmVzcG9uc2l2ZSgpO1xuICAgICAgICBfLnNldFBvc2l0aW9uKCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnBhdXNlID0gU2xpY2sucHJvdG90eXBlLnNsaWNrUGF1c2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5hdXRvUGxheUNsZWFyKCk7XG4gICAgICAgIF8ucGF1c2VkID0gdHJ1ZTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucGxheSA9IFNsaWNrLnByb3RvdHlwZS5zbGlja1BsYXkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5hdXRvUGxheSgpO1xuICAgICAgICBfLm9wdGlvbnMuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICBfLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICBfLmZvY3Vzc2VkID0gZmFsc2U7XG4gICAgICAgIF8uaW50ZXJydXB0ZWQgPSBmYWxzZTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucG9zdFNsaWRlID0gZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYoICFfLnVuc2xpY2tlZCApIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2FmdGVyQ2hhbmdlJywgW18sIGluZGV4XSk7XG5cbiAgICAgICAgICAgIF8uYW5pbWF0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIF8uc2V0UG9zaXRpb24oKTtcblxuICAgICAgICAgICAgXy5zd2lwZUxlZnQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIF8ub3B0aW9ucy5hdXRvcGxheSApIHtcbiAgICAgICAgICAgICAgICBfLmF1dG9QbGF5KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uaW5pdEFEQSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucHJldiA9IFNsaWNrLnByb3RvdHlwZS5zbGlja1ByZXYgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ3ByZXZpb3VzJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnByb2dyZXNzaXZlTGF6eUxvYWQgPSBmdW5jdGlvbiggdHJ5Q291bnQgKSB7XG5cbiAgICAgICAgdHJ5Q291bnQgPSB0cnlDb3VudCB8fCAxO1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgICRpbWdzVG9Mb2FkID0gJCggJ2ltZ1tkYXRhLWxhenldJywgXy4kc2xpZGVyICksXG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIGltYWdlU291cmNlLFxuICAgICAgICAgICAgaW1hZ2VUb0xvYWQ7XG5cbiAgICAgICAgaWYgKCAkaW1nc1RvTG9hZC5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGltYWdlID0gJGltZ3NUb0xvYWQuZmlyc3QoKTtcbiAgICAgICAgICAgIGltYWdlU291cmNlID0gaW1hZ2UuYXR0cignZGF0YS1sYXp5Jyk7XG4gICAgICAgICAgICBpbWFnZVRvTG9hZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXG4gICAgICAgICAgICBpbWFnZVRvTG9hZC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCAnc3JjJywgaW1hZ2VTb3VyY2UgKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1sYXp5JylcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1sb2FkaW5nJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIF8ub3B0aW9ucy5hZGFwdGl2ZUhlaWdodCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgXy5zZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdsYXp5TG9hZGVkJywgWyBfLCBpbWFnZSwgaW1hZ2VTb3VyY2UgXSk7XG4gICAgICAgICAgICAgICAgXy5wcm9ncmVzc2l2ZUxhenlMb2FkKCk7XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGltYWdlVG9Mb2FkLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGlmICggdHJ5Q291bnQgPCAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiB0cnkgdG8gbG9hZCB0aGUgaW1hZ2UgMyB0aW1lcyxcbiAgICAgICAgICAgICAgICAgICAgICogbGVhdmUgYSBzbGlnaHQgZGVsYXkgc28gd2UgZG9uJ3QgZ2V0XG4gICAgICAgICAgICAgICAgICAgICAqIHNlcnZlcnMgYmxvY2tpbmcgdGhlIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ucHJvZ3Jlc3NpdmVMYXp5TG9hZCggdHJ5Q291bnQgKyAxICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDUwMCApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoICdkYXRhLWxhenknIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyggJ3NsaWNrLWxvYWRpbmcnIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyggJ3NsaWNrLWxhenlsb2FkLWVycm9yJyApO1xuXG4gICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdsYXp5TG9hZEVycm9yJywgWyBfLCBpbWFnZSwgaW1hZ2VTb3VyY2UgXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5wcm9ncmVzc2l2ZUxhenlMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGltYWdlVG9Mb2FkLnNyYyA9IGltYWdlU291cmNlO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdhbGxJbWFnZXNMb2FkZWQnLCBbIF8gXSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oIGluaXRpYWxpemluZyApIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsIGN1cnJlbnRTbGlkZSwgbGFzdFZpc2libGVJbmRleDtcblxuICAgICAgICBsYXN0VmlzaWJsZUluZGV4ID0gXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdztcblxuICAgICAgICAvLyBpbiBub24taW5maW5pdGUgc2xpZGVycywgd2UgZG9uJ3Qgd2FudCB0byBnbyBwYXN0IHRoZVxuICAgICAgICAvLyBsYXN0IHZpc2libGUgaW5kZXguXG4gICAgICAgIGlmKCAhXy5vcHRpb25zLmluZmluaXRlICYmICggXy5jdXJyZW50U2xpZGUgPiBsYXN0VmlzaWJsZUluZGV4ICkpIHtcbiAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gbGFzdFZpc2libGVJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGxlc3Mgc2xpZGVzIHRoYW4gdG8gc2hvdywgZ28gdG8gc3RhcnQuXG4gICAgICAgIGlmICggXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKSB7XG4gICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IDA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRTbGlkZSA9IF8uY3VycmVudFNsaWRlO1xuXG4gICAgICAgIF8uZGVzdHJveSh0cnVlKTtcblxuICAgICAgICAkLmV4dGVuZChfLCBfLmluaXRpYWxzLCB7IGN1cnJlbnRTbGlkZTogY3VycmVudFNsaWRlIH0pO1xuXG4gICAgICAgIF8uaW5pdCgpO1xuXG4gICAgICAgIGlmKCAhaW5pdGlhbGl6aW5nICkge1xuXG4gICAgICAgICAgICBfLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpbmRleCcsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBjdXJyZW50U2xpZGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5yZWdpc3RlckJyZWFrcG9pbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLCBicmVha3BvaW50LCBjdXJyZW50QnJlYWtwb2ludCwgbCxcbiAgICAgICAgICAgIHJlc3BvbnNpdmVTZXR0aW5ncyA9IF8ub3B0aW9ucy5yZXNwb25zaXZlIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKCAkLnR5cGUocmVzcG9uc2l2ZVNldHRpbmdzKSA9PT0gJ2FycmF5JyAmJiByZXNwb25zaXZlU2V0dGluZ3MubGVuZ3RoICkge1xuXG4gICAgICAgICAgICBfLnJlc3BvbmRUbyA9IF8ub3B0aW9ucy5yZXNwb25kVG8gfHwgJ3dpbmRvdyc7XG5cbiAgICAgICAgICAgIGZvciAoIGJyZWFrcG9pbnQgaW4gcmVzcG9uc2l2ZVNldHRpbmdzICkge1xuXG4gICAgICAgICAgICAgICAgbCA9IF8uYnJlYWtwb2ludHMubGVuZ3RoLTE7XG4gICAgICAgICAgICAgICAgY3VycmVudEJyZWFrcG9pbnQgPSByZXNwb25zaXZlU2V0dGluZ3NbYnJlYWtwb2ludF0uYnJlYWtwb2ludDtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zaXZlU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYnJlYWtwb2ludCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGJyZWFrcG9pbnRzIGFuZCBjdXQgb3V0IGFueSBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmVzIHdpdGggdGhlIHNhbWUgYnJlYWtwb2ludCBudW1iZXIsIHdlIGRvbid0IHdhbnQgZHVwZXMuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKCBsID49IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggXy5icmVha3BvaW50c1tsXSAmJiBfLmJyZWFrcG9pbnRzW2xdID09PSBjdXJyZW50QnJlYWtwb2ludCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmJyZWFrcG9pbnRzLnNwbGljZShsLDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgXy5icmVha3BvaW50cy5wdXNoKGN1cnJlbnRCcmVha3BvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgXy5icmVha3BvaW50U2V0dGluZ3NbY3VycmVudEJyZWFrcG9pbnRdID0gcmVzcG9uc2l2ZVNldHRpbmdzW2JyZWFrcG9pbnRdLnNldHRpbmdzO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uYnJlYWtwb2ludHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICggXy5vcHRpb25zLm1vYmlsZUZpcnN0ICkgPyBhLWIgOiBiLWE7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnJlaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLiRzbGlkZXMgPVxuICAgICAgICAgICAgXy4kc2xpZGVUcmFja1xuICAgICAgICAgICAgICAgIC5jaGlsZHJlbihfLm9wdGlvbnMuc2xpZGUpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1zbGlkZScpO1xuXG4gICAgICAgIF8uc2xpZGVDb3VudCA9IF8uJHNsaWRlcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKF8uY3VycmVudFNsaWRlID49IF8uc2xpZGVDb3VudCAmJiBfLmN1cnJlbnRTbGlkZSAhPT0gMCkge1xuICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBfLmN1cnJlbnRTbGlkZSAtIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5yZWdpc3RlckJyZWFrcG9pbnRzKCk7XG5cbiAgICAgICAgXy5zZXRQcm9wcygpO1xuICAgICAgICBfLnNldHVwSW5maW5pdGUoKTtcbiAgICAgICAgXy5idWlsZEFycm93cygpO1xuICAgICAgICBfLnVwZGF0ZUFycm93cygpO1xuICAgICAgICBfLmluaXRBcnJvd0V2ZW50cygpO1xuICAgICAgICBfLmJ1aWxkRG90cygpO1xuICAgICAgICBfLnVwZGF0ZURvdHMoKTtcbiAgICAgICAgXy5pbml0RG90RXZlbnRzKCk7XG4gICAgICAgIF8uY2xlYW5VcFNsaWRlRXZlbnRzKCk7XG4gICAgICAgIF8uaW5pdFNsaWRlRXZlbnRzKCk7XG5cbiAgICAgICAgXy5jaGVja1Jlc3BvbnNpdmUoZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZm9jdXNPblNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgJChfLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9uKCdjbGljay5zbGljaycsIF8uc2VsZWN0SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBfLnNldFNsaWRlQ2xhc3Nlcyh0eXBlb2YgXy5jdXJyZW50U2xpZGUgPT09ICdudW1iZXInID8gXy5jdXJyZW50U2xpZGUgOiAwKTtcblxuICAgICAgICBfLnNldFBvc2l0aW9uKCk7XG4gICAgICAgIF8uZm9jdXNIYW5kbGVyKCk7XG5cbiAgICAgICAgXy5wYXVzZWQgPSAhXy5vcHRpb25zLmF1dG9wbGF5O1xuICAgICAgICBfLmF1dG9QbGF5KCk7XG5cbiAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ3JlSW5pdCcsIFtfXSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoJCh3aW5kb3cpLndpZHRoKCkgIT09IF8ud2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfLndpbmRvd0RlbGF5KTtcbiAgICAgICAgICAgIF8ud2luZG93RGVsYXkgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfLndpbmRvd1dpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgXy5jaGVja1Jlc3BvbnNpdmUoKTtcbiAgICAgICAgICAgICAgICBpZiggIV8udW5zbGlja2VkICkgeyBfLnNldFBvc2l0aW9uKCk7IH1cbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucmVtb3ZlU2xpZGUgPSBTbGljay5wcm90b3R5cGUuc2xpY2tSZW1vdmUgPSBmdW5jdGlvbihpbmRleCwgcmVtb3ZlQmVmb3JlLCByZW1vdmVBbGwpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZihpbmRleCkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmVtb3ZlQmVmb3JlID0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IHJlbW92ZUJlZm9yZSA9PT0gdHJ1ZSA/IDAgOiBfLnNsaWRlQ291bnQgLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSByZW1vdmVCZWZvcmUgPT09IHRydWUgPyAtLWluZGV4IDogaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDwgMSB8fCBpbmRleCA8IDAgfHwgaW5kZXggPiBfLnNsaWRlQ291bnQgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBfLnVubG9hZCgpO1xuXG4gICAgICAgIGlmIChyZW1vdmVBbGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oKS5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5lcShpbmRleCkucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfLiRzbGlkZXMgPSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suYXBwZW5kKF8uJHNsaWRlcyk7XG5cbiAgICAgICAgXy4kc2xpZGVzQ2FjaGUgPSBfLiRzbGlkZXM7XG5cbiAgICAgICAgXy5yZWluaXQoKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0Q1NTID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBwb3NpdGlvblByb3BzID0ge30sXG4gICAgICAgICAgICB4LCB5O1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMucnRsID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IC1wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB4ID0gXy5wb3NpdGlvblByb3AgPT0gJ2xlZnQnID8gTWF0aC5jZWlsKHBvc2l0aW9uKSArICdweCcgOiAnMHB4JztcbiAgICAgICAgeSA9IF8ucG9zaXRpb25Qcm9wID09ICd0b3AnID8gTWF0aC5jZWlsKHBvc2l0aW9uKSArICdweCcgOiAnMHB4JztcblxuICAgICAgICBwb3NpdGlvblByb3BzW18ucG9zaXRpb25Qcm9wXSA9IHBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChfLnRyYW5zZm9ybXNFbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MocG9zaXRpb25Qcm9wcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvblByb3BzID0ge307XG4gICAgICAgICAgICBpZiAoXy5jc3NUcmFuc2l0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzW18uYW5pbVR5cGVdID0gJ3RyYW5zbGF0ZSgnICsgeCArICcsICcgKyB5ICsgJyknO1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKHBvc2l0aW9uUHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzW18uYW5pbVR5cGVdID0gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJywgJyArIHkgKyAnLCAwcHgpJztcbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyhwb3NpdGlvblByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXREaW1lbnNpb25zID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLiRsaXN0LmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICgnMHB4ICcgKyBfLm9wdGlvbnMuY2VudGVyUGFkZGluZylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJGxpc3QuaGVpZ2h0KF8uJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KHRydWUpICogXy5vcHRpb25zLnNsaWRlc1RvU2hvdyk7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLiRsaXN0LmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IChfLm9wdGlvbnMuY2VudGVyUGFkZGluZyArICcgMHB4JylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF8ubGlzdFdpZHRoID0gXy4kbGlzdC53aWR0aCgpO1xuICAgICAgICBfLmxpc3RIZWlnaHQgPSBfLiRsaXN0LmhlaWdodCgpO1xuXG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UgJiYgXy5vcHRpb25zLnZhcmlhYmxlV2lkdGggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLnNsaWRlV2lkdGggPSBNYXRoLmNlaWwoXy5saXN0V2lkdGggLyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KTtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2sud2lkdGgoTWF0aC5jZWlsKChfLnNsaWRlV2lkdGggKiBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCcuc2xpY2stc2xpZGUnKS5sZW5ndGgpKSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMudmFyaWFibGVXaWR0aCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay53aWR0aCg1MDAwICogXy5zbGlkZUNvdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uc2xpZGVXaWR0aCA9IE1hdGguY2VpbChfLmxpc3RXaWR0aCk7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmhlaWdodChNYXRoLmNlaWwoKF8uJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KHRydWUpICogXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykubGVuZ3RoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IF8uJHNsaWRlcy5maXJzdCgpLm91dGVyV2lkdGgodHJ1ZSkgLSBfLiRzbGlkZXMuZmlyc3QoKS53aWR0aCgpO1xuICAgICAgICBpZiAoXy5vcHRpb25zLnZhcmlhYmxlV2lkdGggPT09IGZhbHNlKSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCcuc2xpY2stc2xpZGUnKS53aWR0aChfLnNsaWRlV2lkdGggLSBvZmZzZXQpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRGYWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgdGFyZ2V0TGVmdDtcblxuICAgICAgICBfLiRzbGlkZXMuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IChfLnNsaWRlV2lkdGggKiBpbmRleCkgKiAtMTtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMucnRsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHRhcmdldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4IC0gMixcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleCAtIDIsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy4kc2xpZGVzLmVxKF8uY3VycmVudFNsaWRlKS5jc3Moe1xuICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4IC0gMSxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA9PT0gMSAmJiBfLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQgPT09IHRydWUgJiYgXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldEhlaWdodCA9IF8uJHNsaWRlcy5lcShfLmN1cnJlbnRTbGlkZSkub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gICAgICAgICAgICBfLiRsaXN0LmNzcygnaGVpZ2h0JywgdGFyZ2V0SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRPcHRpb24gPVxuICAgIFNsaWNrLnByb3RvdHlwZS5zbGlja1NldE9wdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhY2NlcHRzIGFyZ3VtZW50cyBpbiBmb3JtYXQgb2Y6XG4gICAgICAgICAqXG4gICAgICAgICAqICAtIGZvciBjaGFuZ2luZyBhIHNpbmdsZSBvcHRpb24ncyB2YWx1ZTpcbiAgICAgICAgICogICAgIC5zbGljayhcInNldE9wdGlvblwiLCBvcHRpb24sIHZhbHVlLCByZWZyZXNoIClcbiAgICAgICAgICpcbiAgICAgICAgICogIC0gZm9yIGNoYW5naW5nIGEgc2V0IG9mIHJlc3BvbnNpdmUgb3B0aW9uczpcbiAgICAgICAgICogICAgIC5zbGljayhcInNldE9wdGlvblwiLCAncmVzcG9uc2l2ZScsIFt7fSwgLi4uXSwgcmVmcmVzaCApXG4gICAgICAgICAqXG4gICAgICAgICAqICAtIGZvciB1cGRhdGluZyBtdWx0aXBsZSB2YWx1ZXMgYXQgb25jZSAobm90IHJlc3BvbnNpdmUpXG4gICAgICAgICAqICAgICAuc2xpY2soXCJzZXRPcHRpb25cIiwgeyAnb3B0aW9uJzogdmFsdWUsIC4uLiB9LCByZWZyZXNoIClcbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLCBsLCBpdGVtLCBvcHRpb24sIHZhbHVlLCByZWZyZXNoID0gZmFsc2UsIHR5cGU7XG5cbiAgICAgICAgaWYoICQudHlwZSggYXJndW1lbnRzWzBdICkgPT09ICdvYmplY3QnICkge1xuXG4gICAgICAgICAgICBvcHRpb24gPSAgYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgcmVmcmVzaCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHR5cGUgPSAnbXVsdGlwbGUnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoICQudHlwZSggYXJndW1lbnRzWzBdICkgPT09ICdzdHJpbmcnICkge1xuXG4gICAgICAgICAgICBvcHRpb24gPSAgYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZWZyZXNoID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICAgICAgICBpZiAoIGFyZ3VtZW50c1swXSA9PT0gJ3Jlc3BvbnNpdmUnICYmICQudHlwZSggYXJndW1lbnRzWzFdICkgPT09ICdhcnJheScgKSB7XG5cbiAgICAgICAgICAgICAgICB0eXBlID0gJ3Jlc3BvbnNpdmUnO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgYXJndW1lbnRzWzFdICE9PSAndW5kZWZpbmVkJyApIHtcblxuICAgICAgICAgICAgICAgIHR5cGUgPSAnc2luZ2xlJztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHR5cGUgPT09ICdzaW5nbGUnICkge1xuXG4gICAgICAgICAgICBfLm9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xuXG5cbiAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gJ211bHRpcGxlJyApIHtcblxuICAgICAgICAgICAgJC5lYWNoKCBvcHRpb24gLCBmdW5jdGlvbiggb3B0LCB2YWwgKSB7XG5cbiAgICAgICAgICAgICAgICBfLm9wdGlvbnNbb3B0XSA9IHZhbDtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlID09PSAncmVzcG9uc2l2ZScgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIGl0ZW0gaW4gdmFsdWUgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiggJC50eXBlKCBfLm9wdGlvbnMucmVzcG9uc2l2ZSApICE9PSAnYXJyYXknICkge1xuXG4gICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy5yZXNwb25zaXZlID0gWyB2YWx1ZVtpdGVtXSBdO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBsID0gXy5vcHRpb25zLnJlc3BvbnNpdmUubGVuZ3RoLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSByZXNwb25zaXZlIG9iamVjdCBhbmQgc3BsaWNlIG91dCBkdXBsaWNhdGVzLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSggbCA+PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggXy5vcHRpb25zLnJlc3BvbnNpdmVbbF0uYnJlYWtwb2ludCA9PT0gdmFsdWVbaXRlbV0uYnJlYWtwb2ludCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy5yZXNwb25zaXZlLnNwbGljZShsLDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGwtLTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zLnJlc3BvbnNpdmUucHVzaCggdmFsdWVbaXRlbV0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHJlZnJlc2ggKSB7XG5cbiAgICAgICAgICAgIF8udW5sb2FkKCk7XG4gICAgICAgICAgICBfLnJlaW5pdCgpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5zZXREaW1lbnNpb25zKCk7XG5cbiAgICAgICAgXy5zZXRIZWlnaHQoKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLnNldENTUyhfLmdldExlZnQoXy5jdXJyZW50U2xpZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uc2V0RmFkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ3NldFBvc2l0aW9uJywgW19dKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0UHJvcHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBib2R5U3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuXG4gICAgICAgIF8ucG9zaXRpb25Qcm9wID0gXy5vcHRpb25zLnZlcnRpY2FsID09PSB0cnVlID8gJ3RvcCcgOiAnbGVmdCc7XG5cbiAgICAgICAgaWYgKF8ucG9zaXRpb25Qcm9wID09PSAndG9wJykge1xuICAgICAgICAgICAgXy4kc2xpZGVyLmFkZENsYXNzKCdzbGljay12ZXJ0aWNhbCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy4kc2xpZGVyLnJlbW92ZUNsYXNzKCdzbGljay12ZXJ0aWNhbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHlTdHlsZS5XZWJraXRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGJvZHlTdHlsZS5Nb3pUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGJvZHlTdHlsZS5tc1RyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy51c2VDU1MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLmNzc1RyYW5zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmZhZGUgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBfLm9wdGlvbnMuekluZGV4ID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgICBpZiggXy5vcHRpb25zLnpJbmRleCA8IDMgKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy56SW5kZXggPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXy5vcHRpb25zLnpJbmRleCA9IF8uZGVmYXVsdHMuekluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHlTdHlsZS5PVHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF8uYW5pbVR5cGUgPSAnT1RyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSAnLW8tdHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNpdGlvblR5cGUgPSAnT1RyYW5zaXRpb24nO1xuICAgICAgICAgICAgaWYgKGJvZHlTdHlsZS5wZXJzcGVjdGl2ZVByb3BlcnR5ID09PSB1bmRlZmluZWQgJiYgYm9keVN0eWxlLndlYmtpdFBlcnNwZWN0aXZlID09PSB1bmRlZmluZWQpIF8uYW5pbVR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keVN0eWxlLk1velRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfLmFuaW1UeXBlID0gJ01velRyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSAnLW1vei10cmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2l0aW9uVHlwZSA9ICdNb3pUcmFuc2l0aW9uJztcbiAgICAgICAgICAgIGlmIChib2R5U3R5bGUucGVyc3BlY3RpdmVQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkICYmIGJvZHlTdHlsZS5Nb3pQZXJzcGVjdGl2ZSA9PT0gdW5kZWZpbmVkKSBfLmFuaW1UeXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHlTdHlsZS53ZWJraXRUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9ICd3ZWJraXRUcmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gJy13ZWJraXQtdHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNpdGlvblR5cGUgPSAnd2Via2l0VHJhbnNpdGlvbic7XG4gICAgICAgICAgICBpZiAoYm9keVN0eWxlLnBlcnNwZWN0aXZlUHJvcGVydHkgPT09IHVuZGVmaW5lZCAmJiBib2R5U3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPT09IHVuZGVmaW5lZCkgXy5hbmltVHlwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5U3R5bGUubXNUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9ICdtc1RyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSAnLW1zLXRyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gJ21zVHJhbnNpdGlvbic7XG4gICAgICAgICAgICBpZiAoYm9keVN0eWxlLm1zVHJhbnNmb3JtID09PSB1bmRlZmluZWQpIF8uYW5pbVR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keVN0eWxlLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkICYmIF8uYW5pbVR5cGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLmFuaW1UeXBlID0gJ3RyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSAndHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNpdGlvblR5cGUgPSAndHJhbnNpdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgXy50cmFuc2Zvcm1zRW5hYmxlZCA9IF8ub3B0aW9ucy51c2VUcmFuc2Zvcm0gJiYgKF8uYW5pbVR5cGUgIT09IG51bGwgJiYgXy5hbmltVHlwZSAhPT0gZmFsc2UpO1xuICAgIH07XG5cblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRTbGlkZUNsYXNzZXMgPSBmdW5jdGlvbihpbmRleCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGNlbnRlck9mZnNldCwgYWxsU2xpZGVzLCBpbmRleE9mZnNldCwgcmVtYWluZGVyO1xuXG4gICAgICAgIGFsbFNsaWRlcyA9IF8uJHNsaWRlclxuICAgICAgICAgICAgLmZpbmQoJy5zbGljay1zbGlkZScpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLWFjdGl2ZSBzbGljay1jZW50ZXIgc2xpY2stY3VycmVudCcpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgLmVxKGluZGV4KVxuICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1jdXJyZW50Jyk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgIGNlbnRlck9mZnNldCA9IE1hdGguZmxvb3IoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIpO1xuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gY2VudGVyT2Zmc2V0ICYmIGluZGV4IDw9IChfLnNsaWRlQ291bnQgLSAxKSAtIGNlbnRlck9mZnNldCkge1xuXG4gICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGluZGV4IC0gY2VudGVyT2Zmc2V0LCBpbmRleCArIGNlbnRlck9mZnNldCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5kZXhPZmZzZXQgPSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGFsbFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGluZGV4T2Zmc2V0IC0gY2VudGVyT2Zmc2V0ICsgMSwgaW5kZXhPZmZzZXQgKyBjZW50ZXJPZmZzZXQgKyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcShhbGxTbGlkZXMubGVuZ3RoIC0gMSAtIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWNlbnRlcicpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gXy5zbGlkZUNvdW50IC0gMSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGFsbFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWNlbnRlcicpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgICAgIC5lcShpbmRleClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWNlbnRlcicpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDw9IChfLnNsaWRlQ291bnQgLSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSkge1xuXG4gICAgICAgICAgICAgICAgXy4kc2xpZGVzXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleCwgaW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsbFNsaWRlcy5sZW5ndGggPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICAgICAgYWxsU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSBfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93O1xuICAgICAgICAgICAgICAgIGluZGV4T2Zmc2V0ID0gXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlID8gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIGluZGV4IDogaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA9PSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgJiYgKF8uc2xpZGVDb3VudCAtIGluZGV4KSA8IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleE9mZnNldCAtIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC0gcmVtYWluZGVyKSwgaW5kZXhPZmZzZXQgKyByZW1haW5kZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaW5kZXhPZmZzZXQsIGluZGV4T2Zmc2V0ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMubGF6eUxvYWQgPT09ICdvbmRlbWFuZCcpIHtcbiAgICAgICAgICAgIF8ubGF6eUxvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXR1cEluZmluaXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgaSwgc2xpZGVJbmRleCwgaW5maW5pdGVDb3VudDtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8ub3B0aW9ucy5jZW50ZXJNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlICYmIF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICBzbGlkZUluZGV4ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZpbml0ZUNvdW50ID0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5maW5pdGVDb3VudCA9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gXy5zbGlkZUNvdW50OyBpID4gKF8uc2xpZGVDb3VudCAtXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZpbml0ZUNvdW50KTsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSW5kZXggPSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgJChfLiRzbGlkZXNbc2xpZGVJbmRleF0pLmNsb25lKHRydWUpLmF0dHIoJ2lkJywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZGF0YS1zbGljay1pbmRleCcsIHNsaWRlSW5kZXggLSBfLnNsaWRlQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAucHJlcGVuZFRvKF8uJHNsaWRlVHJhY2spLmFkZENsYXNzKCdzbGljay1jbG9uZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluZmluaXRlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzbGlkZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgJChfLiRzbGlkZXNbc2xpZGVJbmRleF0pLmNsb25lKHRydWUpLmF0dHIoJ2lkJywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZGF0YS1zbGljay1pbmRleCcsIHNsaWRlSW5kZXggKyBfLnNsaWRlQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oXy4kc2xpZGVUcmFjaykuYWRkQ2xhc3MoJ3NsaWNrLWNsb25lZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmZpbmQoJy5zbGljay1jbG9uZWQnKS5maW5kKCdbaWRdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hdHRyKCdpZCcsICcnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24oIHRvZ2dsZSApIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYoICF0b2dnbGUgKSB7XG4gICAgICAgICAgICBfLmF1dG9QbGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IHRvZ2dsZTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2VsZWN0SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIHZhciB0YXJnZXRFbGVtZW50ID1cbiAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS5pcygnLnNsaWNrLXNsaWRlJykgP1xuICAgICAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KSA6XG4gICAgICAgICAgICAgICAgJChldmVudC50YXJnZXQpLnBhcmVudHMoJy5zbGljay1zbGlkZScpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KHRhcmdldEVsZW1lbnQuYXR0cignZGF0YS1zbGljay1pbmRleCcpKTtcblxuICAgICAgICBpZiAoIWluZGV4KSBpbmRleCA9IDA7XG5cbiAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgIF8uc2V0U2xpZGVDbGFzc2VzKGluZGV4KTtcbiAgICAgICAgICAgIF8uYXNOYXZGb3IoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfLnNsaWRlSGFuZGxlcihpbmRleCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNsaWRlSGFuZGxlciA9IGZ1bmN0aW9uKGluZGV4LCBzeW5jLCBkb250QW5pbWF0ZSkge1xuXG4gICAgICAgIHZhciB0YXJnZXRTbGlkZSwgYW5pbVNsaWRlLCBvbGRTbGlkZSwgc2xpZGVMZWZ0LCB0YXJnZXRMZWZ0ID0gbnVsbCxcbiAgICAgICAgICAgIF8gPSB0aGlzLCBuYXZUYXJnZXQ7XG5cbiAgICAgICAgc3luYyA9IHN5bmMgfHwgZmFsc2U7XG5cbiAgICAgICAgaWYgKF8uYW5pbWF0aW5nID09PSB0cnVlICYmIF8ub3B0aW9ucy53YWl0Rm9yQW5pbWF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSB0cnVlICYmIF8uY3VycmVudFNsaWRlID09PSBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uYXNOYXZGb3IoaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0U2xpZGUgPSBpbmRleDtcbiAgICAgICAgdGFyZ2V0TGVmdCA9IF8uZ2V0TGVmdCh0YXJnZXRTbGlkZSk7XG4gICAgICAgIHNsaWRlTGVmdCA9IF8uZ2V0TGVmdChfLmN1cnJlbnRTbGlkZSk7XG5cbiAgICAgICAgXy5jdXJyZW50TGVmdCA9IF8uc3dpcGVMZWZ0ID09PSBudWxsID8gc2xpZGVMZWZ0IDogXy5zd2lwZUxlZnQ7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UgJiYgXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IGZhbHNlICYmIChpbmRleCA8IDAgfHwgaW5kZXggPiBfLmdldERvdENvdW50KCkgKiBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2xpZGUgPSBfLmN1cnJlbnRTbGlkZTtcbiAgICAgICAgICAgICAgICBpZiAoZG9udEFuaW1hdGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5hbmltYXRlU2xpZGUoc2xpZGVMZWZ0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKHRhcmdldFNsaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUodGFyZ2V0U2xpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlICYmIF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlICYmIChpbmRleCA8IDAgfHwgaW5kZXggPiAoXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSkpIHtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTbGlkZSA9IF8uY3VycmVudFNsaWRlO1xuICAgICAgICAgICAgICAgIGlmIChkb250QW5pbWF0ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfLmFuaW1hdGVTbGlkZShzbGlkZUxlZnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUodGFyZ2V0U2xpZGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZSh0YXJnZXRTbGlkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMuYXV0b3BsYXkgKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKF8uYXV0b1BsYXlUaW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0U2xpZGUgPCAwKSB7XG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgYW5pbVNsaWRlID0gXy5zbGlkZUNvdW50IC0gKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1TbGlkZSA9IF8uc2xpZGVDb3VudCArIHRhcmdldFNsaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFNsaWRlID49IF8uc2xpZGVDb3VudCkge1xuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGFuaW1TbGlkZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1TbGlkZSA9IHRhcmdldFNsaWRlIC0gXy5zbGlkZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5pbVNsaWRlID0gdGFyZ2V0U2xpZGU7XG4gICAgICAgIH1cblxuICAgICAgICBfLmFuaW1hdGluZyA9IHRydWU7XG5cbiAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2JlZm9yZUNoYW5nZScsIFtfLCBfLmN1cnJlbnRTbGlkZSwgYW5pbVNsaWRlXSk7XG5cbiAgICAgICAgb2xkU2xpZGUgPSBfLmN1cnJlbnRTbGlkZTtcbiAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBhbmltU2xpZGU7XG5cbiAgICAgICAgXy5zZXRTbGlkZUNsYXNzZXMoXy5jdXJyZW50U2xpZGUpO1xuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmFzTmF2Rm9yICkge1xuXG4gICAgICAgICAgICBuYXZUYXJnZXQgPSBfLmdldE5hdlRhcmdldCgpO1xuICAgICAgICAgICAgbmF2VGFyZ2V0ID0gbmF2VGFyZ2V0LnNsaWNrKCdnZXRTbGljaycpO1xuXG4gICAgICAgICAgICBpZiAoIG5hdlRhcmdldC5zbGlkZUNvdW50IDw9IG5hdlRhcmdldC5vcHRpb25zLnNsaWRlc1RvU2hvdyApIHtcbiAgICAgICAgICAgICAgICBuYXZUYXJnZXQuc2V0U2xpZGVDbGFzc2VzKF8uY3VycmVudFNsaWRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgXy51cGRhdGVEb3RzKCk7XG4gICAgICAgIF8udXBkYXRlQXJyb3dzKCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoZG9udEFuaW1hdGUgIT09IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIF8uZmFkZVNsaWRlT3V0KG9sZFNsaWRlKTtcblxuICAgICAgICAgICAgICAgIF8uZmFkZVNsaWRlKGFuaW1TbGlkZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKGFuaW1TbGlkZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUoYW5pbVNsaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8uYW5pbWF0ZUhlaWdodCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbnRBbmltYXRlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBfLmFuaW1hdGVTbGlkZSh0YXJnZXRMZWZ0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZShhbmltU2xpZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLnBvc3RTbGlkZShhbmltU2xpZGUpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgIF8uJHByZXZBcnJvdy5oaWRlKCk7XG4gICAgICAgICAgICBfLiRuZXh0QXJyb3cuaGlkZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmRvdHMgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLiRkb3RzLmhpZGUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgXy4kc2xpZGVyLmFkZENsYXNzKCdzbGljay1sb2FkaW5nJyk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN3aXBlRGlyZWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHhEaXN0LCB5RGlzdCwgciwgc3dpcGVBbmdsZSwgXyA9IHRoaXM7XG5cbiAgICAgICAgeERpc3QgPSBfLnRvdWNoT2JqZWN0LnN0YXJ0WCAtIF8udG91Y2hPYmplY3QuY3VyWDtcbiAgICAgICAgeURpc3QgPSBfLnRvdWNoT2JqZWN0LnN0YXJ0WSAtIF8udG91Y2hPYmplY3QuY3VyWTtcbiAgICAgICAgciA9IE1hdGguYXRhbjIoeURpc3QsIHhEaXN0KTtcblxuICAgICAgICBzd2lwZUFuZ2xlID0gTWF0aC5yb3VuZChyICogMTgwIC8gTWF0aC5QSSk7XG4gICAgICAgIGlmIChzd2lwZUFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgc3dpcGVBbmdsZSA9IDM2MCAtIE1hdGguYWJzKHN3aXBlQW5nbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChzd2lwZUFuZ2xlIDw9IDQ1KSAmJiAoc3dpcGVBbmdsZSA+PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIChfLm9wdGlvbnMucnRsID09PSBmYWxzZSA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3dpcGVBbmdsZSA8PSAzNjApICYmIChzd2lwZUFuZ2xlID49IDMxNSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoXy5vcHRpb25zLnJ0bCA9PT0gZmFsc2UgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN3aXBlQW5nbGUgPj0gMTM1KSAmJiAoc3dpcGVBbmdsZSA8PSAyMjUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKF8ub3B0aW9ucy5ydGwgPT09IGZhbHNlID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICgoc3dpcGVBbmdsZSA+PSAzNSkgJiYgKHN3aXBlQW5nbGUgPD0gMTM1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZG93bic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAndXAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICd2ZXJ0aWNhbCc7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN3aXBlRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgZGlyZWN0aW9uO1xuXG4gICAgICAgIF8uZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICAgICAgICBfLnNob3VsZENsaWNrID0gKCBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID4gMTAgKSA/IGZhbHNlIDogdHJ1ZTtcblxuICAgICAgICBpZiAoIF8udG91Y2hPYmplY3QuY3VyWCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLnRvdWNoT2JqZWN0LmVkZ2VIaXQgPT09IHRydWUgKSB7XG4gICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignZWRnZScsIFtfLCBfLnN3aXBlRGlyZWN0aW9uKCkgXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPj0gXy50b3VjaE9iamVjdC5taW5Td2lwZSApIHtcblxuICAgICAgICAgICAgZGlyZWN0aW9uID0gXy5zd2lwZURpcmVjdGlvbigpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBkaXJlY3Rpb24gKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3duJzpcblxuICAgICAgICAgICAgICAgICAgICBzbGlkZUNvdW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy5zd2lwZVRvU2xpZGUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY2hlY2tOYXZpZ2FibGUoIF8uY3VycmVudFNsaWRlICsgXy5nZXRTbGlkZUNvdW50KCkgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgKyBfLmdldFNsaWRlQ291bnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnREaXJlY3Rpb24gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3VwJzpcblxuICAgICAgICAgICAgICAgICAgICBzbGlkZUNvdW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy5zd2lwZVRvU2xpZGUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY2hlY2tOYXZpZ2FibGUoIF8uY3VycmVudFNsaWRlIC0gXy5nZXRTbGlkZUNvdW50KCkgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgLSBfLmdldFNsaWRlQ291bnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnREaXJlY3Rpb24gPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBkaXJlY3Rpb24gIT0gJ3ZlcnRpY2FsJyApIHtcblxuICAgICAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKCBzbGlkZUNvdW50ICk7XG4gICAgICAgICAgICAgICAgXy50b3VjaE9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdzd2lwZScsIFtfLCBkaXJlY3Rpb24gXSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoIF8udG91Y2hPYmplY3Quc3RhcnRYICE9PSBfLnRvdWNoT2JqZWN0LmN1clggKSB7XG5cbiAgICAgICAgICAgICAgICBfLnNsaWRlSGFuZGxlciggXy5jdXJyZW50U2xpZGUgKTtcbiAgICAgICAgICAgICAgICBfLnRvdWNoT2JqZWN0ID0ge307XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN3aXBlSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICgoXy5vcHRpb25zLnN3aXBlID09PSBmYWxzZSkgfHwgKCdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudCAmJiBfLm9wdGlvbnMuc3dpcGUgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKF8ub3B0aW9ucy5kcmFnZ2FibGUgPT09IGZhbHNlICYmIGV2ZW50LnR5cGUuaW5kZXhPZignbW91c2UnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF8udG91Y2hPYmplY3QuZmluZ2VyQ291bnQgPSBldmVudC5vcmlnaW5hbEV2ZW50ICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcy5sZW5ndGggOiAxO1xuXG4gICAgICAgIF8udG91Y2hPYmplY3QubWluU3dpcGUgPSBfLmxpc3RXaWR0aCAvIF8ub3B0aW9uc1xuICAgICAgICAgICAgLnRvdWNoVGhyZXNob2xkO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLnRvdWNoT2JqZWN0Lm1pblN3aXBlID0gXy5saXN0SGVpZ2h0IC8gXy5vcHRpb25zXG4gICAgICAgICAgICAgICAgLnRvdWNoVGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5kYXRhLmFjdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgXy5zd2lwZVN0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbW92ZSc6XG4gICAgICAgICAgICAgICAgXy5zd2lwZU1vdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIF8uc3dpcGVFbmQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc3dpcGVNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBlZGdlV2FzSGl0ID0gZmFsc2UsXG4gICAgICAgICAgICBjdXJMZWZ0LCBzd2lwZURpcmVjdGlvbiwgc3dpcGVMZW5ndGgsIHBvc2l0aW9uT2Zmc2V0LCB0b3VjaGVzO1xuXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5vcmlnaW5hbEV2ZW50ICE9PSB1bmRlZmluZWQgPyBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgOiBudWxsO1xuXG4gICAgICAgIGlmICghXy5kcmFnZ2luZyB8fCB0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJMZWZ0ID0gXy5nZXRMZWZ0KF8uY3VycmVudFNsaWRlKTtcblxuICAgICAgICBfLnRvdWNoT2JqZWN0LmN1clggPSB0b3VjaGVzICE9PSB1bmRlZmluZWQgPyB0b3VjaGVzWzBdLnBhZ2VYIDogZXZlbnQuY2xpZW50WDtcbiAgICAgICAgXy50b3VjaE9iamVjdC5jdXJZID0gdG91Y2hlcyAhPT0gdW5kZWZpbmVkID8gdG91Y2hlc1swXS5wYWdlWSA6IGV2ZW50LmNsaWVudFk7XG5cbiAgICAgICAgXy50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3coXy50b3VjaE9iamVjdC5jdXJYIC0gXy50b3VjaE9iamVjdC5zdGFydFgsIDIpKSk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPSBNYXRoLnJvdW5kKE1hdGguc3FydChcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyhfLnRvdWNoT2JqZWN0LmN1clkgLSBfLnRvdWNoT2JqZWN0LnN0YXJ0WSwgMikpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlRGlyZWN0aW9uID0gXy5zd2lwZURpcmVjdGlvbigpO1xuXG4gICAgICAgIGlmIChzd2lwZURpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgIT09IHVuZGVmaW5lZCAmJiBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uT2Zmc2V0ID0gKF8ub3B0aW9ucy5ydGwgPT09IGZhbHNlID8gMSA6IC0xKSAqIChfLnRvdWNoT2JqZWN0LmN1clggPiBfLnRvdWNoT2JqZWN0LnN0YXJ0WCA/IDEgOiAtMSk7XG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk9mZnNldCA9IF8udG91Y2hPYmplY3QuY3VyWSA+IF8udG91Y2hPYmplY3Quc3RhcnRZID8gMSA6IC0xO1xuICAgICAgICB9XG5cblxuICAgICAgICBzd2lwZUxlbmd0aCA9IF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGg7XG5cbiAgICAgICAgXy50b3VjaE9iamVjdC5lZGdlSGl0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICgoXy5jdXJyZW50U2xpZGUgPT09IDAgJiYgc3dpcGVEaXJlY3Rpb24gPT09ICdyaWdodCcpIHx8IChfLmN1cnJlbnRTbGlkZSA+PSBfLmdldERvdENvdW50KCkgJiYgc3dpcGVEaXJlY3Rpb24gPT09ICdsZWZ0JykpIHtcbiAgICAgICAgICAgICAgICBzd2lwZUxlbmd0aCA9IF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggKiBfLm9wdGlvbnMuZWRnZUZyaWN0aW9uO1xuICAgICAgICAgICAgICAgIF8udG91Y2hPYmplY3QuZWRnZUhpdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy5zd2lwZUxlZnQgPSBjdXJMZWZ0ICsgc3dpcGVMZW5ndGggKiBwb3NpdGlvbk9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uc3dpcGVMZWZ0ID0gY3VyTGVmdCArIChzd2lwZUxlbmd0aCAqIChfLiRsaXN0LmhlaWdodCgpIC8gXy5saXN0V2lkdGgpKSAqIHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLnN3aXBlTGVmdCA9IGN1ckxlZnQgKyBzd2lwZUxlbmd0aCAqIHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSB0cnVlIHx8IF8ub3B0aW9ucy50b3VjaE1vdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5hbmltYXRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uc3dpcGVMZWZ0ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uc2V0Q1NTKF8uc3dpcGVMZWZ0KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc3dpcGVTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgdG91Y2hlcztcblxuICAgICAgICBfLmludGVycnVwdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoXy50b3VjaE9iamVjdC5maW5nZXJDb3VudCAhPT0gMSB8fCBfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgXy50b3VjaE9iamVjdCA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG91Y2hlcyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8udG91Y2hPYmplY3Quc3RhcnRYID0gXy50b3VjaE9iamVjdC5jdXJYID0gdG91Y2hlcyAhPT0gdW5kZWZpbmVkID8gdG91Y2hlcy5wYWdlWCA6IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIF8udG91Y2hPYmplY3Quc3RhcnRZID0gXy50b3VjaE9iamVjdC5jdXJZID0gdG91Y2hlcyAhPT0gdW5kZWZpbmVkID8gdG91Y2hlcy5wYWdlWSA6IGV2ZW50LmNsaWVudFk7XG5cbiAgICAgICAgXy5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnVuZmlsdGVyU2xpZGVzID0gU2xpY2sucHJvdG90eXBlLnNsaWNrVW5maWx0ZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8uJHNsaWRlc0NhY2hlICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIF8udW5sb2FkKCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKTtcblxuICAgICAgICAgICAgXy4kc2xpZGVzQ2FjaGUuYXBwZW5kVG8oXy4kc2xpZGVUcmFjayk7XG5cbiAgICAgICAgICAgIF8ucmVpbml0KCk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS51bmxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgJCgnLnNsaWNrLWNsb25lZCcsIF8uJHNsaWRlcikucmVtb3ZlKCk7XG5cbiAgICAgICAgaWYgKF8uJGRvdHMpIHtcbiAgICAgICAgICAgIF8uJGRvdHMucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy4kcHJldkFycm93ICYmIF8uaHRtbEV4cHIudGVzdChfLm9wdGlvbnMucHJldkFycm93KSkge1xuICAgICAgICAgICAgXy4kcHJldkFycm93LnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uJG5leHRBcnJvdyAmJiBfLmh0bWxFeHByLnRlc3QoXy5vcHRpb25zLm5leHRBcnJvdykpIHtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvdy5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1zbGlkZSBzbGljay1hY3RpdmUgc2xpY2stdmlzaWJsZSBzbGljay1jdXJyZW50JylcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJylcbiAgICAgICAgICAgIC5jc3MoJ3dpZHRoJywgJycpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS51bnNsaWNrID0gZnVuY3Rpb24oZnJvbUJyZWFrcG9pbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG4gICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCd1bnNsaWNrJywgW18sIGZyb21CcmVha3BvaW50XSk7XG4gICAgICAgIF8uZGVzdHJveSgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS51cGRhdGVBcnJvd3MgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBjZW50ZXJPZmZzZXQ7XG5cbiAgICAgICAgY2VudGVyT2Zmc2V0ID0gTWF0aC5mbG9vcihfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMik7XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMuYXJyb3dzID09PSB0cnVlICYmXG4gICAgICAgICAgICBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmXG4gICAgICAgICAgICAhXy5vcHRpb25zLmluZmluaXRlICkge1xuXG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93LnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgaWYgKF8uY3VycmVudFNsaWRlID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cuYWRkQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmN1cnJlbnRTbGlkZSA+PSBfLnNsaWRlQ291bnQgLSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LmFkZENsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5jdXJyZW50U2xpZGUgPj0gXy5zbGlkZUNvdW50IC0gMSAmJiBfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LmFkZENsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnVwZGF0ZURvdHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8uJGRvdHMgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgXy4kZG90c1xuICAgICAgICAgICAgICAgIC5maW5kKCdsaScpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAgICAgICAgIF8uJGRvdHNcbiAgICAgICAgICAgICAgICAuZmluZCgnbGknKVxuICAgICAgICAgICAgICAgIC5lcShNYXRoLmZsb29yKF8uY3VycmVudFNsaWRlIC8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS52aXNpYmlsaXR5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmF1dG9wbGF5ICkge1xuXG4gICAgICAgICAgICBpZiAoIGRvY3VtZW50W18uaGlkZGVuXSApIHtcblxuICAgICAgICAgICAgICAgIF8uaW50ZXJydXB0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgICQuZm4uc2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgb3B0ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBsID0gXy5sZW5ndGgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcmV0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdCA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb3B0ID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIF9baV0uc2xpY2sgPSBuZXcgU2xpY2soX1tpXSwgb3B0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXQgPSBfW2ldLnNsaWNrW29wdF0uYXBwbHkoX1tpXS5zbGljaywgYXJncyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJldCAhPSAndW5kZWZpbmVkJykgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXztcbiAgICB9O1xuXG59KSk7XG4iLCIvKlxuICAgICBfIF8gICAgICBfICAgICAgIF9cbiBfX198IChfKSBfX198IHwgX18gIChfKV9fX1xuLyBfX3wgfCB8LyBfX3wgfC8gLyAgfCAvIF9ffFxuXFxfXyBcXCB8IHwgKF9ffCAgIDwgXyB8IFxcX18gXFxcbnxfX18vX3xffFxcX19ffF98XFxfKF8pLyB8X19fL1xuICAgICAgICAgICAgICAgICAgIHxfXy9cblxuIFZlcnNpb246IDEuNi4wXG4gIEF1dGhvcjogS2VuIFdoZWVsZXJcbiBXZWJzaXRlOiBodHRwOi8va2Vud2hlZWxlci5naXRodWIuaW9cbiAgICBEb2NzOiBodHRwOi8va2Vud2hlZWxlci5naXRodWIuaW8vc2xpY2tcbiAgICBSZXBvOiBodHRwOi8vZ2l0aHViLmNvbS9rZW53aGVlbGVyL3NsaWNrXG4gIElzc3VlczogaHR0cDovL2dpdGh1Yi5jb20va2Vud2hlZWxlci9zbGljay9pc3N1ZXNcblxuICovXG4hZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJqcXVlcnlcIl0sYSk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9YShyZXF1aXJlKFwianF1ZXJ5XCIpKTphKGpRdWVyeSl9KGZ1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO3ZhciBiPXdpbmRvdy5TbGlja3x8e307Yj1mdW5jdGlvbigpe2Z1bmN0aW9uIGMoYyxkKXt2YXIgZixlPXRoaXM7ZS5kZWZhdWx0cz17YWNjZXNzaWJpbGl0eTohMCxhZGFwdGl2ZUhlaWdodDohMSxhcHBlbmRBcnJvd3M6YShjKSxhcHBlbmREb3RzOmEoYyksYXJyb3dzOiEwLGFzTmF2Rm9yOm51bGwscHJldkFycm93Oic8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLXJvbGU9XCJub25lXCIgY2xhc3M9XCJzbGljay1wcmV2XCIgYXJpYS1sYWJlbD1cIlByZXZpb3VzXCIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImJ1dHRvblwiPlByZXZpb3VzPC9idXR0b24+JyxuZXh0QXJyb3c6JzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtcm9sZT1cIm5vbmVcIiBjbGFzcz1cInNsaWNrLW5leHRcIiBhcmlhLWxhYmVsPVwiTmV4dFwiIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJidXR0b25cIj5OZXh0PC9idXR0b24+JyxhdXRvcGxheTohMSxhdXRvcGxheVNwZWVkOjNlMyxjZW50ZXJNb2RlOiExLGNlbnRlclBhZGRpbmc6XCI1MHB4XCIsY3NzRWFzZTpcImVhc2VcIixjdXN0b21QYWdpbmc6ZnVuY3Rpb24oYixjKXtyZXR1cm4gYSgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1yb2xlPVwibm9uZVwiIHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiAvPicpLnRleHQoYysxKX0sZG90czohMSxkb3RzQ2xhc3M6XCJzbGljay1kb3RzXCIsZHJhZ2dhYmxlOiEwLGVhc2luZzpcImxpbmVhclwiLGVkZ2VGcmljdGlvbjouMzUsZmFkZTohMSxmb2N1c09uU2VsZWN0OiExLGluZmluaXRlOiEwLGluaXRpYWxTbGlkZTowLGxhenlMb2FkOlwib25kZW1hbmRcIixtb2JpbGVGaXJzdDohMSxwYXVzZU9uSG92ZXI6ITAscGF1c2VPbkZvY3VzOiEwLHBhdXNlT25Eb3RzSG92ZXI6ITEscmVzcG9uZFRvOlwid2luZG93XCIscmVzcG9uc2l2ZTpudWxsLHJvd3M6MSxydGw6ITEsc2xpZGU6XCJcIixzbGlkZXNQZXJSb3c6MSxzbGlkZXNUb1Nob3c6MSxzbGlkZXNUb1Njcm9sbDoxLHNwZWVkOjUwMCxzd2lwZTohMCxzd2lwZVRvU2xpZGU6ITEsdG91Y2hNb3ZlOiEwLHRvdWNoVGhyZXNob2xkOjUsdXNlQ1NTOiEwLHVzZVRyYW5zZm9ybTohMCx2YXJpYWJsZVdpZHRoOiExLHZlcnRpY2FsOiExLHZlcnRpY2FsU3dpcGluZzohMSx3YWl0Rm9yQW5pbWF0ZTohMCx6SW5kZXg6MWUzfSxlLmluaXRpYWxzPXthbmltYXRpbmc6ITEsZHJhZ2dpbmc6ITEsYXV0b1BsYXlUaW1lcjpudWxsLGN1cnJlbnREaXJlY3Rpb246MCxjdXJyZW50TGVmdDpudWxsLGN1cnJlbnRTbGlkZTowLGRpcmVjdGlvbjoxLCRkb3RzOm51bGwsbGlzdFdpZHRoOm51bGwsbGlzdEhlaWdodDpudWxsLGxvYWRJbmRleDowLCRuZXh0QXJyb3c6bnVsbCwkcHJldkFycm93Om51bGwsc2xpZGVDb3VudDpudWxsLHNsaWRlV2lkdGg6bnVsbCwkc2xpZGVUcmFjazpudWxsLCRzbGlkZXM6bnVsbCxzbGlkaW5nOiExLHNsaWRlT2Zmc2V0OjAsc3dpcGVMZWZ0Om51bGwsJGxpc3Q6bnVsbCx0b3VjaE9iamVjdDp7fSx0cmFuc2Zvcm1zRW5hYmxlZDohMSx1bnNsaWNrZWQ6ITF9LGEuZXh0ZW5kKGUsZS5pbml0aWFscyksZS5hY3RpdmVCcmVha3BvaW50PW51bGwsZS5hbmltVHlwZT1udWxsLGUuYW5pbVByb3A9bnVsbCxlLmJyZWFrcG9pbnRzPVtdLGUuYnJlYWtwb2ludFNldHRpbmdzPVtdLGUuY3NzVHJhbnNpdGlvbnM9ITEsZS5mb2N1c3NlZD0hMSxlLmludGVycnVwdGVkPSExLGUuaGlkZGVuPVwiaGlkZGVuXCIsZS5wYXVzZWQ9ITAsZS5wb3NpdGlvblByb3A9bnVsbCxlLnJlc3BvbmRUbz1udWxsLGUucm93Q291bnQ9MSxlLnNob3VsZENsaWNrPSEwLGUuJHNsaWRlcj1hKGMpLGUuJHNsaWRlc0NhY2hlPW51bGwsZS50cmFuc2Zvcm1UeXBlPW51bGwsZS50cmFuc2l0aW9uVHlwZT1udWxsLGUudmlzaWJpbGl0eUNoYW5nZT1cInZpc2liaWxpdHljaGFuZ2VcIixlLndpbmRvd1dpZHRoPTAsZS53aW5kb3dUaW1lcj1udWxsLGY9YShjKS5kYXRhKFwic2xpY2tcIil8fHt9LGUub3B0aW9ucz1hLmV4dGVuZCh7fSxlLmRlZmF1bHRzLGQsZiksZS5jdXJyZW50U2xpZGU9ZS5vcHRpb25zLmluaXRpYWxTbGlkZSxlLm9yaWdpbmFsU2V0dGluZ3M9ZS5vcHRpb25zLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudC5tb3pIaWRkZW4/KGUuaGlkZGVuPVwibW96SGlkZGVuXCIsZS52aXNpYmlsaXR5Q2hhbmdlPVwibW96dmlzaWJpbGl0eWNoYW5nZVwiKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQud2Via2l0SGlkZGVuJiYoZS5oaWRkZW49XCJ3ZWJraXRIaWRkZW5cIixlLnZpc2liaWxpdHlDaGFuZ2U9XCJ3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlXCIpLGUuYXV0b1BsYXk9YS5wcm94eShlLmF1dG9QbGF5LGUpLGUuYXV0b1BsYXlDbGVhcj1hLnByb3h5KGUuYXV0b1BsYXlDbGVhcixlKSxlLmF1dG9QbGF5SXRlcmF0b3I9YS5wcm94eShlLmF1dG9QbGF5SXRlcmF0b3IsZSksZS5jaGFuZ2VTbGlkZT1hLnByb3h5KGUuY2hhbmdlU2xpZGUsZSksZS5jbGlja0hhbmRsZXI9YS5wcm94eShlLmNsaWNrSGFuZGxlcixlKSxlLnNlbGVjdEhhbmRsZXI9YS5wcm94eShlLnNlbGVjdEhhbmRsZXIsZSksZS5zZXRQb3NpdGlvbj1hLnByb3h5KGUuc2V0UG9zaXRpb24sZSksZS5zd2lwZUhhbmRsZXI9YS5wcm94eShlLnN3aXBlSGFuZGxlcixlKSxlLmRyYWdIYW5kbGVyPWEucHJveHkoZS5kcmFnSGFuZGxlcixlKSxlLmtleUhhbmRsZXI9YS5wcm94eShlLmtleUhhbmRsZXIsZSksZS5pbnN0YW5jZVVpZD1iKyssZS5odG1sRXhwcj0vXig/OlxccyooPFtcXHdcXFddKz4pW14+XSopJC8sZS5yZWdpc3RlckJyZWFrcG9pbnRzKCksZS5pbml0KCEwKX12YXIgYj0wO3JldHVybiBjfSgpLGIucHJvdG90eXBlLmFjdGl2YXRlQURBPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLiRzbGlkZVRyYWNrLmZpbmQoXCIuc2xpY2stYWN0aXZlXCIpLmF0dHIoe1wiYXJpYS1oaWRkZW5cIjpcImZhbHNlXCJ9KS5maW5kKFwiYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0XCIpLmF0dHIoe3RhYmluZGV4OlwiMFwifSl9LGIucHJvdG90eXBlLmFkZFNsaWRlPWIucHJvdG90eXBlLnNsaWNrQWRkPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT10aGlzO2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYylkPWMsYz1udWxsO2Vsc2UgaWYoMD5jfHxjPj1lLnNsaWRlQ291bnQpcmV0dXJuITE7ZS51bmxvYWQoKSxcIm51bWJlclwiPT10eXBlb2YgYz8wPT09YyYmMD09PWUuJHNsaWRlcy5sZW5ndGg/YShiKS5hcHBlbmRUbyhlLiRzbGlkZVRyYWNrKTpkP2EoYikuaW5zZXJ0QmVmb3JlKGUuJHNsaWRlcy5lcShjKSk6YShiKS5pbnNlcnRBZnRlcihlLiRzbGlkZXMuZXEoYykpOmQ9PT0hMD9hKGIpLnByZXBlbmRUbyhlLiRzbGlkZVRyYWNrKTphKGIpLmFwcGVuZFRvKGUuJHNsaWRlVHJhY2spLGUuJHNsaWRlcz1lLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSksZS4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpLGUuJHNsaWRlVHJhY2suYXBwZW5kKGUuJHNsaWRlcyksZS4kc2xpZGVzLmVhY2goZnVuY3Rpb24oYixjKXthKGMpLmF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIsYil9KSxlLiRzbGlkZXNDYWNoZT1lLiRzbGlkZXMsZS5yZWluaXQoKX0sYi5wcm90b3R5cGUuYW5pbWF0ZUhlaWdodD1mdW5jdGlvbigpe3ZhciBhPXRoaXM7aWYoMT09PWEub3B0aW9ucy5zbGlkZXNUb1Nob3cmJmEub3B0aW9ucy5hZGFwdGl2ZUhlaWdodD09PSEwJiZhLm9wdGlvbnMudmVydGljYWw9PT0hMSl7dmFyIGI9YS4kc2xpZGVzLmVxKGEuY3VycmVudFNsaWRlKS5vdXRlckhlaWdodCghMCk7YS4kbGlzdC5hbmltYXRlKHtoZWlnaHQ6Yn0sYS5vcHRpb25zLnNwZWVkKX19LGIucHJvdG90eXBlLmFuaW1hdGVTbGlkZT1mdW5jdGlvbihiLGMpe3ZhciBkPXt9LGU9dGhpcztlLmFuaW1hdGVIZWlnaHQoKSxlLm9wdGlvbnMucnRsPT09ITAmJmUub3B0aW9ucy52ZXJ0aWNhbD09PSExJiYoYj0tYiksZS50cmFuc2Zvcm1zRW5hYmxlZD09PSExP2Uub3B0aW9ucy52ZXJ0aWNhbD09PSExP2UuJHNsaWRlVHJhY2suYW5pbWF0ZSh7bGVmdDpifSxlLm9wdGlvbnMuc3BlZWQsZS5vcHRpb25zLmVhc2luZyxjKTplLiRzbGlkZVRyYWNrLmFuaW1hdGUoe3RvcDpifSxlLm9wdGlvbnMuc3BlZWQsZS5vcHRpb25zLmVhc2luZyxjKTplLmNzc1RyYW5zaXRpb25zPT09ITE/KGUub3B0aW9ucy5ydGw9PT0hMCYmKGUuY3VycmVudExlZnQ9LWUuY3VycmVudExlZnQpLGEoe2FuaW1TdGFydDplLmN1cnJlbnRMZWZ0fSkuYW5pbWF0ZSh7YW5pbVN0YXJ0OmJ9LHtkdXJhdGlvbjplLm9wdGlvbnMuc3BlZWQsZWFzaW5nOmUub3B0aW9ucy5lYXNpbmcsc3RlcDpmdW5jdGlvbihhKXthPU1hdGguY2VpbChhKSxlLm9wdGlvbnMudmVydGljYWw9PT0hMT8oZFtlLmFuaW1UeXBlXT1cInRyYW5zbGF0ZShcIithK1wicHgsIDBweClcIixlLiRzbGlkZVRyYWNrLmNzcyhkKSk6KGRbZS5hbmltVHlwZV09XCJ0cmFuc2xhdGUoMHB4LFwiK2ErXCJweClcIixlLiRzbGlkZVRyYWNrLmNzcyhkKSl9LGNvbXBsZXRlOmZ1bmN0aW9uKCl7YyYmYy5jYWxsKCl9fSkpOihlLmFwcGx5VHJhbnNpdGlvbigpLGI9TWF0aC5jZWlsKGIpLGUub3B0aW9ucy52ZXJ0aWNhbD09PSExP2RbZS5hbmltVHlwZV09XCJ0cmFuc2xhdGUzZChcIitiK1wicHgsIDBweCwgMHB4KVwiOmRbZS5hbmltVHlwZV09XCJ0cmFuc2xhdGUzZCgwcHgsXCIrYitcInB4LCAwcHgpXCIsZS4kc2xpZGVUcmFjay5jc3MoZCksYyYmc2V0VGltZW91dChmdW5jdGlvbigpe2UuZGlzYWJsZVRyYW5zaXRpb24oKSxjLmNhbGwoKX0sZS5vcHRpb25zLnNwZWVkKSl9LGIucHJvdG90eXBlLmdldE5hdlRhcmdldD1mdW5jdGlvbigpe3ZhciBiPXRoaXMsYz1iLm9wdGlvbnMuYXNOYXZGb3I7cmV0dXJuIGMmJm51bGwhPT1jJiYoYz1hKGMpLm5vdChiLiRzbGlkZXIpKSxjfSxiLnByb3RvdHlwZS5hc05hdkZvcj1mdW5jdGlvbihiKXt2YXIgYz10aGlzLGQ9Yy5nZXROYXZUYXJnZXQoKTtudWxsIT09ZCYmXCJvYmplY3RcIj09dHlwZW9mIGQmJmQuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcykuc2xpY2soXCJnZXRTbGlja1wiKTtjLnVuc2xpY2tlZHx8Yy5zbGlkZUhhbmRsZXIoYiwhMCl9KX0sYi5wcm90b3R5cGUuYXBwbHlUcmFuc2l0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz17fTtiLm9wdGlvbnMuZmFkZT09PSExP2NbYi50cmFuc2l0aW9uVHlwZV09Yi50cmFuc2Zvcm1UeXBlK1wiIFwiK2Iub3B0aW9ucy5zcGVlZCtcIm1zIFwiK2Iub3B0aW9ucy5jc3NFYXNlOmNbYi50cmFuc2l0aW9uVHlwZV09XCJvcGFjaXR5IFwiK2Iub3B0aW9ucy5zcGVlZCtcIm1zIFwiK2Iub3B0aW9ucy5jc3NFYXNlLGIub3B0aW9ucy5mYWRlPT09ITE/Yi4kc2xpZGVUcmFjay5jc3MoYyk6Yi4kc2xpZGVzLmVxKGEpLmNzcyhjKX0sYi5wcm90b3R5cGUuYXV0b1BsYXk9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2EuYXV0b1BsYXlDbGVhcigpLGEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYS5hdXRvUGxheVRpbWVyPXNldEludGVydmFsKGEuYXV0b1BsYXlJdGVyYXRvcixhLm9wdGlvbnMuYXV0b3BsYXlTcGVlZCkpfSxiLnByb3RvdHlwZS5hdXRvUGxheUNsZWFyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLmF1dG9QbGF5VGltZXImJmNsZWFySW50ZXJ2YWwoYS5hdXRvUGxheVRpbWVyKX0sYi5wcm90b3R5cGUuYXV0b1BsYXlJdGVyYXRvcj1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmN1cnJlbnRTbGlkZSthLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7YS5wYXVzZWR8fGEuaW50ZXJydXB0ZWR8fGEuZm9jdXNzZWR8fChhLm9wdGlvbnMuaW5maW5pdGU9PT0hMSYmKDE9PT1hLmRpcmVjdGlvbiYmYS5jdXJyZW50U2xpZGUrMT09PWEuc2xpZGVDb3VudC0xP2EuZGlyZWN0aW9uPTA6MD09PWEuZGlyZWN0aW9uJiYoYj1hLmN1cnJlbnRTbGlkZS1hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsYS5jdXJyZW50U2xpZGUtMT09PTAmJihhLmRpcmVjdGlvbj0xKSkpLGEuc2xpZGVIYW5kbGVyKGIpKX0sYi5wcm90b3R5cGUuYnVpbGRBcnJvd3M9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2Iub3B0aW9ucy5hcnJvd3M9PT0hMCYmKGIuJHByZXZBcnJvdz1hKGIub3B0aW9ucy5wcmV2QXJyb3cpLmFkZENsYXNzKFwic2xpY2stYXJyb3dcIiksYi4kbmV4dEFycm93PWEoYi5vcHRpb25zLm5leHRBcnJvdykuYWRkQ2xhc3MoXCJzbGljay1hcnJvd1wiKSxiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdz8oYi4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiB0YWJpbmRleFwiKSxiLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1oaWRkZW5cIikucmVtb3ZlQXR0cihcImFyaWEtaGlkZGVuIHRhYmluZGV4XCIpLGIuaHRtbEV4cHIudGVzdChiLm9wdGlvbnMucHJldkFycm93KSYmYi4kcHJldkFycm93LnByZXBlbmRUbyhiLm9wdGlvbnMuYXBwZW5kQXJyb3dzKSxiLmh0bWxFeHByLnRlc3QoYi5vcHRpb25zLm5leHRBcnJvdykmJmIuJG5leHRBcnJvdy5hcHBlbmRUbyhiLm9wdGlvbnMuYXBwZW5kQXJyb3dzKSxiLm9wdGlvbnMuaW5maW5pdGUhPT0hMCYmYi4kcHJldkFycm93LmFkZENsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcInRydWVcIikpOmIuJHByZXZBcnJvdy5hZGQoYi4kbmV4dEFycm93KS5hZGRDbGFzcyhcInNsaWNrLWhpZGRlblwiKS5hdHRyKHtcImFyaWEtZGlzYWJsZWRcIjpcInRydWVcIix0YWJpbmRleDpcIi0xXCJ9KSl9LGIucHJvdG90eXBlLmJ1aWxkRG90cz1mdW5jdGlvbigpe3ZhciBjLGQsYj10aGlzO2lmKGIub3B0aW9ucy5kb3RzPT09ITAmJmIuc2xpZGVDb3VudD5iLm9wdGlvbnMuc2xpZGVzVG9TaG93KXtmb3IoYi4kc2xpZGVyLmFkZENsYXNzKFwic2xpY2stZG90dGVkXCIpLGQ9YShcIjx1bCAvPlwiKS5hZGRDbGFzcyhiLm9wdGlvbnMuZG90c0NsYXNzKSxjPTA7Yzw9Yi5nZXREb3RDb3VudCgpO2MrPTEpZC5hcHBlbmQoYShcIjxsaSAvPlwiKS5hcHBlbmQoYi5vcHRpb25zLmN1c3RvbVBhZ2luZy5jYWxsKHRoaXMsYixjKSkpO2IuJGRvdHM9ZC5hcHBlbmRUbyhiLm9wdGlvbnMuYXBwZW5kRG90cyksYi4kZG90cy5maW5kKFwibGlcIikuZmlyc3QoKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpfX0sYi5wcm90b3R5cGUuYnVpbGRPdXQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2IuJHNsaWRlcz1iLiRzbGlkZXIuY2hpbGRyZW4oYi5vcHRpb25zLnNsaWRlK1wiOm5vdCguc2xpY2stY2xvbmVkKVwiKS5hZGRDbGFzcyhcInNsaWNrLXNsaWRlXCIpLGIuc2xpZGVDb3VudD1iLiRzbGlkZXMubGVuZ3RoLGIuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKGIsYyl7YShjKS5hdHRyKFwiZGF0YS1zbGljay1pbmRleFwiLGIpLmRhdGEoXCJvcmlnaW5hbFN0eWxpbmdcIixhKGMpLmF0dHIoXCJzdHlsZVwiKXx8XCJcIil9KSxiLiRzbGlkZXIuYWRkQ2xhc3MoXCJzbGljay1zbGlkZXJcIiksYi4kc2xpZGVUcmFjaz0wPT09Yi5zbGlkZUNvdW50P2EoJzxkaXYgY2xhc3M9XCJzbGljay10cmFja1wiLz4nKS5hcHBlbmRUbyhiLiRzbGlkZXIpOmIuJHNsaWRlcy53cmFwQWxsKCc8ZGl2IGNsYXNzPVwic2xpY2stdHJhY2tcIi8+JykucGFyZW50KCksYi4kbGlzdD1iLiRzbGlkZVRyYWNrLndyYXAoJzxkaXYgYXJpYS1saXZlPVwicG9saXRlXCIgY2xhc3M9XCJzbGljay1saXN0XCIvPicpLnBhcmVudCgpLGIuJHNsaWRlVHJhY2suY3NzKFwib3BhY2l0eVwiLDApLChiLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwfHxiLm9wdGlvbnMuc3dpcGVUb1NsaWRlPT09ITApJiYoYi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsPTEpLGEoXCJpbWdbZGF0YS1sYXp5XVwiLGIuJHNsaWRlcikubm90KFwiW3NyY11cIikuYWRkQ2xhc3MoXCJzbGljay1sb2FkaW5nXCIpLGIuc2V0dXBJbmZpbml0ZSgpLGIuYnVpbGRBcnJvd3MoKSxiLmJ1aWxkRG90cygpLGIudXBkYXRlRG90cygpLGIuc2V0U2xpZGVDbGFzc2VzKFwibnVtYmVyXCI9PXR5cGVvZiBiLmN1cnJlbnRTbGlkZT9iLmN1cnJlbnRTbGlkZTowKSxiLm9wdGlvbnMuZHJhZ2dhYmxlPT09ITAmJmIuJGxpc3QuYWRkQ2xhc3MoXCJkcmFnZ2FibGVcIil9LGIucHJvdG90eXBlLmJ1aWxkUm93cz1mdW5jdGlvbigpe3ZhciBiLGMsZCxlLGYsZyxoLGE9dGhpcztpZihlPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxnPWEuJHNsaWRlci5jaGlsZHJlbigpLGEub3B0aW9ucy5yb3dzPjEpe2ZvcihoPWEub3B0aW9ucy5zbGlkZXNQZXJSb3cqYS5vcHRpb25zLnJvd3MsZj1NYXRoLmNlaWwoZy5sZW5ndGgvaCksYj0wO2Y+YjtiKyspe3ZhciBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Zm9yKGM9MDtjPGEub3B0aW9ucy5yb3dzO2MrKyl7dmFyIGo9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtmb3IoZD0wO2Q8YS5vcHRpb25zLnNsaWRlc1BlclJvdztkKyspe3ZhciBrPWIqaCsoYyphLm9wdGlvbnMuc2xpZGVzUGVyUm93K2QpO2cuZ2V0KGspJiZqLmFwcGVuZENoaWxkKGcuZ2V0KGspKX1pLmFwcGVuZENoaWxkKGopfWUuYXBwZW5kQ2hpbGQoaSl9YS4kc2xpZGVyLmVtcHR5KCkuYXBwZW5kKGUpLGEuJHNsaWRlci5jaGlsZHJlbigpLmNoaWxkcmVuKCkuY2hpbGRyZW4oKS5jc3Moe3dpZHRoOjEwMC9hLm9wdGlvbnMuc2xpZGVzUGVyUm93K1wiJVwiLGRpc3BsYXk6XCJpbmxpbmUtYmxvY2tcIn0pfX0sYi5wcm90b3R5cGUuY2hlY2tSZXNwb25zaXZlPWZ1bmN0aW9uKGIsYyl7dmFyIGUsZixnLGQ9dGhpcyxoPSExLGk9ZC4kc2xpZGVyLndpZHRoKCksaj13aW5kb3cuaW5uZXJXaWR0aHx8YSh3aW5kb3cpLndpZHRoKCk7aWYoXCJ3aW5kb3dcIj09PWQucmVzcG9uZFRvP2c9ajpcInNsaWRlclwiPT09ZC5yZXNwb25kVG8/Zz1pOlwibWluXCI9PT1kLnJlc3BvbmRUbyYmKGc9TWF0aC5taW4oaixpKSksZC5vcHRpb25zLnJlc3BvbnNpdmUmJmQub3B0aW9ucy5yZXNwb25zaXZlLmxlbmd0aCYmbnVsbCE9PWQub3B0aW9ucy5yZXNwb25zaXZlKXtmPW51bGw7Zm9yKGUgaW4gZC5icmVha3BvaW50cylkLmJyZWFrcG9pbnRzLmhhc093blByb3BlcnR5KGUpJiYoZC5vcmlnaW5hbFNldHRpbmdzLm1vYmlsZUZpcnN0PT09ITE/ZzxkLmJyZWFrcG9pbnRzW2VdJiYoZj1kLmJyZWFrcG9pbnRzW2VdKTpnPmQuYnJlYWtwb2ludHNbZV0mJihmPWQuYnJlYWtwb2ludHNbZV0pKTtudWxsIT09Zj9udWxsIT09ZC5hY3RpdmVCcmVha3BvaW50PyhmIT09ZC5hY3RpdmVCcmVha3BvaW50fHxjKSYmKGQuYWN0aXZlQnJlYWtwb2ludD1mLFwidW5zbGlja1wiPT09ZC5icmVha3BvaW50U2V0dGluZ3NbZl0/ZC51bnNsaWNrKGYpOihkLm9wdGlvbnM9YS5leHRlbmQoe30sZC5vcmlnaW5hbFNldHRpbmdzLGQuYnJlYWtwb2ludFNldHRpbmdzW2ZdKSxiPT09ITAmJihkLmN1cnJlbnRTbGlkZT1kLm9wdGlvbnMuaW5pdGlhbFNsaWRlKSxkLnJlZnJlc2goYikpLGg9Zik6KGQuYWN0aXZlQnJlYWtwb2ludD1mLFwidW5zbGlja1wiPT09ZC5icmVha3BvaW50U2V0dGluZ3NbZl0/ZC51bnNsaWNrKGYpOihkLm9wdGlvbnM9YS5leHRlbmQoe30sZC5vcmlnaW5hbFNldHRpbmdzLGQuYnJlYWtwb2ludFNldHRpbmdzW2ZdKSxiPT09ITAmJihkLmN1cnJlbnRTbGlkZT1kLm9wdGlvbnMuaW5pdGlhbFNsaWRlKSxkLnJlZnJlc2goYikpLGg9Zik6bnVsbCE9PWQuYWN0aXZlQnJlYWtwb2ludCYmKGQuYWN0aXZlQnJlYWtwb2ludD1udWxsLGQub3B0aW9ucz1kLm9yaWdpbmFsU2V0dGluZ3MsYj09PSEwJiYoZC5jdXJyZW50U2xpZGU9ZC5vcHRpb25zLmluaXRpYWxTbGlkZSksZC5yZWZyZXNoKGIpLGg9ZiksYnx8aD09PSExfHxkLiRzbGlkZXIudHJpZ2dlcihcImJyZWFrcG9pbnRcIixbZCxoXSl9fSxiLnByb3RvdHlwZS5jaGFuZ2VTbGlkZT1mdW5jdGlvbihiLGMpe3ZhciBmLGcsaCxkPXRoaXMsZT1hKGIuY3VycmVudFRhcmdldCk7c3dpdGNoKGUuaXMoXCJhXCIpJiZiLnByZXZlbnREZWZhdWx0KCksZS5pcyhcImxpXCIpfHwoZT1lLmNsb3Nlc3QoXCJsaVwiKSksaD1kLnNsaWRlQ291bnQlZC5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIT09MCxmPWg/MDooZC5zbGlkZUNvdW50LWQuY3VycmVudFNsaWRlKSVkLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsYi5kYXRhLm1lc3NhZ2Upe2Nhc2VcInByZXZpb3VzXCI6Zz0wPT09Zj9kLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6ZC5vcHRpb25zLnNsaWRlc1RvU2hvdy1mLGQuc2xpZGVDb3VudD5kLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZkLnNsaWRlSGFuZGxlcihkLmN1cnJlbnRTbGlkZS1nLCExLGMpO2JyZWFrO2Nhc2VcIm5leHRcIjpnPTA9PT1mP2Qub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDpmLGQuc2xpZGVDb3VudD5kLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZkLnNsaWRlSGFuZGxlcihkLmN1cnJlbnRTbGlkZStnLCExLGMpO2JyZWFrO2Nhc2VcImluZGV4XCI6dmFyIGk9MD09PWIuZGF0YS5pbmRleD8wOmIuZGF0YS5pbmRleHx8ZS5pbmRleCgpKmQub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtkLnNsaWRlSGFuZGxlcihkLmNoZWNrTmF2aWdhYmxlKGkpLCExLGMpLGUuY2hpbGRyZW4oKS50cmlnZ2VyKFwiZm9jdXNcIik7YnJlYWs7ZGVmYXVsdDpyZXR1cm59fSxiLnByb3RvdHlwZS5jaGVja05hdmlnYWJsZT1mdW5jdGlvbihhKXt2YXIgYyxkLGI9dGhpcztpZihjPWIuZ2V0TmF2aWdhYmxlSW5kZXhlcygpLGQ9MCxhPmNbYy5sZW5ndGgtMV0pYT1jW2MubGVuZ3RoLTFdO2Vsc2UgZm9yKHZhciBlIGluIGMpe2lmKGE8Y1tlXSl7YT1kO2JyZWFrfWQ9Y1tlXX1yZXR1cm4gYX0sYi5wcm90b3R5cGUuY2xlYW5VcEV2ZW50cz1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi5vcHRpb25zLmRvdHMmJm51bGwhPT1iLiRkb3RzJiZhKFwibGlcIixiLiRkb3RzKS5vZmYoXCJjbGljay5zbGlja1wiLGIuY2hhbmdlU2xpZGUpLm9mZihcIm1vdXNlZW50ZXIuc2xpY2tcIixhLnByb3h5KGIuaW50ZXJydXB0LGIsITApKS5vZmYoXCJtb3VzZWxlYXZlLnNsaWNrXCIsYS5wcm94eShiLmludGVycnVwdCxiLCExKSksYi4kc2xpZGVyLm9mZihcImZvY3VzLnNsaWNrIGJsdXIuc2xpY2tcIiksYi5vcHRpb25zLmFycm93cz09PSEwJiZiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGIuJHByZXZBcnJvdyYmYi4kcHJldkFycm93Lm9mZihcImNsaWNrLnNsaWNrXCIsYi5jaGFuZ2VTbGlkZSksYi4kbmV4dEFycm93JiZiLiRuZXh0QXJyb3cub2ZmKFwiY2xpY2suc2xpY2tcIixiLmNoYW5nZVNsaWRlKSksYi4kbGlzdC5vZmYoXCJ0b3VjaHN0YXJ0LnNsaWNrIG1vdXNlZG93bi5zbGlja1wiLGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9mZihcInRvdWNobW92ZS5zbGljayBtb3VzZW1vdmUuc2xpY2tcIixiLnN3aXBlSGFuZGxlciksYi4kbGlzdC5vZmYoXCJ0b3VjaGVuZC5zbGljayBtb3VzZXVwLnNsaWNrXCIsYi5zd2lwZUhhbmRsZXIpLGIuJGxpc3Qub2ZmKFwidG91Y2hjYW5jZWwuc2xpY2sgbW91c2VsZWF2ZS5zbGlja1wiLGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9mZihcImNsaWNrLnNsaWNrXCIsYi5jbGlja0hhbmRsZXIpLGEoZG9jdW1lbnQpLm9mZihiLnZpc2liaWxpdHlDaGFuZ2UsYi52aXNpYmlsaXR5KSxiLmNsZWFuVXBTbGlkZUV2ZW50cygpLGIub3B0aW9ucy5hY2Nlc3NpYmlsaXR5PT09ITAmJmIuJGxpc3Qub2ZmKFwia2V5ZG93bi5zbGlja1wiLGIua2V5SGFuZGxlciksYi5vcHRpb25zLmZvY3VzT25TZWxlY3Q9PT0hMCYmYShiLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9mZihcImNsaWNrLnNsaWNrXCIsYi5zZWxlY3RIYW5kbGVyKSxhKHdpbmRvdykub2ZmKFwib3JpZW50YXRpb25jaGFuZ2Uuc2xpY2suc2xpY2stXCIrYi5pbnN0YW5jZVVpZCxiLm9yaWVudGF0aW9uQ2hhbmdlKSxhKHdpbmRvdykub2ZmKFwicmVzaXplLnNsaWNrLnNsaWNrLVwiK2IuaW5zdGFuY2VVaWQsYi5yZXNpemUpLGEoXCJbZHJhZ2dhYmxlIT10cnVlXVwiLGIuJHNsaWRlVHJhY2spLm9mZihcImRyYWdzdGFydFwiLGIucHJldmVudERlZmF1bHQpLGEod2luZG93KS5vZmYoXCJsb2FkLnNsaWNrLnNsaWNrLVwiK2IuaW5zdGFuY2VVaWQsYi5zZXRQb3NpdGlvbiksYShkb2N1bWVudCkub2ZmKFwicmVhZHkuc2xpY2suc2xpY2stXCIrYi5pbnN0YW5jZVVpZCxiLnNldFBvc2l0aW9uKX0sYi5wcm90b3R5cGUuY2xlYW5VcFNsaWRlRXZlbnRzPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcztiLiRsaXN0Lm9mZihcIm1vdXNlZW50ZXIuc2xpY2tcIixhLnByb3h5KGIuaW50ZXJydXB0LGIsITApKSxiLiRsaXN0Lm9mZihcIm1vdXNlbGVhdmUuc2xpY2tcIixhLnByb3h5KGIuaW50ZXJydXB0LGIsITEpKX0sYi5wcm90b3R5cGUuY2xlYW5VcFJvd3M9ZnVuY3Rpb24oKXt2YXIgYixhPXRoaXM7YS5vcHRpb25zLnJvd3M+MSYmKGI9YS4kc2xpZGVzLmNoaWxkcmVuKCkuY2hpbGRyZW4oKSxiLnJlbW92ZUF0dHIoXCJzdHlsZVwiKSxhLiRzbGlkZXIuZW1wdHkoKS5hcHBlbmQoYikpfSxiLnByb3RvdHlwZS5jbGlja0hhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztiLnNob3VsZENsaWNrPT09ITEmJihhLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpKX0sYi5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbihiKXt2YXIgYz10aGlzO2MuYXV0b1BsYXlDbGVhcigpLGMudG91Y2hPYmplY3Q9e30sYy5jbGVhblVwRXZlbnRzKCksYShcIi5zbGljay1jbG9uZWRcIixjLiRzbGlkZXIpLmRldGFjaCgpLGMuJGRvdHMmJmMuJGRvdHMucmVtb3ZlKCksYy4kcHJldkFycm93JiZjLiRwcmV2QXJyb3cubGVuZ3RoJiYoYy4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4XCIpLmNzcyhcImRpc3BsYXlcIixcIlwiKSxjLmh0bWxFeHByLnRlc3QoYy5vcHRpb25zLnByZXZBcnJvdykmJmMuJHByZXZBcnJvdy5yZW1vdmUoKSksYy4kbmV4dEFycm93JiZjLiRuZXh0QXJyb3cubGVuZ3RoJiYoYy4kbmV4dEFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4XCIpLmNzcyhcImRpc3BsYXlcIixcIlwiKSxjLmh0bWxFeHByLnRlc3QoYy5vcHRpb25zLm5leHRBcnJvdykmJmMuJG5leHRBcnJvdy5yZW1vdmUoKSksYy4kc2xpZGVzJiYoYy4kc2xpZGVzLnJlbW92ZUNsYXNzKFwic2xpY2stc2xpZGUgc2xpY2stYWN0aXZlIHNsaWNrLWNlbnRlciBzbGljay12aXNpYmxlIHNsaWNrLWN1cnJlbnRcIikucmVtb3ZlQXR0cihcImFyaWEtaGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIpLmVhY2goZnVuY3Rpb24oKXthKHRoaXMpLmF0dHIoXCJzdHlsZVwiLGEodGhpcykuZGF0YShcIm9yaWdpbmFsU3R5bGluZ1wiKSl9KSxjLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCksYy4kc2xpZGVUcmFjay5kZXRhY2goKSxjLiRsaXN0LmRldGFjaCgpLGMuJHNsaWRlci5hcHBlbmQoYy4kc2xpZGVzKSksYy5jbGVhblVwUm93cygpLGMuJHNsaWRlci5yZW1vdmVDbGFzcyhcInNsaWNrLXNsaWRlclwiKSxjLiRzbGlkZXIucmVtb3ZlQ2xhc3MoXCJzbGljay1pbml0aWFsaXplZFwiKSxjLiRzbGlkZXIucmVtb3ZlQ2xhc3MoXCJzbGljay1kb3R0ZWRcIiksYy51bnNsaWNrZWQ9ITAsYnx8Yy4kc2xpZGVyLnRyaWdnZXIoXCJkZXN0cm95XCIsW2NdKX0sYi5wcm90b3R5cGUuZGlzYWJsZVRyYW5zaXRpb249ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXt9O2NbYi50cmFuc2l0aW9uVHlwZV09XCJcIixiLm9wdGlvbnMuZmFkZT09PSExP2IuJHNsaWRlVHJhY2suY3NzKGMpOmIuJHNsaWRlcy5lcShhKS5jc3MoYyl9LGIucHJvdG90eXBlLmZhZGVTbGlkZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7Yy5jc3NUcmFuc2l0aW9ucz09PSExPyhjLiRzbGlkZXMuZXEoYSkuY3NzKHt6SW5kZXg6Yy5vcHRpb25zLnpJbmRleH0pLGMuJHNsaWRlcy5lcShhKS5hbmltYXRlKHtvcGFjaXR5OjF9LGMub3B0aW9ucy5zcGVlZCxjLm9wdGlvbnMuZWFzaW5nLGIpKTooYy5hcHBseVRyYW5zaXRpb24oYSksYy4kc2xpZGVzLmVxKGEpLmNzcyh7b3BhY2l0eToxLHpJbmRleDpjLm9wdGlvbnMuekluZGV4fSksYiYmc2V0VGltZW91dChmdW5jdGlvbigpe2MuZGlzYWJsZVRyYW5zaXRpb24oYSksYi5jYWxsKCl9LGMub3B0aW9ucy5zcGVlZCkpfSxiLnByb3RvdHlwZS5mYWRlU2xpZGVPdXQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztiLmNzc1RyYW5zaXRpb25zPT09ITE/Yi4kc2xpZGVzLmVxKGEpLmFuaW1hdGUoe29wYWNpdHk6MCx6SW5kZXg6Yi5vcHRpb25zLnpJbmRleC0yfSxiLm9wdGlvbnMuc3BlZWQsYi5vcHRpb25zLmVhc2luZyk6KGIuYXBwbHlUcmFuc2l0aW9uKGEpLGIuJHNsaWRlcy5lcShhKS5jc3Moe29wYWNpdHk6MCx6SW5kZXg6Yi5vcHRpb25zLnpJbmRleC0yfSkpfSxiLnByb3RvdHlwZS5maWx0ZXJTbGlkZXM9Yi5wcm90b3R5cGUuc2xpY2tGaWx0ZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztudWxsIT09YSYmKGIuJHNsaWRlc0NhY2hlPWIuJHNsaWRlcyxiLnVubG9hZCgpLGIuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKSxiLiRzbGlkZXNDYWNoZS5maWx0ZXIoYSkuYXBwZW5kVG8oYi4kc2xpZGVUcmFjayksYi5yZWluaXQoKSl9LGIucHJvdG90eXBlLmZvY3VzSGFuZGxlcj1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi4kc2xpZGVyLm9mZihcImZvY3VzLnNsaWNrIGJsdXIuc2xpY2tcIikub24oXCJmb2N1cy5zbGljayBibHVyLnNsaWNrXCIsXCIqOm5vdCguc2xpY2stYXJyb3cpXCIsZnVuY3Rpb24oYyl7Yy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTt2YXIgZD1hKHRoaXMpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtiLm9wdGlvbnMucGF1c2VPbkZvY3VzJiYoYi5mb2N1c3NlZD1kLmlzKFwiOmZvY3VzXCIpLGIuYXV0b1BsYXkoKSl9LDApfSl9LGIucHJvdG90eXBlLmdldEN1cnJlbnQ9Yi5wcm90b3R5cGUuc2xpY2tDdXJyZW50U2xpZGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiBhLmN1cnJlbnRTbGlkZX0sYi5wcm90b3R5cGUuZ2V0RG90Q291bnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9MCxjPTAsZD0wO2lmKGEub3B0aW9ucy5pbmZpbml0ZT09PSEwKWZvcig7YjxhLnNsaWRlQ291bnQ7KSsrZCxiPWMrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLGMrPWEub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDw9YS5vcHRpb25zLnNsaWRlc1RvU2hvdz9hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6YS5vcHRpb25zLnNsaWRlc1RvU2hvdztlbHNlIGlmKGEub3B0aW9ucy5jZW50ZXJNb2RlPT09ITApZD1hLnNsaWRlQ291bnQ7ZWxzZSBpZihhLm9wdGlvbnMuYXNOYXZGb3IpZm9yKDtiPGEuc2xpZGVDb3VudDspKytkLGI9YythLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsYys9YS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsPD1hLm9wdGlvbnMuc2xpZGVzVG9TaG93P2Eub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDphLm9wdGlvbnMuc2xpZGVzVG9TaG93O2Vsc2UgZD0xK01hdGguY2VpbCgoYS5zbGlkZUNvdW50LWEub3B0aW9ucy5zbGlkZXNUb1Nob3cpL2Eub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCk7cmV0dXJuIGQtMX0sYi5wcm90b3R5cGUuZ2V0TGVmdD1mdW5jdGlvbihhKXt2YXIgYyxkLGYsYj10aGlzLGU9MDtyZXR1cm4gYi5zbGlkZU9mZnNldD0wLGQ9Yi4kc2xpZGVzLmZpcnN0KCkub3V0ZXJIZWlnaHQoITApLGIub3B0aW9ucy5pbmZpbml0ZT09PSEwPyhiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGIuc2xpZGVPZmZzZXQ9Yi5zbGlkZVdpZHRoKmIub3B0aW9ucy5zbGlkZXNUb1Nob3cqLTEsZT1kKmIub3B0aW9ucy5zbGlkZXNUb1Nob3cqLTEpLGIuc2xpZGVDb3VudCViLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwhPT0wJiZhK2Iub3B0aW9ucy5zbGlkZXNUb1Njcm9sbD5iLnNsaWRlQ291bnQmJmIuc2xpZGVDb3VudD5iLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYT5iLnNsaWRlQ291bnQ/KGIuc2xpZGVPZmZzZXQ9KGIub3B0aW9ucy5zbGlkZXNUb1Nob3ctKGEtYi5zbGlkZUNvdW50KSkqYi5zbGlkZVdpZHRoKi0xLGU9KGIub3B0aW9ucy5zbGlkZXNUb1Nob3ctKGEtYi5zbGlkZUNvdW50KSkqZCotMSk6KGIuc2xpZGVPZmZzZXQ9Yi5zbGlkZUNvdW50JWIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCpiLnNsaWRlV2lkdGgqLTEsZT1iLnNsaWRlQ291bnQlYi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKmQqLTEpKSk6YStiLm9wdGlvbnMuc2xpZGVzVG9TaG93PmIuc2xpZGVDb3VudCYmKGIuc2xpZGVPZmZzZXQ9KGErYi5vcHRpb25zLnNsaWRlc1RvU2hvdy1iLnNsaWRlQ291bnQpKmIuc2xpZGVXaWR0aCxlPShhK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3ctYi5zbGlkZUNvdW50KSpkKSxiLnNsaWRlQ291bnQ8PWIub3B0aW9ucy5zbGlkZXNUb1Nob3cmJihiLnNsaWRlT2Zmc2V0PTAsZT0wKSxiLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwJiZiLm9wdGlvbnMuaW5maW5pdGU9PT0hMD9iLnNsaWRlT2Zmc2V0Kz1iLnNsaWRlV2lkdGgqTWF0aC5mbG9vcihiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIpLWIuc2xpZGVXaWR0aDpiLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwJiYoYi5zbGlkZU9mZnNldD0wLGIuc2xpZGVPZmZzZXQrPWIuc2xpZGVXaWR0aCpNYXRoLmZsb29yKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cvMikpLGM9Yi5vcHRpb25zLnZlcnRpY2FsPT09ITE/YSpiLnNsaWRlV2lkdGgqLTErYi5zbGlkZU9mZnNldDphKmQqLTErZSxiLm9wdGlvbnMudmFyaWFibGVXaWR0aD09PSEwJiYoZj1iLnNsaWRlQ291bnQ8PWIub3B0aW9ucy5zbGlkZXNUb1Nob3d8fGIub3B0aW9ucy5pbmZpbml0ZT09PSExP2IuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikuZXEoYSk6Yi4kc2xpZGVUcmFjay5jaGlsZHJlbihcIi5zbGljay1zbGlkZVwiKS5lcShhK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3cpLGM9Yi5vcHRpb25zLnJ0bD09PSEwP2ZbMF0/LTEqKGIuJHNsaWRlVHJhY2sud2lkdGgoKS1mWzBdLm9mZnNldExlZnQtZi53aWR0aCgpKTowOmZbMF0/LTEqZlswXS5vZmZzZXRMZWZ0OjAsYi5vcHRpb25zLmNlbnRlck1vZGU9PT0hMCYmKGY9Yi5zbGlkZUNvdW50PD1iLm9wdGlvbnMuc2xpZGVzVG9TaG93fHxiLm9wdGlvbnMuaW5maW5pdGU9PT0hMT9iLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmVxKGEpOmIuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikuZXEoYStiLm9wdGlvbnMuc2xpZGVzVG9TaG93KzEpLGM9Yi5vcHRpb25zLnJ0bD09PSEwP2ZbMF0/LTEqKGIuJHNsaWRlVHJhY2sud2lkdGgoKS1mWzBdLm9mZnNldExlZnQtZi53aWR0aCgpKTowOmZbMF0/LTEqZlswXS5vZmZzZXRMZWZ0OjAsYys9KGIuJGxpc3Qud2lkdGgoKS1mLm91dGVyV2lkdGgoKSkvMikpLGN9LGIucHJvdG90eXBlLmdldE9wdGlvbj1iLnByb3RvdHlwZS5zbGlja0dldE9wdGlvbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiBiLm9wdGlvbnNbYV19LGIucHJvdG90eXBlLmdldE5hdmlnYWJsZUluZGV4ZXM9ZnVuY3Rpb24oKXt2YXIgZSxhPXRoaXMsYj0wLGM9MCxkPVtdO2ZvcihhLm9wdGlvbnMuaW5maW5pdGU9PT0hMT9lPWEuc2xpZGVDb3VudDooYj0tMSphLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsYz0tMSphLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsZT0yKmEuc2xpZGVDb3VudCk7ZT5iOylkLnB1c2goYiksYj1jK2Eub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCxjKz1hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw8PWEub3B0aW9ucy5zbGlkZXNUb1Nob3c/YS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsOmEub3B0aW9ucy5zbGlkZXNUb1Nob3c7cmV0dXJuIGR9LGIucHJvdG90eXBlLmdldFNsaWNrPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGIucHJvdG90eXBlLmdldFNsaWRlQ291bnQ9ZnVuY3Rpb24oKXt2YXIgYyxkLGUsYj10aGlzO3JldHVybiBlPWIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITA/Yi5zbGlkZVdpZHRoKk1hdGguZmxvb3IoYi5vcHRpb25zLnNsaWRlc1RvU2hvdy8yKTowLGIub3B0aW9ucy5zd2lwZVRvU2xpZGU9PT0hMD8oYi4kc2xpZGVUcmFjay5maW5kKFwiLnNsaWNrLXNsaWRlXCIpLmVhY2goZnVuY3Rpb24oYyxmKXtyZXR1cm4gZi5vZmZzZXRMZWZ0LWUrYShmKS5vdXRlcldpZHRoKCkvMj4tMSpiLnN3aXBlTGVmdD8oZD1mLCExKTp2b2lkIDB9KSxjPU1hdGguYWJzKGEoZCkuYXR0cihcImRhdGEtc2xpY2staW5kZXhcIiktYi5jdXJyZW50U2xpZGUpfHwxKTpiLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGx9LGIucHJvdG90eXBlLmdvVG89Yi5wcm90b3R5cGUuc2xpY2tHb1RvPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztjLmNoYW5nZVNsaWRlKHtkYXRhOnttZXNzYWdlOlwiaW5kZXhcIixpbmRleDpwYXJzZUludChhKX19LGIpfSxiLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXM7YShjLiRzbGlkZXIpLmhhc0NsYXNzKFwic2xpY2staW5pdGlhbGl6ZWRcIil8fChhKGMuJHNsaWRlcikuYWRkQ2xhc3MoXCJzbGljay1pbml0aWFsaXplZFwiKSxjLmJ1aWxkUm93cygpLGMuYnVpbGRPdXQoKSxjLnNldFByb3BzKCksYy5zdGFydExvYWQoKSxjLmxvYWRTbGlkZXIoKSxjLmluaXRpYWxpemVFdmVudHMoKSxjLnVwZGF0ZUFycm93cygpLGMudXBkYXRlRG90cygpLGMuY2hlY2tSZXNwb25zaXZlKCEwKSxjLmZvY3VzSGFuZGxlcigpKSxiJiZjLiRzbGlkZXIudHJpZ2dlcihcImluaXRcIixbY10pLGMub3B0aW9ucy5hY2Nlc3NpYmlsaXR5PT09ITAmJmMuaW5pdEFEQSgpLGMub3B0aW9ucy5hdXRvcGxheSYmKGMucGF1c2VkPSExLGMuYXV0b1BsYXkoKSl9LGIucHJvdG90eXBlLmluaXRBREE9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2IuJHNsaWRlcy5hZGQoYi4kc2xpZGVUcmFjay5maW5kKFwiLnNsaWNrLWNsb25lZFwiKSkuYXR0cih7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwiLHRhYmluZGV4OlwiLTFcIn0pLmZpbmQoXCJhLCBpbnB1dCwgYnV0dG9uLCBzZWxlY3RcIikuYXR0cih7dGFiaW5kZXg6XCItMVwifSksYi4kc2xpZGVUcmFjay5hdHRyKFwicm9sZVwiLFwibGlzdGJveFwiKSxiLiRzbGlkZXMubm90KGIuJHNsaWRlVHJhY2suZmluZChcIi5zbGljay1jbG9uZWRcIikpLmVhY2goZnVuY3Rpb24oYyl7YSh0aGlzKS5hdHRyKHtyb2xlOlwib3B0aW9uXCIsXCJhcmlhLWRlc2NyaWJlZGJ5XCI6XCJzbGljay1zbGlkZVwiK2IuaW5zdGFuY2VVaWQrY30pfSksbnVsbCE9PWIuJGRvdHMmJmIuJGRvdHMuYXR0cihcInJvbGVcIixcInRhYmxpc3RcIikuZmluZChcImxpXCIpLmVhY2goZnVuY3Rpb24oYyl7YSh0aGlzKS5hdHRyKHtyb2xlOlwicHJlc2VudGF0aW9uXCIsXCJhcmlhLXNlbGVjdGVkXCI6XCJmYWxzZVwiLFwiYXJpYS1jb250cm9sc1wiOlwibmF2aWdhdGlvblwiK2IuaW5zdGFuY2VVaWQrYyxpZDpcInNsaWNrLXNsaWRlXCIrYi5pbnN0YW5jZVVpZCtjfSl9KS5maXJzdCgpLmF0dHIoXCJhcmlhLXNlbGVjdGVkXCIsXCJ0cnVlXCIpLmVuZCgpLmZpbmQoXCJidXR0b25cIikuYXR0cihcInJvbGVcIixcImJ1dHRvblwiKS5lbmQoKS5jbG9zZXN0KFwiZGl2XCIpLmF0dHIoXCJyb2xlXCIsXCJ0b29sYmFyXCIpLGIuYWN0aXZhdGVBREEoKX0sYi5wcm90b3R5cGUuaW5pdEFycm93RXZlbnRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLm9wdGlvbnMuYXJyb3dzPT09ITAmJmEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYS4kcHJldkFycm93Lm9mZihcImNsaWNrLnNsaWNrXCIpLm9uKFwiY2xpY2suc2xpY2tcIix7bWVzc2FnZTpcInByZXZpb3VzXCJ9LGEuY2hhbmdlU2xpZGUpLGEuJG5leHRBcnJvdy5vZmYoXCJjbGljay5zbGlja1wiKS5vbihcImNsaWNrLnNsaWNrXCIse21lc3NhZ2U6XCJuZXh0XCJ9LGEuY2hhbmdlU2xpZGUpKX0sYi5wcm90b3R5cGUuaW5pdERvdEV2ZW50cz1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi5vcHRpb25zLmRvdHM9PT0hMCYmYi5zbGlkZUNvdW50PmIub3B0aW9ucy5zbGlkZXNUb1Nob3cmJmEoXCJsaVwiLGIuJGRvdHMpLm9uKFwiY2xpY2suc2xpY2tcIix7bWVzc2FnZTpcImluZGV4XCJ9LGIuY2hhbmdlU2xpZGUpLGIub3B0aW9ucy5kb3RzPT09ITAmJmIub3B0aW9ucy5wYXVzZU9uRG90c0hvdmVyPT09ITAmJmEoXCJsaVwiLGIuJGRvdHMpLm9uKFwibW91c2VlbnRlci5zbGlja1wiLGEucHJveHkoYi5pbnRlcnJ1cHQsYiwhMCkpLm9uKFwibW91c2VsZWF2ZS5zbGlja1wiLGEucHJveHkoYi5pbnRlcnJ1cHQsYiwhMSkpfSxiLnByb3RvdHlwZS5pbml0U2xpZGVFdmVudHM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2Iub3B0aW9ucy5wYXVzZU9uSG92ZXImJihiLiRsaXN0Lm9uKFwibW91c2VlbnRlci5zbGlja1wiLGEucHJveHkoYi5pbnRlcnJ1cHQsYiwhMCkpLGIuJGxpc3Qub24oXCJtb3VzZWxlYXZlLnNsaWNrXCIsYS5wcm94eShiLmludGVycnVwdCxiLCExKSkpfSxiLnByb3RvdHlwZS5pbml0aWFsaXplRXZlbnRzPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcztiLmluaXRBcnJvd0V2ZW50cygpLGIuaW5pdERvdEV2ZW50cygpLGIuaW5pdFNsaWRlRXZlbnRzKCksYi4kbGlzdC5vbihcInRvdWNoc3RhcnQuc2xpY2sgbW91c2Vkb3duLnNsaWNrXCIse2FjdGlvbjpcInN0YXJ0XCJ9LGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9uKFwidG91Y2htb3ZlLnNsaWNrIG1vdXNlbW92ZS5zbGlja1wiLHthY3Rpb246XCJtb3ZlXCJ9LGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9uKFwidG91Y2hlbmQuc2xpY2sgbW91c2V1cC5zbGlja1wiLHthY3Rpb246XCJlbmRcIn0sYi5zd2lwZUhhbmRsZXIpLGIuJGxpc3Qub24oXCJ0b3VjaGNhbmNlbC5zbGljayBtb3VzZWxlYXZlLnNsaWNrXCIse2FjdGlvbjpcImVuZFwifSxiLnN3aXBlSGFuZGxlciksYi4kbGlzdC5vbihcImNsaWNrLnNsaWNrXCIsYi5jbGlja0hhbmRsZXIpLGEoZG9jdW1lbnQpLm9uKGIudmlzaWJpbGl0eUNoYW5nZSxhLnByb3h5KGIudmlzaWJpbGl0eSxiKSksYi5vcHRpb25zLmFjY2Vzc2liaWxpdHk9PT0hMCYmYi4kbGlzdC5vbihcImtleWRvd24uc2xpY2tcIixiLmtleUhhbmRsZXIpLGIub3B0aW9ucy5mb2N1c09uU2VsZWN0PT09ITAmJmEoYi4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vbihcImNsaWNrLnNsaWNrXCIsYi5zZWxlY3RIYW5kbGVyKSxhKHdpbmRvdykub24oXCJvcmllbnRhdGlvbmNoYW5nZS5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGEucHJveHkoYi5vcmllbnRhdGlvbkNoYW5nZSxiKSksYSh3aW5kb3cpLm9uKFwicmVzaXplLnNsaWNrLnNsaWNrLVwiK2IuaW5zdGFuY2VVaWQsYS5wcm94eShiLnJlc2l6ZSxiKSksYShcIltkcmFnZ2FibGUhPXRydWVdXCIsYi4kc2xpZGVUcmFjaykub24oXCJkcmFnc3RhcnRcIixiLnByZXZlbnREZWZhdWx0KSxhKHdpbmRvdykub24oXCJsb2FkLnNsaWNrLnNsaWNrLVwiK2IuaW5zdGFuY2VVaWQsYi5zZXRQb3NpdGlvbiksYShkb2N1bWVudCkub24oXCJyZWFkeS5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGIuc2V0UG9zaXRpb24pfSxiLnByb3RvdHlwZS5pbml0VUk9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2Eub3B0aW9ucy5hcnJvd3M9PT0hMCYmYS5zbGlkZUNvdW50PmEub3B0aW9ucy5zbGlkZXNUb1Nob3cmJihhLiRwcmV2QXJyb3cuc2hvdygpLGEuJG5leHRBcnJvdy5zaG93KCkpLGEub3B0aW9ucy5kb3RzPT09ITAmJmEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZhLiRkb3RzLnNob3coKX0sYi5wcm90b3R5cGUua2V5SGFuZGxlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2EudGFyZ2V0LnRhZ05hbWUubWF0Y2goXCJURVhUQVJFQXxJTlBVVHxTRUxFQ1RcIil8fCgzNz09PWEua2V5Q29kZSYmYi5vcHRpb25zLmFjY2Vzc2liaWxpdHk9PT0hMD9iLmNoYW5nZVNsaWRlKHtkYXRhOnttZXNzYWdlOmIub3B0aW9ucy5ydGw9PT0hMD9cIm5leHRcIjpcInByZXZpb3VzXCJ9fSk6Mzk9PT1hLmtleUNvZGUmJmIub3B0aW9ucy5hY2Nlc3NpYmlsaXR5PT09ITAmJmIuY2hhbmdlU2xpZGUoe2RhdGE6e21lc3NhZ2U6Yi5vcHRpb25zLnJ0bD09PSEwP1wicHJldmlvdXNcIjpcIm5leHRcIn19KSl9LGIucHJvdG90eXBlLmxhenlMb2FkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyhjKXthKFwiaW1nW2RhdGEtbGF6eV1cIixjKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9YSh0aGlzKSxkPWEodGhpcykuYXR0cihcImRhdGEtbGF6eVwiKSxlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7ZS5vbmxvYWQ9ZnVuY3Rpb24oKXtjLmFuaW1hdGUoe29wYWNpdHk6MH0sMTAwLGZ1bmN0aW9uKCl7Yy5hdHRyKFwic3JjXCIsZCkuYW5pbWF0ZSh7b3BhY2l0eToxfSwyMDAsZnVuY3Rpb24oKXtjLnJlbW92ZUF0dHIoXCJkYXRhLWxhenlcIikucmVtb3ZlQ2xhc3MoXCJzbGljay1sb2FkaW5nXCIpfSksYi4kc2xpZGVyLnRyaWdnZXIoXCJsYXp5TG9hZGVkXCIsW2IsYyxkXSl9KX0sZS5vbmVycm9yPWZ1bmN0aW9uKCl7Yy5yZW1vdmVBdHRyKFwiZGF0YS1sYXp5XCIpLnJlbW92ZUNsYXNzKFwic2xpY2stbG9hZGluZ1wiKS5hZGRDbGFzcyhcInNsaWNrLWxhenlsb2FkLWVycm9yXCIpLGIuJHNsaWRlci50cmlnZ2VyKFwibGF6eUxvYWRFcnJvclwiLFtiLGMsZF0pfSxlLnNyYz1kfSl9dmFyIGMsZCxlLGYsYj10aGlzO2Iub3B0aW9ucy5jZW50ZXJNb2RlPT09ITA/Yi5vcHRpb25zLmluZmluaXRlPT09ITA/KGU9Yi5jdXJyZW50U2xpZGUrKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cvMisxKSxmPWUrYi5vcHRpb25zLnNsaWRlc1RvU2hvdysyKTooZT1NYXRoLm1heCgwLGIuY3VycmVudFNsaWRlLShiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIrMSkpLGY9MisoYi5vcHRpb25zLnNsaWRlc1RvU2hvdy8yKzEpK2IuY3VycmVudFNsaWRlKTooZT1iLm9wdGlvbnMuaW5maW5pdGU/Yi5vcHRpb25zLnNsaWRlc1RvU2hvdytiLmN1cnJlbnRTbGlkZTpiLmN1cnJlbnRTbGlkZSxmPU1hdGguY2VpbChlK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3cpLGIub3B0aW9ucy5mYWRlPT09ITAmJihlPjAmJmUtLSxmPD1iLnNsaWRlQ291bnQmJmYrKykpLGM9Yi4kc2xpZGVyLmZpbmQoXCIuc2xpY2stc2xpZGVcIikuc2xpY2UoZSxmKSxnKGMpLGIuc2xpZGVDb3VudDw9Yi5vcHRpb25zLnNsaWRlc1RvU2hvdz8oZD1iLiRzbGlkZXIuZmluZChcIi5zbGljay1zbGlkZVwiKSxnKGQpKTpiLmN1cnJlbnRTbGlkZT49Yi5zbGlkZUNvdW50LWIub3B0aW9ucy5zbGlkZXNUb1Nob3c/KGQ9Yi4kc2xpZGVyLmZpbmQoXCIuc2xpY2stY2xvbmVkXCIpLnNsaWNlKDAsYi5vcHRpb25zLnNsaWRlc1RvU2hvdyksZyhkKSk6MD09PWIuY3VycmVudFNsaWRlJiYoZD1iLiRzbGlkZXIuZmluZChcIi5zbGljay1jbG9uZWRcIikuc2xpY2UoLTEqYi5vcHRpb25zLnNsaWRlc1RvU2hvdyksZyhkKSl9LGIucHJvdG90eXBlLmxvYWRTbGlkZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2Euc2V0UG9zaXRpb24oKSxhLiRzbGlkZVRyYWNrLmNzcyh7b3BhY2l0eToxfSksYS4kc2xpZGVyLnJlbW92ZUNsYXNzKFwic2xpY2stbG9hZGluZ1wiKSxhLmluaXRVSSgpLFwicHJvZ3Jlc3NpdmVcIj09PWEub3B0aW9ucy5sYXp5TG9hZCYmYS5wcm9ncmVzc2l2ZUxhenlMb2FkKCl9LGIucHJvdG90eXBlLm5leHQ9Yi5wcm90b3R5cGUuc2xpY2tOZXh0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLmNoYW5nZVNsaWRlKHtkYXRhOnttZXNzYWdlOlwibmV4dFwifX0pfSxiLnByb3RvdHlwZS5vcmllbnRhdGlvbkNoYW5nZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5jaGVja1Jlc3BvbnNpdmUoKSxhLnNldFBvc2l0aW9uKCl9LGIucHJvdG90eXBlLnBhdXNlPWIucHJvdG90eXBlLnNsaWNrUGF1c2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2EuYXV0b1BsYXlDbGVhcigpLGEucGF1c2VkPSEwfSxiLnByb3RvdHlwZS5wbGF5PWIucHJvdG90eXBlLnNsaWNrUGxheT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5hdXRvUGxheSgpLGEub3B0aW9ucy5hdXRvcGxheT0hMCxhLnBhdXNlZD0hMSxhLmZvY3Vzc2VkPSExLGEuaW50ZXJydXB0ZWQ9ITF9LGIucHJvdG90eXBlLnBvc3RTbGlkZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2IudW5zbGlja2VkfHwoYi4kc2xpZGVyLnRyaWdnZXIoXCJhZnRlckNoYW5nZVwiLFtiLGFdKSxiLmFuaW1hdGluZz0hMSxiLnNldFBvc2l0aW9uKCksYi5zd2lwZUxlZnQ9bnVsbCxiLm9wdGlvbnMuYXV0b3BsYXkmJmIuYXV0b1BsYXkoKSxiLm9wdGlvbnMuYWNjZXNzaWJpbGl0eT09PSEwJiZiLmluaXRBREEoKSl9LGIucHJvdG90eXBlLnByZXY9Yi5wcm90b3R5cGUuc2xpY2tQcmV2PWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLmNoYW5nZVNsaWRlKHtkYXRhOnttZXNzYWdlOlwicHJldmlvdXNcIn19KX0sYi5wcm90b3R5cGUucHJldmVudERlZmF1bHQ9ZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpfSxiLnByb3RvdHlwZS5wcm9ncmVzc2l2ZUxhenlMb2FkPWZ1bmN0aW9uKGIpe2I9Ynx8MTt2YXIgZSxmLGcsYz10aGlzLGQ9YShcImltZ1tkYXRhLWxhenldXCIsYy4kc2xpZGVyKTtkLmxlbmd0aD8oZT1kLmZpcnN0KCksZj1lLmF0dHIoXCJkYXRhLWxhenlcIiksZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpLGcub25sb2FkPWZ1bmN0aW9uKCl7ZS5hdHRyKFwic3JjXCIsZikucmVtb3ZlQXR0cihcImRhdGEtbGF6eVwiKS5yZW1vdmVDbGFzcyhcInNsaWNrLWxvYWRpbmdcIiksYy5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0PT09ITAmJmMuc2V0UG9zaXRpb24oKSxjLiRzbGlkZXIudHJpZ2dlcihcImxhenlMb2FkZWRcIixbYyxlLGZdKSxjLnByb2dyZXNzaXZlTGF6eUxvYWQoKX0sZy5vbmVycm9yPWZ1bmN0aW9uKCl7Mz5iP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtjLnByb2dyZXNzaXZlTGF6eUxvYWQoYisxKX0sNTAwKTooZS5yZW1vdmVBdHRyKFwiZGF0YS1sYXp5XCIpLnJlbW92ZUNsYXNzKFwic2xpY2stbG9hZGluZ1wiKS5hZGRDbGFzcyhcInNsaWNrLWxhenlsb2FkLWVycm9yXCIpLGMuJHNsaWRlci50cmlnZ2VyKFwibGF6eUxvYWRFcnJvclwiLFtjLGUsZl0pLGMucHJvZ3Jlc3NpdmVMYXp5TG9hZCgpKX0sZy5zcmM9Zik6Yy4kc2xpZGVyLnRyaWdnZXIoXCJhbGxJbWFnZXNMb2FkZWRcIixbY10pfSxiLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKGIpe3ZhciBkLGUsYz10aGlzO2U9Yy5zbGlkZUNvdW50LWMub3B0aW9ucy5zbGlkZXNUb1Nob3csIWMub3B0aW9ucy5pbmZpbml0ZSYmYy5jdXJyZW50U2xpZGU+ZSYmKGMuY3VycmVudFNsaWRlPWUpLGMuc2xpZGVDb3VudDw9Yy5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGMuY3VycmVudFNsaWRlPTApLGQ9Yy5jdXJyZW50U2xpZGUsYy5kZXN0cm95KCEwKSxhLmV4dGVuZChjLGMuaW5pdGlhbHMse2N1cnJlbnRTbGlkZTpkfSksYy5pbml0KCksYnx8Yy5jaGFuZ2VTbGlkZSh7ZGF0YTp7bWVzc2FnZTpcImluZGV4XCIsaW5kZXg6ZH19LCExKX0sYi5wcm90b3R5cGUucmVnaXN0ZXJCcmVha3BvaW50cz1mdW5jdGlvbigpe3ZhciBjLGQsZSxiPXRoaXMsZj1iLm9wdGlvbnMucmVzcG9uc2l2ZXx8bnVsbDtpZihcImFycmF5XCI9PT1hLnR5cGUoZikmJmYubGVuZ3RoKXtiLnJlc3BvbmRUbz1iLm9wdGlvbnMucmVzcG9uZFRvfHxcIndpbmRvd1wiO2ZvcihjIGluIGYpaWYoZT1iLmJyZWFrcG9pbnRzLmxlbmd0aC0xLGQ9ZltjXS5icmVha3BvaW50LGYuaGFzT3duUHJvcGVydHkoYykpe2Zvcig7ZT49MDspYi5icmVha3BvaW50c1tlXSYmYi5icmVha3BvaW50c1tlXT09PWQmJmIuYnJlYWtwb2ludHMuc3BsaWNlKGUsMSksZS0tO2IuYnJlYWtwb2ludHMucHVzaChkKSxiLmJyZWFrcG9pbnRTZXR0aW5nc1tkXT1mW2NdLnNldHRpbmdzfWIuYnJlYWtwb2ludHMuc29ydChmdW5jdGlvbihhLGMpe3JldHVybiBiLm9wdGlvbnMubW9iaWxlRmlyc3Q/YS1jOmMtYX0pfX0sYi5wcm90b3R5cGUucmVpbml0PWZ1bmN0aW9uKCl7dmFyIGI9dGhpcztiLiRzbGlkZXM9Yi4kc2xpZGVUcmFjay5jaGlsZHJlbihiLm9wdGlvbnMuc2xpZGUpLmFkZENsYXNzKFwic2xpY2stc2xpZGVcIiksYi5zbGlkZUNvdW50PWIuJHNsaWRlcy5sZW5ndGgsYi5jdXJyZW50U2xpZGU+PWIuc2xpZGVDb3VudCYmMCE9PWIuY3VycmVudFNsaWRlJiYoYi5jdXJyZW50U2xpZGU9Yi5jdXJyZW50U2xpZGUtYi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSxiLnNsaWRlQ291bnQ8PWIub3B0aW9ucy5zbGlkZXNUb1Nob3cmJihiLmN1cnJlbnRTbGlkZT0wKSxiLnJlZ2lzdGVyQnJlYWtwb2ludHMoKSxiLnNldFByb3BzKCksYi5zZXR1cEluZmluaXRlKCksYi5idWlsZEFycm93cygpLGIudXBkYXRlQXJyb3dzKCksYi5pbml0QXJyb3dFdmVudHMoKSxiLmJ1aWxkRG90cygpLGIudXBkYXRlRG90cygpLGIuaW5pdERvdEV2ZW50cygpLGIuY2xlYW5VcFNsaWRlRXZlbnRzKCksYi5pbml0U2xpZGVFdmVudHMoKSxiLmNoZWNrUmVzcG9uc2l2ZSghMSwhMCksYi5vcHRpb25zLmZvY3VzT25TZWxlY3Q9PT0hMCYmYShiLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9uKFwiY2xpY2suc2xpY2tcIixiLnNlbGVjdEhhbmRsZXIpLGIuc2V0U2xpZGVDbGFzc2VzKFwibnVtYmVyXCI9PXR5cGVvZiBiLmN1cnJlbnRTbGlkZT9iLmN1cnJlbnRTbGlkZTowKSxiLnNldFBvc2l0aW9uKCksYi5mb2N1c0hhbmRsZXIoKSxiLnBhdXNlZD0hYi5vcHRpb25zLmF1dG9wbGF5LGIuYXV0b1BsYXkoKSxiLiRzbGlkZXIudHJpZ2dlcihcInJlSW5pdFwiLFtiXSl9LGIucHJvdG90eXBlLnJlc2l6ZT1mdW5jdGlvbigpe3ZhciBiPXRoaXM7YSh3aW5kb3cpLndpZHRoKCkhPT1iLndpbmRvd1dpZHRoJiYoY2xlYXJUaW1lb3V0KGIud2luZG93RGVsYXkpLGIud2luZG93RGVsYXk9d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLndpbmRvd1dpZHRoPWEod2luZG93KS53aWR0aCgpLGIuY2hlY2tSZXNwb25zaXZlKCksYi51bnNsaWNrZWR8fGIuc2V0UG9zaXRpb24oKX0sNTApKX0sYi5wcm90b3R5cGUucmVtb3ZlU2xpZGU9Yi5wcm90b3R5cGUuc2xpY2tSZW1vdmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXM7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBhPyhiPWEsYT1iPT09ITA/MDpkLnNsaWRlQ291bnQtMSk6YT1iPT09ITA/LS1hOmEsZC5zbGlkZUNvdW50PDF8fDA+YXx8YT5kLnNsaWRlQ291bnQtMT8hMTooZC51bmxvYWQoKSxjPT09ITA/ZC4kc2xpZGVUcmFjay5jaGlsZHJlbigpLnJlbW92ZSgpOmQuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5lcShhKS5yZW1vdmUoKSxkLiRzbGlkZXM9ZC4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLGQuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKSxkLiRzbGlkZVRyYWNrLmFwcGVuZChkLiRzbGlkZXMpLGQuJHNsaWRlc0NhY2hlPWQuJHNsaWRlcyx2b2lkIGQucmVpbml0KCkpfSxiLnByb3RvdHlwZS5zZXRDU1M9ZnVuY3Rpb24oYSl7dmFyIGQsZSxiPXRoaXMsYz17fTtiLm9wdGlvbnMucnRsPT09ITAmJihhPS1hKSxkPVwibGVmdFwiPT1iLnBvc2l0aW9uUHJvcD9NYXRoLmNlaWwoYSkrXCJweFwiOlwiMHB4XCIsZT1cInRvcFwiPT1iLnBvc2l0aW9uUHJvcD9NYXRoLmNlaWwoYSkrXCJweFwiOlwiMHB4XCIsY1tiLnBvc2l0aW9uUHJvcF09YSxiLnRyYW5zZm9ybXNFbmFibGVkPT09ITE/Yi4kc2xpZGVUcmFjay5jc3MoYyk6KGM9e30sYi5jc3NUcmFuc2l0aW9ucz09PSExPyhjW2IuYW5pbVR5cGVdPVwidHJhbnNsYXRlKFwiK2QrXCIsIFwiK2UrXCIpXCIsYi4kc2xpZGVUcmFjay5jc3MoYykpOihjW2IuYW5pbVR5cGVdPVwidHJhbnNsYXRlM2QoXCIrZCtcIiwgXCIrZStcIiwgMHB4KVwiLGIuJHNsaWRlVHJhY2suY3NzKGMpKSl9LGIucHJvdG90eXBlLnNldERpbWVuc2lvbnM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2Eub3B0aW9ucy52ZXJ0aWNhbD09PSExP2Eub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJmEuJGxpc3QuY3NzKHtwYWRkaW5nOlwiMHB4IFwiK2Eub3B0aW9ucy5jZW50ZXJQYWRkaW5nfSk6KGEuJGxpc3QuaGVpZ2h0KGEuJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KCEwKSphLm9wdGlvbnMuc2xpZGVzVG9TaG93KSxhLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwJiZhLiRsaXN0LmNzcyh7cGFkZGluZzphLm9wdGlvbnMuY2VudGVyUGFkZGluZytcIiAwcHhcIn0pKSxhLmxpc3RXaWR0aD1hLiRsaXN0LndpZHRoKCksYS5saXN0SGVpZ2h0PWEuJGxpc3QuaGVpZ2h0KCksYS5vcHRpb25zLnZlcnRpY2FsPT09ITEmJmEub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITE/KGEuc2xpZGVXaWR0aD1NYXRoLmNlaWwoYS5saXN0V2lkdGgvYS5vcHRpb25zLnNsaWRlc1RvU2hvdyksYS4kc2xpZGVUcmFjay53aWR0aChNYXRoLmNlaWwoYS5zbGlkZVdpZHRoKmEuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikubGVuZ3RoKSkpOmEub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITA/YS4kc2xpZGVUcmFjay53aWR0aCg1ZTMqYS5zbGlkZUNvdW50KTooYS5zbGlkZVdpZHRoPU1hdGguY2VpbChhLmxpc3RXaWR0aCksYS4kc2xpZGVUcmFjay5oZWlnaHQoTWF0aC5jZWlsKGEuJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KCEwKSphLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmxlbmd0aCkpKTt2YXIgYj1hLiRzbGlkZXMuZmlyc3QoKS5vdXRlcldpZHRoKCEwKS1hLiRzbGlkZXMuZmlyc3QoKS53aWR0aCgpO2Eub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITEmJmEuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikud2lkdGgoYS5zbGlkZVdpZHRoLWIpfSxiLnByb3RvdHlwZS5zZXRGYWRlPWZ1bmN0aW9uKCl7dmFyIGMsYj10aGlzO2IuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKGQsZSl7Yz1iLnNsaWRlV2lkdGgqZCotMSxiLm9wdGlvbnMucnRsPT09ITA/YShlKS5jc3Moe3Bvc2l0aW9uOlwicmVsYXRpdmVcIixyaWdodDpjLHRvcDowLHpJbmRleDpiLm9wdGlvbnMuekluZGV4LTIsb3BhY2l0eTowfSk6YShlKS5jc3Moe3Bvc2l0aW9uOlwicmVsYXRpdmVcIixsZWZ0OmMsdG9wOjAsekluZGV4OmIub3B0aW9ucy56SW5kZXgtMixvcGFjaXR5OjB9KX0pLGIuJHNsaWRlcy5lcShiLmN1cnJlbnRTbGlkZSkuY3NzKHt6SW5kZXg6Yi5vcHRpb25zLnpJbmRleC0xLG9wYWNpdHk6MX0pfSxiLnByb3RvdHlwZS5zZXRIZWlnaHQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2lmKDE9PT1hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZhLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQ9PT0hMCYmYS5vcHRpb25zLnZlcnRpY2FsPT09ITEpe3ZhciBiPWEuJHNsaWRlcy5lcShhLmN1cnJlbnRTbGlkZSkub3V0ZXJIZWlnaHQoITApO2EuJGxpc3QuY3NzKFwiaGVpZ2h0XCIsYil9fSxiLnByb3RvdHlwZS5zZXRPcHRpb249Yi5wcm90b3R5cGUuc2xpY2tTZXRPcHRpb249ZnVuY3Rpb24oKXt2YXIgYyxkLGUsZixoLGI9dGhpcyxnPSExO2lmKFwib2JqZWN0XCI9PT1hLnR5cGUoYXJndW1lbnRzWzBdKT8oZT1hcmd1bWVudHNbMF0sZz1hcmd1bWVudHNbMV0saD1cIm11bHRpcGxlXCIpOlwic3RyaW5nXCI9PT1hLnR5cGUoYXJndW1lbnRzWzBdKSYmKGU9YXJndW1lbnRzWzBdLGY9YXJndW1lbnRzWzFdLGc9YXJndW1lbnRzWzJdLFwicmVzcG9uc2l2ZVwiPT09YXJndW1lbnRzWzBdJiZcImFycmF5XCI9PT1hLnR5cGUoYXJndW1lbnRzWzFdKT9oPVwicmVzcG9uc2l2ZVwiOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhcmd1bWVudHNbMV0mJihoPVwic2luZ2xlXCIpKSxcInNpbmdsZVwiPT09aCliLm9wdGlvbnNbZV09ZjtlbHNlIGlmKFwibXVsdGlwbGVcIj09PWgpYS5lYWNoKGUsZnVuY3Rpb24oYSxjKXtiLm9wdGlvbnNbYV09Y30pO2Vsc2UgaWYoXCJyZXNwb25zaXZlXCI9PT1oKWZvcihkIGluIGYpaWYoXCJhcnJheVwiIT09YS50eXBlKGIub3B0aW9ucy5yZXNwb25zaXZlKSliLm9wdGlvbnMucmVzcG9uc2l2ZT1bZltkXV07ZWxzZXtmb3IoYz1iLm9wdGlvbnMucmVzcG9uc2l2ZS5sZW5ndGgtMTtjPj0wOyliLm9wdGlvbnMucmVzcG9uc2l2ZVtjXS5icmVha3BvaW50PT09ZltkXS5icmVha3BvaW50JiZiLm9wdGlvbnMucmVzcG9uc2l2ZS5zcGxpY2UoYywxKSxjLS07Yi5vcHRpb25zLnJlc3BvbnNpdmUucHVzaChmW2RdKX1nJiYoYi51bmxvYWQoKSxiLnJlaW5pdCgpKX0sYi5wcm90b3R5cGUuc2V0UG9zaXRpb249ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2Euc2V0RGltZW5zaW9ucygpLGEuc2V0SGVpZ2h0KCksYS5vcHRpb25zLmZhZGU9PT0hMT9hLnNldENTUyhhLmdldExlZnQoYS5jdXJyZW50U2xpZGUpKTphLnNldEZhZGUoKSxhLiRzbGlkZXIudHJpZ2dlcihcInNldFBvc2l0aW9uXCIsW2FdKX0sYi5wcm90b3R5cGUuc2V0UHJvcHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9ZG9jdW1lbnQuYm9keS5zdHlsZTthLnBvc2l0aW9uUHJvcD1hLm9wdGlvbnMudmVydGljYWw9PT0hMD9cInRvcFwiOlwibGVmdFwiLFwidG9wXCI9PT1hLnBvc2l0aW9uUHJvcD9hLiRzbGlkZXIuYWRkQ2xhc3MoXCJzbGljay12ZXJ0aWNhbFwiKTphLiRzbGlkZXIucmVtb3ZlQ2xhc3MoXCJzbGljay12ZXJ0aWNhbFwiKSwodm9pZCAwIT09Yi5XZWJraXRUcmFuc2l0aW9ufHx2b2lkIDAhPT1iLk1velRyYW5zaXRpb258fHZvaWQgMCE9PWIubXNUcmFuc2l0aW9uKSYmYS5vcHRpb25zLnVzZUNTUz09PSEwJiYoYS5jc3NUcmFuc2l0aW9ucz0hMCksYS5vcHRpb25zLmZhZGUmJihcIm51bWJlclwiPT10eXBlb2YgYS5vcHRpb25zLnpJbmRleD9hLm9wdGlvbnMuekluZGV4PDMmJihhLm9wdGlvbnMuekluZGV4PTMpOmEub3B0aW9ucy56SW5kZXg9YS5kZWZhdWx0cy56SW5kZXgpLHZvaWQgMCE9PWIuT1RyYW5zZm9ybSYmKGEuYW5pbVR5cGU9XCJPVHJhbnNmb3JtXCIsYS50cmFuc2Zvcm1UeXBlPVwiLW8tdHJhbnNmb3JtXCIsYS50cmFuc2l0aW9uVHlwZT1cIk9UcmFuc2l0aW9uXCIsdm9pZCAwPT09Yi5wZXJzcGVjdGl2ZVByb3BlcnR5JiZ2b2lkIDA9PT1iLndlYmtpdFBlcnNwZWN0aXZlJiYoYS5hbmltVHlwZT0hMSkpLHZvaWQgMCE9PWIuTW96VHJhbnNmb3JtJiYoYS5hbmltVHlwZT1cIk1velRyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cIi1tb3otdHJhbnNmb3JtXCIsYS50cmFuc2l0aW9uVHlwZT1cIk1velRyYW5zaXRpb25cIix2b2lkIDA9PT1iLnBlcnNwZWN0aXZlUHJvcGVydHkmJnZvaWQgMD09PWIuTW96UGVyc3BlY3RpdmUmJihhLmFuaW1UeXBlPSExKSksdm9pZCAwIT09Yi53ZWJraXRUcmFuc2Zvcm0mJihhLmFuaW1UeXBlPVwid2Via2l0VHJhbnNmb3JtXCIsYS50cmFuc2Zvcm1UeXBlPVwiLXdlYmtpdC10cmFuc2Zvcm1cIixhLnRyYW5zaXRpb25UeXBlPVwid2Via2l0VHJhbnNpdGlvblwiLHZvaWQgMD09PWIucGVyc3BlY3RpdmVQcm9wZXJ0eSYmdm9pZCAwPT09Yi53ZWJraXRQZXJzcGVjdGl2ZSYmKGEuYW5pbVR5cGU9ITEpKSx2b2lkIDAhPT1iLm1zVHJhbnNmb3JtJiYoYS5hbmltVHlwZT1cIm1zVHJhbnNmb3JtXCIsYS50cmFuc2Zvcm1UeXBlPVwiLW1zLXRyYW5zZm9ybVwiLGEudHJhbnNpdGlvblR5cGU9XCJtc1RyYW5zaXRpb25cIix2b2lkIDA9PT1iLm1zVHJhbnNmb3JtJiYoYS5hbmltVHlwZT0hMSkpLHZvaWQgMCE9PWIudHJhbnNmb3JtJiZhLmFuaW1UeXBlIT09ITEmJihhLmFuaW1UeXBlPVwidHJhbnNmb3JtXCIsYS50cmFuc2Zvcm1UeXBlPVwidHJhbnNmb3JtXCIsYS50cmFuc2l0aW9uVHlwZT1cInRyYW5zaXRpb25cIiksYS50cmFuc2Zvcm1zRW5hYmxlZD1hLm9wdGlvbnMudXNlVHJhbnNmb3JtJiZudWxsIT09YS5hbmltVHlwZSYmYS5hbmltVHlwZSE9PSExfSxiLnByb3RvdHlwZS5zZXRTbGlkZUNsYXNzZXM9ZnVuY3Rpb24oYSl7dmFyIGMsZCxlLGYsYj10aGlzO2Q9Yi4kc2xpZGVyLmZpbmQoXCIuc2xpY2stc2xpZGVcIikucmVtb3ZlQ2xhc3MoXCJzbGljay1hY3RpdmUgc2xpY2stY2VudGVyIHNsaWNrLWN1cnJlbnRcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpLGIuJHNsaWRlcy5lcShhKS5hZGRDbGFzcyhcInNsaWNrLWN1cnJlbnRcIiksYi5vcHRpb25zLmNlbnRlck1vZGU9PT0hMD8oYz1NYXRoLmZsb29yKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cvMiksYi5vcHRpb25zLmluZmluaXRlPT09ITAmJihhPj1jJiZhPD1iLnNsaWRlQ291bnQtMS1jP2IuJHNsaWRlcy5zbGljZShhLWMsYStjKzEpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIik6KGU9Yi5vcHRpb25zLnNsaWRlc1RvU2hvdythLFxuZC5zbGljZShlLWMrMSxlK2MrMikuYWRkQ2xhc3MoXCJzbGljay1hY3RpdmVcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJmYWxzZVwiKSksMD09PWE/ZC5lcShkLmxlbmd0aC0xLWIub3B0aW9ucy5zbGlkZXNUb1Nob3cpLmFkZENsYXNzKFwic2xpY2stY2VudGVyXCIpOmE9PT1iLnNsaWRlQ291bnQtMSYmZC5lcShiLm9wdGlvbnMuc2xpZGVzVG9TaG93KS5hZGRDbGFzcyhcInNsaWNrLWNlbnRlclwiKSksYi4kc2xpZGVzLmVxKGEpLmFkZENsYXNzKFwic2xpY2stY2VudGVyXCIpKTphPj0wJiZhPD1iLnNsaWRlQ291bnQtYi5vcHRpb25zLnNsaWRlc1RvU2hvdz9iLiRzbGlkZXMuc2xpY2UoYSxhK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3cpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIik6ZC5sZW5ndGg8PWIub3B0aW9ucy5zbGlkZXNUb1Nob3c/ZC5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpOihmPWIuc2xpZGVDb3VudCViLm9wdGlvbnMuc2xpZGVzVG9TaG93LGU9Yi5vcHRpb25zLmluZmluaXRlPT09ITA/Yi5vcHRpb25zLnNsaWRlc1RvU2hvdythOmEsYi5vcHRpb25zLnNsaWRlc1RvU2hvdz09Yi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsJiZiLnNsaWRlQ291bnQtYTxiLm9wdGlvbnMuc2xpZGVzVG9TaG93P2Quc2xpY2UoZS0oYi5vcHRpb25zLnNsaWRlc1RvU2hvdy1mKSxlK2YpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIik6ZC5zbGljZShlLGUrYi5vcHRpb25zLnNsaWRlc1RvU2hvdykuYWRkQ2xhc3MoXCJzbGljay1hY3RpdmVcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJmYWxzZVwiKSksXCJvbmRlbWFuZFwiPT09Yi5vcHRpb25zLmxhenlMb2FkJiZiLmxhenlMb2FkKCl9LGIucHJvdG90eXBlLnNldHVwSW5maW5pdGU9ZnVuY3Rpb24oKXt2YXIgYyxkLGUsYj10aGlzO2lmKGIub3B0aW9ucy5mYWRlPT09ITAmJihiLm9wdGlvbnMuY2VudGVyTW9kZT0hMSksYi5vcHRpb25zLmluZmluaXRlPT09ITAmJmIub3B0aW9ucy5mYWRlPT09ITEmJihkPW51bGwsYi5zbGlkZUNvdW50PmIub3B0aW9ucy5zbGlkZXNUb1Nob3cpKXtmb3IoZT1iLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwP2Iub3B0aW9ucy5zbGlkZXNUb1Nob3crMTpiLm9wdGlvbnMuc2xpZGVzVG9TaG93LGM9Yi5zbGlkZUNvdW50O2M+Yi5zbGlkZUNvdW50LWU7Yy09MSlkPWMtMSxhKGIuJHNsaWRlc1tkXSkuY2xvbmUoITApLmF0dHIoXCJpZFwiLFwiXCIpLmF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIsZC1iLnNsaWRlQ291bnQpLnByZXBlbmRUbyhiLiRzbGlkZVRyYWNrKS5hZGRDbGFzcyhcInNsaWNrLWNsb25lZFwiKTtmb3IoYz0wO2U+YztjKz0xKWQ9YyxhKGIuJHNsaWRlc1tkXSkuY2xvbmUoITApLmF0dHIoXCJpZFwiLFwiXCIpLmF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIsZCtiLnNsaWRlQ291bnQpLmFwcGVuZFRvKGIuJHNsaWRlVHJhY2spLmFkZENsYXNzKFwic2xpY2stY2xvbmVkXCIpO2IuJHNsaWRlVHJhY2suZmluZChcIi5zbGljay1jbG9uZWRcIikuZmluZChcIltpZF1cIikuZWFjaChmdW5jdGlvbigpe2EodGhpcykuYXR0cihcImlkXCIsXCJcIil9KX19LGIucHJvdG90eXBlLmludGVycnVwdD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2F8fGIuYXV0b1BsYXkoKSxiLmludGVycnVwdGVkPWF9LGIucHJvdG90eXBlLnNlbGVjdEhhbmRsZXI9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcyxkPWEoYi50YXJnZXQpLmlzKFwiLnNsaWNrLXNsaWRlXCIpP2EoYi50YXJnZXQpOmEoYi50YXJnZXQpLnBhcmVudHMoXCIuc2xpY2stc2xpZGVcIiksZT1wYXJzZUludChkLmF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIpKTtyZXR1cm4gZXx8KGU9MCksYy5zbGlkZUNvdW50PD1jLm9wdGlvbnMuc2xpZGVzVG9TaG93PyhjLnNldFNsaWRlQ2xhc3NlcyhlKSx2b2lkIGMuYXNOYXZGb3IoZSkpOnZvaWQgYy5zbGlkZUhhbmRsZXIoZSl9LGIucHJvdG90eXBlLnNsaWRlSGFuZGxlcj1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGcsaixoPW51bGwsaT10aGlzO3JldHVybiBiPWJ8fCExLGkuYW5pbWF0aW5nPT09ITAmJmkub3B0aW9ucy53YWl0Rm9yQW5pbWF0ZT09PSEwfHxpLm9wdGlvbnMuZmFkZT09PSEwJiZpLmN1cnJlbnRTbGlkZT09PWF8fGkuc2xpZGVDb3VudDw9aS5vcHRpb25zLnNsaWRlc1RvU2hvdz92b2lkIDA6KGI9PT0hMSYmaS5hc05hdkZvcihhKSxkPWEsaD1pLmdldExlZnQoZCksZz1pLmdldExlZnQoaS5jdXJyZW50U2xpZGUpLGkuY3VycmVudExlZnQ9bnVsbD09PWkuc3dpcGVMZWZ0P2c6aS5zd2lwZUxlZnQsaS5vcHRpb25zLmluZmluaXRlPT09ITEmJmkub3B0aW9ucy5jZW50ZXJNb2RlPT09ITEmJigwPmF8fGE+aS5nZXREb3RDb3VudCgpKmkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCk/dm9pZChpLm9wdGlvbnMuZmFkZT09PSExJiYoZD1pLmN1cnJlbnRTbGlkZSxjIT09ITA/aS5hbmltYXRlU2xpZGUoZyxmdW5jdGlvbigpe2kucG9zdFNsaWRlKGQpfSk6aS5wb3N0U2xpZGUoZCkpKTppLm9wdGlvbnMuaW5maW5pdGU9PT0hMSYmaS5vcHRpb25zLmNlbnRlck1vZGU9PT0hMCYmKDA+YXx8YT5pLnNsaWRlQ291bnQtaS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKT92b2lkKGkub3B0aW9ucy5mYWRlPT09ITEmJihkPWkuY3VycmVudFNsaWRlLGMhPT0hMD9pLmFuaW1hdGVTbGlkZShnLGZ1bmN0aW9uKCl7aS5wb3N0U2xpZGUoZCl9KTppLnBvc3RTbGlkZShkKSkpOihpLm9wdGlvbnMuYXV0b3BsYXkmJmNsZWFySW50ZXJ2YWwoaS5hdXRvUGxheVRpbWVyKSxlPTA+ZD9pLnNsaWRlQ291bnQlaS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIT09MD9pLnNsaWRlQ291bnQtaS5zbGlkZUNvdW50JWkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDppLnNsaWRlQ291bnQrZDpkPj1pLnNsaWRlQ291bnQ/aS5zbGlkZUNvdW50JWkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCE9PTA/MDpkLWkuc2xpZGVDb3VudDpkLGkuYW5pbWF0aW5nPSEwLGkuJHNsaWRlci50cmlnZ2VyKFwiYmVmb3JlQ2hhbmdlXCIsW2ksaS5jdXJyZW50U2xpZGUsZV0pLGY9aS5jdXJyZW50U2xpZGUsaS5jdXJyZW50U2xpZGU9ZSxpLnNldFNsaWRlQ2xhc3NlcyhpLmN1cnJlbnRTbGlkZSksaS5vcHRpb25zLmFzTmF2Rm9yJiYoaj1pLmdldE5hdlRhcmdldCgpLGo9ai5zbGljayhcImdldFNsaWNrXCIpLGouc2xpZGVDb3VudDw9ai5vcHRpb25zLnNsaWRlc1RvU2hvdyYmai5zZXRTbGlkZUNsYXNzZXMoaS5jdXJyZW50U2xpZGUpKSxpLnVwZGF0ZURvdHMoKSxpLnVwZGF0ZUFycm93cygpLGkub3B0aW9ucy5mYWRlPT09ITA/KGMhPT0hMD8oaS5mYWRlU2xpZGVPdXQoZiksaS5mYWRlU2xpZGUoZSxmdW5jdGlvbigpe2kucG9zdFNsaWRlKGUpfSkpOmkucG9zdFNsaWRlKGUpLHZvaWQgaS5hbmltYXRlSGVpZ2h0KCkpOnZvaWQoYyE9PSEwP2kuYW5pbWF0ZVNsaWRlKGgsZnVuY3Rpb24oKXtpLnBvc3RTbGlkZShlKX0pOmkucG9zdFNsaWRlKGUpKSkpfSxiLnByb3RvdHlwZS5zdGFydExvYWQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2Eub3B0aW9ucy5hcnJvd3M9PT0hMCYmYS5zbGlkZUNvdW50PmEub3B0aW9ucy5zbGlkZXNUb1Nob3cmJihhLiRwcmV2QXJyb3cuaGlkZSgpLGEuJG5leHRBcnJvdy5oaWRlKCkpLGEub3B0aW9ucy5kb3RzPT09ITAmJmEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZhLiRkb3RzLmhpZGUoKSxhLiRzbGlkZXIuYWRkQ2xhc3MoXCJzbGljay1sb2FkaW5nXCIpfSxiLnByb3RvdHlwZS5zd2lwZURpcmVjdGlvbj1mdW5jdGlvbigpe3ZhciBhLGIsYyxkLGU9dGhpcztyZXR1cm4gYT1lLnRvdWNoT2JqZWN0LnN0YXJ0WC1lLnRvdWNoT2JqZWN0LmN1clgsYj1lLnRvdWNoT2JqZWN0LnN0YXJ0WS1lLnRvdWNoT2JqZWN0LmN1clksYz1NYXRoLmF0YW4yKGIsYSksZD1NYXRoLnJvdW5kKDE4MCpjL01hdGguUEkpLDA+ZCYmKGQ9MzYwLU1hdGguYWJzKGQpKSw0NT49ZCYmZD49MD9lLm9wdGlvbnMucnRsPT09ITE/XCJsZWZ0XCI6XCJyaWdodFwiOjM2MD49ZCYmZD49MzE1P2Uub3B0aW9ucy5ydGw9PT0hMT9cImxlZnRcIjpcInJpZ2h0XCI6ZD49MTM1JiYyMjU+PWQ/ZS5vcHRpb25zLnJ0bD09PSExP1wicmlnaHRcIjpcImxlZnRcIjplLm9wdGlvbnMudmVydGljYWxTd2lwaW5nPT09ITA/ZD49MzUmJjEzNT49ZD9cImRvd25cIjpcInVwXCI6XCJ2ZXJ0aWNhbFwifSxiLnByb3RvdHlwZS5zd2lwZUVuZD1mdW5jdGlvbihhKXt2YXIgYyxkLGI9dGhpcztpZihiLmRyYWdnaW5nPSExLGIuaW50ZXJydXB0ZWQ9ITEsYi5zaG91bGRDbGljaz1iLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoPjEwPyExOiEwLHZvaWQgMD09PWIudG91Y2hPYmplY3QuY3VyWClyZXR1cm4hMTtpZihiLnRvdWNoT2JqZWN0LmVkZ2VIaXQ9PT0hMCYmYi4kc2xpZGVyLnRyaWdnZXIoXCJlZGdlXCIsW2IsYi5zd2lwZURpcmVjdGlvbigpXSksYi50b3VjaE9iamVjdC5zd2lwZUxlbmd0aD49Yi50b3VjaE9iamVjdC5taW5Td2lwZSl7c3dpdGNoKGQ9Yi5zd2lwZURpcmVjdGlvbigpKXtjYXNlXCJsZWZ0XCI6Y2FzZVwiZG93blwiOmM9Yi5vcHRpb25zLnN3aXBlVG9TbGlkZT9iLmNoZWNrTmF2aWdhYmxlKGIuY3VycmVudFNsaWRlK2IuZ2V0U2xpZGVDb3VudCgpKTpiLmN1cnJlbnRTbGlkZStiLmdldFNsaWRlQ291bnQoKSxiLmN1cnJlbnREaXJlY3Rpb249MDticmVhaztjYXNlXCJyaWdodFwiOmNhc2VcInVwXCI6Yz1iLm9wdGlvbnMuc3dpcGVUb1NsaWRlP2IuY2hlY2tOYXZpZ2FibGUoYi5jdXJyZW50U2xpZGUtYi5nZXRTbGlkZUNvdW50KCkpOmIuY3VycmVudFNsaWRlLWIuZ2V0U2xpZGVDb3VudCgpLGIuY3VycmVudERpcmVjdGlvbj0xfVwidmVydGljYWxcIiE9ZCYmKGIuc2xpZGVIYW5kbGVyKGMpLGIudG91Y2hPYmplY3Q9e30sYi4kc2xpZGVyLnRyaWdnZXIoXCJzd2lwZVwiLFtiLGRdKSl9ZWxzZSBiLnRvdWNoT2JqZWN0LnN0YXJ0WCE9PWIudG91Y2hPYmplY3QuY3VyWCYmKGIuc2xpZGVIYW5kbGVyKGIuY3VycmVudFNsaWRlKSxiLnRvdWNoT2JqZWN0PXt9KX0sYi5wcm90b3R5cGUuc3dpcGVIYW5kbGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7aWYoIShiLm9wdGlvbnMuc3dpcGU9PT0hMXx8XCJvbnRvdWNoZW5kXCJpbiBkb2N1bWVudCYmYi5vcHRpb25zLnN3aXBlPT09ITF8fGIub3B0aW9ucy5kcmFnZ2FibGU9PT0hMSYmLTEhPT1hLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpKSlzd2l0Y2goYi50b3VjaE9iamVjdC5maW5nZXJDb3VudD1hLm9yaWdpbmFsRXZlbnQmJnZvaWQgMCE9PWEub3JpZ2luYWxFdmVudC50b3VjaGVzP2Eub3JpZ2luYWxFdmVudC50b3VjaGVzLmxlbmd0aDoxLGIudG91Y2hPYmplY3QubWluU3dpcGU9Yi5saXN0V2lkdGgvYi5vcHRpb25zLnRvdWNoVGhyZXNob2xkLGIub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmc9PT0hMCYmKGIudG91Y2hPYmplY3QubWluU3dpcGU9Yi5saXN0SGVpZ2h0L2Iub3B0aW9ucy50b3VjaFRocmVzaG9sZCksYS5kYXRhLmFjdGlvbil7Y2FzZVwic3RhcnRcIjpiLnN3aXBlU3RhcnQoYSk7YnJlYWs7Y2FzZVwibW92ZVwiOmIuc3dpcGVNb3ZlKGEpO2JyZWFrO2Nhc2VcImVuZFwiOmIuc3dpcGVFbmQoYSl9fSxiLnByb3RvdHlwZS5zd2lwZU1vdmU9ZnVuY3Rpb24oYSl7dmFyIGQsZSxmLGcsaCxiPXRoaXM7cmV0dXJuIGg9dm9pZCAwIT09YS5vcmlnaW5hbEV2ZW50P2Eub3JpZ2luYWxFdmVudC50b3VjaGVzOm51bGwsIWIuZHJhZ2dpbmd8fGgmJjEhPT1oLmxlbmd0aD8hMTooZD1iLmdldExlZnQoYi5jdXJyZW50U2xpZGUpLGIudG91Y2hPYmplY3QuY3VyWD12b2lkIDAhPT1oP2hbMF0ucGFnZVg6YS5jbGllbnRYLGIudG91Y2hPYmplY3QuY3VyWT12b2lkIDAhPT1oP2hbMF0ucGFnZVk6YS5jbGllbnRZLGIudG91Y2hPYmplY3Quc3dpcGVMZW5ndGg9TWF0aC5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3coYi50b3VjaE9iamVjdC5jdXJYLWIudG91Y2hPYmplY3Quc3RhcnRYLDIpKSksYi5vcHRpb25zLnZlcnRpY2FsU3dpcGluZz09PSEwJiYoYi50b3VjaE9iamVjdC5zd2lwZUxlbmd0aD1NYXRoLnJvdW5kKE1hdGguc3FydChNYXRoLnBvdyhiLnRvdWNoT2JqZWN0LmN1clktYi50b3VjaE9iamVjdC5zdGFydFksMikpKSksZT1iLnN3aXBlRGlyZWN0aW9uKCksXCJ2ZXJ0aWNhbFwiIT09ZT8odm9pZCAwIT09YS5vcmlnaW5hbEV2ZW50JiZiLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoPjQmJmEucHJldmVudERlZmF1bHQoKSxnPShiLm9wdGlvbnMucnRsPT09ITE/MTotMSkqKGIudG91Y2hPYmplY3QuY3VyWD5iLnRvdWNoT2JqZWN0LnN0YXJ0WD8xOi0xKSxiLm9wdGlvbnMudmVydGljYWxTd2lwaW5nPT09ITAmJihnPWIudG91Y2hPYmplY3QuY3VyWT5iLnRvdWNoT2JqZWN0LnN0YXJ0WT8xOi0xKSxmPWIudG91Y2hPYmplY3Quc3dpcGVMZW5ndGgsYi50b3VjaE9iamVjdC5lZGdlSGl0PSExLGIub3B0aW9ucy5pbmZpbml0ZT09PSExJiYoMD09PWIuY3VycmVudFNsaWRlJiZcInJpZ2h0XCI9PT1lfHxiLmN1cnJlbnRTbGlkZT49Yi5nZXREb3RDb3VudCgpJiZcImxlZnRcIj09PWUpJiYoZj1iLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoKmIub3B0aW9ucy5lZGdlRnJpY3Rpb24sYi50b3VjaE9iamVjdC5lZGdlSGl0PSEwKSxiLm9wdGlvbnMudmVydGljYWw9PT0hMT9iLnN3aXBlTGVmdD1kK2YqZzpiLnN3aXBlTGVmdD1kK2YqKGIuJGxpc3QuaGVpZ2h0KCkvYi5saXN0V2lkdGgpKmcsYi5vcHRpb25zLnZlcnRpY2FsU3dpcGluZz09PSEwJiYoYi5zd2lwZUxlZnQ9ZCtmKmcpLGIub3B0aW9ucy5mYWRlPT09ITB8fGIub3B0aW9ucy50b3VjaE1vdmU9PT0hMT8hMTpiLmFuaW1hdGluZz09PSEwPyhiLnN3aXBlTGVmdD1udWxsLCExKTp2b2lkIGIuc2V0Q1NTKGIuc3dpcGVMZWZ0KSk6dm9pZCAwKX0sYi5wcm90b3R5cGUuc3dpcGVTdGFydD1mdW5jdGlvbihhKXt2YXIgYyxiPXRoaXM7cmV0dXJuIGIuaW50ZXJydXB0ZWQ9ITAsMSE9PWIudG91Y2hPYmplY3QuZmluZ2VyQ291bnR8fGIuc2xpZGVDb3VudDw9Yi5vcHRpb25zLnNsaWRlc1RvU2hvdz8oYi50b3VjaE9iamVjdD17fSwhMSk6KHZvaWQgMCE9PWEub3JpZ2luYWxFdmVudCYmdm9pZCAwIT09YS5vcmlnaW5hbEV2ZW50LnRvdWNoZXMmJihjPWEub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdKSxiLnRvdWNoT2JqZWN0LnN0YXJ0WD1iLnRvdWNoT2JqZWN0LmN1clg9dm9pZCAwIT09Yz9jLnBhZ2VYOmEuY2xpZW50WCxiLnRvdWNoT2JqZWN0LnN0YXJ0WT1iLnRvdWNoT2JqZWN0LmN1clk9dm9pZCAwIT09Yz9jLnBhZ2VZOmEuY2xpZW50WSx2b2lkKGIuZHJhZ2dpbmc9ITApKX0sYi5wcm90b3R5cGUudW5maWx0ZXJTbGlkZXM9Yi5wcm90b3R5cGUuc2xpY2tVbmZpbHRlcj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7bnVsbCE9PWEuJHNsaWRlc0NhY2hlJiYoYS51bmxvYWQoKSxhLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCksYS4kc2xpZGVzQ2FjaGUuYXBwZW5kVG8oYS4kc2xpZGVUcmFjayksYS5yZWluaXQoKSl9LGIucHJvdG90eXBlLnVubG9hZD1mdW5jdGlvbigpe3ZhciBiPXRoaXM7YShcIi5zbGljay1jbG9uZWRcIixiLiRzbGlkZXIpLnJlbW92ZSgpLGIuJGRvdHMmJmIuJGRvdHMucmVtb3ZlKCksYi4kcHJldkFycm93JiZiLmh0bWxFeHByLnRlc3QoYi5vcHRpb25zLnByZXZBcnJvdykmJmIuJHByZXZBcnJvdy5yZW1vdmUoKSxiLiRuZXh0QXJyb3cmJmIuaHRtbEV4cHIudGVzdChiLm9wdGlvbnMubmV4dEFycm93KSYmYi4kbmV4dEFycm93LnJlbW92ZSgpLGIuJHNsaWRlcy5yZW1vdmVDbGFzcyhcInNsaWNrLXNsaWRlIHNsaWNrLWFjdGl2ZSBzbGljay12aXNpYmxlIHNsaWNrLWN1cnJlbnRcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpLmNzcyhcIndpZHRoXCIsXCJcIil9LGIucHJvdG90eXBlLnVuc2xpY2s9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztiLiRzbGlkZXIudHJpZ2dlcihcInVuc2xpY2tcIixbYixhXSksYi5kZXN0cm95KCl9LGIucHJvdG90eXBlLnVwZGF0ZUFycm93cz1mdW5jdGlvbigpe3ZhciBiLGE9dGhpcztiPU1hdGguZmxvb3IoYS5vcHRpb25zLnNsaWRlc1RvU2hvdy8yKSxhLm9wdGlvbnMuYXJyb3dzPT09ITAmJmEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYhYS5vcHRpb25zLmluZmluaXRlJiYoYS4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcImZhbHNlXCIpLGEuJG5leHRBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsXCJmYWxzZVwiKSwwPT09YS5jdXJyZW50U2xpZGU/KGEuJHByZXZBcnJvdy5hZGRDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsXCJ0cnVlXCIpLGEuJG5leHRBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsXCJmYWxzZVwiKSk6YS5jdXJyZW50U2xpZGU+PWEuc2xpZGVDb3VudC1hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZhLm9wdGlvbnMuY2VudGVyTW9kZT09PSExPyhhLiRuZXh0QXJyb3cuYWRkQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSxhLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwiZmFsc2VcIikpOmEuY3VycmVudFNsaWRlPj1hLnNsaWRlQ291bnQtMSYmYS5vcHRpb25zLmNlbnRlck1vZGU9PT0hMCYmKGEuJG5leHRBcnJvdy5hZGRDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsXCJ0cnVlXCIpLGEuJHByZXZBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsXCJmYWxzZVwiKSkpfSxiLnByb3RvdHlwZS51cGRhdGVEb3RzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztudWxsIT09YS4kZG90cyYmKGEuJGRvdHMuZmluZChcImxpXCIpLnJlbW92ZUNsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKSxhLiRkb3RzLmZpbmQoXCJsaVwiKS5lcShNYXRoLmZsb29yKGEuY3VycmVudFNsaWRlL2Eub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCkpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIikpfSxiLnByb3RvdHlwZS52aXNpYmlsaXR5PWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLm9wdGlvbnMuYXV0b3BsYXkmJihkb2N1bWVudFthLmhpZGRlbl0/YS5pbnRlcnJ1cHRlZD0hMDphLmludGVycnVwdGVkPSExKX0sYS5mbi5zbGljaz1mdW5jdGlvbigpe3ZhciBmLGcsYT10aGlzLGM9YXJndW1lbnRzWzBdLGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGU9YS5sZW5ndGg7Zm9yKGY9MDtlPmY7ZisrKWlmKFwib2JqZWN0XCI9PXR5cGVvZiBjfHxcInVuZGVmaW5lZFwiPT10eXBlb2YgYz9hW2ZdLnNsaWNrPW5ldyBiKGFbZl0sYyk6Zz1hW2ZdLnNsaWNrW2NdLmFwcGx5KGFbZl0uc2xpY2ssZCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGcpcmV0dXJuIGc7cmV0dXJuIGF9fSk7IiwiLyohIHB1cmwgdjIuMy4xIHwgTUlUICovXG4oZnVuY3Rpb24oZmFjdG9yeSl7aWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKGZhY3RvcnkpfWVsc2V7d2luZG93LnB1cmw9ZmFjdG9yeSgpfX0pKGZ1bmN0aW9uKCl7dmFyIHRhZzJhdHRyPXthOlwiaHJlZlwiLGltZzpcInNyY1wiLGZvcm06XCJhY3Rpb25cIixiYXNlOlwiaHJlZlwiLHNjcmlwdDpcInNyY1wiLGlmcmFtZTpcInNyY1wiLGxpbms6XCJocmVmXCJ9LGtleT1bXCJzb3VyY2VcIixcInByb3RvY29sXCIsXCJhdXRob3JpdHlcIixcInVzZXJJbmZvXCIsXCJ1c2VyXCIsXCJwYXNzd29yZFwiLFwiaG9zdFwiLFwicG9ydFwiLFwicmVsYXRpdmVcIixcInBhdGhcIixcImRpcmVjdG9yeVwiLFwiZmlsZVwiLFwicXVlcnlcIixcImZyYWdtZW50XCJdLGFsaWFzZXM9e2FuY2hvcjpcImZyYWdtZW50XCJ9LHBhcnNlcj17c3RyaWN0Oi9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OigoW146QF0qKTo/KFteOkBdKikpP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPygoKCg/OltePyNcXC9dKlxcLykqKShbXj8jXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLyxsb29zZTovXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShbXjpcXC8/Iy5dKyk6KT8oPzpcXC9cXC8pPygoPzooKFteOkBdKik6PyhbXjpAXSopKT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pL30saXNpbnQ9L15bMC05XSskLztmdW5jdGlvbiBwYXJzZVVyaSh1cmwsc3RyaWN0TW9kZSl7dmFyIHN0cj1kZWNvZGVVUkkodXJsKSxyZXM9cGFyc2VyW3N0cmljdE1vZGV8fGZhbHNlP1wic3RyaWN0XCI6XCJsb29zZVwiXS5leGVjKHN0ciksdXJpPXthdHRyOnt9LHBhcmFtOnt9LHNlZzp7fX0saT0xNDt3aGlsZShpLS0pe3VyaS5hdHRyW2tleVtpXV09cmVzW2ldfHxcIlwifXVyaS5wYXJhbVtcInF1ZXJ5XCJdPXBhcnNlU3RyaW5nKHVyaS5hdHRyW1wicXVlcnlcIl0pO3VyaS5wYXJhbVtcImZyYWdtZW50XCJdPXBhcnNlU3RyaW5nKHVyaS5hdHRyW1wiZnJhZ21lbnRcIl0pO3VyaS5zZWdbXCJwYXRoXCJdPXVyaS5hdHRyLnBhdGgucmVwbGFjZSgvXlxcLyt8XFwvKyQvZyxcIlwiKS5zcGxpdChcIi9cIik7dXJpLnNlZ1tcImZyYWdtZW50XCJdPXVyaS5hdHRyLmZyYWdtZW50LnJlcGxhY2UoL15cXC8rfFxcLyskL2csXCJcIikuc3BsaXQoXCIvXCIpO3VyaS5hdHRyW1wiYmFzZVwiXT11cmkuYXR0ci5ob3N0Pyh1cmkuYXR0ci5wcm90b2NvbD91cmkuYXR0ci5wcm90b2NvbCtcIjovL1wiK3VyaS5hdHRyLmhvc3Q6dXJpLmF0dHIuaG9zdCkrKHVyaS5hdHRyLnBvcnQ/XCI6XCIrdXJpLmF0dHIucG9ydDpcIlwiKTpcIlwiO3JldHVybiB1cml9ZnVuY3Rpb24gZ2V0QXR0ck5hbWUoZWxtKXt2YXIgdG49ZWxtLnRhZ05hbWU7aWYodHlwZW9mIHRuIT09XCJ1bmRlZmluZWRcIilyZXR1cm4gdGFnMmF0dHJbdG4udG9Mb3dlckNhc2UoKV07cmV0dXJuIHRufWZ1bmN0aW9uIHByb21vdGUocGFyZW50LGtleSl7aWYocGFyZW50W2tleV0ubGVuZ3RoPT09MClyZXR1cm4gcGFyZW50W2tleV09e307dmFyIHQ9e307Zm9yKHZhciBpIGluIHBhcmVudFtrZXldKXRbaV09cGFyZW50W2tleV1baV07cGFyZW50W2tleV09dDtyZXR1cm4gdH1mdW5jdGlvbiBwYXJzZShwYXJ0cyxwYXJlbnQsa2V5LHZhbCl7dmFyIHBhcnQ9cGFydHMuc2hpZnQoKTtpZighcGFydCl7aWYoaXNBcnJheShwYXJlbnRba2V5XSkpe3BhcmVudFtrZXldLnB1c2godmFsKX1lbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBwYXJlbnRba2V5XSl7cGFyZW50W2tleV09dmFsfWVsc2UgaWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHBhcmVudFtrZXldKXtwYXJlbnRba2V5XT12YWx9ZWxzZXtwYXJlbnRba2V5XT1bcGFyZW50W2tleV0sdmFsXX19ZWxzZXt2YXIgb2JqPXBhcmVudFtrZXldPXBhcmVudFtrZXldfHxbXTtpZihcIl1cIj09cGFydCl7aWYoaXNBcnJheShvYmopKXtpZihcIlwiIT09dmFsKW9iai5wdXNoKHZhbCl9ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2Ygb2JqKXtvYmpba2V5cyhvYmopLmxlbmd0aF09dmFsfWVsc2V7b2JqPXBhcmVudFtrZXldPVtwYXJlbnRba2V5XSx2YWxdfX1lbHNlIGlmKH5wYXJ0LmluZGV4T2YoXCJdXCIpKXtwYXJ0PXBhcnQuc3Vic3RyKDAscGFydC5sZW5ndGgtMSk7aWYoIWlzaW50LnRlc3QocGFydCkmJmlzQXJyYXkob2JqKSlvYmo9cHJvbW90ZShwYXJlbnQsa2V5KTtwYXJzZShwYXJ0cyxvYmoscGFydCx2YWwpfWVsc2V7aWYoIWlzaW50LnRlc3QocGFydCkmJmlzQXJyYXkob2JqKSlvYmo9cHJvbW90ZShwYXJlbnQsa2V5KTtwYXJzZShwYXJ0cyxvYmoscGFydCx2YWwpfX19ZnVuY3Rpb24gbWVyZ2UocGFyZW50LGtleSx2YWwpe2lmKH5rZXkuaW5kZXhPZihcIl1cIikpe3ZhciBwYXJ0cz1rZXkuc3BsaXQoXCJbXCIpO3BhcnNlKHBhcnRzLHBhcmVudCxcImJhc2VcIix2YWwpfWVsc2V7aWYoIWlzaW50LnRlc3Qoa2V5KSYmaXNBcnJheShwYXJlbnQuYmFzZSkpe3ZhciB0PXt9O2Zvcih2YXIgayBpbiBwYXJlbnQuYmFzZSl0W2tdPXBhcmVudC5iYXNlW2tdO3BhcmVudC5iYXNlPXR9aWYoa2V5IT09XCJcIil7c2V0KHBhcmVudC5iYXNlLGtleSx2YWwpfX1yZXR1cm4gcGFyZW50fWZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cil7cmV0dXJuIHJlZHVjZShTdHJpbmcoc3RyKS5zcGxpdCgvJnw7LyksZnVuY3Rpb24ocmV0LHBhaXIpe3RyeXtwYWlyPWRlY29kZVVSSUNvbXBvbmVudChwYWlyLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSl9Y2F0Y2goZSl7fXZhciBlcWw9cGFpci5pbmRleE9mKFwiPVwiKSxicmFjZT1sYXN0QnJhY2VJbktleShwYWlyKSxrZXk9cGFpci5zdWJzdHIoMCxicmFjZXx8ZXFsKSx2YWw9cGFpci5zdWJzdHIoYnJhY2V8fGVxbCxwYWlyLmxlbmd0aCk7dmFsPXZhbC5zdWJzdHIodmFsLmluZGV4T2YoXCI9XCIpKzEsdmFsLmxlbmd0aCk7aWYoa2V5PT09XCJcIil7a2V5PXBhaXI7dmFsPVwiXCJ9cmV0dXJuIG1lcmdlKHJldCxrZXksdmFsKX0se2Jhc2U6e319KS5iYXNlfWZ1bmN0aW9uIHNldChvYmosa2V5LHZhbCl7dmFyIHY9b2JqW2tleV07aWYodHlwZW9mIHY9PT1cInVuZGVmaW5lZFwiKXtvYmpba2V5XT12YWx9ZWxzZSBpZihpc0FycmF5KHYpKXt2LnB1c2godmFsKX1lbHNle29ialtrZXldPVt2LHZhbF19fWZ1bmN0aW9uIGxhc3RCcmFjZUluS2V5KHN0cil7dmFyIGxlbj1zdHIubGVuZ3RoLGJyYWNlLGM7Zm9yKHZhciBpPTA7aTxsZW47KytpKXtjPXN0cltpXTtpZihcIl1cIj09YylicmFjZT1mYWxzZTtpZihcIltcIj09YylicmFjZT10cnVlO2lmKFwiPVwiPT1jJiYhYnJhY2UpcmV0dXJuIGl9fWZ1bmN0aW9uIHJlZHVjZShvYmosYWNjdW11bGF0b3Ipe3ZhciBpPTAsbD1vYmoubGVuZ3RoPj4wLGN1cnI9YXJndW1lbnRzWzJdO3doaWxlKGk8bCl7aWYoaSBpbiBvYmopY3Vycj1hY2N1bXVsYXRvci5jYWxsKHVuZGVmaW5lZCxjdXJyLG9ialtpXSxpLG9iaik7KytpfXJldHVybiBjdXJyfWZ1bmN0aW9uIGlzQXJyYXkodkFyZyl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2QXJnKT09PVwiW29iamVjdCBBcnJheV1cIn1mdW5jdGlvbiBrZXlzKG9iail7dmFyIGtleV9hcnJheT1bXTtmb3IodmFyIHByb3AgaW4gb2JqKXtpZihvYmouaGFzT3duUHJvcGVydHkocHJvcCkpa2V5X2FycmF5LnB1c2gocHJvcCl9cmV0dXJuIGtleV9hcnJheX1mdW5jdGlvbiBwdXJsKHVybCxzdHJpY3RNb2RlKXtpZihhcmd1bWVudHMubGVuZ3RoPT09MSYmdXJsPT09dHJ1ZSl7c3RyaWN0TW9kZT10cnVlO3VybD11bmRlZmluZWR9c3RyaWN0TW9kZT1zdHJpY3RNb2RlfHxmYWxzZTt1cmw9dXJsfHx3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKTtyZXR1cm57ZGF0YTpwYXJzZVVyaSh1cmwsc3RyaWN0TW9kZSksYXR0cjpmdW5jdGlvbihhdHRyKXthdHRyPWFsaWFzZXNbYXR0cl18fGF0dHI7cmV0dXJuIHR5cGVvZiBhdHRyIT09XCJ1bmRlZmluZWRcIj90aGlzLmRhdGEuYXR0clthdHRyXTp0aGlzLmRhdGEuYXR0cn0scGFyYW06ZnVuY3Rpb24ocGFyYW0pe3JldHVybiB0eXBlb2YgcGFyYW0hPT1cInVuZGVmaW5lZFwiP3RoaXMuZGF0YS5wYXJhbS5xdWVyeVtwYXJhbV06dGhpcy5kYXRhLnBhcmFtLnF1ZXJ5fSxmcGFyYW06ZnVuY3Rpb24ocGFyYW0pe3JldHVybiB0eXBlb2YgcGFyYW0hPT1cInVuZGVmaW5lZFwiP3RoaXMuZGF0YS5wYXJhbS5mcmFnbWVudFtwYXJhbV06dGhpcy5kYXRhLnBhcmFtLmZyYWdtZW50fSxzZWdtZW50OmZ1bmN0aW9uKHNlZyl7aWYodHlwZW9mIHNlZz09PVwidW5kZWZpbmVkXCIpe3JldHVybiB0aGlzLmRhdGEuc2VnLnBhdGh9ZWxzZXtzZWc9c2VnPDA/dGhpcy5kYXRhLnNlZy5wYXRoLmxlbmd0aCtzZWc6c2VnLTE7cmV0dXJuIHRoaXMuZGF0YS5zZWcucGF0aFtzZWddfX0sZnNlZ21lbnQ6ZnVuY3Rpb24oc2VnKXtpZih0eXBlb2Ygc2VnPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIHRoaXMuZGF0YS5zZWcuZnJhZ21lbnR9ZWxzZXtzZWc9c2VnPDA/dGhpcy5kYXRhLnNlZy5mcmFnbWVudC5sZW5ndGgrc2VnOnNlZy0xO3JldHVybiB0aGlzLmRhdGEuc2VnLmZyYWdtZW50W3NlZ119fX19cHVybC5qUXVlcnk9ZnVuY3Rpb24oJCl7aWYoJCE9bnVsbCl7JC5mbi51cmw9ZnVuY3Rpb24oc3RyaWN0TW9kZSl7dmFyIHVybD1cIlwiO2lmKHRoaXMubGVuZ3RoKXt1cmw9JCh0aGlzKS5hdHRyKGdldEF0dHJOYW1lKHRoaXNbMF0pKXx8XCJcIn1yZXR1cm4gcHVybCh1cmwsc3RyaWN0TW9kZSl9OyQudXJsPXB1cmx9fTtwdXJsLmpRdWVyeSh3aW5kb3cualF1ZXJ5KTtyZXR1cm4gcHVybH0pOyJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
