'use strict';

window.whatInput = function () {

  'use strict';

  /*
    ---------------
    variables
    ---------------
  */

  // array of actively pressed keys

  var activeKeys = [];

  // cache document.body
  var body;

  // boolean: true if touch buffer timer is running
  var buffer = false;

  // the last used input type
  var currentInput = null;

  // `input` types that don't accept text
  var nonTypingInputs = ['button', 'checkbox', 'file', 'image', 'radio', 'reset', 'submit'];

  // detect version of mouse wheel event to use
  // via https://developer.mozilla.org/en-US/docs/Web/Events/wheel
  var mouseWheel = detectWheel();

  // list of modifier keys commonly used with the mouse and
  // can be safely ignored to prevent false keyboard detection
  var ignoreMap = [16, // shift
  17, // control
  18, // alt
  91, // Windows key / left Apple cmd
  93 // Windows menu / right Apple cmd
  ];

  // mapping of events to input types
  var inputMap = {
    'keydown': 'keyboard',
    'keyup': 'keyboard',
    'mousedown': 'mouse',
    'mousemove': 'mouse',
    'MSPointerDown': 'pointer',
    'MSPointerMove': 'pointer',
    'pointerdown': 'pointer',
    'pointermove': 'pointer',
    'touchstart': 'touch'
  };

  // add correct mouse wheel event mapping to `inputMap`
  inputMap[detectWheel()] = 'mouse';

  // array of all used input types
  var inputTypes = [];

  // mapping of key codes to a common name
  var keyMap = {
    9: 'tab',
    13: 'enter',
    16: 'shift',
    27: 'esc',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down'
  };

  // map of IE 10 pointer events
  var pointerMap = {
    2: 'touch',
    3: 'touch', // treat pen like touch
    4: 'mouse'
  };

  // touch buffer timer
  var timer;

  /*
    ---------------
    functions
    ---------------
  */

  // allows events that are also triggered to be filtered out for `touchstart`
  function eventBuffer() {
    clearTimer();
    setInput(event);

    buffer = true;
    timer = window.setTimeout(function () {
      buffer = false;
    }, 650);
  }

  function bufferedEvent(event) {
    if (!buffer) setInput(event);
  }

  function unBufferedEvent(event) {
    clearTimer();
    setInput(event);
  }

  function clearTimer() {
    window.clearTimeout(timer);
  }

  function setInput(event) {
    var eventKey = key(event);
    var value = inputMap[event.type];
    if (value === 'pointer') value = pointerType(event);

    // don't do anything if the value matches the input type already set
    if (currentInput !== value) {
      var eventTarget = target(event);
      var eventTargetNode = eventTarget.nodeName.toLowerCase();
      var eventTargetType = eventTargetNode === 'input' ? eventTarget.getAttribute('type') : null;

      if ( // only if the user flag to allow typing in form fields isn't set
      !body.hasAttribute('data-whatinput-formtyping') &&

      // only if currentInput has a value
      currentInput &&

      // only if the input is `keyboard`
      value === 'keyboard' &&

      // not if the key is `TAB`
      keyMap[eventKey] !== 'tab' && (

      // only if the target is a form input that accepts text
      eventTargetNode === 'textarea' || eventTargetNode === 'select' || eventTargetNode === 'input' && nonTypingInputs.indexOf(eventTargetType) < 0) ||
      // ignore modifier keys
      ignoreMap.indexOf(eventKey) > -1) {
        // ignore keyboard typing
      } else {
        switchInput(value);
      }
    }

    if (value === 'keyboard') logKeys(eventKey);
  }

  function switchInput(string) {
    currentInput = string;
    body.setAttribute('data-whatinput', currentInput);

    if (inputTypes.indexOf(currentInput) === -1) inputTypes.push(currentInput);
  }

  function key(event) {
    return event.keyCode ? event.keyCode : event.which;
  }

  function target(event) {
    return event.target || event.srcElement;
  }

  function pointerType(event) {
    if (typeof event.pointerType === 'number') {
      return pointerMap[event.pointerType];
    } else {
      return event.pointerType === 'pen' ? 'touch' : event.pointerType; // treat pen like touch
    }
  }

  // keyboard logging
  function logKeys(eventKey) {
    if (activeKeys.indexOf(keyMap[eventKey]) === -1 && keyMap[eventKey]) activeKeys.push(keyMap[eventKey]);
  }

  function unLogKeys(event) {
    var eventKey = key(event);
    var arrayPos = activeKeys.indexOf(keyMap[eventKey]);

    if (arrayPos !== -1) activeKeys.splice(arrayPos, 1);
  }

  function bindEvents() {
    body = document.body;

    // pointer events (mouse, pen, touch)
    if (window.PointerEvent) {
      body.addEventListener('pointerdown', bufferedEvent);
      body.addEventListener('pointermove', bufferedEvent);
    } else if (window.MSPointerEvent) {
      body.addEventListener('MSPointerDown', bufferedEvent);
      body.addEventListener('MSPointerMove', bufferedEvent);
    } else {

      // mouse events
      body.addEventListener('mousedown', bufferedEvent);
      body.addEventListener('mousemove', bufferedEvent);

      // touch events
      if ('ontouchstart' in window) {
        body.addEventListener('touchstart', eventBuffer);
      }
    }

    // mouse wheel
    body.addEventListener(mouseWheel, bufferedEvent);

    // keyboard events
    body.addEventListener('keydown', unBufferedEvent);
    body.addEventListener('keyup', unBufferedEvent);
    document.addEventListener('keyup', unLogKeys);
  }

  /*
    ---------------
    utilities
    ---------------
  */

  // detect version of mouse wheel event to use
  // via https://developer.mozilla.org/en-US/docs/Web/Events/wheel
  function detectWheel() {
    return mouseWheel = 'onwheel' in document.createElement('div') ? 'wheel' : // Modern browsers support "wheel"

    document.onmousewheel !== undefined ? 'mousewheel' : // Webkit and IE support at least "mousewheel"
    'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox
  }

  /*
    ---------------
    init
     don't start script unless browser cuts the mustard,
    also passes if polyfills are used
    ---------------
  */

  if ('addEventListener' in window && Array.prototype.indexOf) {

    // if the dom is already ready already (script was placed at bottom of <body>)
    if (document.body) {
      bindEvents();

      // otherwise wait for the dom to load (script was placed in the <head>)
    } else {
      document.addEventListener('DOMContentLoaded', bindEvents);
    }
  }

  /*
    ---------------
    api
    ---------------
  */

  return {

    // returns string: the current input type
    ask: function () {
      return currentInput;
    },

    // returns array: currently pressed keys
    keys: function () {
      return activeKeys;
    },

    // returns array: all the detected input types
    types: function () {
      return inputTypes;
    },

    // accepts string: manually set the input type
    set: switchInput
  };
}();
;'use strict';

!function ($) {

  "use strict";

  var FOUNDATION_VERSION = '6.2.2';

  // Global Foundation object
  // This is attached to the window, or used as a module for AMD/Browserify
  var Foundation = {
    version: FOUNDATION_VERSION,

    /**
     * Stores initialized plugins.
     */
    _plugins: {},

    /**
     * Stores generated unique ids for plugin instances
     */
    _uuids: [],

    /**
     * Returns a boolean for RTL support
     */
    rtl: function () {
      return $('html').attr('dir') === 'rtl';
    },
    /**
     * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.
     * @param {Object} plugin - The constructor of the plugin.
     */
    plugin: function (plugin, name) {
      // Object key to use when adding to global Foundation object
      // Examples: Foundation.Reveal, Foundation.OffCanvas
      var className = name || functionName(plugin);
      // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin
      // Examples: data-reveal, data-off-canvas
      var attrName = hyphenate(className);

      // Add to the Foundation object and the plugins list (for reflowing)
      this._plugins[attrName] = this[className] = plugin;
    },
    /**
     * @function
     * Populates the _uuids array with pointers to each individual plugin instance.
     * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.
     * Also fires the initialization event for each plugin, consolidating repetitive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @param {String} name - the name of the plugin, passed as a camelCased string.
     * @fires Plugin#init
     */
    registerPlugin: function (plugin, name) {
      var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();
      plugin.uuid = this.GetYoDigits(6, pluginName);

      if (!plugin.$element.attr('data-' + pluginName)) {
        plugin.$element.attr('data-' + pluginName, plugin.uuid);
      }
      if (!plugin.$element.data('zfPlugin')) {
        plugin.$element.data('zfPlugin', plugin);
      }
      /**
       * Fires when the plugin has initialized.
       * @event Plugin#init
       */
      plugin.$element.trigger('init.zf.' + pluginName);

      this._uuids.push(plugin.uuid);

      return;
    },
    /**
     * @function
     * Removes the plugins uuid from the _uuids array.
     * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.
     * Also fires the destroyed event for the plugin, consolidating repetitive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @fires Plugin#destroyed
     */
    unregisterPlugin: function (plugin) {
      var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));

      this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);
      plugin.$element.removeAttr('data-' + pluginName).removeData('zfPlugin')
      /**
       * Fires when the plugin has been destroyed.
       * @event Plugin#destroyed
       */
      .trigger('destroyed.zf.' + pluginName);
      for (var prop in plugin) {
        plugin[prop] = null; //clean up script to prep for garbage collection.
      }
      return;
    },

    /**
     * @function
     * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.
     * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`
     * @default If no argument is passed, reflow all currently active plugins.
     */
    reInit: function (plugins) {
      var isJQ = plugins instanceof $;
      try {
        if (isJQ) {
          plugins.each(function () {
            $(this).data('zfPlugin')._init();
          });
        } else {
          var type = typeof plugins,
              _this = this,
              fns = {
            'object': function (plgs) {
              plgs.forEach(function (p) {
                p = hyphenate(p);
                $('[data-' + p + ']').foundation('_init');
              });
            },
            'string': function () {
              plugins = hyphenate(plugins);
              $('[data-' + plugins + ']').foundation('_init');
            },
            'undefined': function () {
              this['object'](Object.keys(_this._plugins));
            }
          };
          fns[type](plugins);
        }
      } catch (err) {
        console.error(err);
      } finally {
        return plugins;
      }
    },

    /**
     * returns a random base-36 uid with namespacing
     * @function
     * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.
     * @param {String} namespace - name of plugin to be incorporated in uid, optional.
     * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.
     * @returns {String} - unique id
     */
    GetYoDigits: function (length, namespace) {
      length = length || 6;
      return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? '-' + namespace : '');
    },
    /**
     * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.
     * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.
     * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.
     */
    reflow: function (elem, plugins) {

      // If plugins is undefined, just grab everything
      if (typeof plugins === 'undefined') {
        plugins = Object.keys(this._plugins);
      }
      // If plugins is a string, convert it to an array with one item
      else if (typeof plugins === 'string') {
          plugins = [plugins];
        }

      var _this = this;

      // Iterate through each plugin
      $.each(plugins, function (i, name) {
        // Get the current plugin
        var plugin = _this._plugins[name];

        // Localize the search to all elements inside elem, as well as elem itself, unless elem === document
        var $elem = $(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');

        // For each plugin found, initialize it
        $elem.each(function () {
          var $el = $(this),
              opts = {};
          // Don't double-dip on plugins
          if ($el.data('zfPlugin')) {
            console.warn("Tried to initialize " + name + " on an element that already has a Foundation plugin.");
            return;
          }

          if ($el.attr('data-options')) {
            var thing = $el.attr('data-options').split(';').forEach(function (e, i) {
              var opt = e.split(':').map(function (el) {
                return el.trim();
              });
              if (opt[0]) opts[opt[0]] = parseValue(opt[1]);
            });
          }
          try {
            $el.data('zfPlugin', new plugin($(this), opts));
          } catch (er) {
            console.error(er);
          } finally {
            return;
          }
        });
      });
    },
    getFnName: functionName,
    transitionend: function ($elem) {
      var transitions = {
        'transition': 'transitionend',
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'otransitionend'
      };
      var elem = document.createElement('div'),
          end;

      for (var t in transitions) {
        if (typeof elem.style[t] !== 'undefined') {
          end = transitions[t];
        }
      }
      if (end) {
        return end;
      } else {
        end = setTimeout(function () {
          $elem.triggerHandler('transitionend', [$elem]);
        }, 1);
        return 'transitionend';
      }
    }
  };

  Foundation.util = {
    /**
     * Function for applying a debounce effect to a function call.
     * @function
     * @param {Function} func - Function to be called at end of timeout.
     * @param {Number} delay - Time in ms to delay the call of `func`.
     * @returns function
     */
    throttle: function (func, delay) {
      var timer = null;

      return function () {
        var context = this,
            args = arguments;

        if (timer === null) {
          timer = setTimeout(function () {
            func.apply(context, args);
            timer = null;
          }, delay);
        }
      };
    }
  };

  // TODO: consider not making this a jQuery function
  // TODO: need way to reflow vs. re-initialize
  /**
   * The Foundation jQuery method.
   * @param {String|Array} method - An action to perform on the current jQuery object.
   */
  var foundation = function (method) {
    var type = typeof method,
        $meta = $('meta.foundation-mq'),
        $noJS = $('.no-js');

    if (!$meta.length) {
      $('<meta class="foundation-mq">').appendTo(document.head);
    }
    if ($noJS.length) {
      $noJS.removeClass('no-js');
    }

    if (type === 'undefined') {
      //needs to initialize the Foundation object, or an individual plugin.
      Foundation.MediaQuery._init();
      Foundation.reflow(this);
    } else if (type === 'string') {
      //an individual method to invoke on a plugin or group of plugins
      var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary
      var plugClass = this.data('zfPlugin'); //determine the class of plugin

      if (plugClass !== undefined && plugClass[method] !== undefined) {
        //make sure both the class and method exist
        if (this.length === 1) {
          //if there's only one, call it directly.
          plugClass[method].apply(plugClass, args);
        } else {
          this.each(function (i, el) {
            //otherwise loop through the jQuery collection and invoke the method on each
            plugClass[method].apply($(el).data('zfPlugin'), args);
          });
        }
      } else {
        //error for no class or no method
        throw new ReferenceError("We're sorry, '" + method + "' is not an available method for " + (plugClass ? functionName(plugClass) : 'this element') + '.');
      }
    } else {
      //error for invalid argument type
      throw new TypeError('We\'re sorry, ' + type + ' is not a valid parameter. You must use a string representing the method you wish to invoke.');
    }
    return this;
  };

  window.Foundation = Foundation;
  $.fn.foundation = foundation;

  // Polyfill for requestAnimationFrame
  (function () {
    if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {
      return new Date().getTime();
    };

    var vendors = ['webkit', 'moz'];
    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
      var vp = vendors[i];
      window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
      var lastTime = 0;
      window.requestAnimationFrame = function (callback) {
        var now = Date.now();
        var nextTime = Math.max(lastTime + 16, now);
        return setTimeout(function () {
          callback(lastTime = nextTime);
        }, nextTime - now);
      };
      window.cancelAnimationFrame = clearTimeout;
    }
    /**
     * Polyfill for performance.now, required by rAF
     */
    if (!window.performance || !window.performance.now) {
      window.performance = {
        start: Date.now(),
        now: function () {
          return Date.now() - this.start;
        }
      };
    }
  })();
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
      if (typeof this !== 'function') {
        // closest thing possible to the ECMAScript 5
        // internal IsCallable function
        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
      }

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
      };

      if (this.prototype) {
        // native functions don't have a prototype
        fNOP.prototype = this.prototype;
      }
      fBound.prototype = new fNOP();

      return fBound;
    };
  }
  // Polyfill to get the name of a function in IE9
  function functionName(fn) {
    if (Function.prototype.name === undefined) {
      var funcNameRegex = /function\s([^(]{1,})\(/;
      var results = funcNameRegex.exec(fn.toString());
      return results && results.length > 1 ? results[1].trim() : "";
    } else if (fn.prototype === undefined) {
      return fn.constructor.name;
    } else {
      return fn.prototype.constructor.name;
    }
  }
  function parseValue(str) {
    if (/true/.test(str)) return true;else if (/false/.test(str)) return false;else if (!isNaN(str * 1)) return parseFloat(str);
    return str;
  }
  // Convert PascalCase to kebab-case
  // Thank you: http://stackoverflow.com/a/8955580
  function hyphenate(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }
}(jQuery);
;'use strict';

!function ($) {

  Foundation.Box = {
    ImNotTouchingYou: ImNotTouchingYou,
    GetDimensions: GetDimensions,
    GetOffsets: GetOffsets
  };

  /**
   * Compares the dimensions of an element to a container and determines collision events with container.
   * @function
   * @param {jQuery} element - jQuery object to test for collisions.
   * @param {jQuery} parent - jQuery object to use as bounding container.
   * @param {Boolean} lrOnly - set to true to check left and right values only.
   * @param {Boolean} tbOnly - set to true to check top and bottom values only.
   * @default if no parent object passed, detects collisions with `window`.
   * @returns {Boolean} - true if collision free, false if a collision in any direction.
   */
  function ImNotTouchingYou(element, parent, lrOnly, tbOnly) {
    var eleDims = GetDimensions(element),
        top,
        bottom,
        left,
        right;

    if (parent) {
      var parDims = GetDimensions(parent);

      bottom = eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top;
      top = eleDims.offset.top >= parDims.offset.top;
      left = eleDims.offset.left >= parDims.offset.left;
      right = eleDims.offset.left + eleDims.width <= parDims.width + parDims.offset.left;
    } else {
      bottom = eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top;
      top = eleDims.offset.top >= eleDims.windowDims.offset.top;
      left = eleDims.offset.left >= eleDims.windowDims.offset.left;
      right = eleDims.offset.left + eleDims.width <= eleDims.windowDims.width;
    }

    var allDirs = [bottom, top, left, right];

    if (lrOnly) {
      return left === right === true;
    }

    if (tbOnly) {
      return top === bottom === true;
    }

    return allDirs.indexOf(false) === -1;
  };

  /**
   * Uses native methods to return an object of dimension values.
   * @function
   * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.
   * @returns {Object} - nested object of integer pixel values
   * TODO - if element is window, return only those values.
   */
  function GetDimensions(elem, test) {
    elem = elem.length ? elem[0] : elem;

    if (elem === window || elem === document) {
      throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");
    }

    var rect = elem.getBoundingClientRect(),
        parRect = elem.parentNode.getBoundingClientRect(),
        winRect = document.body.getBoundingClientRect(),
        winY = window.pageYOffset,
        winX = window.pageXOffset;

    return {
      width: rect.width,
      height: rect.height,
      offset: {
        top: rect.top + winY,
        left: rect.left + winX
      },
      parentDims: {
        width: parRect.width,
        height: parRect.height,
        offset: {
          top: parRect.top + winY,
          left: parRect.left + winX
        }
      },
      windowDims: {
        width: winRect.width,
        height: winRect.height,
        offset: {
          top: winY,
          left: winX
        }
      }
    };
  }

  /**
   * Returns an object of top and left integer pixel values for dynamically rendered elements,
   * such as: Tooltip, Reveal, and Dropdown
   * @function
   * @param {jQuery} element - jQuery object for the element being positioned.
   * @param {jQuery} anchor - jQuery object for the element's anchor point.
   * @param {String} position - a string relating to the desired position of the element, relative to it's anchor
   * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.
   * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.
   * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.
   * TODO alter/rewrite to work with `em` values as well/instead of pixels
   */
  function GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {
    var $eleDims = GetDimensions(element),
        $anchorDims = anchor ? GetDimensions(anchor) : null;

    switch (position) {
      case 'top':
        return {
          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top
        };
        break;
      case 'right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset,
          top: $anchorDims.offset.top
        };
        break;
      case 'center top':
        return {
          left: $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'center bottom':
        return {
          left: isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
        break;
      case 'center left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'center right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,
          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'center':
        return {
          left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2,
          top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'reveal':
        return {
          left: ($eleDims.windowDims.width - $eleDims.width) / 2,
          top: $eleDims.windowDims.offset.top + vOffset
        };
      case 'reveal full':
        return {
          left: $eleDims.windowDims.offset.left,
          top: $eleDims.windowDims.offset.top
        };
        break;
      case 'left bottom':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top + $anchorDims.height
        };
        break;
      case 'right bottom':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset - $eleDims.width,
          top: $anchorDims.offset.top + $anchorDims.height
        };
        break;
      default:
        return {
          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
    }
  }
}(jQuery);
;/*******************************************
 *                                         *
 * This util was created by Marius Olbertz *
 * Please thank Marius on GitHub /owlbertz *
 * or the web http://www.mariusolbertz.de/ *
 *                                         *
 ******************************************/

'use strict';

!function ($) {

  var keyCodes = {
    9: 'TAB',
    13: 'ENTER',
    27: 'ESCAPE',
    32: 'SPACE',
    37: 'ARROW_LEFT',
    38: 'ARROW_UP',
    39: 'ARROW_RIGHT',
    40: 'ARROW_DOWN'
  };

  var commands = {};

  var Keyboard = {
    keys: getKeyCodes(keyCodes),

    /**
     * Parses the (keyboard) event and returns a String that represents its key
     * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
     * @param {Event} event - the event generated by the event handler
     * @return String key - String that represents the key pressed
     */
    parseKey: function (event) {
      var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();
      if (event.shiftKey) key = 'SHIFT_' + key;
      if (event.ctrlKey) key = 'CTRL_' + key;
      if (event.altKey) key = 'ALT_' + key;
      return key;
    },


    /**
     * Handles the given (keyboard) event
     * @param {Event} event - the event generated by the event handler
     * @param {String} component - Foundation component's name, e.g. Slider or Reveal
     * @param {Objects} functions - collection of functions that are to be executed
     */
    handleKey: function (event, component, functions) {
      var commandList = commands[component],
          keyCode = this.parseKey(event),
          cmds,
          command,
          fn;

      if (!commandList) return console.warn('Component not defined!');

      if (typeof commandList.ltr === 'undefined') {
        // this component does not differentiate between ltr and rtl
        cmds = commandList; // use plain list
      } else {
        // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa
        if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);else cmds = $.extend({}, commandList.rtl, commandList.ltr);
      }
      command = cmds[keyCode];

      fn = functions[command];
      if (fn && typeof fn === 'function') {
        // execute function  if exists
        var returnValue = fn.apply();
        if (functions.handled || typeof functions.handled === 'function') {
          // execute function when event was handled
          functions.handled(returnValue);
        }
      } else {
        if (functions.unhandled || typeof functions.unhandled === 'function') {
          // execute function when event was not handled
          functions.unhandled();
        }
      }
    },


    /**
     * Finds all focusable elements within the given `$element`
     * @param {jQuery} $element - jQuery object to search within
     * @return {jQuery} $focusable - all focusable elements within `$element`
     */
    findFocusable: function ($element) {
      return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {
        if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) {
          return false;
        } //only have visible elements and those that have a tabindex greater or equal 0
        return true;
      });
    },


    /**
     * Returns the component name name
     * @param {Object} component - Foundation component, e.g. Slider or Reveal
     * @return String componentName
     */

    register: function (componentName, cmds) {
      commands[componentName] = cmds;
    }
  };

  /*
   * Constants for easier comparing.
   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
   */
  function getKeyCodes(kcs) {
    var k = {};
    for (var kc in kcs) {
      k[kcs[kc]] = kcs[kc];
    }return k;
  }

  Foundation.Keyboard = Keyboard;
}(jQuery);
;'use strict';

!function ($) {

  // Default set of media queries
  var defaultQueries = {
    'default': 'only screen',
    landscape: 'only screen and (orientation: landscape)',
    portrait: 'only screen and (orientation: portrait)',
    retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'
  };

  var MediaQuery = {
    queries: [],

    current: '',

    /**
     * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.
     * @function
     * @private
     */
    _init: function () {
      var self = this;
      var extractedStyles = $('.foundation-mq').css('font-family');
      var namedQueries;

      namedQueries = parseStyleToObject(extractedStyles);

      for (var key in namedQueries) {
        if (namedQueries.hasOwnProperty(key)) {
          self.queries.push({
            name: key,
            value: 'only screen and (min-width: ' + namedQueries[key] + ')'
          });
        }
      }

      this.current = this._getCurrentSize();

      this._watcher();
    },


    /**
     * Checks if the screen is at least as wide as a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to check.
     * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.
     */
    atLeast: function (size) {
      var query = this.get(size);

      if (query) {
        return window.matchMedia(query).matches;
      }

      return false;
    },


    /**
     * Gets the media query of a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to get.
     * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.
     */
    get: function (size) {
      for (var i in this.queries) {
        if (this.queries.hasOwnProperty(i)) {
          var query = this.queries[i];
          if (size === query.name) return query.value;
        }
      }

      return null;
    },


    /**
     * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).
     * @function
     * @private
     * @returns {String} Name of the current breakpoint.
     */
    _getCurrentSize: function () {
      var matched;

      for (var i = 0; i < this.queries.length; i++) {
        var query = this.queries[i];

        if (window.matchMedia(query.value).matches) {
          matched = query;
        }
      }

      if (typeof matched === 'object') {
        return matched.name;
      } else {
        return matched;
      }
    },


    /**
     * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.
     * @function
     * @private
     */
    _watcher: function () {
      var _this = this;

      $(window).on('resize.zf.mediaquery', function () {
        var newSize = _this._getCurrentSize(),
            currentSize = _this.current;

        if (newSize !== currentSize) {
          // Change the current media query
          _this.current = newSize;

          // Broadcast the media query change on the window
          $(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);
        }
      });
    }
  };

  Foundation.MediaQuery = MediaQuery;

  // matchMedia() polyfill - Test a CSS media type/query in JS.
  // Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license
  window.matchMedia || (window.matchMedia = function () {
    'use strict';

    // For browsers that support matchMedium api such as IE 9 and webkit

    var styleMedia = window.styleMedia || window.media;

    // For those that don't support matchMedium
    if (!styleMedia) {
      var style = document.createElement('style'),
          script = document.getElementsByTagName('script')[0],
          info = null;

      style.type = 'text/css';
      style.id = 'matchmediajs-test';

      script.parentNode.insertBefore(style, script);

      // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
      info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;

      styleMedia = {
        matchMedium: function (media) {
          var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

          // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
          if (style.styleSheet) {
            style.styleSheet.cssText = text;
          } else {
            style.textContent = text;
          }

          // Test if media query is true or false
          return info.width === '1px';
        }
      };
    }

    return function (media) {
      return {
        matches: styleMedia.matchMedium(media || 'all'),
        media: media || 'all'
      };
    };
  }());

  // Thank you: https://github.com/sindresorhus/query-string
  function parseStyleToObject(str) {
    var styleObject = {};

    if (typeof str !== 'string') {
      return styleObject;
    }

    str = str.trim().slice(1, -1); // browsers re-quote string style values

    if (!str) {
      return styleObject;
    }

    styleObject = str.split('&').reduce(function (ret, param) {
      var parts = param.replace(/\+/g, ' ').split('=');
      var key = parts[0];
      var val = parts[1];
      key = decodeURIComponent(key);

      // missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
      val = val === undefined ? null : decodeURIComponent(val);

      if (!ret.hasOwnProperty(key)) {
        ret[key] = val;
      } else if (Array.isArray(ret[key])) {
        ret[key].push(val);
      } else {
        ret[key] = [ret[key], val];
      }
      return ret;
    }, {});

    return styleObject;
  }

  Foundation.MediaQuery = MediaQuery;
}(jQuery);
;'use strict';

!function ($) {

  /**
   * Motion module.
   * @module foundation.motion
   */

  var initClasses = ['mui-enter', 'mui-leave'];
  var activeClasses = ['mui-enter-active', 'mui-leave-active'];

  var Motion = {
    animateIn: function (element, animation, cb) {
      animate(true, element, animation, cb);
    },

    animateOut: function (element, animation, cb) {
      animate(false, element, animation, cb);
    }
  };

  function Move(duration, elem, fn) {
    var anim,
        prog,
        start = null;
    // console.log('called');

    function move(ts) {
      if (!start) start = window.performance.now();
      // console.log(start, ts);
      prog = ts - start;
      fn.apply(elem);

      if (prog < duration) {
        anim = window.requestAnimationFrame(move, elem);
      } else {
        window.cancelAnimationFrame(anim);
        elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
      }
    }
    anim = window.requestAnimationFrame(move);
  }

  /**
   * Animates an element in or out using a CSS transition class.
   * @function
   * @private
   * @param {Boolean} isIn - Defines if the animation is in or out.
   * @param {Object} element - jQuery or HTML object to animate.
   * @param {String} animation - CSS class to use.
   * @param {Function} cb - Callback to run when animation is finished.
   */
  function animate(isIn, element, animation, cb) {
    element = $(element).eq(0);

    if (!element.length) return;

    var initClass = isIn ? initClasses[0] : initClasses[1];
    var activeClass = isIn ? activeClasses[0] : activeClasses[1];

    // Set up the animation
    reset();

    element.addClass(animation).css('transition', 'none');

    requestAnimationFrame(function () {
      element.addClass(initClass);
      if (isIn) element.show();
    });

    // Start the animation
    requestAnimationFrame(function () {
      element[0].offsetWidth;
      element.css('transition', '').addClass(activeClass);
    });

    // Clean up the animation when it finishes
    element.one(Foundation.transitionend(element), finish);

    // Hides the element (for out animations), resets the element, and runs a callback
    function finish() {
      if (!isIn) element.hide();
      reset();
      if (cb) cb.apply(element);
    }

    // Resets transitions and removes motion-specific classes
    function reset() {
      element[0].style.transitionDuration = 0;
      element.removeClass(initClass + ' ' + activeClass + ' ' + animation);
    }
  }

  Foundation.Move = Move;
  Foundation.Motion = Motion;
}(jQuery);
;'use strict';

!function ($) {

  var Nest = {
    Feather: function (menu) {
      var type = arguments.length <= 1 || arguments[1] === undefined ? 'zf' : arguments[1];

      menu.attr('role', 'menubar');

      var items = menu.find('li').attr({ 'role': 'menuitem' }),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      menu.find('a:first').attr('tabindex', 0);

      items.each(function () {
        var $item = $(this),
            $sub = $item.children('ul');

        if ($sub.length) {
          $item.addClass(hasSubClass).attr({
            'aria-haspopup': true,
            'aria-expanded': false,
            'aria-label': $item.children('a:first').text()
          });

          $sub.addClass('submenu ' + subMenuClass).attr({
            'data-submenu': '',
            'aria-hidden': true,
            'role': 'menu'
          });
        }

        if ($item.parent('[data-submenu]').length) {
          $item.addClass('is-submenu-item ' + subItemClass);
        }
      });

      return;
    },
    Burn: function (menu, type) {
      var items = menu.find('li').removeAttr('tabindex'),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      menu.find('*').removeClass(subMenuClass + ' ' + subItemClass + ' ' + hasSubClass + ' is-submenu-item submenu is-active').removeAttr('data-submenu').css('display', '');

      // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')
      //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')
      //           .removeAttr('data-submenu'));
      // items.each(function(){
      //   var $item = $(this),
      //       $sub = $item.children('ul');
      //   if($item.parent('[data-submenu]').length){
      //     $item.removeClass('is-submenu-item ' + subItemClass);
      //   }
      //   if($sub.length){
      //     $item.removeClass('has-submenu');
      //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');
      //   }
      // });
    }
  };

  Foundation.Nest = Nest;
}(jQuery);
;'use strict';

!function ($) {

  function Timer(elem, options, cb) {
    var _this = this,
        duration = options.duration,
        //options is an object for easily adding features later.
    nameSpace = Object.keys(elem.data())[0] || 'timer',
        remain = -1,
        start,
        timer;

    this.isPaused = false;

    this.restart = function () {
      remain = -1;
      clearTimeout(timer);
      this.start();
    };

    this.start = function () {
      this.isPaused = false;
      // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      remain = remain <= 0 ? duration : remain;
      elem.data('paused', false);
      start = Date.now();
      timer = setTimeout(function () {
        if (options.infinite) {
          _this.restart(); //rerun the timer.
        }
        cb();
      }, remain);
      elem.trigger('timerstart.zf.' + nameSpace);
    };

    this.pause = function () {
      this.isPaused = true;
      //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      elem.data('paused', true);
      var end = Date.now();
      remain = remain - (end - start);
      elem.trigger('timerpaused.zf.' + nameSpace);
    };
  }

  /**
   * Runs a callback function when images are fully loaded.
   * @param {Object} images - Image(s) to check if loaded.
   * @param {Func} callback - Function to execute when image is fully loaded.
   */
  function onImagesLoaded(images, callback) {
    var self = this,
        unloaded = images.length;

    if (unloaded === 0) {
      callback();
    }

    images.each(function () {
      if (this.complete) {
        singleImageLoaded();
      } else if (typeof this.naturalWidth !== 'undefined' && this.naturalWidth > 0) {
        singleImageLoaded();
      } else {
        $(this).one('load', function () {
          singleImageLoaded();
        });
      }
    });

    function singleImageLoaded() {
      unloaded--;
      if (unloaded === 0) {
        callback();
      }
    }
  }

  Foundation.Timer = Timer;
  Foundation.onImagesLoaded = onImagesLoaded;
}(jQuery);
;'use strict';

//**************************************************
//**Work inspired by multiple jquery swipe plugins**
//**Done by Yohai Ararat ***************************
//**************************************************
(function ($) {

	$.spotSwipe = {
		version: '1.0.0',
		enabled: 'ontouchstart' in document.documentElement,
		preventDefault: false,
		moveThreshold: 75,
		timeThreshold: 200
	};

	var startPosX,
	    startPosY,
	    startTime,
	    elapsedTime,
	    isMoving = false;

	function onTouchEnd() {
		//  alert(this);
		this.removeEventListener('touchmove', onTouchMove);
		this.removeEventListener('touchend', onTouchEnd);
		isMoving = false;
	}

	function onTouchMove(e) {
		if ($.spotSwipe.preventDefault) {
			e.preventDefault();
		}
		if (isMoving) {
			var x = e.touches[0].pageX;
			var y = e.touches[0].pageY;
			var dx = startPosX - x;
			var dy = startPosY - y;
			var dir;
			elapsedTime = new Date().getTime() - startTime;
			if (Math.abs(dx) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
				dir = dx > 0 ? 'left' : 'right';
			}
			// else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
			//   dir = dy > 0 ? 'down' : 'up';
			// }
			if (dir) {
				e.preventDefault();
				onTouchEnd.call(this);
				$(this).trigger('swipe', dir).trigger('swipe' + dir);
			}
		}
	}

	function onTouchStart(e) {
		if (e.touches.length == 1) {
			startPosX = e.touches[0].pageX;
			startPosY = e.touches[0].pageY;
			isMoving = true;
			startTime = new Date().getTime();
			this.addEventListener('touchmove', onTouchMove, false);
			this.addEventListener('touchend', onTouchEnd, false);
		}
	}

	function init() {
		this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);
	}

	function teardown() {
		this.removeEventListener('touchstart', onTouchStart);
	}

	$.event.special.swipe = { setup: init };

	$.each(['left', 'up', 'down', 'right'], function () {
		$.event.special['swipe' + this] = { setup: function () {
				$(this).on('swipe', $.noop);
			} };
	});
})(jQuery);
/****************************************************
 * Method for adding psuedo drag events to elements *
 ***************************************************/
!function ($) {
	$.fn.addTouch = function () {
		this.each(function (i, el) {
			$(el).bind('touchstart touchmove touchend touchcancel', function () {
				//we pass the original event object because the jQuery event
				//object is normalized to w3c specs and does not provide the TouchList
				handleTouch(event);
			});
		});

		var handleTouch = function (event) {
			var touches = event.changedTouches,
			    first = touches[0],
			    eventTypes = {
				touchstart: 'mousedown',
				touchmove: 'mousemove',
				touchend: 'mouseup'
			},
			    type = eventTypes[event.type],
			    simulatedEvent;

			if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {
				simulatedEvent = new window.MouseEvent(type, {
					'bubbles': true,
					'cancelable': true,
					'screenX': first.screenX,
					'screenY': first.screenY,
					'clientX': first.clientX,
					'clientY': first.clientY
				});
			} else {
				simulatedEvent = document.createEvent('MouseEvent');
				simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0 /*left*/, null);
			}
			first.target.dispatchEvent(simulatedEvent);
		};
	};
}(jQuery);

//**********************************
//**From the jQuery Mobile Library**
//**need to recreate functionality**
//**and try to improve if possible**
//**********************************

/* Removing the jQuery function ****
************************************

(function( $, window, undefined ) {

	var $document = $( document ),
		// supportTouch = $.mobile.support.touch,
		touchStartEvent = 'touchstart'//supportTouch ? "touchstart" : "mousedown",
		touchStopEvent = 'touchend'//supportTouch ? "touchend" : "mouseup",
		touchMoveEvent = 'touchmove'//supportTouch ? "touchmove" : "mousemove";

	// setup new event shortcuts
	$.each( ( "touchstart touchmove touchend " +
		"swipe swipeleft swiperight" ).split( " " ), function( i, name ) {

		$.fn[ name ] = function( fn ) {
			return fn ? this.bind( name, fn ) : this.trigger( name );
		};

		// jQuery < 1.8
		if ( $.attrFn ) {
			$.attrFn[ name ] = true;
		}
	});

	function triggerCustomEvent( obj, eventType, event, bubble ) {
		var originalType = event.type;
		event.type = eventType;
		if ( bubble ) {
			$.event.trigger( event, undefined, obj );
		} else {
			$.event.dispatch.call( obj, event );
		}
		event.type = originalType;
	}

	// also handles taphold

	// Also handles swipeleft, swiperight
	$.event.special.swipe = {

		// More than this horizontal displacement, and we will suppress scrolling.
		scrollSupressionThreshold: 30,

		// More time than this, and it isn't a swipe.
		durationThreshold: 1000,

		// Swipe horizontal displacement must be more than this.
		horizontalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		// Swipe vertical displacement must be less than this.
		verticalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		getLocation: function ( event ) {
			var winPageX = window.pageXOffset,
				winPageY = window.pageYOffset,
				x = event.clientX,
				y = event.clientY;

			if ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||
				event.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {

				// iOS4 clientX/clientY have the value that should have been
				// in pageX/pageY. While pageX/page/ have the value 0
				x = x - winPageX;
				y = y - winPageY;
			} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {

				// Some Android browsers have totally bogus values for clientX/Y
				// when scrolling/zooming a page. Detectable since clientX/clientY
				// should never be smaller than pageX/pageY minus page scroll
				x = event.pageX - winPageX;
				y = event.pageY - winPageY;
			}

			return {
				x: x,
				y: y
			};
		},

		start: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ],
						origin: $( event.target )
					};
		},

		stop: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ]
					};
		},

		handleSwipe: function( start, stop, thisObject, origTarget ) {
			if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
				Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
				Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {
				var direction = start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight";

				triggerCustomEvent( thisObject, "swipe", $.Event( "swipe", { target: origTarget, swipestart: start, swipestop: stop }), true );
				triggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );
				return true;
			}
			return false;

		},

		// This serves as a flag to ensure that at most one swipe event event is
		// in work at any given time
		eventInProgress: false,

		setup: function() {
			var events,
				thisObject = this,
				$this = $( thisObject ),
				context = {};

			// Retrieve the events data for this element and add the swipe context
			events = $.data( this, "mobile-events" );
			if ( !events ) {
				events = { length: 0 };
				$.data( this, "mobile-events", events );
			}
			events.length++;
			events.swipe = context;

			context.start = function( event ) {

				// Bail if we're already working on a swipe event
				if ( $.event.special.swipe.eventInProgress ) {
					return;
				}
				$.event.special.swipe.eventInProgress = true;

				var stop,
					start = $.event.special.swipe.start( event ),
					origTarget = event.target,
					emitted = false;

				context.move = function( event ) {
					if ( !start || event.isDefaultPrevented() ) {
						return;
					}

					stop = $.event.special.swipe.stop( event );
					if ( !emitted ) {
						emitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );
						if ( emitted ) {

							// Reset the context to make way for the next swipe event
							$.event.special.swipe.eventInProgress = false;
						}
					}
					// prevent scrolling
					if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
						event.preventDefault();
					}
				};

				context.stop = function() {
						emitted = true;

						// Reset the context to make way for the next swipe event
						$.event.special.swipe.eventInProgress = false;
						$document.off( touchMoveEvent, context.move );
						context.move = null;
				};

				$document.on( touchMoveEvent, context.move )
					.one( touchStopEvent, context.stop );
			};
			$this.on( touchStartEvent, context.start );
		},

		teardown: function() {
			var events, context;

			events = $.data( this, "mobile-events" );
			if ( events ) {
				context = events.swipe;
				delete events.swipe;
				events.length--;
				if ( events.length === 0 ) {
					$.removeData( this, "mobile-events" );
				}
			}

			if ( context ) {
				if ( context.start ) {
					$( this ).off( touchStartEvent, context.start );
				}
				if ( context.move ) {
					$document.off( touchMoveEvent, context.move );
				}
				if ( context.stop ) {
					$document.off( touchStopEvent, context.stop );
				}
			}
		}
	};
	$.each({
		swipeleft: "swipe.left",
		swiperight: "swipe.right"
	}, function( event, sourceEvent ) {

		$.event.special[ event ] = {
			setup: function() {
				$( this ).bind( sourceEvent, $.noop );
			},
			teardown: function() {
				$( this ).unbind( sourceEvent );
			}
		};
	});
})( jQuery, this );
*/
;'use strict';

!function ($) {

  var MutationObserver = function () {
    var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
    for (var i = 0; i < prefixes.length; i++) {
      if (prefixes[i] + 'MutationObserver' in window) {
        return window[prefixes[i] + 'MutationObserver'];
      }
    }
    return false;
  }();

  var triggers = function (el, type) {
    el.data(type).split(' ').forEach(function (id) {
      $('#' + id)[type === 'close' ? 'trigger' : 'triggerHandler'](type + '.zf.trigger', [el]);
    });
  };
  // Elements with [data-open] will reveal a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-open]', function () {
    triggers($(this), 'open');
  });

  // Elements with [data-close] will close a plugin that supports it when clicked.
  // If used without a value on [data-close], the event will bubble, allowing it to close a parent component.
  $(document).on('click.zf.trigger', '[data-close]', function () {
    var id = $(this).data('close');
    if (id) {
      triggers($(this), 'close');
    } else {
      $(this).trigger('close.zf.trigger');
    }
  });

  // Elements with [data-toggle] will toggle a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-toggle]', function () {
    triggers($(this), 'toggle');
  });

  // Elements with [data-closable] will respond to close.zf.trigger events.
  $(document).on('close.zf.trigger', '[data-closable]', function (e) {
    e.stopPropagation();
    var animation = $(this).data('closable');

    if (animation !== '') {
      Foundation.Motion.animateOut($(this), animation, function () {
        $(this).trigger('closed.zf');
      });
    } else {
      $(this).fadeOut().trigger('closed.zf');
    }
  });

  $(document).on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', function () {
    var id = $(this).data('toggle-focus');
    $('#' + id).triggerHandler('toggle.zf.trigger', [$(this)]);
  });

  /**
  * Fires once after all other scripts have loaded
  * @function
  * @private
  */
  $(window).load(function () {
    checkListeners();
  });

  function checkListeners() {
    eventsListener();
    resizeListener();
    scrollListener();
    closemeListener();
  }

  //******** only fires this function once on load, if there's something to watch ********
  function closemeListener(pluginName) {
    var yetiBoxes = $('[data-yeti-box]'),
        plugNames = ['dropdown', 'tooltip', 'reveal'];

    if (pluginName) {
      if (typeof pluginName === 'string') {
        plugNames.push(pluginName);
      } else if (typeof pluginName === 'object' && typeof pluginName[0] === 'string') {
        plugNames.concat(pluginName);
      } else {
        console.error('Plugin names must be strings');
      }
    }
    if (yetiBoxes.length) {
      var listeners = plugNames.map(function (name) {
        return 'closeme.zf.' + name;
      }).join(' ');

      $(window).off(listeners).on(listeners, function (e, pluginId) {
        var plugin = e.namespace.split('.')[0];
        var plugins = $('[data-' + plugin + ']').not('[data-yeti-box="' + pluginId + '"]');

        plugins.each(function () {
          var _this = $(this);

          _this.triggerHandler('close.zf.trigger', [_this]);
        });
      });
    }
  }

  function resizeListener(debounce) {
    var timer = void 0,
        $nodes = $('[data-resize]');
    if ($nodes.length) {
      $(window).off('resize.zf.trigger').on('resize.zf.trigger', function (e) {
        if (timer) {
          clearTimeout(timer);
        }

        timer = setTimeout(function () {

          if (!MutationObserver) {
            //fallback for IE 9
            $nodes.each(function () {
              $(this).triggerHandler('resizeme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a resize event
          $nodes.attr('data-events', "resize");
        }, debounce || 10); //default time to emit resize event
      });
    }
  }

  function scrollListener(debounce) {
    var timer = void 0,
        $nodes = $('[data-scroll]');
    if ($nodes.length) {
      $(window).off('scroll.zf.trigger').on('scroll.zf.trigger', function (e) {
        if (timer) {
          clearTimeout(timer);
        }

        timer = setTimeout(function () {

          if (!MutationObserver) {
            //fallback for IE 9
            $nodes.each(function () {
              $(this).triggerHandler('scrollme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a scroll event
          $nodes.attr('data-events', "scroll");
        }, debounce || 10); //default time to emit scroll event
      });
    }
  }

  function eventsListener() {
    if (!MutationObserver) {
      return false;
    }
    var nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');

    //element callback
    var listeningElementsMutation = function (mutationRecordsList) {
      var $target = $(mutationRecordsList[0].target);
      //trigger the event handler for the element depending on type
      switch ($target.attr("data-events")) {

        case "resize":
          $target.triggerHandler('resizeme.zf.trigger', [$target]);
          break;

        case "scroll":
          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);
          break;

        // case "mutate" :
        // console.log('mutate', $target);
        // $target.triggerHandler('mutate.zf.trigger');
        //
        // //make sure we don't get stuck in an infinite loop from sloppy codeing
        // if ($target.index('[data-mutate]') == $("[data-mutate]").length-1) {
        //   domMutationObserver();
        // }
        // break;

        default:
          return false;
        //nothing
      }
    };

    if (nodes.length) {
      //for each element that needs to listen for resizing, scrolling, (or coming soon mutation) add a single observer
      for (var i = 0; i <= nodes.length - 1; i++) {
        var elementObserver = new MutationObserver(listeningElementsMutation);
        elementObserver.observe(nodes[i], { attributes: true, childList: false, characterData: false, subtree: false, attributeFilter: ["data-events"] });
      }
    }
  }

  // ------------------------------------

  // [PH]
  // Foundation.CheckWatchers = checkWatchers;
  Foundation.IHearYou = checkListeners;
  // Foundation.ISeeYou = scrollListener;
  // Foundation.IFeelYou = closemeListener;
}(jQuery);

// function domMutationObserver(debounce) {
//   // !!! This is coming soon and needs more work; not active  !!! //
//   var timer,
//   nodes = document.querySelectorAll('[data-mutate]');
//   //
//   if (nodes.length) {
//     // var MutationObserver = (function () {
//     //   var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
//     //   for (var i=0; i < prefixes.length; i++) {
//     //     if (prefixes[i] + 'MutationObserver' in window) {
//     //       return window[prefixes[i] + 'MutationObserver'];
//     //     }
//     //   }
//     //   return false;
//     // }());
//
//
//     //for the body, we need to listen for all changes effecting the style and class attributes
//     var bodyObserver = new MutationObserver(bodyMutation);
//     bodyObserver.observe(document.body, { attributes: true, childList: true, characterData: false, subtree:true, attributeFilter:["style", "class"]});
//
//
//     //body callback
//     function bodyMutation(mutate) {
//       //trigger all listening elements and signal a mutation event
//       if (timer) { clearTimeout(timer); }
//
//       timer = setTimeout(function() {
//         bodyObserver.disconnect();
//         $('[data-mutate]').attr('data-events',"mutate");
//       }, debounce || 150);
//     }
//   }
// }
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Abide module.
   * @module foundation.abide
   */

  var Abide = function () {
    /**
     * Creates a new instance of Abide.
     * @class
     * @fires Abide#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Abide(element) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      _classCallCheck(this, Abide);

      this.$element = element;
      this.options = $.extend({}, Abide.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Abide');
    }

    /**
     * Initializes the Abide plugin and calls functions to get Abide functioning on load.
     * @private
     */


    _createClass(Abide, [{
      key: '_init',
      value: function _init() {
        this.$inputs = this.$element.find('input, textarea, select');

        this._events();
      }

      /**
       * Initializes events for Abide.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this2 = this;

        this.$element.off('.abide').on('reset.zf.abide', function () {
          _this2.resetForm();
        }).on('submit.zf.abide', function () {
          return _this2.validateForm();
        });

        if (this.options.validateOn === 'fieldChange') {
          this.$inputs.off('change.zf.abide').on('change.zf.abide', function (e) {
            _this2.validateInput($(e.target));
          });
        }

        if (this.options.liveValidate) {
          this.$inputs.off('input.zf.abide').on('input.zf.abide', function (e) {
            _this2.validateInput($(e.target));
          });
        }
      }

      /**
       * Calls necessary functions to update Abide upon DOM change
       * @private
       */

    }, {
      key: '_reflow',
      value: function _reflow() {
        this._init();
      }

      /**
       * Checks whether or not a form element has the required attribute and if it's checked or not
       * @param {Object} element - jQuery object to check for required attribute
       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
       */

    }, {
      key: 'requiredCheck',
      value: function requiredCheck($el) {
        if (!$el.attr('required')) return true;

        var isGood = true;

        switch ($el[0].type) {
          case 'checkbox':
            isGood = $el[0].checked;
            break;

          case 'select':
          case 'select-one':
          case 'select-multiple':
            var opt = $el.find('option:selected');
            if (!opt.length || !opt.val()) isGood = false;
            break;

          default:
            if (!$el.val() || !$el.val().length) isGood = false;
        }

        return isGood;
      }

      /**
       * Based on $el, get the first element with selector in this order:
       * 1. The element's direct sibling('s).
       * 3. The element's parent's children.
       *
       * This allows for multiple form errors per input, though if none are found, no form errors will be shown.
       *
       * @param {Object} $el - jQuery object to use as reference to find the form error selector.
       * @returns {Object} jQuery object with the selector.
       */

    }, {
      key: 'findFormError',
      value: function findFormError($el) {
        var $error = $el.siblings(this.options.formErrorSelector);

        if (!$error.length) {
          $error = $el.parent().find(this.options.formErrorSelector);
        }

        return $error;
      }

      /**
       * Get the first element in this order:
       * 2. The <label> with the attribute `[for="someInputId"]`
       * 3. The `.closest()` <label>
       *
       * @param {Object} $el - jQuery object to check for required attribute
       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
       */

    }, {
      key: 'findLabel',
      value: function findLabel($el) {
        var id = $el[0].id;
        var $label = this.$element.find('label[for="' + id + '"]');

        if (!$label.length) {
          return $el.closest('label');
        }

        return $label;
      }

      /**
       * Get the set of labels associated with a set of radio els in this order
       * 2. The <label> with the attribute `[for="someInputId"]`
       * 3. The `.closest()` <label>
       *
       * @param {Object} $el - jQuery object to check for required attribute
       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
       */

    }, {
      key: 'findRadioLabels',
      value: function findRadioLabels($els) {
        var _this3 = this;

        var labels = $els.map(function (i, el) {
          var id = el.id;
          var $label = _this3.$element.find('label[for="' + id + '"]');

          if (!$label.length) {
            $label = $(el).closest('label');
          }
          return $label[0];
        });

        return $(labels);
      }

      /**
       * Adds the CSS error class as specified by the Abide settings to the label, input, and the form
       * @param {Object} $el - jQuery object to add the class to
       */

    }, {
      key: 'addErrorClasses',
      value: function addErrorClasses($el) {
        var $label = this.findLabel($el);
        var $formError = this.findFormError($el);

        if ($label.length) {
          $label.addClass(this.options.labelErrorClass);
        }

        if ($formError.length) {
          $formError.addClass(this.options.formErrorClass);
        }

        $el.addClass(this.options.inputErrorClass).attr('data-invalid', '');
      }

      /**
       * Remove CSS error classes etc from an entire radio button group
       * @param {String} groupName - A string that specifies the name of a radio button group
       *
       */

    }, {
      key: 'removeRadioErrorClasses',
      value: function removeRadioErrorClasses(groupName) {
        var $els = this.$element.find(':radio[name="' + groupName + '"]');
        var $labels = this.findRadioLabels($els);
        var $formErrors = this.findFormError($els);

        if ($labels.length) {
          $labels.removeClass(this.options.labelErrorClass);
        }

        if ($formErrors.length) {
          $formErrors.removeClass(this.options.formErrorClass);
        }

        $els.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');
      }

      /**
       * Removes CSS error class as specified by the Abide settings from the label, input, and the form
       * @param {Object} $el - jQuery object to remove the class from
       */

    }, {
      key: 'removeErrorClasses',
      value: function removeErrorClasses($el) {
        // radios need to clear all of the els
        if ($el[0].type == 'radio') {
          return this.removeRadioErrorClasses($el.attr('name'));
        }

        var $label = this.findLabel($el);
        var $formError = this.findFormError($el);

        if ($label.length) {
          $label.removeClass(this.options.labelErrorClass);
        }

        if ($formError.length) {
          $formError.removeClass(this.options.formErrorClass);
        }

        $el.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');
      }

      /**
       * Goes through a form to find inputs and proceeds to validate them in ways specific to their type
       * @fires Abide#invalid
       * @fires Abide#valid
       * @param {Object} element - jQuery object to validate, should be an HTML input
       * @returns {Boolean} goodToGo - If the input is valid or not.
       */

    }, {
      key: 'validateInput',
      value: function validateInput($el) {
        var clearRequire = this.requiredCheck($el),
            validated = false,
            customValidator = true,
            validator = $el.attr('data-validator'),
            equalTo = true;

        // don't validate ignored inputs or hidden inputs
        if ($el.is('[data-abide-ignore]') || $el.is('[type="hidden"]')) {
          return true;
        }

        switch ($el[0].type) {
          case 'radio':
            validated = this.validateRadio($el.attr('name'));
            break;

          case 'checkbox':
            validated = clearRequire;
            break;

          case 'select':
          case 'select-one':
          case 'select-multiple':
            validated = clearRequire;
            break;

          default:
            validated = this.validateText($el);
        }

        if (validator) {
          customValidator = this.matchValidation($el, validator, $el.attr('required'));
        }

        if ($el.attr('data-equalto')) {
          equalTo = this.options.validators.equalTo($el);
        }

        var goodToGo = [clearRequire, validated, customValidator, equalTo].indexOf(false) === -1;
        var message = (goodToGo ? 'valid' : 'invalid') + '.zf.abide';

        this[goodToGo ? 'removeErrorClasses' : 'addErrorClasses']($el);

        /**
         * Fires when the input is done checking for validation. Event trigger is either `valid.zf.abide` or `invalid.zf.abide`
         * Trigger includes the DOM element of the input.
         * @event Abide#valid
         * @event Abide#invalid
         */
        $el.trigger(message, [$el]);

        return goodToGo;
      }

      /**
       * Goes through a form and if there are any invalid inputs, it will display the form error element
       * @returns {Boolean} noError - true if no errors were detected...
       * @fires Abide#formvalid
       * @fires Abide#forminvalid
       */

    }, {
      key: 'validateForm',
      value: function validateForm() {
        var acc = [];
        var _this = this;

        this.$inputs.each(function () {
          acc.push(_this.validateInput($(this)));
        });

        var noError = acc.indexOf(false) === -1;

        this.$element.find('[data-abide-error]').css('display', noError ? 'none' : 'block');

        /**
         * Fires when the form is finished validating. Event trigger is either `formvalid.zf.abide` or `forminvalid.zf.abide`.
         * Trigger includes the element of the form.
         * @event Abide#formvalid
         * @event Abide#forminvalid
         */
        this.$element.trigger((noError ? 'formvalid' : 'forminvalid') + '.zf.abide', [this.$element]);

        return noError;
      }

      /**
       * Determines whether or a not a text input is valid based on the pattern specified in the attribute. If no matching pattern is found, returns true.
       * @param {Object} $el - jQuery object to validate, should be a text input HTML element
       * @param {String} pattern - string value of one of the RegEx patterns in Abide.options.patterns
       * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified
       */

    }, {
      key: 'validateText',
      value: function validateText($el, pattern) {
        // A pattern can be passed to this function, or it will be infered from the input's "pattern" attribute, or it's "type" attribute
        pattern = pattern || $el.attr('pattern') || $el.attr('type');
        var inputText = $el.val();
        var valid = false;

        if (inputText.length) {
          // If the pattern attribute on the element is in Abide's list of patterns, then test that regexp
          if (this.options.patterns.hasOwnProperty(pattern)) {
            valid = this.options.patterns[pattern].test(inputText);
          }
          // If the pattern name isn't also the type attribute of the field, then test it as a regexp
          else if (pattern !== $el.attr('type')) {
              valid = new RegExp(pattern).test(inputText);
            } else {
              valid = true;
            }
        }
        // An empty field is valid if it's not required
        else if (!$el.prop('required')) {
            valid = true;
          }

        return valid;
      }

      /**
       * Determines whether or a not a radio input is valid based on whether or not it is required and selected. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all radio buttons in its group.
       * @param {String} groupName - A string that specifies the name of a radio button group
       * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)
       */

    }, {
      key: 'validateRadio',
      value: function validateRadio(groupName) {
        // If at least one radio in the group has the `required` attribute, the group is considered required
        // Per W3C spec, all radio buttons in a group should have `required`, but we're being nice
        var $group = this.$element.find(':radio[name="' + groupName + '"]');
        var valid = false,
            required = false;

        // For the group to be required, at least one radio needs to be required
        $group.each(function (i, e) {
          if ($(e).attr('required')) {
            required = true;
          }
        });
        if (!required) valid = true;

        if (!valid) {
          // For the group to be valid, at least one radio needs to be checked
          $group.each(function (i, e) {
            if ($(e).prop('checked')) {
              valid = true;
            }
          });
        };

        return valid;
      }

      /**
       * Determines if a selected input passes a custom validation function. Multiple validations can be used, if passed to the element with `data-validator="foo bar baz"` in a space separated listed.
       * @param {Object} $el - jQuery input element.
       * @param {String} validators - a string of function names matching functions in the Abide.options.validators object.
       * @param {Boolean} required - self explanatory?
       * @returns {Boolean} - true if validations passed.
       */

    }, {
      key: 'matchValidation',
      value: function matchValidation($el, validators, required) {
        var _this4 = this;

        required = required ? true : false;

        var clear = validators.split(' ').map(function (v) {
          return _this4.options.validators[v]($el, required, $el.parent());
        });
        return clear.indexOf(false) === -1;
      }

      /**
       * Resets form inputs and styles
       * @fires Abide#formreset
       */

    }, {
      key: 'resetForm',
      value: function resetForm() {
        var $form = this.$element,
            opts = this.options;

        $('.' + opts.labelErrorClass, $form).not('small').removeClass(opts.labelErrorClass);
        $('.' + opts.inputErrorClass, $form).not('small').removeClass(opts.inputErrorClass);
        $(opts.formErrorSelector + '.' + opts.formErrorClass).removeClass(opts.formErrorClass);
        $form.find('[data-abide-error]').css('display', 'none');
        $(':input', $form).not(':button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]').val('').removeAttr('data-invalid');
        $(':input:radio', $form).not('[data-abide-ignore]').prop('checked', false).removeAttr('data-invalid');
        $(':input:checkbox', $form).not('[data-abide-ignore]').prop('checked', false).removeAttr('data-invalid');
        /**
         * Fires when the form has been reset.
         * @event Abide#formreset
         */
        $form.trigger('formreset.zf.abide', [$form]);
      }

      /**
       * Destroys an instance of Abide.
       * Removes error styles and classes from elements, without resetting their values.
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        var _this = this;
        this.$element.off('.abide').find('[data-abide-error]').css('display', 'none');

        this.$inputs.off('.abide').each(function () {
          _this.removeErrorClasses($(this));
        });

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Abide;
  }();

  /**
   * Default settings for plugin
   */


  Abide.defaults = {
    /**
     * The default event to validate inputs. Checkboxes and radios validate immediately.
     * Remove or change this value for manual validation.
     * @option
     * @example 'fieldChange'
     */
    validateOn: 'fieldChange',

    /**
     * Class to be applied to input labels on failed validation.
     * @option
     * @example 'is-invalid-label'
     */
    labelErrorClass: 'is-invalid-label',

    /**
     * Class to be applied to inputs on failed validation.
     * @option
     * @example 'is-invalid-input'
     */
    inputErrorClass: 'is-invalid-input',

    /**
     * Class selector to use to target Form Errors for show/hide.
     * @option
     * @example '.form-error'
     */
    formErrorSelector: '.form-error',

    /**
     * Class added to Form Errors on failed validation.
     * @option
     * @example 'is-visible'
     */
    formErrorClass: 'is-visible',

    /**
     * Set to true to validate text inputs on any value change.
     * @option
     * @example false
     */
    liveValidate: false,

    patterns: {
      alpha: /^[a-zA-Z]+$/,
      alpha_numeric: /^[a-zA-Z0-9]+$/,
      integer: /^[-+]?\d+$/,
      number: /^[-+]?\d*(?:[\.\,]\d+)?$/,

      // amex, visa, diners
      card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,
      cvv: /^([0-9]){3,4}$/,

      // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address
      email: /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,

      url: /^(https?|ftp|file|ssh):\/\/(((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/,
      // abc.de
      domain: /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,8}$/,

      datetime: /^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,
      // YYYY-MM-DD
      date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,
      // HH:MM:SS
      time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,
      dateISO: /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
      // MM/DD/YYYY
      month_day_year: /^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,
      // DD/MM/YYYY
      day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,

      // #FFF or #FFFFFF
      color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/
    },

    /**
     * Optional validation functions to be used. `equalTo` being the only default included function.
     * Functions should return only a boolean if the input is valid or not. Functions are given the following arguments:
     * el : The jQuery element to validate.
     * required : Boolean value of the required attribute be present or not.
     * parent : The direct parent of the input.
     * @option
     */
    validators: {
      equalTo: function (el, required, parent) {
        return $('#' + el.attr('data-equalto')).val() === el.val();
      }
    }
  };

  // Window exports
  Foundation.plugin(Abide, 'Abide');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Accordion module.
   * @module foundation.accordion
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   */

  var Accordion = function () {
    /**
     * Creates a new instance of an accordion.
     * @class
     * @fires Accordion#init
     * @param {jQuery} element - jQuery object to make into an accordion.
     * @param {Object} options - a plain object with settings to override the default options.
     */
    function Accordion(element, options) {
      _classCallCheck(this, Accordion);

      this.$element = element;
      this.options = $.extend({}, Accordion.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Accordion');
      Foundation.Keyboard.register('Accordion', {
        'ENTER': 'toggle',
        'SPACE': 'toggle',
        'ARROW_DOWN': 'next',
        'ARROW_UP': 'previous'
      });
    }

    /**
     * Initializes the accordion by animating the preset active pane(s).
     * @private
     */


    _createClass(Accordion, [{
      key: '_init',
      value: function _init() {
        this.$element.attr('role', 'tablist');
        this.$tabs = this.$element.children('li, [data-accordion-item]');

        this.$tabs.each(function (idx, el) {
          var $el = $(el),
              $content = $el.children('[data-tab-content]'),
              id = $content[0].id || Foundation.GetYoDigits(6, 'accordion'),
              linkId = el.id || id + '-label';

          $el.find('a:first').attr({
            'aria-controls': id,
            'role': 'tab',
            'id': linkId,
            'aria-expanded': false,
            'aria-selected': false
          });

          $content.attr({ 'role': 'tabpanel', 'aria-labelledby': linkId, 'aria-hidden': true, 'id': id });
        });
        var $initActive = this.$element.find('.is-active').children('[data-tab-content]');
        if ($initActive.length) {
          this.down($initActive, true);
        }
        this._events();
      }

      /**
       * Adds event handlers for items within the accordion.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;

        this.$tabs.each(function () {
          var $elem = $(this);
          var $tabContent = $elem.children('[data-tab-content]');
          if ($tabContent.length) {
            $elem.children('a').off('click.zf.accordion keydown.zf.accordion').on('click.zf.accordion', function (e) {
              // $(this).children('a').on('click.zf.accordion', function(e) {
              e.preventDefault();
              if ($elem.hasClass('is-active')) {
                if (_this.options.allowAllClosed || $elem.siblings().hasClass('is-active')) {
                  _this.up($tabContent);
                }
              } else {
                _this.down($tabContent);
              }
            }).on('keydown.zf.accordion', function (e) {
              Foundation.Keyboard.handleKey(e, 'Accordion', {
                toggle: function () {
                  _this.toggle($tabContent);
                },
                next: function () {
                  var $a = $elem.next().find('a').focus();
                  if (!_this.options.multiExpand) {
                    $a.trigger('click.zf.accordion');
                  }
                },
                previous: function () {
                  var $a = $elem.prev().find('a').focus();
                  if (!_this.options.multiExpand) {
                    $a.trigger('click.zf.accordion');
                  }
                },
                handled: function () {
                  e.preventDefault();
                  e.stopPropagation();
                }
              });
            });
          }
        });
      }

      /**
       * Toggles the selected content pane's open/close state.
       * @param {jQuery} $target - jQuery object of the pane to toggle.
       * @function
       */

    }, {
      key: 'toggle',
      value: function toggle($target) {
        if ($target.parent().hasClass('is-active')) {
          if (this.options.allowAllClosed || $target.parent().siblings().hasClass('is-active')) {
            this.up($target);
          } else {
            return;
          }
        } else {
          this.down($target);
        }
      }

      /**
       * Opens the accordion tab defined by `$target`.
       * @param {jQuery} $target - Accordion pane to open.
       * @param {Boolean} firstTime - flag to determine if reflow should happen.
       * @fires Accordion#down
       * @function
       */

    }, {
      key: 'down',
      value: function down($target, firstTime) {
        var _this2 = this;

        if (!this.options.multiExpand && !firstTime) {
          var $currentActive = this.$element.children('.is-active').children('[data-tab-content]');
          if ($currentActive.length) {
            this.up($currentActive);
          }
        }

        $target.attr('aria-hidden', false).parent('[data-tab-content]').addBack().parent().addClass('is-active');

        $target.slideDown(this.options.slideSpeed, function () {
          /**
           * Fires when the tab is done opening.
           * @event Accordion#down
           */
          _this2.$element.trigger('down.zf.accordion', [$target]);
        });

        $('#' + $target.attr('aria-labelledby')).attr({
          'aria-expanded': true,
          'aria-selected': true
        });
      }

      /**
       * Closes the tab defined by `$target`.
       * @param {jQuery} $target - Accordion tab to close.
       * @fires Accordion#up
       * @function
       */

    }, {
      key: 'up',
      value: function up($target) {
        var $aunts = $target.parent().siblings(),
            _this = this;
        var canClose = this.options.multiExpand ? $aunts.hasClass('is-active') : $target.parent().hasClass('is-active');

        if (!this.options.allowAllClosed && !canClose) {
          return;
        }

        // Foundation.Move(this.options.slideSpeed, $target, function(){
        $target.slideUp(_this.options.slideSpeed, function () {
          /**
           * Fires when the tab is done collapsing up.
           * @event Accordion#up
           */
          _this.$element.trigger('up.zf.accordion', [$target]);
        });
        // });

        $target.attr('aria-hidden', true).parent().removeClass('is-active');

        $('#' + $target.attr('aria-labelledby')).attr({
          'aria-expanded': false,
          'aria-selected': false
        });
      }

      /**
       * Destroys an instance of an accordion.
       * @fires Accordion#destroyed
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.find('[data-tab-content]').stop(true).slideUp(0).css('display', '');
        this.$element.find('a').off('.zf.accordion');

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Accordion;
  }();

  Accordion.defaults = {
    /**
     * Amount of time to animate the opening of an accordion pane.
     * @option
     * @example 250
     */
    slideSpeed: 250,
    /**
     * Allow the accordion to have multiple open panes.
     * @option
     * @example false
     */
    multiExpand: false,
    /**
     * Allow the accordion to close all panes.
     * @option
     * @example false
     */
    allowAllClosed: false
  };

  // Window exports
  Foundation.plugin(Accordion, 'Accordion');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * AccordionMenu module.
   * @module foundation.accordionMenu
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   * @requires foundation.util.nest
   */

  var AccordionMenu = function () {
    /**
     * Creates a new instance of an accordion menu.
     * @class
     * @fires AccordionMenu#init
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function AccordionMenu(element, options) {
      _classCallCheck(this, AccordionMenu);

      this.$element = element;
      this.options = $.extend({}, AccordionMenu.defaults, this.$element.data(), options);

      Foundation.Nest.Feather(this.$element, 'accordion');

      this._init();

      Foundation.registerPlugin(this, 'AccordionMenu');
      Foundation.Keyboard.register('AccordionMenu', {
        'ENTER': 'toggle',
        'SPACE': 'toggle',
        'ARROW_RIGHT': 'open',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'close',
        'ESCAPE': 'closeAll',
        'TAB': 'down',
        'SHIFT_TAB': 'up'
      });
    }

    /**
     * Initializes the accordion menu by hiding all nested menus.
     * @private
     */


    _createClass(AccordionMenu, [{
      key: '_init',
      value: function _init() {
        this.$element.find('[data-submenu]').not('.is-active').slideUp(0); //.find('a').css('padding-left', '1rem');
        this.$element.attr({
          'role': 'tablist',
          'aria-multiselectable': this.options.multiOpen
        });

        this.$menuLinks = this.$element.find('.is-accordion-submenu-parent');
        this.$menuLinks.each(function () {
          var linkId = this.id || Foundation.GetYoDigits(6, 'acc-menu-link'),
              $elem = $(this),
              $sub = $elem.children('[data-submenu]'),
              subId = $sub[0].id || Foundation.GetYoDigits(6, 'acc-menu'),
              isActive = $sub.hasClass('is-active');
          $elem.attr({
            'aria-controls': subId,
            'aria-expanded': isActive,
            'role': 'tab',
            'id': linkId
          });
          $sub.attr({
            'aria-labelledby': linkId,
            'aria-hidden': !isActive,
            'role': 'tabpanel',
            'id': subId
          });
        });
        var initPanes = this.$element.find('.is-active');
        if (initPanes.length) {
          var _this = this;
          initPanes.each(function () {
            _this.down($(this));
          });
        }
        this._events();
      }

      /**
       * Adds event handlers for items within the menu.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;

        this.$element.find('li').each(function () {
          var $submenu = $(this).children('[data-submenu]');

          if ($submenu.length) {
            $(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {
              e.preventDefault();

              _this.toggle($submenu);
            });
          }
        }).on('keydown.zf.accordionmenu', function (e) {
          var $element = $(this),
              $elements = $element.parent('ul').children('li'),
              $prevElement,
              $nextElement,
              $target = $element.children('[data-submenu]');

          $elements.each(function (i) {
            if ($(this).is($element)) {
              $prevElement = $elements.eq(Math.max(0, i - 1)).find('a').first();
              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1)).find('a').first();

              if ($(this).children('[data-submenu]:visible').length) {
                // has open sub menu
                $nextElement = $element.find('li:first-child').find('a').first();
              }
              if ($(this).is(':first-child')) {
                // is first element of sub menu
                $prevElement = $element.parents('li').first().find('a').first();
              } else if ($prevElement.children('[data-submenu]:visible').length) {
                // if previous element has open sub menu
                $prevElement = $prevElement.find('li:last-child').find('a').first();
              }
              if ($(this).is(':last-child')) {
                // is last element of sub menu
                $nextElement = $element.parents('li').first().next('li').find('a').first();
              }

              return;
            }
          });
          Foundation.Keyboard.handleKey(e, 'AccordionMenu', {
            open: function () {
              if ($target.is(':hidden')) {
                _this.down($target);
                $target.find('li').first().find('a').first().focus();
              }
            },
            close: function () {
              if ($target.length && !$target.is(':hidden')) {
                // close active sub of this item
                _this.up($target);
              } else if ($element.parent('[data-submenu]').length) {
                // close currently open sub
                _this.up($element.parent('[data-submenu]'));
                $element.parents('li').first().find('a').first().focus();
              }
            },
            up: function () {
              $prevElement.attr('tabindex', -1).focus();
              return true;
            },
            down: function () {
              $nextElement.attr('tabindex', -1).focus();
              return true;
            },
            toggle: function () {
              if ($element.children('[data-submenu]').length) {
                _this.toggle($element.children('[data-submenu]'));
              }
            },
            closeAll: function () {
              _this.hideAll();
            },
            handled: function (preventDefault) {
              if (preventDefault) {
                e.preventDefault();
              }
              e.stopImmediatePropagation();
            }
          });
        }); //.attr('tabindex', 0);
      }

      /**
       * Closes all panes of the menu.
       * @function
       */

    }, {
      key: 'hideAll',
      value: function hideAll() {
        this.$element.find('[data-submenu]').slideUp(this.options.slideSpeed);
      }

      /**
       * Toggles the open/close state of a submenu.
       * @function
       * @param {jQuery} $target - the submenu to toggle
       */

    }, {
      key: 'toggle',
      value: function toggle($target) {
        if (!$target.is(':animated')) {
          if (!$target.is(':hidden')) {
            this.up($target);
          } else {
            this.down($target);
          }
        }
      }

      /**
       * Opens the sub-menu defined by `$target`.
       * @param {jQuery} $target - Sub-menu to open.
       * @fires AccordionMenu#down
       */

    }, {
      key: 'down',
      value: function down($target) {
        var _this = this;

        if (!this.options.multiOpen) {
          this.up(this.$element.find('.is-active').not($target.parentsUntil(this.$element).add($target)));
        }

        $target.addClass('is-active').attr({ 'aria-hidden': false }).parent('.is-accordion-submenu-parent').attr({ 'aria-expanded': true });

        //Foundation.Move(this.options.slideSpeed, $target, function() {
        $target.slideDown(_this.options.slideSpeed, function () {
          /**
           * Fires when the menu is done opening.
           * @event AccordionMenu#down
           */
          _this.$element.trigger('down.zf.accordionMenu', [$target]);
        });
        //});
      }

      /**
       * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.
       * @param {jQuery} $target - Sub-menu to close.
       * @fires AccordionMenu#up
       */

    }, {
      key: 'up',
      value: function up($target) {
        var _this = this;
        //Foundation.Move(this.options.slideSpeed, $target, function(){
        $target.slideUp(_this.options.slideSpeed, function () {
          /**
           * Fires when the menu is done collapsing up.
           * @event AccordionMenu#up
           */
          _this.$element.trigger('up.zf.accordionMenu', [$target]);
        });
        //});

        var $menus = $target.find('[data-submenu]').slideUp(0).addBack().attr('aria-hidden', true);

        $menus.parent('.is-accordion-submenu-parent').attr('aria-expanded', false);
      }

      /**
       * Destroys an instance of accordion menu.
       * @fires AccordionMenu#destroyed
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.find('[data-submenu]').slideDown(0).css('display', '');
        this.$element.find('a').off('click.zf.accordionMenu');

        Foundation.Nest.Burn(this.$element, 'accordion');
        Foundation.unregisterPlugin(this);
      }
    }]);

    return AccordionMenu;
  }();

  AccordionMenu.defaults = {
    /**
     * Amount of time to animate the opening of a submenu in ms.
     * @option
     * @example 250
     */
    slideSpeed: 250,
    /**
     * Allow the menu to have multiple open panes.
     * @option
     * @example true
     */
    multiOpen: true
  };

  // Window exports
  Foundation.plugin(AccordionMenu, 'AccordionMenu');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Drilldown module.
   * @module foundation.drilldown
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   * @requires foundation.util.nest
   */

  var Drilldown = function () {
    /**
     * Creates a new instance of a drilldown menu.
     * @class
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Drilldown(element, options) {
      _classCallCheck(this, Drilldown);

      this.$element = element;
      this.options = $.extend({}, Drilldown.defaults, this.$element.data(), options);

      Foundation.Nest.Feather(this.$element, 'drilldown');

      this._init();

      Foundation.registerPlugin(this, 'Drilldown');
      Foundation.Keyboard.register('Drilldown', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'previous',
        'ESCAPE': 'close',
        'TAB': 'down',
        'SHIFT_TAB': 'up'
      });
    }

    /**
     * Initializes the drilldown by creating jQuery collections of elements
     * @private
     */


    _createClass(Drilldown, [{
      key: '_init',
      value: function _init() {
        this.$submenuAnchors = this.$element.find('li.is-drilldown-submenu-parent').children('a');
        this.$submenus = this.$submenuAnchors.parent('li').children('[data-submenu]');
        this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'menuitem').find('a');

        this._prepareMenu();

        this._keyboardEvents();
      }

      /**
       * prepares drilldown menu by setting attributes to links and elements
       * sets a min height to prevent content jumping
       * wraps the element if not already wrapped
       * @private
       * @function
       */

    }, {
      key: '_prepareMenu',
      value: function _prepareMenu() {
        var _this = this;
        // if(!this.options.holdOpen){
        //   this._menuLinkEvents();
        // }
        this.$submenuAnchors.each(function () {
          var $link = $(this);
          var $sub = $link.parent();
          if (_this.options.parentLink) {
            $link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li class="is-submenu-parent-item is-submenu-item is-drilldown-submenu-item" role="menu-item"></li>');
          }
          $link.data('savedHref', $link.attr('href')).removeAttr('href');
          $link.children('[data-submenu]').attr({
            'aria-hidden': true,
            'tabindex': 0,
            'role': 'menu'
          });
          _this._events($link);
        });
        this.$submenus.each(function () {
          var $menu = $(this),
              $back = $menu.find('.js-drilldown-back');
          if (!$back.length) {
            $menu.prepend(_this.options.backButton);
          }
          _this._back($menu);
        });
        if (!this.$element.parent().hasClass('is-drilldown')) {
          this.$wrapper = $(this.options.wrapper).addClass('is-drilldown');
          this.$wrapper = this.$element.wrap(this.$wrapper).parent().css(this._getMaxDims());
        }
      }

      /**
       * Adds event handlers to elements in the menu.
       * @function
       * @private
       * @param {jQuery} $elem - the current menu item to add handlers to.
       */

    }, {
      key: '_events',
      value: function _events($elem) {
        var _this = this;

        $elem.off('click.zf.drilldown').on('click.zf.drilldown', function (e) {
          if ($(e.target).parentsUntil('ul', 'li').hasClass('is-drilldown-submenu-parent')) {
            e.stopImmediatePropagation();
            e.preventDefault();
          }

          // if(e.target !== e.currentTarget.firstElementChild){
          //   return false;
          // }
          _this._show($elem.parent('li'));

          if (_this.options.closeOnClick) {
            var $body = $('body');
            $body.off('.zf.drilldown').on('click.zf.drilldown', function (e) {
              if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {
                return;
              }
              e.preventDefault();
              _this._hideAll();
              $body.off('.zf.drilldown');
            });
          }
        });
      }

      /**
       * Adds keydown event listener to `li`'s in the menu.
       * @private
       */

    }, {
      key: '_keyboardEvents',
      value: function _keyboardEvents() {
        var _this = this;

        this.$menuItems.add(this.$element.find('.js-drilldown-back > a')).on('keydown.zf.drilldown', function (e) {

          var $element = $(this),
              $elements = $element.parent('li').parent('ul').children('li').children('a'),
              $prevElement,
              $nextElement;

          $elements.each(function (i) {
            if ($(this).is($element)) {
              $prevElement = $elements.eq(Math.max(0, i - 1));
              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));
              return;
            }
          });

          Foundation.Keyboard.handleKey(e, 'Drilldown', {
            next: function () {
              if ($element.is(_this.$submenuAnchors)) {
                _this._show($element.parent('li'));
                $element.parent('li').one(Foundation.transitionend($element), function () {
                  $element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();
                });
                return true;
              }
            },
            previous: function () {
              _this._hide($element.parent('li').parent('ul'));
              $element.parent('li').parent('ul').one(Foundation.transitionend($element), function () {
                setTimeout(function () {
                  $element.parent('li').parent('ul').parent('li').children('a').first().focus();
                }, 1);
              });
              return true;
            },
            up: function () {
              $prevElement.focus();
              return true;
            },
            down: function () {
              $nextElement.focus();
              return true;
            },
            close: function () {
              _this._back();
              //_this.$menuItems.first().focus(); // focus to first element
            },
            open: function () {
              if (!$element.is(_this.$menuItems)) {
                // not menu item means back button
                _this._hide($element.parent('li').parent('ul'));
                $element.parent('li').parent('ul').one(Foundation.transitionend($element), function () {
                  setTimeout(function () {
                    $element.parent('li').parent('ul').parent('li').children('a').first().focus();
                  }, 1);
                });
              } else if ($element.is(_this.$submenuAnchors)) {
                _this._show($element.parent('li'));
                $element.parent('li').one(Foundation.transitionend($element), function () {
                  $element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();
                });
              }
              return true;
            },
            handled: function (preventDefault) {
              if (preventDefault) {
                e.preventDefault();
              }
              e.stopImmediatePropagation();
            }
          });
        }); // end keyboardAccess
      }

      /**
       * Closes all open elements, and returns to root menu.
       * @function
       * @fires Drilldown#closed
       */

    }, {
      key: '_hideAll',
      value: function _hideAll() {
        var $elem = this.$element.find('.is-drilldown-submenu.is-active').addClass('is-closing');
        $elem.one(Foundation.transitionend($elem), function (e) {
          $elem.removeClass('is-active is-closing');
        });
        /**
         * Fires when the menu is fully closed.
         * @event Drilldown#closed
         */
        this.$element.trigger('closed.zf.drilldown');
      }

      /**
       * Adds event listener for each `back` button, and closes open menus.
       * @function
       * @fires Drilldown#back
       * @param {jQuery} $elem - the current sub-menu to add `back` event.
       */

    }, {
      key: '_back',
      value: function _back($elem) {
        var _this = this;
        $elem.off('click.zf.drilldown');
        $elem.children('.js-drilldown-back').on('click.zf.drilldown', function (e) {
          e.stopImmediatePropagation();
          // console.log('mouseup on back');
          _this._hide($elem);
        });
      }

      /**
       * Adds event listener to menu items w/o submenus to close open menus on click.
       * @function
       * @private
       */

    }, {
      key: '_menuLinkEvents',
      value: function _menuLinkEvents() {
        var _this = this;
        this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown', function (e) {
          // e.stopImmediatePropagation();
          setTimeout(function () {
            _this._hideAll();
          }, 0);
        });
      }

      /**
       * Opens a submenu.
       * @function
       * @fires Drilldown#open
       * @param {jQuery} $elem - the current element with a submenu to open, i.e. the `li` tag.
       */

    }, {
      key: '_show',
      value: function _show($elem) {
        $elem.children('[data-submenu]').addClass('is-active');
        /**
         * Fires when the submenu has opened.
         * @event Drilldown#open
         */
        this.$element.trigger('open.zf.drilldown', [$elem]);
      }
    }, {
      key: '_hide',


      /**
       * Hides a submenu
       * @function
       * @fires Drilldown#hide
       * @param {jQuery} $elem - the current sub-menu to hide, i.e. the `ul` tag.
       */
      value: function _hide($elem) {
        var _this = this;
        $elem.addClass('is-closing').one(Foundation.transitionend($elem), function () {
          $elem.removeClass('is-active is-closing');
          $elem.blur();
        });
        /**
         * Fires when the submenu has closed.
         * @event Drilldown#hide
         */
        $elem.trigger('hide.zf.drilldown', [$elem]);
      }

      /**
       * Iterates through the nested menus to calculate the min-height, and max-width for the menu.
       * Prevents content jumping.
       * @function
       * @private
       */

    }, {
      key: '_getMaxDims',
      value: function _getMaxDims() {
        var max = 0,
            result = {};
        this.$submenus.add(this.$element).each(function () {
          var numOfElems = $(this).children('li').length;
          max = numOfElems > max ? numOfElems : max;
        });

        result['min-height'] = max * this.$menuItems[0].getBoundingClientRect().height + 'px';
        result['max-width'] = this.$element[0].getBoundingClientRect().width + 'px';

        return result;
      }

      /**
       * Destroys the Drilldown Menu
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this._hideAll();
        Foundation.Nest.Burn(this.$element, 'drilldown');
        this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role');
        this.$submenuAnchors.each(function () {
          $(this).off('.zf.drilldown');
        });
        this.$element.find('a').each(function () {
          var $link = $(this);
          if ($link.data('savedHref')) {
            $link.attr('href', $link.data('savedHref')).removeData('savedHref');
          } else {
            return;
          }
        });
        Foundation.unregisterPlugin(this);
      }
    }]);

    return Drilldown;
  }();

  Drilldown.defaults = {
    /**
     * Markup used for JS generated back button. Prepended to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\`) if copy and pasting.
     * @option
     * @example '<\li><\a>Back<\/a><\/li>'
     */
    backButton: '<li class="js-drilldown-back"><a tabindex="0">Back</a></li>',
    /**
     * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\`) if copy and pasting.
     * @option
     * @example '<\div class="is-drilldown"><\/div>'
     */
    wrapper: '<div></div>',
    /**
     * Adds the parent link to the submenu.
     * @option
     * @example false
     */
    parentLink: false,
    /**
     * Allow the menu to return to root list on body click.
     * @option
     * @example false
     */
    closeOnClick: false
    // holdOpen: false
  };

  // Window exports
  Foundation.plugin(Drilldown, 'Drilldown');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Dropdown module.
   * @module foundation.dropdown
   * @requires foundation.util.keyboard
   * @requires foundation.util.box
   * @requires foundation.util.triggers
   */

  var Dropdown = function () {
    /**
     * Creates a new instance of a dropdown.
     * @class
     * @param {jQuery} element - jQuery object to make into a dropdown.
     *        Object should be of the dropdown panel, rather than its anchor.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Dropdown(element, options) {
      _classCallCheck(this, Dropdown);

      this.$element = element;
      this.options = $.extend({}, Dropdown.defaults, this.$element.data(), options);
      this._init();

      Foundation.registerPlugin(this, 'Dropdown');
      Foundation.Keyboard.register('Dropdown', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ESCAPE': 'close',
        'TAB': 'tab_forward',
        'SHIFT_TAB': 'tab_backward'
      });
    }

    /**
     * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.
     * @function
     * @private
     */


    _createClass(Dropdown, [{
      key: '_init',
      value: function _init() {
        var $id = this.$element.attr('id');

        this.$anchor = $('[data-toggle="' + $id + '"]') || $('[data-open="' + $id + '"]');
        this.$anchor.attr({
          'aria-controls': $id,
          'data-is-focus': false,
          'data-yeti-box': $id,
          'aria-haspopup': true,
          'aria-expanded': false

        });

        this.options.positionClass = this.getPositionClass();
        this.counter = 4;
        this.usedPositions = [];
        this.$element.attr({
          'aria-hidden': 'true',
          'data-yeti-box': $id,
          'data-resize': $id,
          'aria-labelledby': this.$anchor[0].id || Foundation.GetYoDigits(6, 'dd-anchor')
        });
        this._events();
      }

      /**
       * Helper function to determine current orientation of dropdown pane.
       * @function
       * @returns {String} position - string value of a position class.
       */

    }, {
      key: 'getPositionClass',
      value: function getPositionClass() {
        var verticalPosition = this.$element[0].className.match(/(top|left|right|bottom)/g);
        verticalPosition = verticalPosition ? verticalPosition[0] : '';
        var horizontalPosition = /float-(\S+)\s/.exec(this.$anchor[0].className);
        horizontalPosition = horizontalPosition ? horizontalPosition[1] : '';
        var position = horizontalPosition ? horizontalPosition + ' ' + verticalPosition : verticalPosition;
        return position;
      }

      /**
       * Adjusts the dropdown panes orientation by adding/removing positioning classes.
       * @function
       * @private
       * @param {String} position - position class to remove.
       */

    }, {
      key: '_reposition',
      value: function _reposition(position) {
        this.usedPositions.push(position ? position : 'bottom');
        //default, try switching to opposite side
        if (!position && this.usedPositions.indexOf('top') < 0) {
          this.$element.addClass('top');
        } else if (position === 'top' && this.usedPositions.indexOf('bottom') < 0) {
          this.$element.removeClass(position);
        } else if (position === 'left' && this.usedPositions.indexOf('right') < 0) {
          this.$element.removeClass(position).addClass('right');
        } else if (position === 'right' && this.usedPositions.indexOf('left') < 0) {
          this.$element.removeClass(position).addClass('left');
        }

        //if default change didn't work, try bottom or left first
        else if (!position && this.usedPositions.indexOf('top') > -1 && this.usedPositions.indexOf('left') < 0) {
            this.$element.addClass('left');
          } else if (position === 'top' && this.usedPositions.indexOf('bottom') > -1 && this.usedPositions.indexOf('left') < 0) {
            this.$element.removeClass(position).addClass('left');
          } else if (position === 'left' && this.usedPositions.indexOf('right') > -1 && this.usedPositions.indexOf('bottom') < 0) {
            this.$element.removeClass(position);
          } else if (position === 'right' && this.usedPositions.indexOf('left') > -1 && this.usedPositions.indexOf('bottom') < 0) {
            this.$element.removeClass(position);
          }
          //if nothing cleared, set to bottom
          else {
              this.$element.removeClass(position);
            }
        this.classChanged = true;
        this.counter--;
      }

      /**
       * Sets the position and orientation of the dropdown pane, checks for collisions.
       * Recursively calls itself if a collision is detected, with a new position class.
       * @function
       * @private
       */

    }, {
      key: '_setPosition',
      value: function _setPosition() {
        if (this.$anchor.attr('aria-expanded') === 'false') {
          return false;
        }
        var position = this.getPositionClass(),
            $eleDims = Foundation.Box.GetDimensions(this.$element),
            $anchorDims = Foundation.Box.GetDimensions(this.$anchor),
            _this = this,
            direction = position === 'left' ? 'left' : position === 'right' ? 'left' : 'top',
            param = direction === 'top' ? 'height' : 'width',
            offset = param === 'height' ? this.options.vOffset : this.options.hOffset;

        if ($eleDims.width >= $eleDims.windowDims.width || !this.counter && !Foundation.Box.ImNotTouchingYou(this.$element)) {
          this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({
            'width': $eleDims.windowDims.width - this.options.hOffset * 2,
            'height': 'auto'
          });
          this.classChanged = true;
          return false;
        }

        this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, position, this.options.vOffset, this.options.hOffset));

        while (!Foundation.Box.ImNotTouchingYou(this.$element, false, true) && this.counter) {
          this._reposition(position);
          this._setPosition();
        }
      }

      /**
       * Adds event listeners to the element utilizing the triggers utility library.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;
        this.$element.on({
          'open.zf.trigger': this.open.bind(this),
          'close.zf.trigger': this.close.bind(this),
          'toggle.zf.trigger': this.toggle.bind(this),
          'resizeme.zf.trigger': this._setPosition.bind(this)
        });

        if (this.options.hover) {
          this.$anchor.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {
            clearTimeout(_this.timeout);
            _this.timeout = setTimeout(function () {
              _this.open();
              _this.$anchor.data('hover', true);
            }, _this.options.hoverDelay);
          }).on('mouseleave.zf.dropdown', function () {
            clearTimeout(_this.timeout);
            _this.timeout = setTimeout(function () {
              _this.close();
              _this.$anchor.data('hover', false);
            }, _this.options.hoverDelay);
          });
          if (this.options.hoverPane) {
            this.$element.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {
              clearTimeout(_this.timeout);
            }).on('mouseleave.zf.dropdown', function () {
              clearTimeout(_this.timeout);
              _this.timeout = setTimeout(function () {
                _this.close();
                _this.$anchor.data('hover', false);
              }, _this.options.hoverDelay);
            });
          }
        }
        this.$anchor.add(this.$element).on('keydown.zf.dropdown', function (e) {

          var $target = $(this),
              visibleFocusableElements = Foundation.Keyboard.findFocusable(_this.$element);

          Foundation.Keyboard.handleKey(e, 'Dropdown', {
            tab_forward: function () {
              if (_this.$element.find(':focus').is(visibleFocusableElements.eq(-1))) {
                // left modal downwards, setting focus to first element
                if (_this.options.trapFocus) {
                  // if focus shall be trapped
                  visibleFocusableElements.eq(0).focus();
                  e.preventDefault();
                } else {
                  // if focus is not trapped, close dropdown on focus out
                  _this.close();
                }
              }
            },
            tab_backward: function () {
              if (_this.$element.find(':focus').is(visibleFocusableElements.eq(0)) || _this.$element.is(':focus')) {
                // left modal upwards, setting focus to last element
                if (_this.options.trapFocus) {
                  // if focus shall be trapped
                  visibleFocusableElements.eq(-1).focus();
                  e.preventDefault();
                } else {
                  // if focus is not trapped, close dropdown on focus out
                  _this.close();
                }
              }
            },
            open: function () {
              if ($target.is(_this.$anchor)) {
                _this.open();
                _this.$element.attr('tabindex', -1).focus();
                e.preventDefault();
              }
            },
            close: function () {
              _this.close();
              _this.$anchor.focus();
            }
          });
        });
      }

      /**
       * Adds an event handler to the body to close any dropdowns on a click.
       * @function
       * @private
       */

    }, {
      key: '_addBodyHandler',
      value: function _addBodyHandler() {
        var $body = $(document.body).not(this.$element),
            _this = this;
        $body.off('click.zf.dropdown').on('click.zf.dropdown', function (e) {
          if (_this.$anchor.is(e.target) || _this.$anchor.find(e.target).length) {
            return;
          }
          if (_this.$element.find(e.target).length) {
            return;
          }
          _this.close();
          $body.off('click.zf.dropdown');
        });
      }

      /**
       * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.
       * @function
       * @fires Dropdown#closeme
       * @fires Dropdown#show
       */

    }, {
      key: 'open',
      value: function open() {
        // var _this = this;
        /**
         * Fires to close other open dropdowns
         * @event Dropdown#closeme
         */
        this.$element.trigger('closeme.zf.dropdown', this.$element.attr('id'));
        this.$anchor.addClass('hover').attr({ 'aria-expanded': true });
        // this.$element/*.show()*/;
        this._setPosition();
        this.$element.addClass('is-open').attr({ 'aria-hidden': false });

        if (this.options.autoFocus) {
          var $focusable = Foundation.Keyboard.findFocusable(this.$element);
          if ($focusable.length) {
            $focusable.eq(0).focus();
          }
        }

        if (this.options.closeOnClick) {
          this._addBodyHandler();
        }

        /**
         * Fires once the dropdown is visible.
         * @event Dropdown#show
         */
        this.$element.trigger('show.zf.dropdown', [this.$element]);
      }

      /**
       * Closes the open dropdown pane.
       * @function
       * @fires Dropdown#hide
       */

    }, {
      key: 'close',
      value: function close() {
        if (!this.$element.hasClass('is-open')) {
          return false;
        }
        this.$element.removeClass('is-open').attr({ 'aria-hidden': true });

        this.$anchor.removeClass('hover').attr('aria-expanded', false);

        if (this.classChanged) {
          var curPositionClass = this.getPositionClass();
          if (curPositionClass) {
            this.$element.removeClass(curPositionClass);
          }
          this.$element.addClass(this.options.positionClass)
          /*.hide()*/.css({ height: '', width: '' });
          this.classChanged = false;
          this.counter = 4;
          this.usedPositions.length = 0;
        }
        this.$element.trigger('hide.zf.dropdown', [this.$element]);
      }

      /**
       * Toggles the dropdown pane's visibility.
       * @function
       */

    }, {
      key: 'toggle',
      value: function toggle() {
        if (this.$element.hasClass('is-open')) {
          if (this.$anchor.data('hover')) return;
          this.close();
        } else {
          this.open();
        }
      }

      /**
       * Destroys the dropdown.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.off('.zf.trigger').hide();
        this.$anchor.off('.zf.dropdown');

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Dropdown;
  }();

  Dropdown.defaults = {
    /**
     * Amount of time to delay opening a submenu on hover event.
     * @option
     * @example 250
     */
    hoverDelay: 250,
    /**
     * Allow submenus to open on hover events
     * @option
     * @example false
     */
    hover: false,
    /**
     * Don't close dropdown when hovering over dropdown pane
     * @option
     * @example true
     */
    hoverPane: false,
    /**
     * Number of pixels between the dropdown pane and the triggering element on open.
     * @option
     * @example 1
     */
    vOffset: 1,
    /**
     * Number of pixels between the dropdown pane and the triggering element on open.
     * @option
     * @example 1
     */
    hOffset: 1,
    /**
     * Class applied to adjust open position. JS will test and fill this in.
     * @option
     * @example 'top'
     */
    positionClass: '',
    /**
     * Allow the plugin to trap focus to the dropdown pane if opened with keyboard commands.
     * @option
     * @example false
     */
    trapFocus: false,
    /**
     * Allow the plugin to set focus to the first focusable element within the pane, regardless of method of opening.
     * @option
     * @example true
     */
    autoFocus: false,
    /**
     * Allows a click on the body to close the dropdown.
     * @option
     * @example false
     */
    closeOnClick: false
  };

  // Window exports
  Foundation.plugin(Dropdown, 'Dropdown');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * DropdownMenu module.
   * @module foundation.dropdown-menu
   * @requires foundation.util.keyboard
   * @requires foundation.util.box
   * @requires foundation.util.nest
   */

  var DropdownMenu = function () {
    /**
     * Creates a new instance of DropdownMenu.
     * @class
     * @fires DropdownMenu#init
     * @param {jQuery} element - jQuery object to make into a dropdown menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function DropdownMenu(element, options) {
      _classCallCheck(this, DropdownMenu);

      this.$element = element;
      this.options = $.extend({}, DropdownMenu.defaults, this.$element.data(), options);

      Foundation.Nest.Feather(this.$element, 'dropdown');
      this._init();

      Foundation.registerPlugin(this, 'DropdownMenu');
      Foundation.Keyboard.register('DropdownMenu', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'previous',
        'ESCAPE': 'close'
      });
    }

    /**
     * Initializes the plugin, and calls _prepareMenu
     * @private
     * @function
     */


    _createClass(DropdownMenu, [{
      key: '_init',
      value: function _init() {
        var subs = this.$element.find('li.is-dropdown-submenu-parent');
        this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');

        this.$menuItems = this.$element.find('[role="menuitem"]');
        this.$tabs = this.$element.children('[role="menuitem"]');
        this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);

        if (this.$element.hasClass(this.options.rightClass) || this.options.alignment === 'right' || Foundation.rtl() || this.$element.parents('.top-bar-right').is('*')) {
          this.options.alignment = 'right';
          subs.addClass('opens-left');
        } else {
          subs.addClass('opens-right');
        }
        this.changed = false;
        this._events();
      }
    }, {
      key: '_events',

      /**
       * Adds event listeners to elements within the menu
       * @private
       * @function
       */
      value: function _events() {
        var _this = this,
            hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined',
            parClass = 'is-dropdown-submenu-parent';

        // used for onClick and in the keyboard handlers
        var handleClickFn = function (e) {
          var $elem = $(e.target).parentsUntil('ul', '.' + parClass),
              hasSub = $elem.hasClass(parClass),
              hasClicked = $elem.attr('data-is-click') === 'true',
              $sub = $elem.children('.is-dropdown-submenu');

          if (hasSub) {
            if (hasClicked) {
              if (!_this.options.closeOnClick || !_this.options.clickOpen && !hasTouch || _this.options.forceFollow && hasTouch) {
                return;
              } else {
                e.stopImmediatePropagation();
                e.preventDefault();
                _this._hide($elem);
              }
            } else {
              e.preventDefault();
              e.stopImmediatePropagation();
              _this._show($elem.children('.is-dropdown-submenu'));
              $elem.add($elem.parentsUntil(_this.$element, '.' + parClass)).attr('data-is-click', true);
            }
          } else {
            return;
          }
        };

        if (this.options.clickOpen || hasTouch) {
          this.$menuItems.on('click.zf.dropdownmenu touchstart.zf.dropdownmenu', handleClickFn);
        }

        if (!this.options.disableHover) {
          this.$menuItems.on('mouseenter.zf.dropdownmenu', function (e) {
            var $elem = $(this),
                hasSub = $elem.hasClass(parClass);

            if (hasSub) {
              clearTimeout(_this.delay);
              _this.delay = setTimeout(function () {
                _this._show($elem.children('.is-dropdown-submenu'));
              }, _this.options.hoverDelay);
            }
          }).on('mouseleave.zf.dropdownmenu', function (e) {
            var $elem = $(this),
                hasSub = $elem.hasClass(parClass);
            if (hasSub && _this.options.autoclose) {
              if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) {
                return false;
              }

              clearTimeout(_this.delay);
              _this.delay = setTimeout(function () {
                _this._hide($elem);
              }, _this.options.closingTime);
            }
          });
        }
        this.$menuItems.on('keydown.zf.dropdownmenu', function (e) {
          var $element = $(e.target).parentsUntil('ul', '[role="menuitem"]'),
              isTab = _this.$tabs.index($element) > -1,
              $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),
              $prevElement,
              $nextElement;

          $elements.each(function (i) {
            if ($(this).is($element)) {
              $prevElement = $elements.eq(i - 1);
              $nextElement = $elements.eq(i + 1);
              return;
            }
          });

          var nextSibling = function () {
            if (!$element.is(':last-child')) {
              $nextElement.children('a:first').focus();
              e.preventDefault();
            }
          },
              prevSibling = function () {
            $prevElement.children('a:first').focus();
            e.preventDefault();
          },
              openSub = function () {
            var $sub = $element.children('ul.is-dropdown-submenu');
            if ($sub.length) {
              _this._show($sub);
              $element.find('li > a:first').focus();
              e.preventDefault();
            } else {
              return;
            }
          },
              closeSub = function () {
            //if ($element.is(':first-child')) {
            var close = $element.parent('ul').parent('li');
            close.children('a:first').focus();
            _this._hide(close);
            e.preventDefault();
            //}
          };
          var functions = {
            open: openSub,
            close: function () {
              _this._hide(_this.$element);
              _this.$menuItems.find('a:first').focus(); // focus to first element
              e.preventDefault();
            },
            handled: function () {
              e.stopImmediatePropagation();
            }
          };

          if (isTab) {
            if (_this.$element.hasClass(_this.options.verticalClass)) {
              // vertical menu
              if (_this.options.alignment === 'left') {
                // left aligned
                $.extend(functions, {
                  down: nextSibling,
                  up: prevSibling,
                  next: openSub,
                  previous: closeSub
                });
              } else {
                // right aligned
                $.extend(functions, {
                  down: nextSibling,
                  up: prevSibling,
                  next: closeSub,
                  previous: openSub
                });
              }
            } else {
              // horizontal menu
              $.extend(functions, {
                next: nextSibling,
                previous: prevSibling,
                down: openSub,
                up: closeSub
              });
            }
          } else {
            // not tabs -> one sub
            if (_this.options.alignment === 'left') {
              // left aligned
              $.extend(functions, {
                next: openSub,
                previous: closeSub,
                down: nextSibling,
                up: prevSibling
              });
            } else {
              // right aligned
              $.extend(functions, {
                next: closeSub,
                previous: openSub,
                down: nextSibling,
                up: prevSibling
              });
            }
          }
          Foundation.Keyboard.handleKey(e, 'DropdownMenu', functions);
        });
      }

      /**
       * Adds an event handler to the body to close any dropdowns on a click.
       * @function
       * @private
       */

    }, {
      key: '_addBodyHandler',
      value: function _addBodyHandler() {
        var $body = $(document.body),
            _this = this;
        $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu').on('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu', function (e) {
          var $link = _this.$element.find(e.target);
          if ($link.length) {
            return;
          }

          _this._hide();
          $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu');
        });
      }

      /**
       * Opens a dropdown pane, and checks for collisions first.
       * @param {jQuery} $sub - ul element that is a submenu to show
       * @function
       * @private
       * @fires DropdownMenu#show
       */

    }, {
      key: '_show',
      value: function _show($sub) {
        var idx = this.$tabs.index(this.$tabs.filter(function (i, el) {
          return $(el).find($sub).length > 0;
        }));
        var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');
        this._hide($sibs, idx);
        $sub.css('visibility', 'hidden').addClass('js-dropdown-active').attr({ 'aria-hidden': false }).parent('li.is-dropdown-submenu-parent').addClass('is-active').attr({ 'aria-expanded': true });
        var clear = Foundation.Box.ImNotTouchingYou($sub, null, true);
        if (!clear) {
          var oldClass = this.options.alignment === 'left' ? '-right' : '-left',
              $parentLi = $sub.parent('.is-dropdown-submenu-parent');
          $parentLi.removeClass('opens' + oldClass).addClass('opens-' + this.options.alignment);
          clear = Foundation.Box.ImNotTouchingYou($sub, null, true);
          if (!clear) {
            $parentLi.removeClass('opens-' + this.options.alignment).addClass('opens-inner');
          }
          this.changed = true;
        }
        $sub.css('visibility', '');
        if (this.options.closeOnClick) {
          this._addBodyHandler();
        }
        /**
         * Fires when the new dropdown pane is visible.
         * @event DropdownMenu#show
         */
        this.$element.trigger('show.zf.dropdownmenu', [$sub]);
      }

      /**
       * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.
       * @function
       * @param {jQuery} $elem - element with a submenu to hide
       * @param {Number} idx - index of the $tabs collection to hide
       * @private
       */

    }, {
      key: '_hide',
      value: function _hide($elem, idx) {
        var $toClose;
        if ($elem && $elem.length) {
          $toClose = $elem;
        } else if (idx !== undefined) {
          $toClose = this.$tabs.not(function (i, el) {
            return i === idx;
          });
        } else {
          $toClose = this.$element;
        }
        var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;

        if (somethingToClose) {
          $toClose.find('li.is-active').add($toClose).attr({
            'aria-expanded': false,
            'data-is-click': false
          }).removeClass('is-active');

          $toClose.find('ul.js-dropdown-active').attr({
            'aria-hidden': true
          }).removeClass('js-dropdown-active');

          if (this.changed || $toClose.find('opens-inner').length) {
            var oldClass = this.options.alignment === 'left' ? 'right' : 'left';
            $toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass('opens-inner opens-' + this.options.alignment).addClass('opens-' + oldClass);
            this.changed = false;
          }
          /**
           * Fires when the open menus are closed.
           * @event DropdownMenu#hide
           */
          this.$element.trigger('hide.zf.dropdownmenu', [$toClose]);
        }
      }

      /**
       * Destroys the plugin.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$menuItems.off('.zf.dropdownmenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');
        $(document.body).off('.zf.dropdownmenu');
        Foundation.Nest.Burn(this.$element, 'dropdown');
        Foundation.unregisterPlugin(this);
      }
    }]);

    return DropdownMenu;
  }();

  /**
   * Default settings for plugin
   */


  DropdownMenu.defaults = {
    /**
     * Disallows hover events from opening submenus
     * @option
     * @example false
     */
    disableHover: false,
    /**
     * Allow a submenu to automatically close on a mouseleave event, if not clicked open.
     * @option
     * @example true
     */
    autoclose: true,
    /**
     * Amount of time to delay opening a submenu on hover event.
     * @option
     * @example 50
     */
    hoverDelay: 50,
    /**
     * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.
     * @option
     * @example true
     */
    clickOpen: false,
    /**
     * Amount of time to delay closing a submenu on a mouseleave event.
     * @option
     * @example 500
     */

    closingTime: 200,
    /**
     * Position of the menu relative to what direction the submenus should open. Handled by JS.
     * @option
     * @example 'left'
     */
    alignment: 'left',
    /**
     * Allow clicks on the body to close any open submenus.
     * @option
     * @example true
     */
    closeOnClick: true,
    /**
     * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.
     * @option
     * @example 'vertical'
     */
    verticalClass: 'vertical',
    /**
     * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.
     * @option
     * @example 'align-right'
     */
    rightClass: 'align-right',
    /**
     * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.
     * @option
     * @example false
     */
    forceFollow: true
  };

  // Window exports
  Foundation.plugin(DropdownMenu, 'DropdownMenu');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Equalizer module.
   * @module foundation.equalizer
   */

  var Equalizer = function () {
    /**
     * Creates a new instance of Equalizer.
     * @class
     * @fires Equalizer#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Equalizer(element, options) {
      _classCallCheck(this, Equalizer);

      this.$element = element;
      this.options = $.extend({}, Equalizer.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Equalizer');
    }

    /**
     * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.
     * @private
     */


    _createClass(Equalizer, [{
      key: '_init',
      value: function _init() {
        var eqId = this.$element.attr('data-equalizer') || '';
        var $watched = this.$element.find('[data-equalizer-watch="' + eqId + '"]');

        this.$watched = $watched.length ? $watched : this.$element.find('[data-equalizer-watch]');
        this.$element.attr('data-resize', eqId || Foundation.GetYoDigits(6, 'eq'));

        this.hasNested = this.$element.find('[data-equalizer]').length > 0;
        this.isNested = this.$element.parentsUntil(document.body, '[data-equalizer]').length > 0;
        this.isOn = false;
        this._bindHandler = {
          onResizeMeBound: this._onResizeMe.bind(this),
          onPostEqualizedBound: this._onPostEqualized.bind(this)
        };

        var imgs = this.$element.find('img');
        var tooSmall;
        if (this.options.equalizeOn) {
          tooSmall = this._checkMQ();
          $(window).on('changed.zf.mediaquery', this._checkMQ.bind(this));
        } else {
          this._events();
        }
        if (tooSmall !== undefined && tooSmall === false || tooSmall === undefined) {
          if (imgs.length) {
            Foundation.onImagesLoaded(imgs, this._reflow.bind(this));
          } else {
            this._reflow();
          }
        }
      }

      /**
       * Removes event listeners if the breakpoint is too small.
       * @private
       */

    }, {
      key: '_pauseEvents',
      value: function _pauseEvents() {
        this.isOn = false;
        this.$element.off({
          '.zf.equalizer': this._bindHandler.onPostEqualizedBound,
          'resizeme.zf.trigger': this._bindHandler.onResizeMeBound
        });
      }

      /**
       * function to handle $elements resizeme.zf.trigger, with bound this on _bindHandler.onResizeMeBound
       * @private
       */

    }, {
      key: '_onResizeMe',
      value: function _onResizeMe(e) {
        this._reflow();
      }

      /**
       * function to handle $elements postequalized.zf.equalizer, with bound this on _bindHandler.onPostEqualizedBound
       * @private
       */

    }, {
      key: '_onPostEqualized',
      value: function _onPostEqualized(e) {
        if (e.target !== this.$element[0]) {
          this._reflow();
        }
      }

      /**
       * Initializes events for Equalizer.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;
        this._pauseEvents();
        if (this.hasNested) {
          this.$element.on('postequalized.zf.equalizer', this._bindHandler.onPostEqualizedBound);
        } else {
          this.$element.on('resizeme.zf.trigger', this._bindHandler.onResizeMeBound);
        }
        this.isOn = true;
      }

      /**
       * Checks the current breakpoint to the minimum required size.
       * @private
       */

    }, {
      key: '_checkMQ',
      value: function _checkMQ() {
        var tooSmall = !Foundation.MediaQuery.atLeast(this.options.equalizeOn);
        if (tooSmall) {
          if (this.isOn) {
            this._pauseEvents();
            this.$watched.css('height', 'auto');
          }
        } else {
          if (!this.isOn) {
            this._events();
          }
        }
        return tooSmall;
      }

      /**
       * A noop version for the plugin
       * @private
       */

    }, {
      key: '_killswitch',
      value: function _killswitch() {
        return;
      }

      /**
       * Calls necessary functions to update Equalizer upon DOM change
       * @private
       */

    }, {
      key: '_reflow',
      value: function _reflow() {
        if (!this.options.equalizeOnStack) {
          if (this._isStacked()) {
            this.$watched.css('height', 'auto');
            return false;
          }
        }
        if (this.options.equalizeByRow) {
          this.getHeightsByRow(this.applyHeightByRow.bind(this));
        } else {
          this.getHeights(this.applyHeight.bind(this));
        }
      }

      /**
       * Manually determines if the first 2 elements are *NOT* stacked.
       * @private
       */

    }, {
      key: '_isStacked',
      value: function _isStacked() {
        return this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;
      }

      /**
       * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
       * @param {Function} cb - A non-optional callback to return the heights array to.
       * @returns {Array} heights - An array of heights of children within Equalizer container
       */

    }, {
      key: 'getHeights',
      value: function getHeights(cb) {
        var heights = [];
        for (var i = 0, len = this.$watched.length; i < len; i++) {
          this.$watched[i].style.height = 'auto';
          heights.push(this.$watched[i].offsetHeight);
        }
        cb(heights);
      }

      /**
       * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
       * @param {Function} cb - A non-optional callback to return the heights array to.
       * @returns {Array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child
       */

    }, {
      key: 'getHeightsByRow',
      value: function getHeightsByRow(cb) {
        var lastElTopOffset = this.$watched.length ? this.$watched.first().offset().top : 0,
            groups = [],
            group = 0;
        //group by Row
        groups[group] = [];
        for (var i = 0, len = this.$watched.length; i < len; i++) {
          this.$watched[i].style.height = 'auto';
          //maybe could use this.$watched[i].offsetTop
          var elOffsetTop = $(this.$watched[i]).offset().top;
          if (elOffsetTop != lastElTopOffset) {
            group++;
            groups[group] = [];
            lastElTopOffset = elOffsetTop;
          }
          groups[group].push([this.$watched[i], this.$watched[i].offsetHeight]);
        }

        for (var j = 0, ln = groups.length; j < ln; j++) {
          var heights = $(groups[j]).map(function () {
            return this[1];
          }).get();
          var max = Math.max.apply(null, heights);
          groups[j].push(max);
        }
        cb(groups);
      }

      /**
       * Changes the CSS height property of each child in an Equalizer parent to match the tallest
       * @param {array} heights - An array of heights of children within Equalizer container
       * @fires Equalizer#preequalized
       * @fires Equalizer#postequalized
       */

    }, {
      key: 'applyHeight',
      value: function applyHeight(heights) {
        var max = Math.max.apply(null, heights);
        /**
         * Fires before the heights are applied
         * @event Equalizer#preequalized
         */
        this.$element.trigger('preequalized.zf.equalizer');

        this.$watched.css('height', max);

        /**
         * Fires when the heights have been applied
         * @event Equalizer#postequalized
         */
        this.$element.trigger('postequalized.zf.equalizer');
      }

      /**
       * Changes the CSS height property of each child in an Equalizer parent to match the tallest by row
       * @param {array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child
       * @fires Equalizer#preequalized
       * @fires Equalizer#preequalizedRow
       * @fires Equalizer#postequalizedRow
       * @fires Equalizer#postequalized
       */

    }, {
      key: 'applyHeightByRow',
      value: function applyHeightByRow(groups) {
        /**
         * Fires before the heights are applied
         */
        this.$element.trigger('preequalized.zf.equalizer');
        for (var i = 0, len = groups.length; i < len; i++) {
          var groupsILength = groups[i].length,
              max = groups[i][groupsILength - 1];
          if (groupsILength <= 2) {
            $(groups[i][0][0]).css({ 'height': 'auto' });
            continue;
          }
          /**
            * Fires before the heights per row are applied
            * @event Equalizer#preequalizedRow
            */
          this.$element.trigger('preequalizedrow.zf.equalizer');
          for (var j = 0, lenJ = groupsILength - 1; j < lenJ; j++) {
            $(groups[i][j][0]).css({ 'height': max });
          }
          /**
            * Fires when the heights per row have been applied
            * @event Equalizer#postequalizedRow
            */
          this.$element.trigger('postequalizedrow.zf.equalizer');
        }
        /**
         * Fires when the heights have been applied
         */
        this.$element.trigger('postequalized.zf.equalizer');
      }

      /**
       * Destroys an instance of Equalizer.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this._pauseEvents();
        this.$watched.css('height', 'auto');

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Equalizer;
  }();

  /**
   * Default settings for plugin
   */


  Equalizer.defaults = {
    /**
     * Enable height equalization when stacked on smaller screens.
     * @option
     * @example true
     */
    equalizeOnStack: true,
    /**
     * Enable height equalization row by row.
     * @option
     * @example false
     */
    equalizeByRow: false,
    /**
     * String representing the minimum breakpoint size the plugin should equalize heights on.
     * @option
     * @example 'medium'
     */
    equalizeOn: ''
  };

  // Window exports
  Foundation.plugin(Equalizer, 'Equalizer');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Interchange module.
   * @module foundation.interchange
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.timerAndImageLoader
   */

  var Interchange = function () {
    /**
     * Creates a new instance of Interchange.
     * @class
     * @fires Interchange#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Interchange(element, options) {
      _classCallCheck(this, Interchange);

      this.$element = element;
      this.options = $.extend({}, Interchange.defaults, options);
      this.rules = [];
      this.currentPath = '';

      this._init();
      this._events();

      Foundation.registerPlugin(this, 'Interchange');
    }

    /**
     * Initializes the Interchange plugin and calls functions to get interchange functioning on load.
     * @function
     * @private
     */


    _createClass(Interchange, [{
      key: '_init',
      value: function _init() {
        this._addBreakpoints();
        this._generateRules();
        this._reflow();
      }

      /**
       * Initializes events for Interchange.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        $(window).on('resize.zf.interchange', Foundation.util.throttle(this._reflow.bind(this), 50));
      }

      /**
       * Calls necessary functions to update Interchange upon DOM change
       * @function
       * @private
       */

    }, {
      key: '_reflow',
      value: function _reflow() {
        var match;

        // Iterate through each rule, but only save the last match
        for (var i in this.rules) {
          if (this.rules.hasOwnProperty(i)) {
            var rule = this.rules[i];

            if (window.matchMedia(rule.query).matches) {
              match = rule;
            }
          }
        }

        if (match) {
          this.replace(match.path);
        }
      }

      /**
       * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.
       * @function
       * @private
       */

    }, {
      key: '_addBreakpoints',
      value: function _addBreakpoints() {
        for (var i in Foundation.MediaQuery.queries) {
          if (Foundation.MediaQuery.queries.hasOwnProperty(i)) {
            var query = Foundation.MediaQuery.queries[i];
            Interchange.SPECIAL_QUERIES[query.name] = query.value;
          }
        }
      }

      /**
       * Checks the Interchange element for the provided media query + content pairings
       * @function
       * @private
       * @param {Object} element - jQuery object that is an Interchange instance
       * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys
       */

    }, {
      key: '_generateRules',
      value: function _generateRules(element) {
        var rulesList = [];
        var rules;

        if (this.options.rules) {
          rules = this.options.rules;
        } else {
          rules = this.$element.data('interchange').match(/\[.*?\]/g);
        }

        for (var i in rules) {
          if (rules.hasOwnProperty(i)) {
            var rule = rules[i].slice(1, -1).split(', ');
            var path = rule.slice(0, -1).join('');
            var query = rule[rule.length - 1];

            if (Interchange.SPECIAL_QUERIES[query]) {
              query = Interchange.SPECIAL_QUERIES[query];
            }

            rulesList.push({
              path: path,
              query: query
            });
          }
        }

        this.rules = rulesList;
      }

      /**
       * Update the `src` property of an image, or change the HTML of a container, to the specified path.
       * @function
       * @param {String} path - Path to the image or HTML partial.
       * @fires Interchange#replaced
       */

    }, {
      key: 'replace',
      value: function replace(path) {
        if (this.currentPath === path) return;

        var _this = this,
            trigger = 'replaced.zf.interchange';

        // Replacing images
        if (this.$element[0].nodeName === 'IMG') {
          this.$element.attr('src', path).load(function () {
            _this.currentPath = path;
          }).trigger(trigger);
        }
        // Replacing background images
        else if (path.match(/\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)) {
            this.$element.css({ 'background-image': 'url(' + path + ')' }).trigger(trigger);
          }
          // Replacing HTML
          else {
              $.get(path, function (response) {
                _this.$element.html(response).trigger(trigger);
                $(response).foundation();
                _this.currentPath = path;
              });
            }

        /**
         * Fires when content in an Interchange element is done being loaded.
         * @event Interchange#replaced
         */
        // this.$element.trigger('replaced.zf.interchange');
      }

      /**
       * Destroys an instance of interchange.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        //TODO this.
      }
    }]);

    return Interchange;
  }();

  /**
   * Default settings for plugin
   */


  Interchange.defaults = {
    /**
     * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.
     * @option
     */
    rules: null
  };

  Interchange.SPECIAL_QUERIES = {
    'landscape': 'screen and (orientation: landscape)',
    'portrait': 'screen and (orientation: portrait)',
    'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'
  };

  // Window exports
  Foundation.plugin(Interchange, 'Interchange');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Magellan module.
   * @module foundation.magellan
   */

  var Magellan = function () {
    /**
     * Creates a new instance of Magellan.
     * @class
     * @fires Magellan#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Magellan(element, options) {
      _classCallCheck(this, Magellan);

      this.$element = element;
      this.options = $.extend({}, Magellan.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Magellan');
    }

    /**
     * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.
     * @private
     */


    _createClass(Magellan, [{
      key: '_init',
      value: function _init() {
        var id = this.$element[0].id || Foundation.GetYoDigits(6, 'magellan');
        var _this = this;
        this.$targets = $('[data-magellan-target]');
        this.$links = this.$element.find('a');
        this.$element.attr({
          'data-resize': id,
          'data-scroll': id,
          'id': id
        });
        this.$active = $();
        this.scrollPos = parseInt(window.pageYOffset, 10);

        this._events();
      }

      /**
       * Calculates an array of pixel values that are the demarcation lines between locations on the page.
       * Can be invoked if new elements are added or the size of a location changes.
       * @function
       */

    }, {
      key: 'calcPoints',
      value: function calcPoints() {
        var _this = this,
            body = document.body,
            html = document.documentElement;

        this.points = [];
        this.winHeight = Math.round(Math.max(window.innerHeight, html.clientHeight));
        this.docHeight = Math.round(Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight));

        this.$targets.each(function () {
          var $tar = $(this),
              pt = Math.round($tar.offset().top - _this.options.threshold);
          $tar.targetPoint = pt;
          _this.points.push(pt);
        });
      }

      /**
       * Initializes events for Magellan.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this,
            $body = $('html, body'),
            opts = {
          duration: _this.options.animationDuration,
          easing: _this.options.animationEasing
        };
        $(window).one('load', function () {
          if (_this.options.deepLinking) {
            if (location.hash) {
              _this.scrollToLoc(location.hash);
            }
          }
          _this.calcPoints();
          _this._updateActive();
        });

        this.$element.on({
          'resizeme.zf.trigger': this.reflow.bind(this),
          'scrollme.zf.trigger': this._updateActive.bind(this)
        }).on('click.zf.magellan', 'a[href^="#"]', function (e) {
          e.preventDefault();
          var arrival = this.getAttribute('href');
          _this.scrollToLoc(arrival);
        });
      }

      /**
       * Function to scroll to a given location on the page.
       * @param {String} loc - a properly formatted jQuery id selector. Example: '#foo'
       * @function
       */

    }, {
      key: 'scrollToLoc',
      value: function scrollToLoc(loc) {
        var scrollPos = Math.round($(loc).offset().top - this.options.threshold / 2 - this.options.barOffset);

        $('html, body').stop(true).animate({ scrollTop: scrollPos }, this.options.animationDuration, this.options.animationEasing);
      }

      /**
       * Calls necessary functions to update Magellan upon DOM change
       * @function
       */

    }, {
      key: 'reflow',
      value: function reflow() {
        this.calcPoints();
        this._updateActive();
      }

      /**
       * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.
       * @private
       * @function
       * @fires Magellan#update
       */

    }, {
      key: '_updateActive',
      value: function _updateActive() /*evt, elem, scrollPos*/{
        var winPos = /*scrollPos ||*/parseInt(window.pageYOffset, 10),
            curIdx;

        if (winPos + this.winHeight === this.docHeight) {
          curIdx = this.points.length - 1;
        } else if (winPos < this.points[0]) {
          curIdx = 0;
        } else {
          var isDown = this.scrollPos < winPos,
              _this = this,
              curVisible = this.points.filter(function (p, i) {
            return isDown ? p - _this.options.barOffset <= winPos : p - _this.options.barOffset - _this.options.threshold <= winPos;
          });
          curIdx = curVisible.length ? curVisible.length - 1 : 0;
        }

        this.$active.removeClass(this.options.activeClass);
        this.$active = this.$links.eq(curIdx).addClass(this.options.activeClass);

        if (this.options.deepLinking) {
          var hash = this.$active[0].getAttribute('href');
          if (window.history.pushState) {
            window.history.pushState(null, null, hash);
          } else {
            window.location.hash = hash;
          }
        }

        this.scrollPos = winPos;
        /**
         * Fires when magellan is finished updating to the new active element.
         * @event Magellan#update
         */
        this.$element.trigger('update.zf.magellan', [this.$active]);
      }

      /**
       * Destroys an instance of Magellan and resets the url of the window.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.off('.zf.trigger .zf.magellan').find('.' + this.options.activeClass).removeClass(this.options.activeClass);

        if (this.options.deepLinking) {
          var hash = this.$active[0].getAttribute('href');
          window.location.hash.replace(hash, '');
        }

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Magellan;
  }();

  /**
   * Default settings for plugin
   */


  Magellan.defaults = {
    /**
     * Amount of time, in ms, the animated scrolling should take between locations.
     * @option
     * @example 500
     */
    animationDuration: 500,
    /**
     * Animation style to use when scrolling between locations.
     * @option
     * @example 'ease-in-out'
     */
    animationEasing: 'linear',
    /**
     * Number of pixels to use as a marker for location changes.
     * @option
     * @example 50
     */
    threshold: 50,
    /**
     * Class applied to the active locations link on the magellan container.
     * @option
     * @example 'active'
     */
    activeClass: 'active',
    /**
     * Allows the script to manipulate the url of the current page, and if supported, alter the history.
     * @option
     * @example true
     */
    deepLinking: false,
    /**
     * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.
     * @option
     * @example 25
     */
    barOffset: 0
  };

  // Window exports
  Foundation.plugin(Magellan, 'Magellan');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * OffCanvas module.
   * @module foundation.offcanvas
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.triggers
   * @requires foundation.util.motion
   */

  var OffCanvas = function () {
    /**
     * Creates a new instance of an off-canvas wrapper.
     * @class
     * @fires OffCanvas#init
     * @param {Object} element - jQuery object to initialize.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function OffCanvas(element, options) {
      _classCallCheck(this, OffCanvas);

      this.$element = element;
      this.options = $.extend({}, OffCanvas.defaults, this.$element.data(), options);
      this.$lastTrigger = $();
      this.$triggers = $();

      this._init();
      this._events();

      Foundation.registerPlugin(this, 'OffCanvas');
    }

    /**
     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).
     * @function
     * @private
     */


    _createClass(OffCanvas, [{
      key: '_init',
      value: function _init() {
        var id = this.$element.attr('id');

        this.$element.attr('aria-hidden', 'true');

        // Find triggers that affect this element and add aria-expanded to them
        this.$triggers = $(document).find('[data-open="' + id + '"], [data-close="' + id + '"], [data-toggle="' + id + '"]').attr('aria-expanded', 'false').attr('aria-controls', id);

        // Add a close trigger over the body if necessary
        if (this.options.closeOnClick) {
          if ($('.js-off-canvas-exit').length) {
            this.$exiter = $('.js-off-canvas-exit');
          } else {
            var exiter = document.createElement('div');
            exiter.setAttribute('class', 'js-off-canvas-exit');
            $('[data-off-canvas-content]').append(exiter);

            this.$exiter = $(exiter);
          }
        }

        this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, 'g').test(this.$element[0].className);

        if (this.options.isRevealed) {
          this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];
          this._setMQChecker();
        }
        if (!this.options.transitionTime) {
          this.options.transitionTime = parseFloat(window.getComputedStyle($('[data-off-canvas-wrapper]')[0]).transitionDuration) * 1000;
        }
      }

      /**
       * Adds event handlers to the off-canvas wrapper and the exit overlay.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        this.$element.off('.zf.trigger .zf.offcanvas').on({
          'open.zf.trigger': this.open.bind(this),
          'close.zf.trigger': this.close.bind(this),
          'toggle.zf.trigger': this.toggle.bind(this),
          'keydown.zf.offcanvas': this._handleKeyboard.bind(this)
        });

        if (this.options.closeOnClick && this.$exiter.length) {
          this.$exiter.on({ 'click.zf.offcanvas': this.close.bind(this) });
        }
      }

      /**
       * Applies event listener for elements that will reveal at certain breakpoints.
       * @private
       */

    }, {
      key: '_setMQChecker',
      value: function _setMQChecker() {
        var _this = this;

        $(window).on('changed.zf.mediaquery', function () {
          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {
            _this.reveal(true);
          } else {
            _this.reveal(false);
          }
        }).one('load.zf.offcanvas', function () {
          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {
            _this.reveal(true);
          }
        });
      }

      /**
       * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.
       * @param {Boolean} isRevealed - true if element should be revealed.
       * @function
       */

    }, {
      key: 'reveal',
      value: function reveal(isRevealed) {
        var $closer = this.$element.find('[data-close]');
        if (isRevealed) {
          this.close();
          this.isRevealed = true;
          // if (!this.options.forceTop) {
          //   var scrollPos = parseInt(window.pageYOffset);
          //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';
          // }
          // if (this.options.isSticky) { this._stick(); }
          this.$element.off('open.zf.trigger toggle.zf.trigger');
          if ($closer.length) {
            $closer.hide();
          }
        } else {
          this.isRevealed = false;
          // if (this.options.isSticky || !this.options.forceTop) {
          //   this.$element[0].style.transform = '';
          //   $(window).off('scroll.zf.offcanvas');
          // }
          this.$element.on({
            'open.zf.trigger': this.open.bind(this),
            'toggle.zf.trigger': this.toggle.bind(this)
          });
          if ($closer.length) {
            $closer.show();
          }
        }
      }

      /**
       * Opens the off-canvas menu.
       * @function
       * @param {Object} event - Event object passed from listener.
       * @param {jQuery} trigger - element that triggered the off-canvas to open.
       * @fires OffCanvas#opened
       */

    }, {
      key: 'open',
      value: function open(event, trigger) {
        if (this.$element.hasClass('is-open') || this.isRevealed) {
          return;
        }
        var _this = this,
            $body = $(document.body);

        if (this.options.forceTop) {
          $('body').scrollTop(0);
        }
        // window.pageYOffset = 0;

        // if (!this.options.forceTop) {
        //   var scrollPos = parseInt(window.pageYOffset);
        //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';
        //   if (this.$exiter.length) {
        //     this.$exiter[0].style.transform = 'translate(0,' + scrollPos + 'px)';
        //   }
        // }
        /**
         * Fires when the off-canvas menu opens.
         * @event OffCanvas#opened
         */
        Foundation.Move(this.options.transitionTime, this.$element, function () {
          $('[data-off-canvas-wrapper]').addClass('is-off-canvas-open is-open-' + _this.options.position);

          _this.$element.addClass('is-open');

          // if (_this.options.isSticky) {
          //   _this._stick();
          // }
        });

        this.$triggers.attr('aria-expanded', 'true');
        this.$element.attr('aria-hidden', 'false').trigger('opened.zf.offcanvas');

        if (this.options.closeOnClick) {
          this.$exiter.addClass('is-visible');
        }

        if (trigger) {
          this.$lastTrigger = trigger;
        }

        if (this.options.autoFocus) {
          this.$element.one(Foundation.transitionend(this.$element), function () {
            _this.$element.find('a, button').eq(0).focus();
          });
        }

        if (this.options.trapFocus) {
          $('[data-off-canvas-content]').attr('tabindex', '-1');
          this._trapFocus();
        }
      }

      /**
       * Traps focus within the offcanvas on open.
       * @private
       */

    }, {
      key: '_trapFocus',
      value: function _trapFocus() {
        var focusable = Foundation.Keyboard.findFocusable(this.$element),
            first = focusable.eq(0),
            last = focusable.eq(-1);

        focusable.off('.zf.offcanvas').on('keydown.zf.offcanvas', function (e) {
          if (e.which === 9 || e.keycode === 9) {
            if (e.target === last[0] && !e.shiftKey) {
              e.preventDefault();
              first.focus();
            }
            if (e.target === first[0] && e.shiftKey) {
              e.preventDefault();
              last.focus();
            }
          }
        });
      }

      /**
       * Allows the offcanvas to appear sticky utilizing translate properties.
       * @private
       */
      // OffCanvas.prototype._stick = function() {
      //   var elStyle = this.$element[0].style;
      //
      //   if (this.options.closeOnClick) {
      //     var exitStyle = this.$exiter[0].style;
      //   }
      //
      //   $(window).on('scroll.zf.offcanvas', function(e) {
      //     console.log(e);
      //     var pageY = window.pageYOffset;
      //     elStyle.transform = 'translate(0,' + pageY + 'px)';
      //     if (exitStyle !== undefined) { exitStyle.transform = 'translate(0,' + pageY + 'px)'; }
      //   });
      //   // this.$element.trigger('stuck.zf.offcanvas');
      // };
      /**
       * Closes the off-canvas menu.
       * @function
       * @param {Function} cb - optional cb to fire after closure.
       * @fires OffCanvas#closed
       */

    }, {
      key: 'close',
      value: function close(cb) {
        if (!this.$element.hasClass('is-open') || this.isRevealed) {
          return;
        }

        var _this = this;

        //  Foundation.Move(this.options.transitionTime, this.$element, function() {
        $('[data-off-canvas-wrapper]').removeClass('is-off-canvas-open is-open-' + _this.options.position);
        _this.$element.removeClass('is-open');
        // Foundation._reflow();
        // });
        this.$element.attr('aria-hidden', 'true')
        /**
         * Fires when the off-canvas menu opens.
         * @event OffCanvas#closed
         */
        .trigger('closed.zf.offcanvas');
        // if (_this.options.isSticky || !_this.options.forceTop) {
        //   setTimeout(function() {
        //     _this.$element[0].style.transform = '';
        //     $(window).off('scroll.zf.offcanvas');
        //   }, this.options.transitionTime);
        // }
        if (this.options.closeOnClick) {
          this.$exiter.removeClass('is-visible');
        }

        this.$triggers.attr('aria-expanded', 'false');
        if (this.options.trapFocus) {
          $('[data-off-canvas-content]').removeAttr('tabindex');
        }
      }

      /**
       * Toggles the off-canvas menu open or closed.
       * @function
       * @param {Object} event - Event object passed from listener.
       * @param {jQuery} trigger - element that triggered the off-canvas to open.
       */

    }, {
      key: 'toggle',
      value: function toggle(event, trigger) {
        if (this.$element.hasClass('is-open')) {
          this.close(event, trigger);
        } else {
          this.open(event, trigger);
        }
      }

      /**
       * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.
       * @function
       * @private
       */

    }, {
      key: '_handleKeyboard',
      value: function _handleKeyboard(event) {
        if (event.which !== 27) return;

        event.stopPropagation();
        event.preventDefault();
        this.close();
        this.$lastTrigger.focus();
      }

      /**
       * Destroys the offcanvas plugin.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.close();
        this.$element.off('.zf.trigger .zf.offcanvas');
        this.$exiter.off('.zf.offcanvas');

        Foundation.unregisterPlugin(this);
      }
    }]);

    return OffCanvas;
  }();

  OffCanvas.defaults = {
    /**
     * Allow the user to click outside of the menu to close it.
     * @option
     * @example true
     */
    closeOnClick: true,

    /**
     * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.
     * @option
     * @example 500
     */
    transitionTime: 0,

    /**
     * Direction the offcanvas opens from. Determines class applied to body.
     * @option
     * @example left
     */
    position: 'left',

    /**
     * Force the page to scroll to top on open.
     * @option
     * @example true
     */
    forceTop: true,

    /**
     * Allow the offcanvas to remain open for certain breakpoints.
     * @option
     * @example false
     */
    isRevealed: false,

    /**
     * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.
     * @option
     * @example reveal-for-large
     */
    revealOn: null,

    /**
     * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.
     * @option
     * @example true
     */
    autoFocus: true,

    /**
     * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.
     * @option
     * TODO improve the regex testing for this.
     * @example reveal-for-large
     */
    revealClass: 'reveal-for-',

    /**
     * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.
     * @option
     * @example true
     */
    trapFocus: false
  };

  // Window exports
  Foundation.plugin(OffCanvas, 'OffCanvas');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Orbit module.
   * @module foundation.orbit
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   * @requires foundation.util.timerAndImageLoader
   * @requires foundation.util.touch
   */

  var Orbit = function () {
    /**
    * Creates a new instance of an orbit carousel.
    * @class
    * @param {jQuery} element - jQuery object to make into an Orbit Carousel.
    * @param {Object} options - Overrides to the default plugin settings.
    */
    function Orbit(element, options) {
      _classCallCheck(this, Orbit);

      this.$element = element;
      this.options = $.extend({}, Orbit.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Orbit');
      Foundation.Keyboard.register('Orbit', {
        'ltr': {
          'ARROW_RIGHT': 'next',
          'ARROW_LEFT': 'previous'
        },
        'rtl': {
          'ARROW_LEFT': 'next',
          'ARROW_RIGHT': 'previous'
        }
      });
    }

    /**
    * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.
    * @function
    * @private
    */


    _createClass(Orbit, [{
      key: '_init',
      value: function _init() {
        this.$wrapper = this.$element.find('.' + this.options.containerClass);
        this.$slides = this.$element.find('.' + this.options.slideClass);
        var $images = this.$element.find('img'),
            initActive = this.$slides.filter('.is-active');

        if (!initActive.length) {
          this.$slides.eq(0).addClass('is-active');
        }

        if (!this.options.useMUI) {
          this.$slides.addClass('no-motionui');
        }

        if ($images.length) {
          Foundation.onImagesLoaded($images, this._prepareForOrbit.bind(this));
        } else {
          this._prepareForOrbit(); //hehe
        }

        if (this.options.bullets) {
          this._loadBullets();
        }

        this._events();

        if (this.options.autoPlay && this.$slides.length > 1) {
          this.geoSync();
        }

        if (this.options.accessible) {
          // allow wrapper to be focusable to enable arrow navigation
          this.$wrapper.attr('tabindex', 0);
        }
      }

      /**
      * Creates a jQuery collection of bullets, if they are being used.
      * @function
      * @private
      */

    }, {
      key: '_loadBullets',
      value: function _loadBullets() {
        this.$bullets = this.$element.find('.' + this.options.boxOfBullets).find('button');
      }

      /**
      * Sets a `timer` object on the orbit, and starts the counter for the next slide.
      * @function
      */

    }, {
      key: 'geoSync',
      value: function geoSync() {
        var _this = this;
        this.timer = new Foundation.Timer(this.$element, {
          duration: this.options.timerDelay,
          infinite: false
        }, function () {
          _this.changeSlide(true);
        });
        this.timer.start();
      }

      /**
      * Sets wrapper and slide heights for the orbit.
      * @function
      * @private
      */

    }, {
      key: '_prepareForOrbit',
      value: function _prepareForOrbit() {
        var _this = this;
        this._setWrapperHeight(function (max) {
          _this._setSlideHeight(max);
        });
      }

      /**
      * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.
      * @function
      * @private
      * @param {Function} cb - a callback function to fire when complete.
      */

    }, {
      key: '_setWrapperHeight',
      value: function _setWrapperHeight(cb) {
        //rewrite this to `for` loop
        var max = 0,
            temp,
            counter = 0;

        this.$slides.each(function () {
          temp = this.getBoundingClientRect().height;
          $(this).attr('data-slide', counter);

          if (counter) {
            //if not the first slide, set css position and display property
            $(this).css({ 'position': 'relative', 'display': 'none' });
          }
          max = temp > max ? temp : max;
          counter++;
        });

        if (counter === this.$slides.length) {
          this.$wrapper.css({ 'height': max }); //only change the wrapper height property once.
          cb(max); //fire callback with max height dimension.
        }
      }

      /**
      * Sets the max-height of each slide.
      * @function
      * @private
      */

    }, {
      key: '_setSlideHeight',
      value: function _setSlideHeight(height) {
        this.$slides.each(function () {
          $(this).css('max-height', height);
        });
      }

      /**
      * Adds event listeners to basically everything within the element.
      * @function
      * @private
      */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;

        //***************************************
        //**Now using custom event - thanks to:**
        //**      Yohai Ararat of Toronto      **
        //***************************************
        if (this.$slides.length > 1) {

          if (this.options.swipe) {
            this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit').on('swipeleft.zf.orbit', function (e) {
              e.preventDefault();
              _this.changeSlide(true);
            }).on('swiperight.zf.orbit', function (e) {
              e.preventDefault();
              _this.changeSlide(false);
            });
          }
          //***************************************

          if (this.options.autoPlay) {
            this.$slides.on('click.zf.orbit', function () {
              _this.$element.data('clickedOn', _this.$element.data('clickedOn') ? false : true);
              _this.timer[_this.$element.data('clickedOn') ? 'pause' : 'start']();
            });

            if (this.options.pauseOnHover) {
              this.$element.on('mouseenter.zf.orbit', function () {
                _this.timer.pause();
              }).on('mouseleave.zf.orbit', function () {
                if (!_this.$element.data('clickedOn')) {
                  _this.timer.start();
                }
              });
            }
          }

          if (this.options.navButtons) {
            var $controls = this.$element.find('.' + this.options.nextClass + ', .' + this.options.prevClass);
            $controls.attr('tabindex', 0)
            //also need to handle enter/return and spacebar key presses
            .on('click.zf.orbit touchend.zf.orbit', function (e) {
              e.preventDefault();
              _this.changeSlide($(this).hasClass(_this.options.nextClass));
            });
          }

          if (this.options.bullets) {
            this.$bullets.on('click.zf.orbit touchend.zf.orbit', function () {
              if (/is-active/g.test(this.className)) {
                return false;
              } //if this is active, kick out of function.
              var idx = $(this).data('slide'),
                  ltr = idx > _this.$slides.filter('.is-active').data('slide'),
                  $slide = _this.$slides.eq(idx);

              _this.changeSlide(ltr, $slide, idx);
            });
          }

          this.$wrapper.add(this.$bullets).on('keydown.zf.orbit', function (e) {
            // handle keyboard event with keyboard util
            Foundation.Keyboard.handleKey(e, 'Orbit', {
              next: function () {
                _this.changeSlide(true);
              },
              previous: function () {
                _this.changeSlide(false);
              },
              handled: function () {
                // if bullet is focused, make sure focus moves
                if ($(e.target).is(_this.$bullets)) {
                  _this.$bullets.filter('.is-active').focus();
                }
              }
            });
          });
        }
      }

      /**
      * Changes the current slide to a new one.
      * @function
      * @param {Boolean} isLTR - flag if the slide should move left to right.
      * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.
      * @param {Number} idx - the index of the new slide in its collection, if one chosen.
      * @fires Orbit#slidechange
      */

    }, {
      key: 'changeSlide',
      value: function changeSlide(isLTR, chosenSlide, idx) {
        var $curSlide = this.$slides.filter('.is-active').eq(0);

        if (/mui/g.test($curSlide[0].className)) {
          return false;
        } //if the slide is currently animating, kick out of the function

        var $firstSlide = this.$slides.first(),
            $lastSlide = this.$slides.last(),
            dirIn = isLTR ? 'Right' : 'Left',
            dirOut = isLTR ? 'Left' : 'Right',
            _this = this,
            $newSlide;

        if (!chosenSlide) {
          //most of the time, this will be auto played or clicked from the navButtons.
          $newSlide = isLTR ? //if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!
          this.options.infiniteWrap ? $curSlide.next('.' + this.options.slideClass).length ? $curSlide.next('.' + this.options.slideClass) : $firstSlide : $curSlide.next('.' + this.options.slideClass) : //pick next slide if moving left to right
          this.options.infiniteWrap ? $curSlide.prev('.' + this.options.slideClass).length ? $curSlide.prev('.' + this.options.slideClass) : $lastSlide : $curSlide.prev('.' + this.options.slideClass); //pick prev slide if moving right to left
        } else {
          $newSlide = chosenSlide;
        }

        if ($newSlide.length) {
          if (this.options.bullets) {
            idx = idx || this.$slides.index($newSlide); //grab index to update bullets
            this._updateBullets(idx);
          }

          if (this.options.useMUI) {
            Foundation.Motion.animateIn($newSlide.addClass('is-active').css({ 'position': 'absolute', 'top': 0 }), this.options['animInFrom' + dirIn], function () {
              $newSlide.css({ 'position': 'relative', 'display': 'block' }).attr('aria-live', 'polite');
            });

            Foundation.Motion.animateOut($curSlide.removeClass('is-active'), this.options['animOutTo' + dirOut], function () {
              $curSlide.removeAttr('aria-live');
              if (_this.options.autoPlay && !_this.timer.isPaused) {
                _this.timer.restart();
              }
              //do stuff?
            });
          } else {
            $curSlide.removeClass('is-active is-in').removeAttr('aria-live').hide();
            $newSlide.addClass('is-active is-in').attr('aria-live', 'polite').show();
            if (this.options.autoPlay && !this.timer.isPaused) {
              this.timer.restart();
            }
          }
          /**
          * Triggers when the slide has finished animating in.
          * @event Orbit#slidechange
          */
          this.$element.trigger('slidechange.zf.orbit', [$newSlide]);
        }
      }

      /**
      * Updates the active state of the bullets, if displayed.
      * @function
      * @private
      * @param {Number} idx - the index of the current slide.
      */

    }, {
      key: '_updateBullets',
      value: function _updateBullets(idx) {
        var $oldBullet = this.$element.find('.' + this.options.boxOfBullets).find('.is-active').removeClass('is-active').blur(),
            span = $oldBullet.find('span:last').detach(),
            $newBullet = this.$bullets.eq(idx).addClass('is-active').append(span);
      }

      /**
      * Destroys the carousel and hides the element.
      * @function
      */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();
        Foundation.unregisterPlugin(this);
      }
    }]);

    return Orbit;
  }();

  Orbit.defaults = {
    /**
    * Tells the JS to look for and loadBullets.
    * @option
    * @example true
    */
    bullets: true,
    /**
    * Tells the JS to apply event listeners to nav buttons
    * @option
    * @example true
    */
    navButtons: true,
    /**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-in-right'
    */
    animInFromRight: 'slide-in-right',
    /**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-out-right'
    */
    animOutToRight: 'slide-out-right',
    /**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-in-left'
    *
    */
    animInFromLeft: 'slide-in-left',
    /**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-out-left'
    */
    animOutToLeft: 'slide-out-left',
    /**
    * Allows Orbit to automatically animate on page load.
    * @option
    * @example true
    */
    autoPlay: true,
    /**
    * Amount of time, in ms, between slide transitions
    * @option
    * @example 5000
    */
    timerDelay: 5000,
    /**
    * Allows Orbit to infinitely loop through the slides
    * @option
    * @example true
    */
    infiniteWrap: true,
    /**
    * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library
    * @option
    * @example true
    */
    swipe: true,
    /**
    * Allows the timing function to pause animation on hover.
    * @option
    * @example true
    */
    pauseOnHover: true,
    /**
    * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys
    * @option
    * @example true
    */
    accessible: true,
    /**
    * Class applied to the container of Orbit
    * @option
    * @example 'orbit-container'
    */
    containerClass: 'orbit-container',
    /**
    * Class applied to individual slides.
    * @option
    * @example 'orbit-slide'
    */
    slideClass: 'orbit-slide',
    /**
    * Class applied to the bullet container. You're welcome.
    * @option
    * @example 'orbit-bullets'
    */
    boxOfBullets: 'orbit-bullets',
    /**
    * Class applied to the `next` navigation button.
    * @option
    * @example 'orbit-next'
    */
    nextClass: 'orbit-next',
    /**
    * Class applied to the `previous` navigation button.
    * @option
    * @example 'orbit-previous'
    */
    prevClass: 'orbit-previous',
    /**
    * Boolean to flag the js to use motion ui classes or not. Default to true for backwards compatability.
    * @option
    * @example true
    */
    useMUI: true
  };

  // Window exports
  Foundation.plugin(Orbit, 'Orbit');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * ResponsiveMenu module.
   * @module foundation.responsiveMenu
   * @requires foundation.util.triggers
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.accordionMenu
   * @requires foundation.util.drilldown
   * @requires foundation.util.dropdown-menu
   */

  var ResponsiveMenu = function () {
    /**
     * Creates a new instance of a responsive menu.
     * @class
     * @fires ResponsiveMenu#init
     * @param {jQuery} element - jQuery object to make into a dropdown menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function ResponsiveMenu(element, options) {
      _classCallCheck(this, ResponsiveMenu);

      this.$element = $(element);
      this.rules = this.$element.data('responsive-menu');
      this.currentMq = null;
      this.currentPlugin = null;

      this._init();
      this._events();

      Foundation.registerPlugin(this, 'ResponsiveMenu');
    }

    /**
     * Initializes the Menu by parsing the classes from the 'data-ResponsiveMenu' attribute on the element.
     * @function
     * @private
     */


    _createClass(ResponsiveMenu, [{
      key: '_init',
      value: function _init() {
        // The first time an Interchange plugin is initialized, this.rules is converted from a string of "classes" to an object of rules
        if (typeof this.rules === 'string') {
          var rulesTree = {};

          // Parse rules from "classes" pulled from data attribute
          var rules = this.rules.split(' ');

          // Iterate through every rule found
          for (var i = 0; i < rules.length; i++) {
            var rule = rules[i].split('-');
            var ruleSize = rule.length > 1 ? rule[0] : 'small';
            var rulePlugin = rule.length > 1 ? rule[1] : rule[0];

            if (MenuPlugins[rulePlugin] !== null) {
              rulesTree[ruleSize] = MenuPlugins[rulePlugin];
            }
          }

          this.rules = rulesTree;
        }

        if (!$.isEmptyObject(this.rules)) {
          this._checkMediaQueries();
        }
      }

      /**
       * Initializes events for the Menu.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;

        $(window).on('changed.zf.mediaquery', function () {
          _this._checkMediaQueries();
        });
        // $(window).on('resize.zf.ResponsiveMenu', function() {
        //   _this._checkMediaQueries();
        // });
      }

      /**
       * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.
       * @function
       * @private
       */

    }, {
      key: '_checkMediaQueries',
      value: function _checkMediaQueries() {
        var matchedMq,
            _this = this;
        // Iterate through each rule and find the last matching rule
        $.each(this.rules, function (key) {
          if (Foundation.MediaQuery.atLeast(key)) {
            matchedMq = key;
          }
        });

        // No match? No dice
        if (!matchedMq) return;

        // Plugin already initialized? We good
        if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return;

        // Remove existing plugin-specific CSS classes
        $.each(MenuPlugins, function (key, value) {
          _this.$element.removeClass(value.cssClass);
        });

        // Add the CSS class for the new plugin
        this.$element.addClass(this.rules[matchedMq].cssClass);

        // Create an instance of the new plugin
        if (this.currentPlugin) this.currentPlugin.destroy();
        this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});
      }

      /**
       * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.currentPlugin.destroy();
        $(window).off('.zf.ResponsiveMenu');
        Foundation.unregisterPlugin(this);
      }
    }]);

    return ResponsiveMenu;
  }();

  ResponsiveMenu.defaults = {};

  // The plugin matches the plugin classes with these plugin instances.
  var MenuPlugins = {
    dropdown: {
      cssClass: 'dropdown',
      plugin: Foundation._plugins['dropdown-menu'] || null
    },
    drilldown: {
      cssClass: 'drilldown',
      plugin: Foundation._plugins['drilldown'] || null
    },
    accordion: {
      cssClass: 'accordion-menu',
      plugin: Foundation._plugins['accordion-menu'] || null
    }
  };

  // Window exports
  Foundation.plugin(ResponsiveMenu, 'ResponsiveMenu');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * ResponsiveToggle module.
   * @module foundation.responsiveToggle
   * @requires foundation.util.mediaQuery
   */

  var ResponsiveToggle = function () {
    /**
     * Creates a new instance of Tab Bar.
     * @class
     * @fires ResponsiveToggle#init
     * @param {jQuery} element - jQuery object to attach tab bar functionality to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function ResponsiveToggle(element, options) {
      _classCallCheck(this, ResponsiveToggle);

      this.$element = $(element);
      this.options = $.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);

      this._init();
      this._events();

      Foundation.registerPlugin(this, 'ResponsiveToggle');
    }

    /**
     * Initializes the tab bar by finding the target element, toggling element, and running update().
     * @function
     * @private
     */


    _createClass(ResponsiveToggle, [{
      key: '_init',
      value: function _init() {
        var targetID = this.$element.data('responsive-toggle');
        if (!targetID) {
          console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');
        }

        this.$targetMenu = $('#' + targetID);
        this.$toggler = this.$element.find('[data-toggle]');

        this._update();
      }

      /**
       * Adds necessary event handlers for the tab bar to work.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;

        this._updateMqHandler = this._update.bind(this);

        $(window).on('changed.zf.mediaquery', this._updateMqHandler);

        this.$toggler.on('click.zf.responsiveToggle', this.toggleMenu.bind(this));
      }

      /**
       * Checks the current media query to determine if the tab bar should be visible or hidden.
       * @function
       * @private
       */

    }, {
      key: '_update',
      value: function _update() {
        // Mobile
        if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {
          this.$element.show();
          this.$targetMenu.hide();
        }

        // Desktop
        else {
            this.$element.hide();
            this.$targetMenu.show();
          }
      }

      /**
       * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.
       * @function
       * @fires ResponsiveToggle#toggled
       */

    }, {
      key: 'toggleMenu',
      value: function toggleMenu() {
        if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {
          this.$targetMenu.toggle(0);

          /**
           * Fires when the element attached to the tab bar toggles.
           * @event ResponsiveToggle#toggled
           */
          this.$element.trigger('toggled.zf.responsiveToggle');
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.off('.zf.responsiveToggle');
        this.$toggler.off('.zf.responsiveToggle');

        $(window).off('changed.zf.mediaquery', this._updateMqHandler);

        Foundation.unregisterPlugin(this);
      }
    }]);

    return ResponsiveToggle;
  }();

  ResponsiveToggle.defaults = {
    /**
     * The breakpoint after which the menu is always shown, and the tab bar is hidden.
     * @option
     * @example 'medium'
     */
    hideFor: 'medium'
  };

  // Window exports
  Foundation.plugin(ResponsiveToggle, 'ResponsiveToggle');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Reveal module.
   * @module foundation.reveal
   * @requires foundation.util.keyboard
   * @requires foundation.util.box
   * @requires foundation.util.triggers
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.motion if using animations
   */

  var Reveal = function () {
    /**
     * Creates a new instance of Reveal.
     * @class
     * @param {jQuery} element - jQuery object to use for the modal.
     * @param {Object} options - optional parameters.
     */
    function Reveal(element, options) {
      _classCallCheck(this, Reveal);

      this.$element = element;
      this.options = $.extend({}, Reveal.defaults, this.$element.data(), options);
      this._init();

      Foundation.registerPlugin(this, 'Reveal');
      Foundation.Keyboard.register('Reveal', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ESCAPE': 'close',
        'TAB': 'tab_forward',
        'SHIFT_TAB': 'tab_backward'
      });
    }

    /**
     * Initializes the modal by adding the overlay and close buttons, (if selected).
     * @private
     */


    _createClass(Reveal, [{
      key: '_init',
      value: function _init() {
        this.id = this.$element.attr('id');
        this.isActive = false;
        this.cached = { mq: Foundation.MediaQuery.current };
        this.isMobile = mobileSniff();

        this.$anchor = $('[data-open="' + this.id + '"]').length ? $('[data-open="' + this.id + '"]') : $('[data-toggle="' + this.id + '"]');
        this.$anchor.attr({
          'aria-controls': this.id,
          'aria-haspopup': true,
          'tabindex': 0
        });

        if (this.options.fullScreen || this.$element.hasClass('full')) {
          this.options.fullScreen = true;
          this.options.overlay = false;
        }
        if (this.options.overlay && !this.$overlay) {
          this.$overlay = this._makeOverlay(this.id);
        }

        this.$element.attr({
          'role': 'dialog',
          'aria-hidden': true,
          'data-yeti-box': this.id,
          'data-resize': this.id
        });

        if (this.$overlay) {
          this.$element.detach().appendTo(this.$overlay);
        } else {
          this.$element.detach().appendTo($('body'));
          this.$element.addClass('without-overlay');
        }
        this._events();
        if (this.options.deepLink && window.location.hash === '#' + this.id) {
          $(window).one('load.zf.reveal', this.open.bind(this));
        }
      }

      /**
       * Creates an overlay div to display behind the modal.
       * @private
       */

    }, {
      key: '_makeOverlay',
      value: function _makeOverlay(id) {
        var $overlay = $('<div></div>').addClass('reveal-overlay').appendTo('body');
        return $overlay;
      }

      /**
       * Updates position of modal
       * TODO:  Figure out if we actually need to cache these values or if it doesn't matter
       * @private
       */

    }, {
      key: '_updatePosition',
      value: function _updatePosition() {
        var width = this.$element.outerWidth();
        var outerWidth = $(window).width();
        var height = this.$element.outerHeight();
        var outerHeight = $(window).height();
        var left, top;
        if (this.options.hOffset === 'auto') {
          left = parseInt((outerWidth - width) / 2, 10);
        } else {
          left = parseInt(this.options.hOffset, 10);
        }
        if (this.options.vOffset === 'auto') {
          if (height > outerHeight) {
            top = parseInt(Math.min(100, outerHeight / 10), 10);
          } else {
            top = parseInt((outerHeight - height) / 4, 10);
          }
        } else {
          top = parseInt(this.options.vOffset, 10);
        }
        this.$element.css({ top: top + 'px' });
        // only worry about left if we don't have an overlay or we havea  horizontal offset,
        // otherwise we're perfectly in the middle
        if (!this.$overlay || this.options.hOffset !== 'auto') {
          this.$element.css({ left: left + 'px' });
          this.$element.css({ margin: '0px' });
        }
      }

      /**
       * Adds event handlers for the modal.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this2 = this;

        var _this = this;

        this.$element.on({
          'open.zf.trigger': this.open.bind(this),
          'close.zf.trigger': function (event, $element) {
            if (event.target === _this.$element[0] || $(event.target).parents('[data-closable]')[0] === $element) {
              // only close reveal when it's explicitly called
              return _this2.close.apply(_this2);
            }
          },
          'toggle.zf.trigger': this.toggle.bind(this),
          'resizeme.zf.trigger': function () {
            _this._updatePosition();
          }
        });

        if (this.$anchor.length) {
          this.$anchor.on('keydown.zf.reveal', function (e) {
            if (e.which === 13 || e.which === 32) {
              e.stopPropagation();
              e.preventDefault();
              _this.open();
            }
          });
        }

        if (this.options.closeOnClick && this.options.overlay) {
          this.$overlay.off('.zf.reveal').on('click.zf.reveal', function (e) {
            if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {
              return;
            }
            _this.close();
          });
        }
        if (this.options.deepLink) {
          $(window).on('popstate.zf.reveal:' + this.id, this._handleState.bind(this));
        }
      }

      /**
       * Handles modal methods on back/forward button clicks or any other event that triggers popstate.
       * @private
       */

    }, {
      key: '_handleState',
      value: function _handleState(e) {
        if (window.location.hash === '#' + this.id && !this.isActive) {
          this.open();
        } else {
          this.close();
        }
      }

      /**
       * Opens the modal controlled by `this.$anchor`, and closes all others by default.
       * @function
       * @fires Reveal#closeme
       * @fires Reveal#open
       */

    }, {
      key: 'open',
      value: function open() {
        var _this3 = this;

        if (this.options.deepLink) {
          var hash = '#' + this.id;

          if (window.history.pushState) {
            window.history.pushState(null, null, hash);
          } else {
            window.location.hash = hash;
          }
        }

        this.isActive = true;

        // Make elements invisible, but remove display: none so we can get size and positioning
        this.$element.css({ 'visibility': 'hidden' }).show().scrollTop(0);
        if (this.options.overlay) {
          this.$overlay.css({ 'visibility': 'hidden' }).show();
        }

        this._updatePosition();

        this.$element.hide().css({ 'visibility': '' });

        if (this.$overlay) {
          this.$overlay.css({ 'visibility': '' }).hide();
          if (this.$element.hasClass('fast')) {
            this.$overlay.addClass('fast');
          } else if (this.$element.hasClass('slow')) {
            this.$overlay.addClass('slow');
          }
        }

        if (!this.options.multipleOpened) {
          /**
           * Fires immediately before the modal opens.
           * Closes any other modals that are currently open
           * @event Reveal#closeme
           */
          this.$element.trigger('closeme.zf.reveal', this.id);
        }
        // Motion UI method of reveal
        if (this.options.animationIn) {
          var _this;

          (function () {
            var afterAnimationFocus = function () {
              _this.$element.attr({
                'aria-hidden': false,
                'tabindex': -1
              }).focus();
              console.log('focus');
            };

            _this = _this3;

            if (_this3.options.overlay) {
              Foundation.Motion.animateIn(_this3.$overlay, 'fade-in');
            }
            Foundation.Motion.animateIn(_this3.$element, _this3.options.animationIn, function () {
              _this3.focusableElements = Foundation.Keyboard.findFocusable(_this3.$element);
              afterAnimationFocus();
            });
          })();
        }
        // jQuery method of reveal
        else {
            if (this.options.overlay) {
              this.$overlay.show(0);
            }
            this.$element.show(this.options.showDelay);
          }

        // handle accessibility
        this.$element.attr({
          'aria-hidden': false,
          'tabindex': -1
        }).focus();

        /**
         * Fires when the modal has successfully opened.
         * @event Reveal#open
         */
        this.$element.trigger('open.zf.reveal');

        if (this.isMobile) {
          this.originalScrollPos = window.pageYOffset;
          $('html, body').addClass('is-reveal-open');
        } else {
          $('body').addClass('is-reveal-open');
        }

        setTimeout(function () {
          _this3._extraHandlers();
        }, 0);
      }

      /**
       * Adds extra event handlers for the body and window if necessary.
       * @private
       */

    }, {
      key: '_extraHandlers',
      value: function _extraHandlers() {
        var _this = this;
        this.focusableElements = Foundation.Keyboard.findFocusable(this.$element);

        if (!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen) {
          $('body').on('click.zf.reveal', function (e) {
            if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {
              return;
            }
            _this.close();
          });
        }

        if (this.options.closeOnEsc) {
          $(window).on('keydown.zf.reveal', function (e) {
            Foundation.Keyboard.handleKey(e, 'Reveal', {
              close: function () {
                if (_this.options.closeOnEsc) {
                  _this.close();
                  _this.$anchor.focus();
                }
              }
            });
          });
        }

        // lock focus within modal while tabbing
        this.$element.on('keydown.zf.reveal', function (e) {
          var $target = $(this);
          // handle keyboard event with keyboard util
          Foundation.Keyboard.handleKey(e, 'Reveal', {
            tab_forward: function () {
              if (_this.$element.find(':focus').is(_this.focusableElements.eq(-1))) {
                // left modal downwards, setting focus to first element
                _this.focusableElements.eq(0).focus();
                return true;
              }
              if (_this.focusableElements.length === 0) {
                // no focusable elements inside the modal at all, prevent tabbing in general
                return true;
              }
            },
            tab_backward: function () {
              if (_this.$element.find(':focus').is(_this.focusableElements.eq(0)) || _this.$element.is(':focus')) {
                // left modal upwards, setting focus to last element
                _this.focusableElements.eq(-1).focus();
                return true;
              }
              if (_this.focusableElements.length === 0) {
                // no focusable elements inside the modal at all, prevent tabbing in general
                return true;
              }
            },
            open: function () {
              if (_this.$element.find(':focus').is(_this.$element.find('[data-close]'))) {
                setTimeout(function () {
                  // set focus back to anchor if close button has been activated
                  _this.$anchor.focus();
                }, 1);
              } else if ($target.is(_this.focusableElements)) {
                // dont't trigger if acual element has focus (i.e. inputs, links, ...)
                _this.open();
              }
            },
            close: function () {
              if (_this.options.closeOnEsc) {
                _this.close();
                _this.$anchor.focus();
              }
            },
            handled: function (preventDefault) {
              if (preventDefault) {
                e.preventDefault();
              }
            }
          });
        });
      }

      /**
       * Closes the modal.
       * @function
       * @fires Reveal#closed
       */

    }, {
      key: 'close',
      value: function close() {
        if (!this.isActive || !this.$element.is(':visible')) {
          return false;
        }
        var _this = this;

        // Motion UI method of hiding
        if (this.options.animationOut) {
          if (this.options.overlay) {
            Foundation.Motion.animateOut(this.$overlay, 'fade-out', finishUp);
          } else {
            finishUp();
          }

          Foundation.Motion.animateOut(this.$element, this.options.animationOut);
        }
        // jQuery method of hiding
        else {
            if (this.options.overlay) {
              this.$overlay.hide(0, finishUp);
            } else {
              finishUp();
            }

            this.$element.hide(this.options.hideDelay);
          }

        // Conditionals to remove extra event listeners added on open
        if (this.options.closeOnEsc) {
          $(window).off('keydown.zf.reveal');
        }

        if (!this.options.overlay && this.options.closeOnClick) {
          $('body').off('click.zf.reveal');
        }

        this.$element.off('keydown.zf.reveal');

        function finishUp() {
          if (_this.isMobile) {
            $('html, body').removeClass('is-reveal-open');
            if (_this.originalScrollPos) {
              $('body').scrollTop(_this.originalScrollPos);
              _this.originalScrollPos = null;
            }
          } else {
            $('body').removeClass('is-reveal-open');
          }

          _this.$element.attr('aria-hidden', true);

          /**
          * Fires when the modal is done closing.
          * @event Reveal#closed
          */
          _this.$element.trigger('closed.zf.reveal');
        }

        /**
        * Resets the modal content
        * This prevents a running video to keep going in the background
        */
        if (this.options.resetOnClose) {
          this.$element.html(this.$element.html());
        }

        this.isActive = false;
        if (_this.options.deepLink) {
          if (window.history.replaceState) {
            window.history.replaceState("", document.title, window.location.pathname);
          } else {
            window.location.hash = '';
          }
        }
      }

      /**
       * Toggles the open/closed state of a modal.
       * @function
       */

    }, {
      key: 'toggle',
      value: function toggle() {
        if (this.isActive) {
          this.close();
        } else {
          this.open();
        }
      }
    }, {
      key: 'destroy',


      /**
       * Destroys an instance of a modal.
       * @function
       */
      value: function destroy() {
        if (this.options.overlay) {
          this.$element.appendTo($('body')); // move $element outside of $overlay to prevent error unregisterPlugin()
          this.$overlay.hide().off().remove();
        }
        this.$element.hide().off();
        this.$anchor.off('.zf');
        $(window).off('.zf.reveal:' + this.id);

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Reveal;
  }();

  Reveal.defaults = {
    /**
     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
     * @option
     * @example 'slide-in-left'
     */
    animationIn: '',
    /**
     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
     * @option
     * @example 'slide-out-right'
     */
    animationOut: '',
    /**
     * Time, in ms, to delay the opening of a modal after a click if no animation used.
     * @option
     * @example 10
     */
    showDelay: 0,
    /**
     * Time, in ms, to delay the closing of a modal after a click if no animation used.
     * @option
     * @example 10
     */
    hideDelay: 0,
    /**
     * Allows a click on the body/overlay to close the modal.
     * @option
     * @example true
     */
    closeOnClick: true,
    /**
     * Allows the modal to close if the user presses the `ESCAPE` key.
     * @option
     * @example true
     */
    closeOnEsc: true,
    /**
     * If true, allows multiple modals to be displayed at once.
     * @option
     * @example false
     */
    multipleOpened: false,
    /**
     * Distance, in pixels, the modal should push down from the top of the screen.
     * @option
     * @example auto
     */
    vOffset: 'auto',
    /**
     * Distance, in pixels, the modal should push in from the side of the screen.
     * @option
     * @example auto
     */
    hOffset: 'auto',
    /**
     * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.
     * @option
     * @example false
     */
    fullScreen: false,
    /**
     * Percentage of screen height the modal should push up from the bottom of the view.
     * @option
     * @example 10
     */
    btmOffsetPct: 10,
    /**
     * Allows the modal to generate an overlay div, which will cover the view when modal opens.
     * @option
     * @example true
     */
    overlay: true,
    /**
     * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.
     * @option
     * @example false
     */
    resetOnClose: false,
    /**
     * Allows the modal to alter the url on open/close, and allows the use of the `back` button to close modals. ALSO, allows a modal to auto-maniacally open on page load IF the hash === the modal's user-set id.
     * @option
     * @example false
     */
    deepLink: false
  };

  // Window exports
  Foundation.plugin(Reveal, 'Reveal');

  function iPhoneSniff() {
    return (/iP(ad|hone|od).*OS/.test(window.navigator.userAgent)
    );
  }

  function androidSniff() {
    return (/Android/.test(window.navigator.userAgent)
    );
  }

  function mobileSniff() {
    return iPhoneSniff() || androidSniff();
  }
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Slider module.
   * @module foundation.slider
   * @requires foundation.util.motion
   * @requires foundation.util.triggers
   * @requires foundation.util.keyboard
   * @requires foundation.util.touch
   */

  var Slider = function () {
    /**
     * Creates a new instance of a drilldown menu.
     * @class
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Slider(element, options) {
      _classCallCheck(this, Slider);

      this.$element = element;
      this.options = $.extend({}, Slider.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Slider');
      Foundation.Keyboard.register('Slider', {
        'ltr': {
          'ARROW_RIGHT': 'increase',
          'ARROW_UP': 'increase',
          'ARROW_DOWN': 'decrease',
          'ARROW_LEFT': 'decrease',
          'SHIFT_ARROW_RIGHT': 'increase_fast',
          'SHIFT_ARROW_UP': 'increase_fast',
          'SHIFT_ARROW_DOWN': 'decrease_fast',
          'SHIFT_ARROW_LEFT': 'decrease_fast'
        },
        'rtl': {
          'ARROW_LEFT': 'increase',
          'ARROW_RIGHT': 'decrease',
          'SHIFT_ARROW_LEFT': 'increase_fast',
          'SHIFT_ARROW_RIGHT': 'decrease_fast'
        }
      });
    }

    /**
     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).
     * @function
     * @private
     */


    _createClass(Slider, [{
      key: '_init',
      value: function _init() {
        this.inputs = this.$element.find('input');
        this.handles = this.$element.find('[data-slider-handle]');

        this.$handle = this.handles.eq(0);
        this.$input = this.inputs.length ? this.inputs.eq(0) : $('#' + this.$handle.attr('aria-controls'));
        this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);

        var isDbl = false,
            _this = this;
        if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {
          this.options.disabled = true;
          this.$element.addClass(this.options.disabledClass);
        }
        if (!this.inputs.length) {
          this.inputs = $().add(this.$input);
          this.options.binding = true;
        }
        this._setInitAttr(0);
        this._events(this.$handle);

        if (this.handles[1]) {
          this.options.doubleSided = true;
          this.$handle2 = this.handles.eq(1);
          this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : $('#' + this.$handle2.attr('aria-controls'));

          if (!this.inputs[1]) {
            this.inputs = this.inputs.add(this.$input2);
          }
          isDbl = true;

          this._setHandlePos(this.$handle, this.options.initialStart, true, function () {

            _this._setHandlePos(_this.$handle2, _this.options.initialEnd, true);
          });
          // this.$handle.triggerHandler('click.zf.slider');
          this._setInitAttr(1);
          this._events(this.$handle2);
        }

        if (!isDbl) {
          this._setHandlePos(this.$handle, this.options.initialStart, true);
        }
      }

      /**
       * Sets the position of the selected handle and fill bar.
       * @function
       * @private
       * @param {jQuery} $hndl - the selected handle to move.
       * @param {Number} location - floating point between the start and end values of the slider bar.
       * @param {Function} cb - callback function to fire on completion.
       * @fires Slider#moved
       * @fires Slider#changed
       */

    }, {
      key: '_setHandlePos',
      value: function _setHandlePos($hndl, location, noInvert, cb) {
        // don't move if the slider has been disabled since its initialization
        if (this.$element.hasClass(this.options.disabledClass)) {
          return;
        }
        //might need to alter that slightly for bars that will have odd number selections.
        location = parseFloat(location); //on input change events, convert string to number...grumble.

        // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max
        if (location < this.options.start) {
          location = this.options.start;
        } else if (location > this.options.end) {
          location = this.options.end;
        }

        var isDbl = this.options.doubleSided;

        if (isDbl) {
          //this block is to prevent 2 handles from crossing eachother. Could/should be improved.
          if (this.handles.index($hndl) === 0) {
            var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));
            location = location >= h2Val ? h2Val - this.options.step : location;
          } else {
            var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));
            location = location <= h1Val ? h1Val + this.options.step : location;
          }
        }

        //this is for single-handled vertical sliders, it adjusts the value to account for the slider being "upside-down"
        //for click and drag events, it's weird due to the scale(-1, 1) css property
        if (this.options.vertical && !noInvert) {
          location = this.options.end - location;
        }

        var _this = this,
            vert = this.options.vertical,
            hOrW = vert ? 'height' : 'width',
            lOrT = vert ? 'top' : 'left',
            handleDim = $hndl[0].getBoundingClientRect()[hOrW],
            elemDim = this.$element[0].getBoundingClientRect()[hOrW],

        //percentage of bar min/max value based on click or drag point
        pctOfBar = percent(location - this.options.start, this.options.end - this.options.start).toFixed(2),

        //number of actual pixels to shift the handle, based on the percentage obtained above
        pxToMove = (elemDim - handleDim) * pctOfBar,

        //percentage of bar to shift the handle
        movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal);
        //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value
        location = parseFloat(location.toFixed(this.options.decimal));
        // declare empty object for css adjustments, only used with 2 handled-sliders
        var css = {};

        this._setValues($hndl, location);

        // TODO update to calculate based on values set to respective inputs??
        if (isDbl) {
          var isLeftHndl = this.handles.index($hndl) === 0,

          //empty variable, will be used for min-height/width for fill bar
          dim,

          //percentage w/h of the handle compared to the slider bar
          handlePct = ~~(percent(handleDim, elemDim) * 100);
          //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar
          if (isLeftHndl) {
            //left or top percentage value to apply to the fill bar.
            css[lOrT] = movement + '%';
            //calculate the new min-height/width for the fill bar.
            dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct;
            //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider
            //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.
            if (cb && typeof cb === 'function') {
              cb();
            } //this is only needed for the initialization of 2 handled sliders
          } else {
            //just caching the value of the left/bottom handle's left/top property
            var handlePos = parseFloat(this.$handle[0].style[lOrT]);
            //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0
            //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself
            dim = movement - (isNaN(handlePos) ? this.options.initialStart / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;
          }
          // assign the min-height/width to our css object
          css['min-' + hOrW] = dim + '%';
        }

        this.$element.one('finished.zf.animate', function () {
          /**
           * Fires when the handle is done moving.
           * @event Slider#moved
           */
          _this.$element.trigger('moved.zf.slider', [$hndl]);
        });

        //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.
        var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;

        Foundation.Move(moveTime, $hndl, function () {
          //adjusting the left/top property of the handle, based on the percentage calculated above
          $hndl.css(lOrT, movement + '%');

          if (!_this.options.doubleSided) {
            //if single-handled, a simple method to expand the fill bar
            _this.$fill.css(hOrW, pctOfBar * 100 + '%');
          } else {
            //otherwise, use the css object we created above
            _this.$fill.css(css);
          }
        });

        /**
         * Fires when the value has not been change for a given time.
         * @event Slider#changed
         */
        clearTimeout(_this.timeout);
        _this.timeout = setTimeout(function () {
          _this.$element.trigger('changed.zf.slider', [$hndl]);
        }, _this.options.changedDelay);
      }

      /**
       * Sets the initial attribute for the slider element.
       * @function
       * @private
       * @param {Number} idx - index of the current handle/input to use.
       */

    }, {
      key: '_setInitAttr',
      value: function _setInitAttr(idx) {
        var id = this.inputs.eq(idx).attr('id') || Foundation.GetYoDigits(6, 'slider');
        this.inputs.eq(idx).attr({
          'id': id,
          'max': this.options.end,
          'min': this.options.start,
          'step': this.options.step
        });
        this.handles.eq(idx).attr({
          'role': 'slider',
          'aria-controls': id,
          'aria-valuemax': this.options.end,
          'aria-valuemin': this.options.start,
          'aria-valuenow': idx === 0 ? this.options.initialStart : this.options.initialEnd,
          'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',
          'tabindex': 0
        });
      }

      /**
       * Sets the input and `aria-valuenow` values for the slider element.
       * @function
       * @private
       * @param {jQuery} $handle - the currently selected handle.
       * @param {Number} val - floating point of the new value.
       */

    }, {
      key: '_setValues',
      value: function _setValues($handle, val) {
        var idx = this.options.doubleSided ? this.handles.index($handle) : 0;
        this.inputs.eq(idx).val(val);
        $handle.attr('aria-valuenow', val);
      }

      /**
       * Handles events on the slider element.
       * Calculates the new location of the current handle.
       * If there are two handles and the bar was clicked, it determines which handle to move.
       * @function
       * @private
       * @param {Object} e - the `event` object passed from the listener.
       * @param {jQuery} $handle - the current handle to calculate for, if selected.
       * @param {Number} val - floating point number for the new value of the slider.
       * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.
       */

    }, {
      key: '_handleEvent',
      value: function _handleEvent(e, $handle, val) {
        var value, hasVal;
        if (!val) {
          //click or drag events
          e.preventDefault();
          var _this = this,
              vertical = this.options.vertical,
              param = vertical ? 'height' : 'width',
              direction = vertical ? 'top' : 'left',
              eventOffset = vertical ? e.pageY : e.pageX,
              halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,
              barDim = this.$element[0].getBoundingClientRect()[param],
              windowScroll = vertical ? $(window).scrollTop() : $(window).scrollLeft();

          var elemOffset = this.$element.offset()[direction];

          // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...
          // best way to guess this is simulated is if clientY == pageY
          if (e.clientY === e.pageY) {
            eventOffset = eventOffset + windowScroll;
          }
          var eventFromBar = eventOffset - elemOffset;
          var barXY;
          if (eventFromBar < 0) {
            barXY = 0;
          } else if (eventFromBar > barDim) {
            barXY = barDim;
          } else {
            barXY = eventFromBar;
          }
          offsetPct = percent(barXY, barDim);

          value = (this.options.end - this.options.start) * offsetPct + this.options.start;

          // turn everything around for RTL, yay math!
          if (Foundation.rtl() && !this.options.vertical) {
            value = this.options.end - value;
          }

          value = _this._adjustValue(null, value);
          //boolean flag for the setHandlePos fn, specifically for vertical sliders
          hasVal = false;

          if (!$handle) {
            //figure out which handle it is, pass it to the next function.
            var firstHndlPos = absPosition(this.$handle, direction, barXY, param),
                secndHndlPos = absPosition(this.$handle2, direction, barXY, param);
            $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;
          }
        } else {
          //change event on input
          value = this._adjustValue(null, val);
          hasVal = true;
        }

        this._setHandlePos($handle, value, hasVal);
      }

      /**
       * Adjustes value for handle in regard to step value. returns adjusted value
       * @function
       * @private
       * @param {jQuery} $handle - the selected handle.
       * @param {Number} value - value to adjust. used if $handle is falsy
       */

    }, {
      key: '_adjustValue',
      value: function _adjustValue($handle, value) {
        var val,
            step = this.options.step,
            div = parseFloat(step / 2),
            left,
            prev_val,
            next_val;
        if (!!$handle) {
          val = parseFloat($handle.attr('aria-valuenow'));
        } else {
          val = value;
        }
        left = val % step;
        prev_val = val - left;
        next_val = prev_val + step;
        if (left === 0) {
          return val;
        }
        val = val >= prev_val + div ? next_val : prev_val;
        return val;
      }

      /**
       * Adds event listeners to the slider elements.
       * @function
       * @private
       * @param {jQuery} $handle - the current handle to apply listeners to.
       */

    }, {
      key: '_events',
      value: function _events($handle) {
        var _this = this,
            curHandle,
            timer;

        this.inputs.off('change.zf.slider').on('change.zf.slider', function (e) {
          var idx = _this.inputs.index($(this));
          _this._handleEvent(e, _this.handles.eq(idx), $(this).val());
        });

        if (this.options.clickSelect) {
          this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {
            if (_this.$element.data('dragging')) {
              return false;
            }

            if (!$(e.target).is('[data-slider-handle]')) {
              if (_this.options.doubleSided) {
                _this._handleEvent(e);
              } else {
                _this._handleEvent(e, _this.$handle);
              }
            }
          });
        }

        if (this.options.draggable) {
          this.handles.addTouch();

          var $body = $('body');
          $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {
            $handle.addClass('is-dragging');
            _this.$fill.addClass('is-dragging'); //
            _this.$element.data('dragging', true);

            curHandle = $(e.currentTarget);

            $body.on('mousemove.zf.slider', function (e) {
              e.preventDefault();
              _this._handleEvent(e, curHandle);
            }).on('mouseup.zf.slider', function (e) {
              _this._handleEvent(e, curHandle);

              $handle.removeClass('is-dragging');
              _this.$fill.removeClass('is-dragging');
              _this.$element.data('dragging', false);

              $body.off('mousemove.zf.slider mouseup.zf.slider');
            });
          })
          // prevent events triggered by touch
          .on('selectstart.zf.slider touchmove.zf.slider', function (e) {
            e.preventDefault();
          });
        }

        $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {
          var _$handle = $(this),
              idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,
              oldValue = parseFloat(_this.inputs.eq(idx).val()),
              newValue;

          // handle keyboard event with keyboard util
          Foundation.Keyboard.handleKey(e, 'Slider', {
            decrease: function () {
              newValue = oldValue - _this.options.step;
            },
            increase: function () {
              newValue = oldValue + _this.options.step;
            },
            decrease_fast: function () {
              newValue = oldValue - _this.options.step * 10;
            },
            increase_fast: function () {
              newValue = oldValue + _this.options.step * 10;
            },
            handled: function () {
              // only set handle pos when event was handled specially
              e.preventDefault();
              _this._setHandlePos(_$handle, newValue, true);
            }
          });
          /*if (newValue) { // if pressed key has special function, update value
            e.preventDefault();
            _this._setHandlePos(_$handle, newValue);
          }*/
        });
      }

      /**
       * Destroys the slider plugin.
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.handles.off('.zf.slider');
        this.inputs.off('.zf.slider');
        this.$element.off('.zf.slider');

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Slider;
  }();

  Slider.defaults = {
    /**
     * Minimum value for the slider scale.
     * @option
     * @example 0
     */
    start: 0,
    /**
     * Maximum value for the slider scale.
     * @option
     * @example 100
     */
    end: 100,
    /**
     * Minimum value change per change event.
     * @option
     * @example 1
     */
    step: 1,
    /**
     * Value at which the handle/input *(left handle/first input)* should be set to on initialization.
     * @option
     * @example 0
     */
    initialStart: 0,
    /**
     * Value at which the right handle/second input should be set to on initialization.
     * @option
     * @example 100
     */
    initialEnd: 100,
    /**
     * Allows the input to be located outside the container and visible. Set to by the JS
     * @option
     * @example false
     */
    binding: false,
    /**
     * Allows the user to click/tap on the slider bar to select a value.
     * @option
     * @example true
     */
    clickSelect: true,
    /**
     * Set to true and use the `vertical` class to change alignment to vertical.
     * @option
     * @example false
     */
    vertical: false,
    /**
     * Allows the user to drag the slider handle(s) to select a value.
     * @option
     * @example true
     */
    draggable: true,
    /**
     * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.
     * @option
     * @example false
     */
    disabled: false,
    /**
     * Allows the use of two handles. Double checked by the JS. Changes some logic handling.
     * @option
     * @example false
     */
    doubleSided: false,
    /**
     * Potential future feature.
     */
    // steps: 100,
    /**
     * Number of decimal places the plugin should go to for floating point precision.
     * @option
     * @example 2
     */
    decimal: 2,
    /**
     * Time delay for dragged elements.
     */
    // dragDelay: 0,
    /**
     * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.
     * @option
     * @example 200
     */
    moveTime: 200, //update this if changing the transition time in the sass
    /**
     * Class applied to disabled sliders.
     * @option
     * @example 'disabled'
     */
    disabledClass: 'disabled',
    /**
     * Will invert the default layout for a vertical<span data-tooltip title="who would do this???"> </span>slider.
     * @option
     * @example false
     */
    invertVertical: false,
    /**
     * Milliseconds before the `changed.zf-slider` event is triggered after value change.
     * @option
     * @example 500
     */
    changedDelay: 500
  };

  function percent(frac, num) {
    return frac / num;
  }
  function absPosition($handle, dir, clickPos, param) {
    return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);
  }

  // Window exports
  Foundation.plugin(Slider, 'Slider');
}(jQuery);

//*********this is in case we go to static, absolute positions instead of dynamic positioning********
// this.setSteps(function() {
//   _this._events();
//   var initStart = _this.options.positions[_this.options.initialStart - 1] || null;
//   var initEnd = _this.options.initialEnd ? _this.options.position[_this.options.initialEnd - 1] : null;
//   if (initStart || initEnd) {
//     _this._handleEvent(initStart, initEnd);
//   }
// });

//***********the other part of absolute positions*************
// Slider.prototype.setSteps = function(cb) {
//   var posChange = this.$element.outerWidth() / this.options.steps;
//   var counter = 0
//   while(counter < this.options.steps) {
//     if (counter) {
//       this.options.positions.push(this.options.positions[counter - 1] + posChange);
//     } else {
//       this.options.positions.push(posChange);
//     }
//     counter++;
//   }
//   cb();
// };
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Sticky module.
   * @module foundation.sticky
   * @requires foundation.util.triggers
   * @requires foundation.util.mediaQuery
   */

  var Sticky = function () {
    /**
     * Creates a new instance of a sticky thing.
     * @class
     * @param {jQuery} element - jQuery object to make sticky.
     * @param {Object} options - options object passed when creating the element programmatically.
     */
    function Sticky(element, options) {
      _classCallCheck(this, Sticky);

      this.$element = element;
      this.options = $.extend({}, Sticky.defaults, this.$element.data(), options);

      this._init();

      Foundation.registerPlugin(this, 'Sticky');
    }

    /**
     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes
     * @function
     * @private
     */


    _createClass(Sticky, [{
      key: '_init',
      value: function _init() {
        var $parent = this.$element.parent('[data-sticky-container]'),
            id = this.$element[0].id || Foundation.GetYoDigits(6, 'sticky'),
            _this = this;

        if (!$parent.length) {
          this.wasWrapped = true;
        }
        this.$container = $parent.length ? $parent : $(this.options.container).wrapInner(this.$element);
        this.$container.addClass(this.options.containerClass);

        this.$element.addClass(this.options.stickyClass).attr({ 'data-resize': id });

        this.scrollCount = this.options.checkEvery;
        this.isStuck = false;
        $(window).one('load.zf.sticky', function () {
          if (_this.options.anchor !== '') {
            _this.$anchor = $('#' + _this.options.anchor);
          } else {
            _this._parsePoints();
          }

          _this._setSizes(function () {
            _this._calc(false);
          });
          _this._events(id.split('-').reverse().join('-'));
        });
      }

      /**
       * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.
       * @function
       * @private
       */

    }, {
      key: '_parsePoints',
      value: function _parsePoints() {
        var top = this.options.topAnchor == "" ? 1 : this.options.topAnchor,
            btm = this.options.btmAnchor == "" ? document.documentElement.scrollHeight : this.options.btmAnchor,
            pts = [top, btm],
            breaks = {};
        for (var i = 0, len = pts.length; i < len && pts[i]; i++) {
          var pt;
          if (typeof pts[i] === 'number') {
            pt = pts[i];
          } else {
            var place = pts[i].split(':'),
                anchor = $('#' + place[0]);

            pt = anchor.offset().top;
            if (place[1] && place[1].toLowerCase() === 'bottom') {
              pt += anchor[0].getBoundingClientRect().height;
            }
          }
          breaks[i] = pt;
        }

        this.points = breaks;
        return;
      }

      /**
       * Adds event handlers for the scrolling element.
       * @private
       * @param {String} id - psuedo-random id for unique scroll event listener.
       */

    }, {
      key: '_events',
      value: function _events(id) {
        var _this = this,
            scrollListener = this.scrollListener = 'scroll.zf.' + id;
        if (this.isOn) {
          return;
        }
        if (this.canStick) {
          this.isOn = true;
          $(window).off(scrollListener).on(scrollListener, function (e) {
            if (_this.scrollCount === 0) {
              _this.scrollCount = _this.options.checkEvery;
              _this._setSizes(function () {
                _this._calc(false, window.pageYOffset);
              });
            } else {
              _this.scrollCount--;
              _this._calc(false, window.pageYOffset);
            }
          });
        }

        this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {
          _this._setSizes(function () {
            _this._calc(false);
            if (_this.canStick) {
              if (!_this.isOn) {
                _this._events(id);
              }
            } else if (_this.isOn) {
              _this._pauseListeners(scrollListener);
            }
          });
        });
      }

      /**
       * Removes event handlers for scroll and change events on anchor.
       * @fires Sticky#pause
       * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`
       */

    }, {
      key: '_pauseListeners',
      value: function _pauseListeners(scrollListener) {
        this.isOn = false;
        $(window).off(scrollListener);

        /**
         * Fires when the plugin is paused due to resize event shrinking the view.
         * @event Sticky#pause
         * @private
         */
        this.$element.trigger('pause.zf.sticky');
      }

      /**
       * Called on every `scroll` event and on `_init`
       * fires functions based on booleans and cached values
       * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.
       * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.
       */

    }, {
      key: '_calc',
      value: function _calc(checkSizes, scroll) {
        if (checkSizes) {
          this._setSizes();
        }

        if (!this.canStick) {
          if (this.isStuck) {
            this._removeSticky(true);
          }
          return false;
        }

        if (!scroll) {
          scroll = window.pageYOffset;
        }

        if (scroll >= this.topPoint) {
          if (scroll <= this.bottomPoint) {
            if (!this.isStuck) {
              this._setSticky();
            }
          } else {
            if (this.isStuck) {
              this._removeSticky(false);
            }
          }
        } else {
          if (this.isStuck) {
            this._removeSticky(true);
          }
        }
      }

      /**
       * Causes the $element to become stuck.
       * Adds `position: fixed;`, and helper classes.
       * @fires Sticky#stuckto
       * @function
       * @private
       */

    }, {
      key: '_setSticky',
      value: function _setSticky() {
        var _this = this,
            stickTo = this.options.stickTo,
            mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',
            notStuckTo = stickTo === 'top' ? 'bottom' : 'top',
            css = {};

        css[mrgn] = this.options[mrgn] + 'em';
        css[stickTo] = 0;
        css[notStuckTo] = 'auto';
        css['left'] = this.$container.offset().left + parseInt(window.getComputedStyle(this.$container[0])["padding-left"], 10);
        this.isStuck = true;
        this.$element.removeClass('is-anchored is-at-' + notStuckTo).addClass('is-stuck is-at-' + stickTo).css(css)
        /**
         * Fires when the $element has become `position: fixed;`
         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`
         * @event Sticky#stuckto
         */
        .trigger('sticky.zf.stuckto:' + stickTo);
        this.$element.on("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd", function () {
          _this._setSizes();
        });
      }

      /**
       * Causes the $element to become unstuck.
       * Removes `position: fixed;`, and helper classes.
       * Adds other helper classes.
       * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.
       * @fires Sticky#unstuckfrom
       * @private
       */

    }, {
      key: '_removeSticky',
      value: function _removeSticky(isTop) {
        var stickTo = this.options.stickTo,
            stickToTop = stickTo === 'top',
            css = {},
            anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,
            mrgn = stickToTop ? 'marginTop' : 'marginBottom',
            notStuckTo = stickToTop ? 'bottom' : 'top',
            topOrBottom = isTop ? 'top' : 'bottom';

        css[mrgn] = 0;

        css['bottom'] = 'auto';
        if (isTop) {
          css['top'] = 0;
        } else {
          css['top'] = anchorPt;
        }

        css['left'] = '';
        this.isStuck = false;
        this.$element.removeClass('is-stuck is-at-' + stickTo).addClass('is-anchored is-at-' + topOrBottom).css(css)
        /**
         * Fires when the $element has become anchored.
         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`
         * @event Sticky#unstuckfrom
         */
        .trigger('sticky.zf.unstuckfrom:' + topOrBottom);
      }

      /**
       * Sets the $element and $container sizes for plugin.
       * Calls `_setBreakPoints`.
       * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.
       * @private
       */

    }, {
      key: '_setSizes',
      value: function _setSizes(cb) {
        this.canStick = Foundation.MediaQuery.atLeast(this.options.stickyOn);
        if (!this.canStick) {
          cb();
        }
        var _this = this,
            newElemWidth = this.$container[0].getBoundingClientRect().width,
            comp = window.getComputedStyle(this.$container[0]),
            pdng = parseInt(comp['padding-right'], 10);

        if (this.$anchor && this.$anchor.length) {
          this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;
        } else {
          this._parsePoints();
        }

        this.$element.css({
          'max-width': newElemWidth - pdng + 'px'
        });

        var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;
        if (this.$element.css("display") == "none") {
          newContainerHeight = 0;
        }
        this.containerHeight = newContainerHeight;
        this.$container.css({
          height: newContainerHeight
        });
        this.elemHeight = newContainerHeight;

        if (this.isStuck) {
          this.$element.css({ "left": this.$container.offset().left + parseInt(comp['padding-left'], 10) });
        }

        this._setBreakPoints(newContainerHeight, function () {
          if (cb) {
            cb();
          }
        });
      }

      /**
       * Sets the upper and lower breakpoints for the element to become sticky/unsticky.
       * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.
       * @param {Function} cb - optional callback function to be called on completion.
       * @private
       */

    }, {
      key: '_setBreakPoints',
      value: function _setBreakPoints(elemHeight, cb) {
        if (!this.canStick) {
          if (cb) {
            cb();
          } else {
            return false;
          }
        }
        var mTop = emCalc(this.options.marginTop),
            mBtm = emCalc(this.options.marginBottom),
            topPoint = this.points ? this.points[0] : this.$anchor.offset().top,
            bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,

        // topPoint = this.$anchor.offset().top || this.points[0],
        // bottomPoint = topPoint + this.anchorHeight || this.points[1],
        winHeight = window.innerHeight;

        if (this.options.stickTo === 'top') {
          topPoint -= mTop;
          bottomPoint -= elemHeight + mTop;
        } else if (this.options.stickTo === 'bottom') {
          topPoint -= winHeight - (elemHeight + mBtm);
          bottomPoint -= winHeight - mBtm;
        } else {
          //this would be the stickTo: both option... tricky
        }

        this.topPoint = topPoint;
        this.bottomPoint = bottomPoint;

        if (cb) {
          cb();
        }
      }

      /**
       * Destroys the current sticky element.
       * Resets the element to the top position first.
       * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this._removeSticky(true);

        this.$element.removeClass(this.options.stickyClass + ' is-anchored is-at-top').css({
          height: '',
          top: '',
          bottom: '',
          'max-width': ''
        }).off('resizeme.zf.trigger');
        if (this.$anchor && this.$anchor.length) {
          this.$anchor.off('change.zf.sticky');
        }
        $(window).off(this.scrollListener);

        if (this.wasWrapped) {
          this.$element.unwrap();
        } else {
          this.$container.removeClass(this.options.containerClass).css({
            height: ''
          });
        }
        Foundation.unregisterPlugin(this);
      }
    }]);

    return Sticky;
  }();

  Sticky.defaults = {
    /**
     * Customizable container template. Add your own classes for styling and sizing.
     * @option
     * @example '&lt;div data-sticky-container class="small-6 columns"&gt;&lt;/div&gt;'
     */
    container: '<div data-sticky-container></div>',
    /**
     * Location in the view the element sticks to.
     * @option
     * @example 'top'
     */
    stickTo: 'top',
    /**
     * If anchored to a single element, the id of that element.
     * @option
     * @example 'exampleId'
     */
    anchor: '',
    /**
     * If using more than one element as anchor points, the id of the top anchor.
     * @option
     * @example 'exampleId:top'
     */
    topAnchor: '',
    /**
     * If using more than one element as anchor points, the id of the bottom anchor.
     * @option
     * @example 'exampleId:bottom'
     */
    btmAnchor: '',
    /**
     * Margin, in `em`'s to apply to the top of the element when it becomes sticky.
     * @option
     * @example 1
     */
    marginTop: 1,
    /**
     * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.
     * @option
     * @example 1
     */
    marginBottom: 1,
    /**
     * Breakpoint string that is the minimum screen size an element should become sticky.
     * @option
     * @example 'medium'
     */
    stickyOn: 'medium',
    /**
     * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.
     * @option
     * @example 'sticky'
     */
    stickyClass: 'sticky',
    /**
     * Class applied to sticky container. Foundation defaults to `sticky-container`.
     * @option
     * @example 'sticky-container'
     */
    containerClass: 'sticky-container',
    /**
     * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.
     * @option
     * @example 50
     */
    checkEvery: -1
  };

  /**
   * Helper function to calculate em values
   * @param Number {em} - number of em's to calculate into pixels
   */
  function emCalc(em) {
    return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;
  }

  // Window exports
  Foundation.plugin(Sticky, 'Sticky');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Tabs module.
   * @module foundation.tabs
   * @requires foundation.util.keyboard
   * @requires foundation.util.timerAndImageLoader if tabs contain images
   */

  var Tabs = function () {
    /**
     * Creates a new instance of tabs.
     * @class
     * @fires Tabs#init
     * @param {jQuery} element - jQuery object to make into tabs.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Tabs(element, options) {
      _classCallCheck(this, Tabs);

      this.$element = element;
      this.options = $.extend({}, Tabs.defaults, this.$element.data(), options);

      this._init();
      Foundation.registerPlugin(this, 'Tabs');
      Foundation.Keyboard.register('Tabs', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'previous',
        'ARROW_DOWN': 'next',
        'ARROW_LEFT': 'previous'
        // 'TAB': 'next',
        // 'SHIFT_TAB': 'previous'
      });
    }

    /**
     * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.
     * @private
     */


    _createClass(Tabs, [{
      key: '_init',
      value: function _init() {
        var _this = this;

        this.$tabTitles = this.$element.find('.' + this.options.linkClass);
        this.$tabContent = $('[data-tabs-content="' + this.$element[0].id + '"]');

        this.$tabTitles.each(function () {
          var $elem = $(this),
              $link = $elem.find('a'),
              isActive = $elem.hasClass('is-active'),
              hash = $link[0].hash.slice(1),
              linkId = $link[0].id ? $link[0].id : hash + '-label',
              $tabContent = $('#' + hash);

          $elem.attr({ 'role': 'presentation' });

          $link.attr({
            'role': 'tab',
            'aria-controls': hash,
            'aria-selected': isActive,
            'id': linkId
          });

          $tabContent.attr({
            'role': 'tabpanel',
            'aria-hidden': !isActive,
            'aria-labelledby': linkId
          });

          if (isActive && _this.options.autoFocus) {
            $link.focus();
          }
        });

        if (this.options.matchHeight) {
          var $images = this.$tabContent.find('img');

          if ($images.length) {
            Foundation.onImagesLoaded($images, this._setHeight.bind(this));
          } else {
            this._setHeight();
          }
        }

        this._events();
      }

      /**
       * Adds event handlers for items within the tabs.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        this._addKeyHandler();
        this._addClickHandler();
        this._setHeightMqHandler = null;

        if (this.options.matchHeight) {
          this._setHeightMqHandler = this._setHeight.bind(this);

          $(window).on('changed.zf.mediaquery', this._setHeightMqHandler);
        }
      }

      /**
       * Adds click handlers for items within the tabs.
       * @private
       */

    }, {
      key: '_addClickHandler',
      value: function _addClickHandler() {
        var _this = this;

        this.$element.off('click.zf.tabs').on('click.zf.tabs', '.' + this.options.linkClass, function (e) {
          e.preventDefault();
          e.stopPropagation();
          if ($(this).hasClass('is-active')) {
            return;
          }
          _this._handleTabChange($(this));
        });
      }

      /**
       * Adds keyboard event handlers for items within the tabs.
       * @private
       */

    }, {
      key: '_addKeyHandler',
      value: function _addKeyHandler() {
        var _this = this;
        var $firstTab = _this.$element.find('li:first-of-type');
        var $lastTab = _this.$element.find('li:last-of-type');

        this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs', function (e) {
          if (e.which === 9) return;

          var $element = $(this),
              $elements = $element.parent('ul').children('li'),
              $prevElement,
              $nextElement;

          $elements.each(function (i) {
            if ($(this).is($element)) {
              if (_this.options.wrapOnKeys) {
                $prevElement = i === 0 ? $elements.last() : $elements.eq(i - 1);
                $nextElement = i === $elements.length - 1 ? $elements.first() : $elements.eq(i + 1);
              } else {
                $prevElement = $elements.eq(Math.max(0, i - 1));
                $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));
              }
              return;
            }
          });

          // handle keyboard event with keyboard util
          Foundation.Keyboard.handleKey(e, 'Tabs', {
            open: function () {
              $element.find('[role="tab"]').focus();
              _this._handleTabChange($element);
            },
            previous: function () {
              $prevElement.find('[role="tab"]').focus();
              _this._handleTabChange($prevElement);
            },
            next: function () {
              $nextElement.find('[role="tab"]').focus();
              _this._handleTabChange($nextElement);
            },
            handled: function () {
              e.stopPropagation();
              e.preventDefault();
            }
          });
        });
      }

      /**
       * Opens the tab `$targetContent` defined by `$target`.
       * @param {jQuery} $target - Tab to open.
       * @fires Tabs#change
       * @function
       */

    }, {
      key: '_handleTabChange',
      value: function _handleTabChange($target) {
        var $tabLink = $target.find('[role="tab"]'),
            hash = $tabLink[0].hash,
            $targetContent = this.$tabContent.find(hash),
            $oldTab = this.$element.find('.' + this.options.linkClass + '.is-active').removeClass('is-active').find('[role="tab"]').attr({ 'aria-selected': 'false' });

        $('#' + $oldTab.attr('aria-controls')).removeClass('is-active').attr({ 'aria-hidden': 'true' });

        $target.addClass('is-active');

        $tabLink.attr({ 'aria-selected': 'true' });

        $targetContent.addClass('is-active').attr({ 'aria-hidden': 'false' });

        /**
         * Fires when the plugin has successfully changed tabs.
         * @event Tabs#change
         */
        this.$element.trigger('change.zf.tabs', [$target]);
      }

      /**
       * Public method for selecting a content pane to display.
       * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.
       * @function
       */

    }, {
      key: 'selectTab',
      value: function selectTab(elem) {
        var idStr;

        if (typeof elem === 'object') {
          idStr = elem[0].id;
        } else {
          idStr = elem;
        }

        if (idStr.indexOf('#') < 0) {
          idStr = '#' + idStr;
        }

        var $target = this.$tabTitles.find('[href="' + idStr + '"]').parent('.' + this.options.linkClass);

        this._handleTabChange($target);
      }
    }, {
      key: '_setHeight',

      /**
       * Sets the height of each panel to the height of the tallest panel.
       * If enabled in options, gets called on media query change.
       * If loading content via external source, can be called directly or with _reflow.
       * @function
       * @private
       */
      value: function _setHeight() {
        var max = 0;
        this.$tabContent.find('.' + this.options.panelClass).css('height', '').each(function () {
          var panel = $(this),
              isActive = panel.hasClass('is-active');

          if (!isActive) {
            panel.css({ 'visibility': 'hidden', 'display': 'block' });
          }

          var temp = this.getBoundingClientRect().height;

          if (!isActive) {
            panel.css({
              'visibility': '',
              'display': ''
            });
          }

          max = temp > max ? temp : max;
        }).css('height', max + 'px');
      }

      /**
       * Destroys an instance of an tabs.
       * @fires Tabs#destroyed
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.find('.' + this.options.linkClass).off('.zf.tabs').hide().end().find('.' + this.options.panelClass).hide();

        if (this.options.matchHeight) {
          if (this._setHeightMqHandler != null) {
            $(window).off('changed.zf.mediaquery', this._setHeightMqHandler);
          }
        }

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Tabs;
  }();

  Tabs.defaults = {
    /**
     * Allows the window to scroll to content of active pane on load if set to true.
     * @option
     * @example false
     */
    autoFocus: false,

    /**
     * Allows keyboard input to 'wrap' around the tab links.
     * @option
     * @example true
     */
    wrapOnKeys: true,

    /**
     * Allows the tab content panes to match heights if set to true.
     * @option
     * @example false
     */
    matchHeight: false,

    /**
     * Class applied to `li`'s in tab link list.
     * @option
     * @example 'tabs-title'
     */
    linkClass: 'tabs-title',

    /**
     * Class applied to the content containers.
     * @option
     * @example 'tabs-panel'
     */
    panelClass: 'tabs-panel'
  };

  function checkClass($elem) {
    return $elem.hasClass('is-active');
  }

  // Window exports
  Foundation.plugin(Tabs, 'Tabs');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Toggler module.
   * @module foundation.toggler
   * @requires foundation.util.motion
   * @requires foundation.util.triggers
   */

  var Toggler = function () {
    /**
     * Creates a new instance of Toggler.
     * @class
     * @fires Toggler#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    function Toggler(element, options) {
      _classCallCheck(this, Toggler);

      this.$element = element;
      this.options = $.extend({}, Toggler.defaults, element.data(), options);
      this.className = '';

      this._init();
      this._events();

      Foundation.registerPlugin(this, 'Toggler');
    }

    /**
     * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.
     * @function
     * @private
     */


    _createClass(Toggler, [{
      key: '_init',
      value: function _init() {
        var input;
        // Parse animation classes if they were set
        if (this.options.animate) {
          input = this.options.animate.split(' ');

          this.animationIn = input[0];
          this.animationOut = input[1] || null;
        }
        // Otherwise, parse toggle class
        else {
            input = this.$element.data('toggler');
            // Allow for a . at the beginning of the string
            this.className = input[0] === '.' ? input.slice(1) : input;
          }

        // Add ARIA attributes to triggers
        var id = this.$element[0].id;
        $('[data-open="' + id + '"], [data-close="' + id + '"], [data-toggle="' + id + '"]').attr('aria-controls', id);
        // If the target is hidden, add aria-hidden
        this.$element.attr('aria-expanded', this.$element.is(':hidden') ? false : true);
      }

      /**
       * Initializes events for the toggle trigger.
       * @function
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        this.$element.off('toggle.zf.trigger').on('toggle.zf.trigger', this.toggle.bind(this));
      }

      /**
       * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was "on" or "off".
       * @function
       * @fires Toggler#on
       * @fires Toggler#off
       */

    }, {
      key: 'toggle',
      value: function toggle() {
        this[this.options.animate ? '_toggleAnimate' : '_toggleClass']();
      }
    }, {
      key: '_toggleClass',
      value: function _toggleClass() {
        this.$element.toggleClass(this.className);

        var isOn = this.$element.hasClass(this.className);
        if (isOn) {
          /**
           * Fires if the target element has the class after a toggle.
           * @event Toggler#on
           */
          this.$element.trigger('on.zf.toggler');
        } else {
          /**
           * Fires if the target element does not have the class after a toggle.
           * @event Toggler#off
           */
          this.$element.trigger('off.zf.toggler');
        }

        this._updateARIA(isOn);
      }
    }, {
      key: '_toggleAnimate',
      value: function _toggleAnimate() {
        var _this = this;

        if (this.$element.is(':hidden')) {
          Foundation.Motion.animateIn(this.$element, this.animationIn, function () {
            _this._updateARIA(true);
            this.trigger('on.zf.toggler');
          });
        } else {
          Foundation.Motion.animateOut(this.$element, this.animationOut, function () {
            _this._updateARIA(false);
            this.trigger('off.zf.toggler');
          });
        }
      }
    }, {
      key: '_updateARIA',
      value: function _updateARIA(isOn) {
        this.$element.attr('aria-expanded', isOn ? true : false);
      }

      /**
       * Destroys the instance of Toggler on the element.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.off('.zf.toggler');
        Foundation.unregisterPlugin(this);
      }
    }]);

    return Toggler;
  }();

  Toggler.defaults = {
    /**
     * Tells the plugin if the element should animated when toggled.
     * @option
     * @example false
     */
    animate: false
  };

  // Window exports
  Foundation.plugin(Toggler, 'Toggler');
}(jQuery);
;'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

!function ($) {

  /**
   * Tooltip module.
   * @module foundation.tooltip
   * @requires foundation.util.box
   * @requires foundation.util.triggers
   */

  var Tooltip = function () {
    /**
     * Creates a new instance of a Tooltip.
     * @class
     * @fires Tooltip#init
     * @param {jQuery} element - jQuery object to attach a tooltip to.
     * @param {Object} options - object to extend the default configuration.
     */
    function Tooltip(element, options) {
      _classCallCheck(this, Tooltip);

      this.$element = element;
      this.options = $.extend({}, Tooltip.defaults, this.$element.data(), options);

      this.isActive = false;
      this.isClick = false;
      this._init();

      Foundation.registerPlugin(this, 'Tooltip');
    }

    /**
     * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.
     * @private
     */


    _createClass(Tooltip, [{
      key: '_init',
      value: function _init() {
        var elemId = this.$element.attr('aria-describedby') || Foundation.GetYoDigits(6, 'tooltip');

        this.options.positionClass = this.options.positionClass || this._getPositionClass(this.$element);
        this.options.tipText = this.options.tipText || this.$element.attr('title');
        this.template = this.options.template ? $(this.options.template) : this._buildTemplate(elemId);

        this.template.appendTo(document.body).text(this.options.tipText).hide();

        this.$element.attr({
          'title': '',
          'aria-describedby': elemId,
          'data-yeti-box': elemId,
          'data-toggle': elemId,
          'data-resize': elemId
        }).addClass(this.triggerClass);

        //helper variables to track movement on collisions
        this.usedPositions = [];
        this.counter = 4;
        this.classChanged = false;

        this._events();
      }

      /**
       * Grabs the current positioning class, if present, and returns the value or an empty string.
       * @private
       */

    }, {
      key: '_getPositionClass',
      value: function _getPositionClass(element) {
        if (!element) {
          return '';
        }
        // var position = element.attr('class').match(/top|left|right/g);
        var position = element[0].className.match(/\b(top|left|right)\b/g);
        position = position ? position[0] : '';
        return position;
      }
    }, {
      key: '_buildTemplate',

      /**
       * builds the tooltip element, adds attributes, and returns the template.
       * @private
       */
      value: function _buildTemplate(id) {
        var templateClasses = (this.options.tooltipClass + ' ' + this.options.positionClass + ' ' + this.options.templateClasses).trim();
        var $template = $('<div></div>').addClass(templateClasses).attr({
          'role': 'tooltip',
          'aria-hidden': true,
          'data-is-active': false,
          'data-is-focus': false,
          'id': id
        });
        return $template;
      }

      /**
       * Function that gets called if a collision event is detected.
       * @param {String} position - positioning class to try
       * @private
       */

    }, {
      key: '_reposition',
      value: function _reposition(position) {
        this.usedPositions.push(position ? position : 'bottom');

        //default, try switching to opposite side
        if (!position && this.usedPositions.indexOf('top') < 0) {
          this.template.addClass('top');
        } else if (position === 'top' && this.usedPositions.indexOf('bottom') < 0) {
          this.template.removeClass(position);
        } else if (position === 'left' && this.usedPositions.indexOf('right') < 0) {
          this.template.removeClass(position).addClass('right');
        } else if (position === 'right' && this.usedPositions.indexOf('left') < 0) {
          this.template.removeClass(position).addClass('left');
        }

        //if default change didn't work, try bottom or left first
        else if (!position && this.usedPositions.indexOf('top') > -1 && this.usedPositions.indexOf('left') < 0) {
            this.template.addClass('left');
          } else if (position === 'top' && this.usedPositions.indexOf('bottom') > -1 && this.usedPositions.indexOf('left') < 0) {
            this.template.removeClass(position).addClass('left');
          } else if (position === 'left' && this.usedPositions.indexOf('right') > -1 && this.usedPositions.indexOf('bottom') < 0) {
            this.template.removeClass(position);
          } else if (position === 'right' && this.usedPositions.indexOf('left') > -1 && this.usedPositions.indexOf('bottom') < 0) {
            this.template.removeClass(position);
          }
          //if nothing cleared, set to bottom
          else {
              this.template.removeClass(position);
            }
        this.classChanged = true;
        this.counter--;
      }

      /**
       * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.
       * if the tooltip is larger than the screen width, default to full width - any user selected margin
       * @private
       */

    }, {
      key: '_setPosition',
      value: function _setPosition() {
        var position = this._getPositionClass(this.template),
            $tipDims = Foundation.Box.GetDimensions(this.template),
            $anchorDims = Foundation.Box.GetDimensions(this.$element),
            direction = position === 'left' ? 'left' : position === 'right' ? 'left' : 'top',
            param = direction === 'top' ? 'height' : 'width',
            offset = param === 'height' ? this.options.vOffset : this.options.hOffset,
            _this = this;

        if ($tipDims.width >= $tipDims.windowDims.width || !this.counter && !Foundation.Box.ImNotTouchingYou(this.template)) {
          this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({
            // this.$element.offset(Foundation.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({
            'width': $anchorDims.windowDims.width - this.options.hOffset * 2,
            'height': 'auto'
          });
          return false;
        }

        this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, 'center ' + (position || 'bottom'), this.options.vOffset, this.options.hOffset));

        while (!Foundation.Box.ImNotTouchingYou(this.template) && this.counter) {
          this._reposition(position);
          this._setPosition();
        }
      }

      /**
       * reveals the tooltip, and fires an event to close any other open tooltips on the page
       * @fires Tooltip#closeme
       * @fires Tooltip#show
       * @function
       */

    }, {
      key: 'show',
      value: function show() {
        if (this.options.showOn !== 'all' && !Foundation.MediaQuery.atLeast(this.options.showOn)) {
          // console.error('The screen is too small to display this tooltip');
          return false;
        }

        var _this = this;
        this.template.css('visibility', 'hidden').show();
        this._setPosition();

        /**
         * Fires to close all other open tooltips on the page
         * @event Closeme#tooltip
         */
        this.$element.trigger('closeme.zf.tooltip', this.template.attr('id'));

        this.template.attr({
          'data-is-active': true,
          'aria-hidden': false
        });
        _this.isActive = true;
        // console.log(this.template);
        this.template.stop().hide().css('visibility', '').fadeIn(this.options.fadeInDuration, function () {
          //maybe do stuff?
        });
        /**
         * Fires when the tooltip is shown
         * @event Tooltip#show
         */
        this.$element.trigger('show.zf.tooltip');
      }

      /**
       * Hides the current tooltip, and resets the positioning class if it was changed due to collision
       * @fires Tooltip#hide
       * @function
       */

    }, {
      key: 'hide',
      value: function hide() {
        // console.log('hiding', this.$element.data('yeti-box'));
        var _this = this;
        this.template.stop().attr({
          'aria-hidden': true,
          'data-is-active': false
        }).fadeOut(this.options.fadeOutDuration, function () {
          _this.isActive = false;
          _this.isClick = false;
          if (_this.classChanged) {
            _this.template.removeClass(_this._getPositionClass(_this.template)).addClass(_this.options.positionClass);

            _this.usedPositions = [];
            _this.counter = 4;
            _this.classChanged = false;
          }
        });
        /**
         * fires when the tooltip is hidden
         * @event Tooltip#hide
         */
        this.$element.trigger('hide.zf.tooltip');
      }

      /**
       * adds event listeners for the tooltip and its anchor
       * TODO combine some of the listeners like focus and mouseenter, etc.
       * @private
       */

    }, {
      key: '_events',
      value: function _events() {
        var _this = this;
        var $template = this.template;
        var isFocus = false;

        if (!this.options.disableHover) {

          this.$element.on('mouseenter.zf.tooltip', function (e) {
            if (!_this.isActive) {
              _this.timeout = setTimeout(function () {
                _this.show();
              }, _this.options.hoverDelay);
            }
          }).on('mouseleave.zf.tooltip', function (e) {
            clearTimeout(_this.timeout);
            if (!isFocus || _this.isClick && !_this.options.clickOpen) {
              _this.hide();
            }
          });
        }

        if (this.options.clickOpen) {
          this.$element.on('mousedown.zf.tooltip', function (e) {
            e.stopImmediatePropagation();
            if (_this.isClick) {
              //_this.hide();
              // _this.isClick = false;
            } else {
              _this.isClick = true;
              if ((_this.options.disableHover || !_this.$element.attr('tabindex')) && !_this.isActive) {
                _this.show();
              }
            }
          });
        } else {
          this.$element.on('mousedown.zf.tooltip', function (e) {
            e.stopImmediatePropagation();
            _this.isClick = true;
          });
        }

        if (!this.options.disableForTouch) {
          this.$element.on('tap.zf.tooltip touchend.zf.tooltip', function (e) {
            _this.isActive ? _this.hide() : _this.show();
          });
        }

        this.$element.on({
          // 'toggle.zf.trigger': this.toggle.bind(this),
          // 'close.zf.trigger': this.hide.bind(this)
          'close.zf.trigger': this.hide.bind(this)
        });

        this.$element.on('focus.zf.tooltip', function (e) {
          isFocus = true;
          if (_this.isClick) {
            // If we're not showing open on clicks, we need to pretend a click-launched focus isn't
            // a real focus, otherwise on hover and come back we get bad behavior
            if (!_this.options.clickOpen) {
              isFocus = false;
            }
            return false;
          } else {
            _this.show();
          }
        }).on('focusout.zf.tooltip', function (e) {
          isFocus = false;
          _this.isClick = false;
          _this.hide();
        }).on('resizeme.zf.trigger', function () {
          if (_this.isActive) {
            _this._setPosition();
          }
        });
      }

      /**
       * adds a toggle method, in addition to the static show() & hide() functions
       * @function
       */

    }, {
      key: 'toggle',
      value: function toggle() {
        if (this.isActive) {
          this.hide();
        } else {
          this.show();
        }
      }

      /**
       * Destroys an instance of tooltip, removes template element from the view.
       * @function
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.$element.attr('title', this.template.text()).off('.zf.trigger .zf.tootip')
        //  .removeClass('has-tip')
        .removeAttr('aria-describedby').removeAttr('data-yeti-box').removeAttr('data-toggle').removeAttr('data-resize');

        this.template.remove();

        Foundation.unregisterPlugin(this);
      }
    }]);

    return Tooltip;
  }();

  Tooltip.defaults = {
    disableForTouch: false,
    /**
     * Time, in ms, before a tooltip should open on hover.
     * @option
     * @example 200
     */
    hoverDelay: 200,
    /**
     * Time, in ms, a tooltip should take to fade into view.
     * @option
     * @example 150
     */
    fadeInDuration: 150,
    /**
     * Time, in ms, a tooltip should take to fade out of view.
     * @option
     * @example 150
     */
    fadeOutDuration: 150,
    /**
     * Disables hover events from opening the tooltip if set to true
     * @option
     * @example false
     */
    disableHover: false,
    /**
     * Optional addtional classes to apply to the tooltip template on init.
     * @option
     * @example 'my-cool-tip-class'
     */
    templateClasses: '',
    /**
     * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.
     * @option
     * @example 'tooltip'
     */
    tooltipClass: 'tooltip',
    /**
     * Class applied to the tooltip anchor element.
     * @option
     * @example 'has-tip'
     */
    triggerClass: 'has-tip',
    /**
     * Minimum breakpoint size at which to open the tooltip.
     * @option
     * @example 'small'
     */
    showOn: 'small',
    /**
     * Custom template to be used to generate markup for tooltip.
     * @option
     * @example '&lt;div class="tooltip"&gt;&lt;/div&gt;'
     */
    template: '',
    /**
     * Text displayed in the tooltip template on open.
     * @option
     * @example 'Some cool space fact here.'
     */
    tipText: '',
    touchCloseText: 'Tap to close.',
    /**
     * Allows the tooltip to remain open if triggered with a click or touch event.
     * @option
     * @example true
     */
    clickOpen: true,
    /**
     * Additional positioning classes, set by the JS
     * @option
     * @example 'top'
     */
    positionClass: '',
    /**
     * Distance, in pixels, the template should push away from the anchor on the Y axis.
     * @option
     * @example 10
     */
    vOffset: 10,
    /**
     * Distance, in pixels, the template should push away from the anchor on the X axis, if aligned to a side.
     * @option
     * @example 12
     */
    hOffset: 12
  };

  /**
   * TODO utilize resize event trigger
   */

  // Window exports
  Foundation.plugin(Tooltip, 'Tooltip');
}(jQuery);
;'use strict';

// Polyfill for requestAnimationFrame

(function () {
  if (!Date.now) Date.now = function () {
    return new Date().getTime();
  };

  var vendors = ['webkit', 'moz'];
  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
    var vp = vendors[i];
    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
  }
  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
    var lastTime = 0;
    window.requestAnimationFrame = function (callback) {
      var now = Date.now();
      var nextTime = Math.max(lastTime + 16, now);
      return setTimeout(function () {
        callback(lastTime = nextTime);
      }, nextTime - now);
    };
    window.cancelAnimationFrame = clearTimeout;
  }
})();

var initClasses = ['mui-enter', 'mui-leave'];
var activeClasses = ['mui-enter-active', 'mui-leave-active'];

// Find the right "transitionend" event for this browser
var endEvent = function () {
  var transitions = {
    'transition': 'transitionend',
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'otransitionend'
  };
  var elem = window.document.createElement('div');

  for (var t in transitions) {
    if (typeof elem.style[t] !== 'undefined') {
      return transitions[t];
    }
  }

  return null;
}();

function animate(isIn, element, animation, cb) {
  element = $(element).eq(0);

  if (!element.length) return;

  if (endEvent === null) {
    isIn ? element.show() : element.hide();
    cb();
    return;
  }

  var initClass = isIn ? initClasses[0] : initClasses[1];
  var activeClass = isIn ? activeClasses[0] : activeClasses[1];

  // Set up the animation
  reset();
  element.addClass(animation);
  element.css('transition', 'none');
  requestAnimationFrame(function () {
    element.addClass(initClass);
    if (isIn) element.show();
  });

  // Start the animation
  requestAnimationFrame(function () {
    element[0].offsetWidth;
    element.css('transition', '');
    element.addClass(activeClass);
  });

  // Clean up the animation when it finishes
  element.one('transitionend', finish);

  // Hides the element (for out animations), resets the element, and runs a callback
  function finish() {
    if (!isIn) element.hide();
    reset();
    if (cb) cb.apply(element);
  }

  // Resets transitions and removes motion-specific classes
  function reset() {
    element[0].style.transitionDuration = 0;
    element.removeClass(initClass + ' ' + activeClass + ' ' + animation);
  }
}

var MotionUI = {
  animateIn: function (element, animation, cb) {
    animate(true, element, animation, cb);
  },

  animateOut: function (element, animation, cb) {
    animate(false, element, animation, cb);
  }
};
;"use strict";

// Snap.svg 0.4.1
//
// Copyright (c) 2013  2015 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// build: 2015-04-13

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//  \\
//  Eve 0.4.2 - JavaScript Events Library                       \\
//  \\
//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\
//  \\

(function (glob) {
    var version = "0.4.2",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        comaseparator = /\s*,\s*/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
        return a - b;
    },
        current_event,
        stop,
        events = { n: {} },
        firstDefined = function () {
        for (var i = 0, ii = this.length; i < ii; i++) {
            if (typeof this[i] != "undefined") {
                return this[i];
            }
        }
    },
        lastDefined = function () {
        var i = this.length;
        while (--i) {
            if (typeof this[i] != "undefined") {
                return this[i];
            }
        }
    },

    /*\
     * eve
     [ method ]
      * Fires event with given `name`, given scope and other parameters.
      > Arguments
      - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers
      = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
    \*/
    eve = function (name, scope) {
        name = String(name);
        var e = events,
            oldstop = stop,
            args = Array.prototype.slice.call(arguments, 2),
            listeners = eve.listeners(name),
            z = 0,
            f = false,
            l,
            indexed = [],
            queue = {},
            out = [],
            ce = current_event,
            errors = [];
        out.firstDefined = firstDefined;
        out.lastDefined = lastDefined;
        current_event = name;
        stop = 0;
        for (var i = 0, ii = listeners.length; i < ii; i++) {
            if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
        }indexed.sort(numsort);
        while (indexed[z] < 0) {
            l = queue[indexed[z++]];
            out.push(l.apply(scope, args));
            if (stop) {
                stop = oldstop;
                return out;
            }
        }
        for (i = 0; i < ii; i++) {
            l = listeners[i];
            if ("zIndex" in l) {
                if (l.zIndex == indexed[z]) {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                    do {
                        z++;
                        l = queue[indexed[z]];
                        l && out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                    } while (l);
                } else {
                    queue[l.zIndex] = l;
                }
            } else {
                out.push(l.apply(scope, args));
                if (stop) {
                    break;
                }
            }
        }
        stop = oldstop;
        current_event = ce;
        return out;
    };
    // Undocumented. Debug only.
    eve._events = events;
    /*\
     * eve.listeners
     [ method ]
      * Internal method which gives you array of all event handlers that will be triggered by the given `name`.
      > Arguments
      - name (string) name of the event, dot (`.`) or slash (`/`) separated
      = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };

    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards `*` for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt` function will be called before `eatIt`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.
    \*/
    eve.on = function (name, f) {
        name = String(name);
        if (typeof f != "function") {
            return function () {};
        }
        var names = name.split(comaseparator);
        for (var i = 0, ii = names.length; i < ii; i++) {
            (function (name) {
                var names = name.split(separator),
                    e = events,
                    exist;
                for (var i = 0, ii = names.length; i < ii; i++) {
                    e = e.n;
                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = { n: {} });
                }
                e.f = e.f || [];
                for (i = 0, ii = e.f.length; i < ii; i++) {
                    if (e.f[i] == f) {
                        exist = true;
                        break;
                    }
                }!exist && e.f.push(f);
            })(names[i]);
        }
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     > Arguments
     - event (string) event name
     - varargs () and any other arguments
     = (function) possible event handler function
    \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current events name contains `subname`
    \*/
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = { n: {} };
            return;
        }
        var names = name.split(comaseparator);
        if (names.length > 1) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                eve.off(names[i], f);
            }
            return;
        }
        names = name.split(separator);
        var e,
            key,
            splice,
            i,
            ii,
            j,
            jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) {
                        if (e[has](key)) {
                            splice.push(e[key]);
                        }
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) {
                            if (e.f[j] == f) {
                                e.f.splice(j, 1);
                                break;
                            }
                        }!e.f.length && delete e.f;
                    }
                    for (key in e.n) {
                        if (e.n[has](key) && e.n[key].f) {
                            var funcs = e.n[key].f;
                            for (j = 0, jj = funcs.length; j < jj; j++) {
                                if (funcs[j] == f) {
                                    funcs.splice(j, 1);
                                    break;
                                }
                            }!funcs.length && delete e.n[key].f;
                        }
                    }
                } else {
                    delete e.f;
                    for (key in e.n) {
                        if (e.n[has](key) && e.n[key].f) {
                            delete e.n[key].f;
                        }
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.unbind(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    typeof module != "undefined" && module.exports ? module.exports = eve : typeof define === "function" && define.amd ? define("eve", [], function () {
        return eve;
    }) : glob.eve = eve;
})(this);

(function (glob, factory) {
    // AMD support
    if (typeof define == "function" && define.amd) {
        // Define as an anonymous module
        define(["eve"], function (eve) {
            return factory(glob, eve);
        });
    } else if (typeof exports != 'undefined') {
        // Next for Node.js or CommonJS
        var eve = require('eve');
        module.exports = factory(glob, eve);
    } else {
        // Browser globals (glob is window)
        // Snap adds itself to window
        factory(glob, glob.eve);
    }
})(window || this, function (window, eve) {

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    var mina = function (eve) {
        var animations = {},
            requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
            setTimeout(callback, 16);
        },
            isArray = Array.isArray || function (a) {
            return a instanceof Array || Object.prototype.toString.call(a) == "[object Array]";
        },
            idgen = 0,
            idprefix = "M" + (+new Date()).toString(36),
            ID = function () {
            return idprefix + (idgen++).toString(36);
        },
            diff = function (a, b, A, B) {
            if (isArray(a)) {
                res = [];
                for (var i = 0, ii = a.length; i < ii; i++) {
                    res[i] = diff(a[i], b, A[i], B);
                }
                return res;
            }
            var dif = (A - a) / (B - b);
            return function (bb) {
                return a + dif * (bb - b);
            };
        },
            timer = Date.now || function () {
            return +new Date();
        },
            sta = function (val) {
            var a = this;
            if (val == null) {
                return a.s;
            }
            var ds = a.s - val;
            a.b += a.dur * ds;
            a.B += a.dur * ds;
            a.s = val;
        },
            speed = function (val) {
            var a = this;
            if (val == null) {
                return a.spd;
            }
            a.spd = val;
        },
            duration = function (val) {
            var a = this;
            if (val == null) {
                return a.dur;
            }
            a.s = a.s * val / a.dur;
            a.dur = val;
        },
            stopit = function () {
            var a = this;
            delete animations[a.id];
            a.update();
            eve("mina.stop." + a.id, a);
        },
            pause = function () {
            var a = this;
            if (a.pdif) {
                return;
            }
            delete animations[a.id];
            a.update();
            a.pdif = a.get() - a.b;
        },
            resume = function () {
            var a = this;
            if (!a.pdif) {
                return;
            }
            a.b = a.get() - a.pdif;
            delete a.pdif;
            animations[a.id] = a;
        },
            update = function () {
            var a = this,
                res;
            if (isArray(a.start)) {
                res = [];
                for (var j = 0, jj = a.start.length; j < jj; j++) {
                    res[j] = +a.start[j] + (a.end[j] - a.start[j]) * a.easing(a.s);
                }
            } else {
                res = +a.start + (a.end - a.start) * a.easing(a.s);
            }
            a.set(res);
        },
            frame = function () {
            var len = 0;
            for (var i in animations) {
                if (animations.hasOwnProperty(i)) {
                    var a = animations[i],
                        b = a.get(),
                        res;
                    len++;
                    a.s = (b - a.b) / (a.dur / a.spd);
                    if (a.s >= 1) {
                        delete animations[i];
                        a.s = 1;
                        len--;
                        (function (a) {
                            setTimeout(function () {
                                eve("mina.finish." + a.id, a);
                            });
                        })(a);
                    }
                    a.update();
                }
            }len && requestAnimFrame(frame);
        },

        /*\
         * mina
         [ method ]
         **
         * Generic animation of numbers
         **
         - a (number) start _slave_ number
         - A (number) end _slave_ number
         - b (number) start _master_ number (start time in general case)
         - B (number) end _master_ number (end time in gereal case)
         - get (function) getter of _master_ number (see @mina.time)
         - set (function) setter of _slave_ number
         - easing (function) #optional easing function, default is @mina.linear
         = (object) animation descriptor
         o {
         o         id (string) animation id,
         o         start (number) start _slave_ number,
         o         end (number) end _slave_ number,
         o         b (number) start _master_ number,
         o         s (number) animation status (0..1),
         o         dur (number) animation duration,
         o         spd (number) animation speed,
         o         get (function) getter of _master_ number (see @mina.time),
         o         set (function) setter of _slave_ number,
         o         easing (function) easing function, default is @mina.linear,
         o         status (function) status getter/setter,
         o         speed (function) speed getter/setter,
         o         duration (function) duration getter/setter,
         o         stop (function) animation stopper
         o         pause (function) pauses the animation
         o         resume (function) resumes the animation
         o         update (function) calles setter with the right value of the animation
         o }
        \*/
        mina = function (a, A, b, B, get, set, easing) {
            var anim = {
                id: ID(),
                start: a,
                end: A,
                b: b,
                s: 0,
                dur: B - b,
                spd: 1,
                get: get,
                set: set,
                easing: easing || mina.linear,
                status: sta,
                speed: speed,
                duration: duration,
                stop: stopit,
                pause: pause,
                resume: resume,
                update: update
            };
            animations[anim.id] = anim;
            var len = 0,
                i;
            for (i in animations) {
                if (animations.hasOwnProperty(i)) {
                    len++;
                    if (len == 2) {
                        break;
                    }
                }
            }len == 1 && requestAnimFrame(frame);
            return anim;
        };
        /*\
         * mina.time
         [ method ]
         **
         * Returns the current time. Equivalent to:
         | function () {
         |     return (new Date).getTime();
         | }
        \*/
        mina.time = timer;
        /*\
         * mina.getById
         [ method ]
         **
         * Returns an animation by its id
         - id (string) animation's id
         = (object) See @mina
        \*/
        mina.getById = function (id) {
            return animations[id] || null;
        };

        /*\
         * mina.linear
         [ method ]
         **
         * Default linear easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.linear = function (n) {
            return n;
        };
        /*\
         * mina.easeout
         [ method ]
         **
         * Easeout easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.easeout = function (n) {
            return Math.pow(n, 1.7);
        };
        /*\
         * mina.easein
         [ method ]
         **
         * Easein easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.easein = function (n) {
            return Math.pow(n, .48);
        };
        /*\
         * mina.easeinout
         [ method ]
         **
         * Easeinout easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.easeinout = function (n) {
            if (n == 1) {
                return 1;
            }
            if (n == 0) {
                return 0;
            }
            var q = .48 - n / 1.04,
                Q = Math.sqrt(.1734 + q * q),
                x = Q - q,
                X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                y = -Q - q,
                Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                t = X + Y + .5;
            return (1 - t) * 3 * t * t + t * t * t;
        };
        /*\
         * mina.backin
         [ method ]
         **
         * Backin easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.backin = function (n) {
            if (n == 1) {
                return 1;
            }
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        };
        /*\
         * mina.backout
         [ method ]
         **
         * Backout easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.backout = function (n) {
            if (n == 0) {
                return 0;
            }
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        };
        /*\
         * mina.elastic
         [ method ]
         **
         * Elastic easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.elastic = function (n) {
            if (n == !!n) {
                return n;
            }
            return Math.pow(2, -10 * n) * Math.sin((n - .075) * (2 * Math.PI) / .3) + 1;
        };
        /*\
         * mina.bounce
         [ method ]
         **
         * Bounce easing
         - n (number) input 0..1
         = (number) output 0..1
        \*/
        mina.bounce = function (n) {
            var s = 7.5625,
                p = 2.75,
                l;
            if (n < 1 / p) {
                l = s * n * n;
            } else {
                if (n < 2 / p) {
                    n -= 1.5 / p;
                    l = s * n * n + .75;
                } else {
                    if (n < 2.5 / p) {
                        n -= 2.25 / p;
                        l = s * n * n + .9375;
                    } else {
                        n -= 2.625 / p;
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        };
        window.mina = mina;
        return mina;
    }(typeof eve == "undefined" ? function () {} : eve);
    // Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.

    var Snap = function (root) {
        Snap.version = "0.4.0";
        /*\
         * Snap
         [ method ]
         **
         * Creates a drawing surface or wraps existing SVG element.
         **
         - width (number|string) width of surface
         - height (number|string) height of surface
         * or
         - DOM (SVGElement) element to be wrapped into Snap structure
         * or
         - array (array) array of elements (will return set of elements)
         * or
         - query (string) CSS query selector
         = (object) @Element
        \*/
        function Snap(w, h) {
            if (w) {
                if (w.nodeType) {
                    return wrap(w);
                }
                if (is(w, "array") && Snap.set) {
                    return Snap.set.apply(Snap, w);
                }
                if (w instanceof Element) {
                    return w;
                }
                if (h == null) {
                    w = glob.doc.querySelector(String(w));
                    return wrap(w);
                }
            }
            w = w == null ? "100%" : w;
            h = h == null ? "100%" : h;
            return new Paper(w, h);
        }
        Snap.toString = function () {
            return "Snap v" + this.version;
        };
        Snap._ = {};
        var glob = {
            win: root.window,
            doc: root.window.document
        };
        Snap._.glob = glob;
        var has = "hasOwnProperty",
            Str = String,
            toFloat = parseFloat,
            toInt = parseInt,
            math = Math,
            mmax = math.max,
            mmin = math.min,
            abs = math.abs,
            pow = math.pow,
            PI = math.PI,
            round = math.round,
            E = "",
            S = " ",
            objectToString = Object.prototype.toString,
            ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
            colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
            bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
            reURLValue = /^url\(#?([^)]+)\)$/,
            separator = Snap._.separator = /[,\s]+/,
            whitespace = /[\s]/g,
            commaSpaces = /[\s]*,[\s]*/,
            hsrg = { hs: 1, rg: 1 },
            pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
            tCommand = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
            pathValues = /(-?\d*\.?\d*(?:e[\-+]?\\d+)?)[\s]*,?[\s]*/ig,
            idgen = 0,
            idprefix = "S" + (+new Date()).toString(36),
            ID = function (el) {
            return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);
        },
            xlink = "http://www.w3.org/1999/xlink",
            xmlns = "http://www.w3.org/2000/svg",
            hub = {},
            URL = Snap.url = function (url) {
            return "url('#" + url + "')";
        };

        function $(el, attr) {
            if (attr) {
                if (el == "#text") {
                    el = glob.doc.createTextNode(attr.text || attr["#text"] || "");
                }
                if (el == "#comment") {
                    el = glob.doc.createComment(attr.text || attr["#text"] || "");
                }
                if (typeof el == "string") {
                    el = $(el);
                }
                if (typeof attr == "string") {
                    if (el.nodeType == 1) {
                        if (attr.substring(0, 6) == "xlink:") {
                            return el.getAttributeNS(xlink, attr.substring(6));
                        }
                        if (attr.substring(0, 4) == "xml:") {
                            return el.getAttributeNS(xmlns, attr.substring(4));
                        }
                        return el.getAttribute(attr);
                    } else if (attr == "text") {
                        return el.nodeValue;
                    } else {
                        return null;
                    }
                }
                if (el.nodeType == 1) {
                    for (var key in attr) {
                        if (attr[has](key)) {
                            var val = Str(attr[key]);
                            if (val) {
                                if (key.substring(0, 6) == "xlink:") {
                                    el.setAttributeNS(xlink, key.substring(6), val);
                                } else if (key.substring(0, 4) == "xml:") {
                                    el.setAttributeNS(xmlns, key.substring(4), val);
                                } else {
                                    el.setAttribute(key, val);
                                }
                            } else {
                                el.removeAttribute(key);
                            }
                        }
                    }
                } else if ("text" in attr) {
                    el.nodeValue = attr.text;
                }
            } else {
                el = glob.doc.createElementNS(xmlns, el);
            }
            return el;
        }
        Snap._.$ = $;
        Snap._.id = ID;
        function getAttrs(el) {
            var attrs = el.attributes,
                name,
                out = {};
            for (var i = 0; i < attrs.length; i++) {
                if (attrs[i].namespaceURI == xlink) {
                    name = "xlink:";
                } else {
                    name = "";
                }
                name += attrs[i].name;
                out[name] = attrs[i].textContent;
            }
            return out;
        }
        function is(o, type) {
            type = Str.prototype.toLowerCase.call(type);
            if (type == "finite") {
                return isFinite(o);
            }
            if (type == "array" && (o instanceof Array || Array.isArray && Array.isArray(o))) {
                return true;
            }
            return type == "null" && o === null || type == typeof o && o !== null || type == "object" && o === Object(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
        }
        /*\
         * Snap.format
         [ method ]
         **
         * Replaces construction of type `{<name>}` to the corresponding argument
         **
         - token (string) string to format
         - json (object) object which properties are used as a replacement
         = (string) formatted string
         > Usage
         | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
         | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
         |     x: 10,
         |     y: 20,
         |     dim: {
         |         width: 40,
         |         height: 50,
         |         "negative width": -40
         |     }
         | }));
        \*/
        Snap.format = function () {
            var tokenRegex = /\{([^\}]+)\}/g,
                objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,
                // matches .xxxxx or ["xxxxx"] to run over object properties
            replacer = function (all, key, obj) {
                var res = obj;
                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                    name = name || quotedName;
                    if (res) {
                        if (name in res) {
                            res = res[name];
                        }
                        typeof res == "function" && isFunc && (res = res());
                    }
                });
                res = (res == null || res == obj ? all : res) + "";
                return res;
            };
            return function (str, obj) {
                return Str(str).replace(tokenRegex, function (all, key) {
                    return replacer(all, key, obj);
                });
            };
        }();
        function clone(obj) {
            if (typeof obj == "function" || Object(obj) !== obj) {
                return obj;
            }
            var res = new obj.constructor();
            for (var key in obj) {
                if (obj[has](key)) {
                    res[key] = clone(obj[key]);
                }
            }return res;
        }
        Snap._.clone = clone;
        function repush(array, item) {
            for (var i = 0, ii = array.length; i < ii; i++) {
                if (array[i] === item) {
                    return array.push(array.splice(i, 1)[0]);
                }
            }
        }
        function cacher(f, scope, postprocessor) {
            function newf() {
                var arg = Array.prototype.slice.call(arguments, 0),
                    args = arg.join("\u2400"),
                    cache = newf.cache = newf.cache || {},
                    count = newf.count = newf.count || [];
                if (cache[has](args)) {
                    repush(count, args);
                    return postprocessor ? postprocessor(cache[args]) : cache[args];
                }
                count.length >= 1e3 && delete cache[count.shift()];
                count.push(args);
                cache[args] = f.apply(scope, arg);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            return newf;
        }
        Snap._.cacher = cacher;
        function angle(x1, y1, x2, y2, x3, y3) {
            if (x3 == null) {
                var x = x1 - x2,
                    y = y1 - y2;
                if (!x && !y) {
                    return 0;
                }
                return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
            } else {
                return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
            }
        }
        function rad(deg) {
            return deg % 360 * PI / 180;
        }
        function deg(rad) {
            return rad * 180 / PI % 360;
        }
        function x_y() {
            return this.x + S + this.y;
        }
        function x_y_w_h() {
            return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
        }

        /*\
         * Snap.rad
         [ method ]
         **
         * Transform angle to radians
         - deg (number) angle in degrees
         = (number) angle in radians
        \*/
        Snap.rad = rad;
        /*\
         * Snap.deg
         [ method ]
         **
         * Transform angle to degrees
         - rad (number) angle in radians
         = (number) angle in degrees
        \*/
        Snap.deg = deg;
        /*\
         * Snap.sin
         [ method ]
         **
         * Equivalent to `Math.sin()` only works with degrees, not radians.
         - angle (number) angle in degrees
         = (number) sin
        \*/
        Snap.sin = function (angle) {
            return math.sin(Snap.rad(angle));
        };
        /*\
         * Snap.tan
         [ method ]
         **
         * Equivalent to `Math.tan()` only works with degrees, not radians.
         - angle (number) angle in degrees
         = (number) tan
        \*/
        Snap.tan = function (angle) {
            return math.tan(Snap.rad(angle));
        };
        /*\
         * Snap.cos
         [ method ]
         **
         * Equivalent to `Math.cos()` only works with degrees, not radians.
         - angle (number) angle in degrees
         = (number) cos
        \*/
        Snap.cos = function (angle) {
            return math.cos(Snap.rad(angle));
        };
        /*\
         * Snap.asin
         [ method ]
         **
         * Equivalent to `Math.asin()` only works with degrees, not radians.
         - num (number) value
         = (number) asin in degrees
        \*/
        Snap.asin = function (num) {
            return Snap.deg(math.asin(num));
        };
        /*\
         * Snap.acos
         [ method ]
         **
         * Equivalent to `Math.acos()` only works with degrees, not radians.
         - num (number) value
         = (number) acos in degrees
        \*/
        Snap.acos = function (num) {
            return Snap.deg(math.acos(num));
        };
        /*\
         * Snap.atan
         [ method ]
         **
         * Equivalent to `Math.atan()` only works with degrees, not radians.
         - num (number) value
         = (number) atan in degrees
        \*/
        Snap.atan = function (num) {
            return Snap.deg(math.atan(num));
        };
        /*\
         * Snap.atan2
         [ method ]
         **
         * Equivalent to `Math.atan2()` only works with degrees, not radians.
         - num (number) value
         = (number) atan2 in degrees
        \*/
        Snap.atan2 = function (num) {
            return Snap.deg(math.atan2(num));
        };
        /*\
         * Snap.angle
         [ method ]
         **
         * Returns an angle between two or three points
         > Parameters
         - x1 (number) x coord of first point
         - y1 (number) y coord of first point
         - x2 (number) x coord of second point
         - y2 (number) y coord of second point
         - x3 (number) #optional x coord of third point
         - y3 (number) #optional y coord of third point
         = (number) angle in degrees
        \*/
        Snap.angle = angle;
        /*\
         * Snap.len
         [ method ]
         **
         * Returns distance between two points
         > Parameters
         - x1 (number) x coord of first point
         - y1 (number) y coord of first point
         - x2 (number) x coord of second point
         - y2 (number) y coord of second point
         = (number) distance
        \*/
        Snap.len = function (x1, y1, x2, y2) {
            return Math.sqrt(Snap.len2(x1, y1, x2, y2));
        };
        /*\
         * Snap.len2
         [ method ]
         **
         * Returns squared distance between two points
         > Parameters
         - x1 (number) x coord of first point
         - y1 (number) y coord of first point
         - x2 (number) x coord of second point
         - y2 (number) y coord of second point
         = (number) distance
        \*/
        Snap.len2 = function (x1, y1, x2, y2) {
            return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
        };
        /*\
         * Snap.closestPoint
         [ method ]
         **
         * Returns closest point to a given one on a given path.
         > Parameters
         - path (Element) path element
         - x (number) x coord of a point
         - y (number) y coord of a point
         = (object) in format
         {
            x (number) x coord of the point on the path
            y (number) y coord of the point on the path
            length (number) length of the path to the point
            distance (number) distance from the given point to the path
         }
        \*/
        // Copied from http://bl.ocks.org/mbostock/8027637
        Snap.closestPoint = function (path, x, y) {
            function distance2(p) {
                var dx = p.x - x,
                    dy = p.y - y;
                return dx * dx + dy * dy;
            }
            var pathNode = path.node,
                pathLength = pathNode.getTotalLength(),
                precision = pathLength / pathNode.pathSegList.numberOfItems * .125,
                best,
                bestLength,
                bestDistance = Infinity;

            // linear scan for coarse approximation
            for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
                if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
                    best = scan, bestLength = scanLength, bestDistance = scanDistance;
                }
            }

            // binary search for precise estimate
            precision *= .5;
            while (precision > .5) {
                var before, after, beforeLength, afterLength, beforeDistance, afterDistance;
                if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
                    best = before, bestLength = beforeLength, bestDistance = beforeDistance;
                } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
                    best = after, bestLength = afterLength, bestDistance = afterDistance;
                } else {
                    precision *= .5;
                }
            }

            best = {
                x: best.x,
                y: best.y,
                length: bestLength,
                distance: Math.sqrt(bestDistance)
            };
            return best;
        };
        /*\
         * Snap.is
         [ method ]
         **
         * Handy replacement for the `typeof` operator
         - o () any object or primitive
         - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
         = (boolean) `true` if given value is of given type
        \*/
        Snap.is = is;
        /*\
         * Snap.snapTo
         [ method ]
         **
         * Snaps given value to given grid
         - values (array|number) given array of values or step of the grid
         - value (number) value to adjust
         - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
         = (number) adjusted value
        \*/
        Snap.snapTo = function (values, value, tolerance) {
            tolerance = is(tolerance, "finite") ? tolerance : 10;
            if (is(values, "array")) {
                var i = values.length;
                while (i--) {
                    if (abs(values[i] - value) <= tolerance) {
                        return values[i];
                    }
                }
            } else {
                values = +values;
                var rem = value % values;
                if (rem < tolerance) {
                    return value - rem;
                }
                if (rem > values - tolerance) {
                    return value - rem + values;
                }
            }
            return value;
        };
        // Colour
        /*\
         * Snap.getRGB
         [ method ]
         **
         * Parses color string as RGB object
         - color (string) color string in one of the following formats:
         # <ul>
         #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
         #     <li>#  shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
         #     <li>#  full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
         #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
         #     <li>rgba(, , , )  also with opacity</li>
         #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
         #     <li>rgba(%, %, %, %)  also with opacity</li>
         #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
         #     <li>hsba(, , , )  also with opacity</li>
         #     <li>hsb(%, %, %)  same as above, but in %</li>
         #     <li>hsba(%, %, %, %)  also with opacity</li>
         #     <li>hsl(, , )  hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
         #     <li>hsla(, , , )  also with opacity</li>
         #     <li>hsl(%, %, %)  same as above, but in %</li>
         #     <li>hsla(%, %, %, %)  also with opacity</li>
         # </ul>
         * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
         = (object) RGB object in the following format:
         o {
         o     r (number) red,
         o     g (number) green,
         o     b (number) blue,
         o     hex (string) color in HTML/CSS format: #,
         o     error (boolean) true if string can't be parsed
         o }
        \*/
        Snap.getRGB = cacher(function (colour) {
            if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
                return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString };
            }
            if (colour == "none") {
                return { r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString };
            }
            !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
            if (!colour) {
                return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString };
            }
            var res,
                red,
                green,
                blue,
                opacity,
                t,
                values,
                rgb = colour.match(colourRegExp);
            if (rgb) {
                if (rgb[2]) {
                    blue = toInt(rgb[2].substring(5), 16);
                    green = toInt(rgb[2].substring(3, 5), 16);
                    red = toInt(rgb[2].substring(1, 3), 16);
                }
                if (rgb[3]) {
                    blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                    green = toInt((t = rgb[3].charAt(2)) + t, 16);
                    red = toInt((t = rgb[3].charAt(1)) + t, 16);
                }
                if (rgb[4]) {
                    values = rgb[4].split(commaSpaces);
                    red = toFloat(values[0]);
                    values[0].slice(-1) == "%" && (red *= 2.55);
                    green = toFloat(values[1]);
                    values[1].slice(-1) == "%" && (green *= 2.55);
                    blue = toFloat(values[2]);
                    values[2].slice(-1) == "%" && (blue *= 2.55);
                    rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                }
                if (rgb[5]) {
                    values = rgb[5].split(commaSpaces);
                    red = toFloat(values[0]);
                    values[0].slice(-1) == "%" && (red /= 100);
                    green = toFloat(values[1]);
                    values[1].slice(-1) == "%" && (green /= 100);
                    blue = toFloat(values[2]);
                    values[2].slice(-1) == "%" && (blue /= 100);
                    (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                    rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                    return Snap.hsb2rgb(red, green, blue, opacity);
                }
                if (rgb[6]) {
                    values = rgb[6].split(commaSpaces);
                    red = toFloat(values[0]);
                    values[0].slice(-1) == "%" && (red /= 100);
                    green = toFloat(values[1]);
                    values[1].slice(-1) == "%" && (green /= 100);
                    blue = toFloat(values[2]);
                    values[2].slice(-1) == "%" && (blue /= 100);
                    (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                    rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                    return Snap.hsl2rgb(red, green, blue, opacity);
                }
                red = mmin(math.round(red), 255);
                green = mmin(math.round(green), 255);
                blue = mmin(math.round(blue), 255);
                opacity = mmin(mmax(opacity, 0), 1);
                rgb = { r: red, g: green, b: blue, toString: rgbtoString };
                rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
                rgb.opacity = is(opacity, "finite") ? opacity : 1;
                return rgb;
            }
            return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString };
        }, Snap);
        /*\
         * Snap.hsb
         [ method ]
         **
         * Converts HSB values to a hex representation of the color
         - h (number) hue
         - s (number) saturation
         - b (number) value or brightness
         = (string) hex representation of the color
        \*/
        Snap.hsb = cacher(function (h, s, b) {
            return Snap.hsb2rgb(h, s, b).hex;
        });
        /*\
         * Snap.hsl
         [ method ]
         **
         * Converts HSL values to a hex representation of the color
         - h (number) hue
         - s (number) saturation
         - l (number) luminosity
         = (string) hex representation of the color
        \*/
        Snap.hsl = cacher(function (h, s, l) {
            return Snap.hsl2rgb(h, s, l).hex;
        });
        /*\
         * Snap.rgb
         [ method ]
         **
         * Converts RGB values to a hex representation of the color
         - r (number) red
         - g (number) green
         - b (number) blue
         = (string) hex representation of the color
        \*/
        Snap.rgb = cacher(function (r, g, b, o) {
            if (is(o, "finite")) {
                var round = math.round;
                return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
            }
            return "#" + (16777216 | b | g << 8 | r << 16).toString(16).slice(1);
        });
        var toHex = function (color) {
            var i = glob.doc.getElementsByTagName("head")[0] || glob.doc.getElementsByTagName("svg")[0],
                red = "rgb(255, 0, 0)";
            toHex = cacher(function (color) {
                if (color.toLowerCase() == "red") {
                    return red;
                }
                i.style.color = red;
                i.style.color = color;
                var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                return out == red ? null : out;
            });
            return toHex(color);
        },
            hsbtoString = function () {
            return "hsb(" + [this.h, this.s, this.b] + ")";
        },
            hsltoString = function () {
            return "hsl(" + [this.h, this.s, this.l] + ")";
        },
            rgbtoString = function () {
            return this.opacity == 1 || this.opacity == null ? this.hex : "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
        },
            prepareRGB = function (r, g, b) {
            if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
                b = r.b;
                g = r.g;
                r = r.r;
            }
            if (g == null && is(r, string)) {
                var clr = Snap.getRGB(r);
                r = clr.r;
                g = clr.g;
                b = clr.b;
            }
            if (r > 1 || g > 1 || b > 1) {
                r /= 255;
                g /= 255;
                b /= 255;
            }

            return [r, g, b];
        },
            packageRGB = function (r, g, b, o) {
            r = math.round(r * 255);
            g = math.round(g * 255);
            b = math.round(b * 255);
            var rgb = {
                r: r,
                g: g,
                b: b,
                opacity: is(o, "finite") ? o : 1,
                hex: Snap.rgb(r, g, b),
                toString: rgbtoString
            };
            is(o, "finite") && (rgb.opacity = o);
            return rgb;
        };
        /*\
         * Snap.color
         [ method ]
         **
         * Parses the color string and returns an object featuring the color's component values
         - clr (string) color string in one of the supported formats (see @Snap.getRGB)
         = (object) Combined RGB/HSB object in the following format:
         o {
         o     r (number) red,
         o     g (number) green,
         o     b (number) blue,
         o     hex (string) color in HTML/CSS format: #,
         o     error (boolean) `true` if string can't be parsed,
         o     h (number) hue,
         o     s (number) saturation,
         o     v (number) value (brightness),
         o     l (number) lightness
         o }
        \*/
        Snap.color = function (clr) {
            var rgb;
            if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
                rgb = Snap.hsb2rgb(clr);
                clr.r = rgb.r;
                clr.g = rgb.g;
                clr.b = rgb.b;
                clr.opacity = 1;
                clr.hex = rgb.hex;
            } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
                rgb = Snap.hsl2rgb(clr);
                clr.r = rgb.r;
                clr.g = rgb.g;
                clr.b = rgb.b;
                clr.opacity = 1;
                clr.hex = rgb.hex;
            } else {
                if (is(clr, "string")) {
                    clr = Snap.getRGB(clr);
                }
                if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
                    rgb = Snap.rgb2hsl(clr);
                    clr.h = rgb.h;
                    clr.s = rgb.s;
                    clr.l = rgb.l;
                    rgb = Snap.rgb2hsb(clr);
                    clr.v = rgb.b;
                } else {
                    clr = { hex: "none" };
                    clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
                    clr.error = 1;
                }
            }
            clr.toString = rgbtoString;
            return clr;
        };
        /*\
         * Snap.hsb2rgb
         [ method ]
         **
         * Converts HSB values to an RGB object
         - h (number) hue
         - s (number) saturation
         - v (number) value or brightness
         = (object) RGB object in the following format:
         o {
         o     r (number) red,
         o     g (number) green,
         o     b (number) blue,
         o     hex (string) color in HTML/CSS format: #
         o }
        \*/
        Snap.hsb2rgb = function (h, s, v, o) {
            if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
                v = h.b;
                s = h.s;
                o = h.o;
                h = h.h;
            }
            h *= 360;
            var R, G, B, X, C;
            h = h % 360 / 60;
            C = v * s;
            X = C * (1 - abs(h % 2 - 1));
            R = G = B = v - C;

            h = ~~h;
            R += [C, X, 0, 0, X, C][h];
            G += [X, C, C, X, 0, 0][h];
            B += [0, 0, X, C, C, X][h];
            return packageRGB(R, G, B, o);
        };
        /*\
         * Snap.hsl2rgb
         [ method ]
         **
         * Converts HSL values to an RGB object
         - h (number) hue
         - s (number) saturation
         - l (number) luminosity
         = (object) RGB object in the following format:
         o {
         o     r (number) red,
         o     g (number) green,
         o     b (number) blue,
         o     hex (string) color in HTML/CSS format: #
         o }
        \*/
        Snap.hsl2rgb = function (h, s, l, o) {
            if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
                l = h.l;
                s = h.s;
                h = h.h;
            }
            if (h > 1 || s > 1 || l > 1) {
                h /= 360;
                s /= 100;
                l /= 100;
            }
            h *= 360;
            var R, G, B, X, C;
            h = h % 360 / 60;
            C = 2 * s * (l < .5 ? l : 1 - l);
            X = C * (1 - abs(h % 2 - 1));
            R = G = B = l - C / 2;

            h = ~~h;
            R += [C, X, 0, 0, X, C][h];
            G += [X, C, C, X, 0, 0][h];
            B += [0, 0, X, C, C, X][h];
            return packageRGB(R, G, B, o);
        };
        /*\
         * Snap.rgb2hsb
         [ method ]
         **
         * Converts RGB values to an HSB object
         - r (number) red
         - g (number) green
         - b (number) blue
         = (object) HSB object in the following format:
         o {
         o     h (number) hue,
         o     s (number) saturation,
         o     b (number) brightness
         o }
        \*/
        Snap.rgb2hsb = function (r, g, b) {
            b = prepareRGB(r, g, b);
            r = b[0];
            g = b[1];
            b = b[2];

            var H, S, V, C;
            V = mmax(r, g, b);
            C = V - mmin(r, g, b);
            H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4;
            H = (H + 360) % 6 * 60 / 360;
            S = C == 0 ? 0 : C / V;
            return { h: H, s: S, b: V, toString: hsbtoString };
        };
        /*\
         * Snap.rgb2hsl
         [ method ]
         **
         * Converts RGB values to an HSL object
         - r (number) red
         - g (number) green
         - b (number) blue
         = (object) HSL object in the following format:
         o {
         o     h (number) hue,
         o     s (number) saturation,
         o     l (number) luminosity
         o }
        \*/
        Snap.rgb2hsl = function (r, g, b) {
            b = prepareRGB(r, g, b);
            r = b[0];
            g = b[1];
            b = b[2];

            var H, S, L, M, m, C;
            M = mmax(r, g, b);
            m = mmin(r, g, b);
            C = M - m;
            H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4;
            H = (H + 360) % 6 * 60 / 360;
            L = (M + m) / 2;
            S = C == 0 ? 0 : L < .5 ? C / (2 * L) : C / (2 - 2 * L);
            return { h: H, s: S, l: L, toString: hsltoString };
        };

        // Transformations
        /*\
         * Snap.parsePathString
         [ method ]
         **
         * Utility method
         **
         * Parses given path string into an array of arrays of path segments
         - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
         = (array) array of segments
        \*/
        Snap.parsePathString = function (pathString) {
            if (!pathString) {
                return null;
            }
            var pth = Snap.path(pathString);
            if (pth.arr) {
                return Snap.path.clone(pth.arr);
            }

            var paramCounts = { a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0 },
                data = [];
            if (is(pathString, "array") && is(pathString[0], "array")) {
                // rough assumption
                data = Snap.path.clone(pathString);
            }
            if (!data.length) {
                Str(pathString).replace(pathCommand, function (a, b, c) {
                    var params = [],
                        name = b.toLowerCase();
                    c.replace(pathValues, function (a, b) {
                        b && params.push(+b);
                    });
                    if (name == "m" && params.length > 2) {
                        data.push([b].concat(params.splice(0, 2)));
                        name = "l";
                        b = b == "m" ? "l" : "L";
                    }
                    if (name == "o" && params.length == 1) {
                        data.push([b, params[0]]);
                    }
                    if (name == "r") {
                        data.push([b].concat(params));
                    } else while (params.length >= paramCounts[name]) {
                        data.push([b].concat(params.splice(0, paramCounts[name])));
                        if (!paramCounts[name]) {
                            break;
                        }
                    }
                });
            }
            data.toString = Snap.path.toString;
            pth.arr = Snap.path.clone(data);
            return data;
        };
        /*\
         * Snap.parseTransformString
         [ method ]
         **
         * Utility method
         **
         * Parses given transform string into an array of transformations
         - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
         = (array) array of transformations
        \*/
        var parseTransformString = Snap.parseTransformString = function (TString) {
            if (!TString) {
                return null;
            }
            var paramCounts = { r: 3, s: 4, t: 2, m: 6 },
                data = [];
            if (is(TString, "array") && is(TString[0], "array")) {
                // rough assumption
                data = Snap.path.clone(TString);
            }
            if (!data.length) {
                Str(TString).replace(tCommand, function (a, b, c) {
                    var params = [],
                        name = b.toLowerCase();
                    c.replace(pathValues, function (a, b) {
                        b && params.push(+b);
                    });
                    data.push([b].concat(params));
                });
            }
            data.toString = Snap.path.toString;
            return data;
        };
        function svgTransform2string(tstr) {
            var res = [];
            tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
                params = params.split(/\s*,\s*|\s+/);
                if (name == "rotate" && params.length == 1) {
                    params.push(0, 0);
                }
                if (name == "scale") {
                    if (params.length > 2) {
                        params = params.slice(0, 2);
                    } else if (params.length == 2) {
                        params.push(0, 0);
                    }
                    if (params.length == 1) {
                        params.push(params[0], 0, 0);
                    }
                }
                if (name == "skewX") {
                    res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
                } else if (name == "skewY") {
                    res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
                } else {
                    res.push([name.charAt(0)].concat(params));
                }
                return all;
            });
            return res;
        }
        Snap._.svgTransform2string = svgTransform2string;
        Snap._.rgTransform = /^[a-z][\s]*-?\.?\d/i;
        function transform2matrix(tstr, bbox) {
            var tdata = parseTransformString(tstr),
                m = new Snap.Matrix();
            if (tdata) {
                for (var i = 0, ii = tdata.length; i < ii; i++) {
                    var t = tdata[i],
                        tlen = t.length,
                        command = Str(t[0]).toLowerCase(),
                        absolute = t[0] != command,
                        inver = absolute ? m.invert() : 0,
                        x1,
                        y1,
                        x2,
                        y2,
                        bb;
                    if (command == "t" && tlen == 2) {
                        m.translate(t[1], 0);
                    } else if (command == "t" && tlen == 3) {
                        if (absolute) {
                            x1 = inver.x(0, 0);
                            y1 = inver.y(0, 0);
                            x2 = inver.x(t[1], t[2]);
                            y2 = inver.y(t[1], t[2]);
                            m.translate(x2 - x1, y2 - y1);
                        } else {
                            m.translate(t[1], t[2]);
                        }
                    } else if (command == "r") {
                        if (tlen == 2) {
                            bb = bb || bbox;
                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.rotate(t[1], x2, y2);
                            } else {
                                m.rotate(t[1], t[2], t[3]);
                            }
                        }
                    } else if (command == "s") {
                        if (tlen == 2 || tlen == 3) {
                            bb = bb || bbox;
                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.scale(t[1], t[1], x2, y2);
                            } else {
                                m.scale(t[1], t[1], t[2], t[3]);
                            }
                        } else if (tlen == 5) {
                            if (absolute) {
                                x2 = inver.x(t[3], t[4]);
                                y2 = inver.y(t[3], t[4]);
                                m.scale(t[1], t[2], x2, y2);
                            } else {
                                m.scale(t[1], t[2], t[3], t[4]);
                            }
                        }
                    } else if (command == "m" && tlen == 7) {
                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                    }
                }
            }
            return m;
        }
        Snap._.transform2matrix = transform2matrix;
        Snap._unit2px = unit2px;
        var contains = glob.doc.contains || glob.doc.compareDocumentPosition ? function (a, b) {
            var adown = a.nodeType == 9 ? a.documentElement : a,
                bup = b && b.parentNode;
            return a == bup || !!(bup && bup.nodeType == 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        } : function (a, b) {
            if (b) {
                while (b) {
                    b = b.parentNode;
                    if (b == a) {
                        return true;
                    }
                }
            }
            return false;
        };
        function getSomeDefs(el) {
            var p = el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || el.node.parentNode && wrap(el.node.parentNode) || Snap.select("svg") || Snap(0, 0),
                pdefs = p.select("defs"),
                defs = pdefs == null ? false : pdefs.node;
            if (!defs) {
                defs = make("defs", p.node).node;
            }
            return defs;
        }
        function getSomeSVG(el) {
            return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select("svg");
        }
        Snap._.getSomeDefs = getSomeDefs;
        Snap._.getSomeSVG = getSomeSVG;
        function unit2px(el, name, value) {
            var svg = getSomeSVG(el).node,
                out = {},
                mgr = svg.querySelector(".svg---mgr");
            if (!mgr) {
                mgr = $("rect");
                $(mgr, { x: -9e9, y: -9e9, width: 10, height: 10, "class": "svg---mgr", fill: "none" });
                svg.appendChild(mgr);
            }
            function getW(val) {
                if (val == null) {
                    return E;
                }
                if (val == +val) {
                    return val;
                }
                $(mgr, { width: val });
                try {
                    return mgr.getBBox().width;
                } catch (e) {
                    return 0;
                }
            }
            function getH(val) {
                if (val == null) {
                    return E;
                }
                if (val == +val) {
                    return val;
                }
                $(mgr, { height: val });
                try {
                    return mgr.getBBox().height;
                } catch (e) {
                    return 0;
                }
            }
            function set(nam, f) {
                if (name == null) {
                    out[nam] = f(el.attr(nam) || 0);
                } else if (nam == name) {
                    out = f(value == null ? el.attr(nam) || 0 : value);
                }
            }
            switch (el.type) {
                case "rect":
                    set("rx", getW);
                    set("ry", getH);
                case "image":
                    set("width", getW);
                    set("height", getH);
                case "text":
                    set("x", getW);
                    set("y", getH);
                    break;
                case "circle":
                    set("cx", getW);
                    set("cy", getH);
                    set("r", getW);
                    break;
                case "ellipse":
                    set("cx", getW);
                    set("cy", getH);
                    set("rx", getW);
                    set("ry", getH);
                    break;
                case "line":
                    set("x1", getW);
                    set("x2", getW);
                    set("y1", getH);
                    set("y2", getH);
                    break;
                case "marker":
                    set("refX", getW);
                    set("markerWidth", getW);
                    set("refY", getH);
                    set("markerHeight", getH);
                    break;
                case "radialGradient":
                    set("fx", getW);
                    set("fy", getH);
                    break;
                case "tspan":
                    set("dx", getW);
                    set("dy", getH);
                    break;
                default:
                    set(name, getW);
            }
            svg.removeChild(mgr);
            return out;
        }
        /*\
         * Snap.select
         [ method ]
         **
         * Wraps a DOM element specified by CSS selector as @Element
         - query (string) CSS selector of the element
         = (Element) the current element
        \*/
        Snap.select = function (query) {
            query = Str(query).replace(/([^\\]):/g, "$1\\:");
            return wrap(glob.doc.querySelector(query));
        };
        /*\
         * Snap.selectAll
         [ method ]
         **
         * Wraps DOM elements specified by CSS selector as set or array of @Element
         - query (string) CSS selector of the element
         = (Element) the current element
        \*/
        Snap.selectAll = function (query) {
            var nodelist = glob.doc.querySelectorAll(query),
                set = (Snap.set || Array)();
            for (var i = 0; i < nodelist.length; i++) {
                set.push(wrap(nodelist[i]));
            }
            return set;
        };

        function add2group(list) {
            if (!is(list, "array")) {
                list = Array.prototype.slice.call(arguments, 0);
            }
            var i = 0,
                j = 0,
                node = this.node;
            while (this[i]) {
                delete this[i++];
            }for (i = 0; i < list.length; i++) {
                if (list[i].type == "set") {
                    list[i].forEach(function (el) {
                        node.appendChild(el.node);
                    });
                } else {
                    node.appendChild(list[i].node);
                }
            }
            var children = node.childNodes;
            for (i = 0; i < children.length; i++) {
                this[j++] = wrap(children[i]);
            }
            return this;
        }
        // Hub garbage collector every 10s
        setInterval(function () {
            for (var key in hub) {
                if (hub[has](key)) {
                    var el = hub[key],
                        node = el.node;
                    if (el.type != "svg" && !node.ownerSVGElement || el.type == "svg" && (!node.parentNode || "ownerSVGElement" in node.parentNode && !node.ownerSVGElement)) {
                        delete hub[key];
                    }
                }
            }
        }, 1e4);
        function Element(el) {
            if (el.snap in hub) {
                return hub[el.snap];
            }
            var svg;
            try {
                svg = el.ownerSVGElement;
            } catch (e) {}
            /*\
             * Element.node
             [ property (object) ]
             **
             * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
             > Usage
             | // draw a circle at coordinate 10,10 with radius of 10
             | var c = paper.circle(10, 10, 10);
             | c.node.onclick = function () {
             |     c.attr("fill", "red");
             | };
            \*/
            this.node = el;
            if (svg) {
                this.paper = new Paper(svg);
            }
            /*\
             * Element.type
             [ property (string) ]
             **
             * SVG tag name of the given element.
            \*/
            this.type = el.tagName || el.nodeName;
            var id = this.id = ID(this);
            this.anims = {};
            this._ = {
                transform: []
            };
            el.snap = id;
            hub[id] = this;
            if (this.type == "g") {
                this.add = add2group;
            }
            if (this.type in { g: 1, mask: 1, pattern: 1, symbol: 1 }) {
                for (var method in Paper.prototype) {
                    if (Paper.prototype[has](method)) {
                        this[method] = Paper.prototype[method];
                    }
                }
            }
        }
        /*\
          * Element.attr
          [ method ]
          **
          * Gets or sets given attributes of the element.
          **
          - params (object) contains key-value pairs of attributes you want to set
          * or
          - param (string) name of the attribute
          = (Element) the current element
          * or
          = (string) value of attribute
          > Usage
          | el.attr({
          |     fill: "#fc0",
          |     stroke: "#000",
          |     strokeWidth: 2, // CamelCase...
          |     "fill-opacity": 0.5, // or dash-separated names
          |     width: "*=2" // prefixed values
          | });
          | console.log(el.attr("fill")); // #fc0
          * Prefixed values in format `"+=10"` supported. All four operations
          * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`
          * and `-`: `"+=2em"`.
         \*/
        Element.prototype.attr = function (params, value) {
            var el = this,
                node = el.node;
            if (!params) {
                if (node.nodeType != 1) {
                    return {
                        text: node.nodeValue
                    };
                }
                var attr = node.attributes,
                    out = {};
                for (var i = 0, ii = attr.length; i < ii; i++) {
                    out[attr[i].nodeName] = attr[i].nodeValue;
                }
                return out;
            }
            if (is(params, "string")) {
                if (arguments.length > 1) {
                    var json = {};
                    json[params] = value;
                    params = json;
                } else {
                    return eve("snap.util.getattr." + params, el).firstDefined();
                }
            }
            for (var att in params) {
                if (params[has](att)) {
                    eve("snap.util.attr." + att, el, params[att]);
                }
            }
            return el;
        };
        /*\
         * Snap.parse
         [ method ]
         **
         * Parses SVG fragment and converts it into a @Fragment
         **
         - svg (string) SVG string
         = (Fragment) the @Fragment
        \*/
        Snap.parse = function (svg) {
            var f = glob.doc.createDocumentFragment(),
                full = true,
                div = glob.doc.createElement("div");
            svg = Str(svg);
            if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
                svg = "<svg>" + svg + "</svg>";
                full = false;
            }
            div.innerHTML = svg;
            svg = div.getElementsByTagName("svg")[0];
            if (svg) {
                if (full) {
                    f = svg;
                } else {
                    while (svg.firstChild) {
                        f.appendChild(svg.firstChild);
                    }
                }
            }
            return new Fragment(f);
        };
        function Fragment(frag) {
            this.node = frag;
        }
        /*\
         * Snap.fragment
         [ method ]
         **
         * Creates a DOM fragment from a given list of elements or strings
         **
         - varargs () SVG string
         = (Fragment) the @Fragment
        \*/
        Snap.fragment = function () {
            var args = Array.prototype.slice.call(arguments, 0),
                f = glob.doc.createDocumentFragment();
            for (var i = 0, ii = args.length; i < ii; i++) {
                var item = args[i];
                if (item.node && item.node.nodeType) {
                    f.appendChild(item.node);
                }
                if (item.nodeType) {
                    f.appendChild(item);
                }
                if (typeof item == "string") {
                    f.appendChild(Snap.parse(item).node);
                }
            }
            return new Fragment(f);
        };

        function make(name, parent) {
            var res = $(name);
            parent.appendChild(res);
            var el = wrap(res);
            return el;
        }
        function Paper(w, h) {
            var res,
                desc,
                defs,
                proto = Paper.prototype;
            if (w && w.tagName == "svg") {
                if (w.snap in hub) {
                    return hub[w.snap];
                }
                var doc = w.ownerDocument;
                res = new Element(w);
                desc = w.getElementsByTagName("desc")[0];
                defs = w.getElementsByTagName("defs")[0];
                if (!desc) {
                    desc = $("desc");
                    desc.appendChild(doc.createTextNode("Created with Snap"));
                    res.node.appendChild(desc);
                }
                if (!defs) {
                    defs = $("defs");
                    res.node.appendChild(defs);
                }
                res.defs = defs;
                for (var key in proto) {
                    if (proto[has](key)) {
                        res[key] = proto[key];
                    }
                }res.paper = res.root = res;
            } else {
                res = make("svg", glob.doc.body);
                $(res.node, {
                    height: h,
                    version: 1.1,
                    width: w,
                    xmlns: xmlns
                });
            }
            return res;
        }
        function wrap(dom) {
            if (!dom) {
                return dom;
            }
            if (dom instanceof Element || dom instanceof Fragment) {
                return dom;
            }
            if (dom.tagName && dom.tagName.toLowerCase() == "svg") {
                return new Paper(dom);
            }
            if (dom.tagName && dom.tagName.toLowerCase() == "object" && dom.type == "image/svg+xml") {
                return new Paper(dom.contentDocument.getElementsByTagName("svg")[0]);
            }
            return new Element(dom);
        }

        Snap._.make = make;
        Snap._.wrap = wrap;
        /*\
         * Paper.el
         [ method ]
         **
         * Creates an element on paper with a given name and no attributes
         **
         - name (string) tag name
         - attr (object) attributes
         = (Element) the current element
         > Usage
         | var c = paper.circle(10, 10, 10); // is the same as...
         | var c = paper.el("circle").attr({
         |     cx: 10,
         |     cy: 10,
         |     r: 10
         | });
         | // and the same as
         | var c = paper.el("circle", {
         |     cx: 10,
         |     cy: 10,
         |     r: 10
         | });
        \*/
        Paper.prototype.el = function (name, attr) {
            var el = make(name, this.node);
            attr && el.attr(attr);
            return el;
        };
        /*\
         * Element.children
         [ method ]
         **
         * Returns array of all the children of the element.
         = (array) array of Elements
        \*/
        Element.prototype.children = function () {
            var out = [],
                ch = this.node.childNodes;
            for (var i = 0, ii = ch.length; i < ii; i++) {
                out[i] = Snap(ch[i]);
            }
            return out;
        };
        function jsonFiller(root, o) {
            for (var i = 0, ii = root.length; i < ii; i++) {
                var item = {
                    type: root[i].type,
                    attr: root[i].attr()
                },
                    children = root[i].children();
                o.push(item);
                if (children.length) {
                    jsonFiller(children, item.childNodes = []);
                }
            }
        }
        /*\
         * Element.toJSON
         [ method ]
         **
         * Returns object representation of the given element and all its children.
         = (object) in format
         o {
         o     type (string) this.type,
         o     attr (object) attributes map,
         o     childNodes (array) optional array of children in the same format
         o }
        \*/
        Element.prototype.toJSON = function () {
            var out = [];
            jsonFiller([this], out);
            return out[0];
        };
        // default
        eve.on("snap.util.getattr", function () {
            var att = eve.nt();
            att = att.substring(att.lastIndexOf(".") + 1);
            var css = att.replace(/[A-Z]/g, function (letter) {
                return "-" + letter.toLowerCase();
            });
            if (cssAttr[has](css)) {
                return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
            } else {
                return $(this.node, att);
            }
        });
        var cssAttr = {
            "alignment-baseline": 0,
            "baseline-shift": 0,
            "clip": 0,
            "clip-path": 0,
            "clip-rule": 0,
            "color": 0,
            "color-interpolation": 0,
            "color-interpolation-filters": 0,
            "color-profile": 0,
            "color-rendering": 0,
            "cursor": 0,
            "direction": 0,
            "display": 0,
            "dominant-baseline": 0,
            "enable-background": 0,
            "fill": 0,
            "fill-opacity": 0,
            "fill-rule": 0,
            "filter": 0,
            "flood-color": 0,
            "flood-opacity": 0,
            "font": 0,
            "font-family": 0,
            "font-size": 0,
            "font-size-adjust": 0,
            "font-stretch": 0,
            "font-style": 0,
            "font-variant": 0,
            "font-weight": 0,
            "glyph-orientation-horizontal": 0,
            "glyph-orientation-vertical": 0,
            "image-rendering": 0,
            "kerning": 0,
            "letter-spacing": 0,
            "lighting-color": 0,
            "marker": 0,
            "marker-end": 0,
            "marker-mid": 0,
            "marker-start": 0,
            "mask": 0,
            "opacity": 0,
            "overflow": 0,
            "pointer-events": 0,
            "shape-rendering": 0,
            "stop-color": 0,
            "stop-opacity": 0,
            "stroke": 0,
            "stroke-dasharray": 0,
            "stroke-dashoffset": 0,
            "stroke-linecap": 0,
            "stroke-linejoin": 0,
            "stroke-miterlimit": 0,
            "stroke-opacity": 0,
            "stroke-width": 0,
            "text-anchor": 0,
            "text-decoration": 0,
            "text-rendering": 0,
            "unicode-bidi": 0,
            "visibility": 0,
            "word-spacing": 0,
            "writing-mode": 0
        };

        eve.on("snap.util.attr", function (value) {
            var att = eve.nt(),
                attr = {};
            att = att.substring(att.lastIndexOf(".") + 1);
            attr[att] = value;
            var style = att.replace(/-(\w)/gi, function (all, letter) {
                return letter.toUpperCase();
            }),
                css = att.replace(/[A-Z]/g, function (letter) {
                return "-" + letter.toLowerCase();
            });
            if (cssAttr[has](css)) {
                this.node.style[style] = value == null ? E : value;
            } else {
                $(this.node, attr);
            }
        });
        (function (proto) {})(Paper.prototype);

        // simple ajax
        /*\
         * Snap.ajax
         [ method ]
         **
         * Simple implementation of Ajax
         **
         - url (string) URL
         - postData (object|string) data for post request
         - callback (function) callback
         - scope (object) #optional scope of callback
         * or
         - url (string) URL
         - callback (function) callback
         - scope (object) #optional scope of callback
         = (XMLHttpRequest) the XMLHttpRequest object, just in case
        \*/
        Snap.ajax = function (url, postData, callback, scope) {
            var req = new XMLHttpRequest(),
                id = ID();
            if (req) {
                if (is(postData, "function")) {
                    scope = callback;
                    callback = postData;
                    postData = null;
                } else if (is(postData, "object")) {
                    var pd = [];
                    for (var key in postData) {
                        if (postData.hasOwnProperty(key)) {
                            pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
                        }
                    }postData = pd.join("&");
                }
                req.open(postData ? "POST" : "GET", url, true);
                if (postData) {
                    req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                    req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                }
                if (callback) {
                    eve.once("snap.ajax." + id + ".0", callback);
                    eve.once("snap.ajax." + id + ".200", callback);
                    eve.once("snap.ajax." + id + ".304", callback);
                }
                req.onreadystatechange = function () {
                    if (req.readyState != 4) return;
                    eve("snap.ajax." + id + "." + req.status, scope, req);
                };
                if (req.readyState == 4) {
                    return req;
                }
                req.send(postData);
                return req;
            }
        };
        /*\
         * Snap.load
         [ method ]
         **
         * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
         **
         - url (string) URL
         - callback (function) callback
         - scope (object) #optional scope of callback
        \*/
        Snap.load = function (url, callback, scope) {
            Snap.ajax(url, function (req) {
                var f = Snap.parse(req.responseText);
                scope ? callback.call(scope, f) : callback(f);
            });
        };
        var getOffset = function (elem) {
            var box = elem.getBoundingClientRect(),
                doc = elem.ownerDocument,
                body = doc.body,
                docElem = doc.documentElement,
                clientTop = docElem.clientTop || body.clientTop || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,
                left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
            return {
                y: top,
                x: left
            };
        };
        /*\
         * Snap.getElementByPoint
         [ method ]
         **
         * Returns you topmost element under given point.
         **
         = (object) Snap element object
         - x (number) x coordinate from the top left corner of the window
         - y (number) y coordinate from the top left corner of the window
         > Usage
         | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
        \*/
        Snap.getElementByPoint = function (x, y) {
            var paper = this,
                svg = paper.canvas,
                target = glob.doc.elementFromPoint(x, y);
            if (glob.win.opera && target.tagName == "svg") {
                var so = getOffset(target),
                    sr = target.createSVGRect();
                sr.x = x - so.x;
                sr.y = y - so.y;
                sr.width = sr.height = 1;
                var hits = target.getIntersectionList(sr, null);
                if (hits.length) {
                    target = hits[hits.length - 1];
                }
            }
            if (!target) {
                return null;
            }
            return wrap(target);
        };
        /*\
         * Snap.plugin
         [ method ]
         **
         * Let you write plugins. You pass in a function with five arguments, like this:
         | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {
         |     Snap.newmethod = function () {};
         |     Element.prototype.newmethod = function () {};
         |     Paper.prototype.newmethod = function () {};
         | });
         * Inside the function you have access to all main objects (and their
         * prototypes). This allow you to extend anything you want.
         **
         - f (function) your plugin body
        \*/
        Snap.plugin = function (f) {
            f(Snap, Element, Paper, glob, Fragment);
        };
        glob.win.Snap = Snap;
        return Snap;
    }(window || this);

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    // http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var elproto = Element.prototype,
            is = Snap.is,
            Str = String,
            unit2px = Snap._unit2px,
            $ = Snap._.$,
            make = Snap._.make,
            getSomeDefs = Snap._.getSomeDefs,
            has = "hasOwnProperty",
            wrap = Snap._.wrap;
        /*\
         * Element.getBBox
         [ method ]
         **
         * Returns the bounding box descriptor for the given element
         **
         = (object) bounding box descriptor:
         o {
         o     cx: (number) x of the center,
         o     cy: (number) x of the center,
         o     h: (number) height,
         o     height: (number) height,
         o     path: (string) path command for the box,
         o     r0: (number) radius of a circle that fully encloses the box,
         o     r1: (number) radius of the smallest circle that can be enclosed,
         o     r2: (number) radius of the largest circle that can be enclosed,
         o     vb: (string) box as a viewbox command,
         o     w: (number) width,
         o     width: (number) width,
         o     x2: (number) x of the right side,
         o     x: (number) x of the left side,
         o     y2: (number) y of the bottom edge,
         o     y: (number) y of the top edge
         o }
        \*/
        elproto.getBBox = function (isWithoutTransform) {
            if (!Snap.Matrix || !Snap.path) {
                return this.node.getBBox();
            }
            var el = this,
                m = new Snap.Matrix();
            if (el.removed) {
                return Snap._.box();
            }
            while (el.type == "use") {
                if (!isWithoutTransform) {
                    m = m.add(el.transform().localMatrix.translate(el.attr("x") || 0, el.attr("y") || 0));
                }
                if (el.original) {
                    el = el.original;
                } else {
                    var href = el.attr("xlink:href");
                    el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf("#") + 1));
                }
            }
            var _ = el._,
                pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;
            try {
                if (isWithoutTransform) {
                    _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());
                    return Snap._.box(_.bboxwt);
                } else {
                    el.realPath = pathfinder(el);
                    el.matrix = el.transform().localMatrix;
                    _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));
                    return Snap._.box(_.bbox);
                }
            } catch (e) {
                // Firefox doesnt give you bbox of hidden element
                return Snap._.box();
            }
        };
        var propString = function () {
            return this.string;
        };
        function extractTransform(el, tstr) {
            if (tstr == null) {
                var doReturn = true;
                if (el.type == "linearGradient" || el.type == "radialGradient") {
                    tstr = el.node.getAttribute("gradientTransform");
                } else if (el.type == "pattern") {
                    tstr = el.node.getAttribute("patternTransform");
                } else {
                    tstr = el.node.getAttribute("transform");
                }
                if (!tstr) {
                    return new Snap.Matrix();
                }
                tstr = Snap._.svgTransform2string(tstr);
            } else {
                if (!Snap._.rgTransform.test(tstr)) {
                    tstr = Snap._.svgTransform2string(tstr);
                } else {
                    tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || "");
                }
                if (is(tstr, "array")) {
                    tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
                }
                el._.transform = tstr;
            }
            var m = Snap._.transform2matrix(tstr, el.getBBox(1));
            if (doReturn) {
                return m;
            } else {
                el.matrix = m;
            }
        }
        /*\
         * Element.transform
         [ method ]
         **
         * Gets or sets transformation of the element
         **
         - tstr (string) transform string in Snap or SVG format
         = (Element) the current element
         * or
         = (object) transformation descriptor:
         o {
         o     string (string) transform string,
         o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
         o     localMatrix (Matrix) matrix of transformations applied only to the element,
         o     diffMatrix (Matrix) matrix of difference between global and local transformations,
         o     global (string) global transformation as string,
         o     local (string) local transformation as string,
         o     toString (function) returns `string` property
         o }
        \*/
        elproto.transform = function (tstr) {
            var _ = this._;
            if (tstr == null) {
                var papa = this,
                    global = new Snap.Matrix(this.node.getCTM()),
                    local = extractTransform(this),
                    ms = [local],
                    m = new Snap.Matrix(),
                    i,
                    localString = local.toTransformString(),
                    string = Str(local) == Str(this.matrix) ? Str(_.transform) : localString;
                while (papa.type != "svg" && (papa = papa.parent())) {
                    ms.push(extractTransform(papa));
                }
                i = ms.length;
                while (i--) {
                    m.add(ms[i]);
                }
                return {
                    string: string,
                    globalMatrix: global,
                    totalMatrix: m,
                    localMatrix: local,
                    diffMatrix: global.clone().add(local.invert()),
                    global: global.toTransformString(),
                    total: m.toTransformString(),
                    local: localString,
                    toString: propString
                };
            }
            if (tstr instanceof Snap.Matrix) {
                this.matrix = tstr;
                this._.transform = tstr.toTransformString();
            } else {
                extractTransform(this, tstr);
            }

            if (this.node) {
                if (this.type == "linearGradient" || this.type == "radialGradient") {
                    $(this.node, { gradientTransform: this.matrix });
                } else if (this.type == "pattern") {
                    $(this.node, { patternTransform: this.matrix });
                } else {
                    $(this.node, { transform: this.matrix });
                }
            }

            return this;
        };
        /*\
         * Element.parent
         [ method ]
         **
         * Returns the element's parent
         **
         = (Element) the parent element
        \*/
        elproto.parent = function () {
            return wrap(this.node.parentNode);
        };
        /*\
         * Element.append
         [ method ]
         **
         * Appends the given element to current one
         **
         - el (Element|Set) element to append
         = (Element) the parent element
        \*/
        /*\
         * Element.add
         [ method ]
         **
         * See @Element.append
        \*/
        elproto.append = elproto.add = function (el) {
            if (el) {
                if (el.type == "set") {
                    var it = this;
                    el.forEach(function (el) {
                        it.add(el);
                    });
                    return this;
                }
                el = wrap(el);
                this.node.appendChild(el.node);
                el.paper = this.paper;
            }
            return this;
        };
        /*\
         * Element.appendTo
         [ method ]
         **
         * Appends the current element to the given one
         **
         - el (Element) parent element to append to
         = (Element) the child element
        \*/
        elproto.appendTo = function (el) {
            if (el) {
                el = wrap(el);
                el.append(this);
            }
            return this;
        };
        /*\
         * Element.prepend
         [ method ]
         **
         * Prepends the given element to the current one
         **
         - el (Element) element to prepend
         = (Element) the parent element
        \*/
        elproto.prepend = function (el) {
            if (el) {
                if (el.type == "set") {
                    var it = this,
                        first;
                    el.forEach(function (el) {
                        if (first) {
                            first.after(el);
                        } else {
                            it.prepend(el);
                        }
                        first = el;
                    });
                    return this;
                }
                el = wrap(el);
                var parent = el.parent();
                this.node.insertBefore(el.node, this.node.firstChild);
                this.add && this.add();
                el.paper = this.paper;
                this.parent() && this.parent().add();
                parent && parent.add();
            }
            return this;
        };
        /*\
         * Element.prependTo
         [ method ]
         **
         * Prepends the current element to the given one
         **
         - el (Element) parent element to prepend to
         = (Element) the child element
        \*/
        elproto.prependTo = function (el) {
            el = wrap(el);
            el.prepend(this);
            return this;
        };
        /*\
         * Element.before
         [ method ]
         **
         * Inserts given element before the current one
         **
         - el (Element) element to insert
         = (Element) the parent element
        \*/
        elproto.before = function (el) {
            if (el.type == "set") {
                var it = this;
                el.forEach(function (el) {
                    var parent = el.parent();
                    it.node.parentNode.insertBefore(el.node, it.node);
                    parent && parent.add();
                });
                this.parent().add();
                return this;
            }
            el = wrap(el);
            var parent = el.parent();
            this.node.parentNode.insertBefore(el.node, this.node);
            this.parent() && this.parent().add();
            parent && parent.add();
            el.paper = this.paper;
            return this;
        };
        /*\
         * Element.after
         [ method ]
         **
         * Inserts given element after the current one
         **
         - el (Element) element to insert
         = (Element) the parent element
        \*/
        elproto.after = function (el) {
            el = wrap(el);
            var parent = el.parent();
            if (this.node.nextSibling) {
                this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
            } else {
                this.node.parentNode.appendChild(el.node);
            }
            this.parent() && this.parent().add();
            parent && parent.add();
            el.paper = this.paper;
            return this;
        };
        /*\
         * Element.insertBefore
         [ method ]
         **
         * Inserts the element after the given one
         **
         - el (Element) element next to whom insert to
         = (Element) the parent element
        \*/
        elproto.insertBefore = function (el) {
            el = wrap(el);
            var parent = this.parent();
            el.node.parentNode.insertBefore(this.node, el.node);
            this.paper = el.paper;
            parent && parent.add();
            el.parent() && el.parent().add();
            return this;
        };
        /*\
         * Element.insertAfter
         [ method ]
         **
         * Inserts the element after the given one
         **
         - el (Element) element next to whom insert to
         = (Element) the parent element
        \*/
        elproto.insertAfter = function (el) {
            el = wrap(el);
            var parent = this.parent();
            el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
            this.paper = el.paper;
            parent && parent.add();
            el.parent() && el.parent().add();
            return this;
        };
        /*\
         * Element.remove
         [ method ]
         **
         * Removes element from the DOM
         = (Element) the detached element
        \*/
        elproto.remove = function () {
            var parent = this.parent();
            this.node.parentNode && this.node.parentNode.removeChild(this.node);
            delete this.paper;
            this.removed = true;
            parent && parent.add();
            return this;
        };
        /*\
         * Element.select
         [ method ]
         **
         * Gathers the nested @Element matching the given set of CSS selectors
         **
         - query (string) CSS selector
         = (Element) result of query selection
        \*/
        elproto.select = function (query) {
            return wrap(this.node.querySelector(query));
        };
        /*\
         * Element.selectAll
         [ method ]
         **
         * Gathers nested @Element objects matching the given set of CSS selectors
         **
         - query (string) CSS selector
         = (Set|array) result of query selection
        \*/
        elproto.selectAll = function (query) {
            var nodelist = this.node.querySelectorAll(query),
                set = (Snap.set || Array)();
            for (var i = 0; i < nodelist.length; i++) {
                set.push(wrap(nodelist[i]));
            }
            return set;
        };
        /*\
         * Element.asPX
         [ method ]
         **
         * Returns given attribute of the element as a `px` value (not %, em, etc.)
         **
         - attr (string) attribute name
         - value (string) #optional attribute value
         = (Element) result of query selection
        \*/
        elproto.asPX = function (attr, value) {
            if (value == null) {
                value = this.attr(attr);
            }
            return +unit2px(this, attr, value);
        };
        // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
        /*\
         * Element.use
         [ method ]
         **
         * Creates a `<use>` element linked to the current element
         **
         = (Element) the `<use>` element
        \*/
        elproto.use = function () {
            var use,
                id = this.node.id;
            if (!id) {
                id = this.id;
                $(this.node, {
                    id: id
                });
            }
            if (this.type == "linearGradient" || this.type == "radialGradient" || this.type == "pattern") {
                use = make(this.type, this.node.parentNode);
            } else {
                use = make("use", this.node.parentNode);
            }
            $(use.node, {
                "xlink:href": "#" + id
            });
            use.original = this;
            return use;
        };
        function fixids(el) {
            var els = el.selectAll("*"),
                it,
                url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
                ids = [],
                uses = {};
            function urltest(it, name) {
                var val = $(it.node, name);
                val = val && val.match(url);
                val = val && val[2];
                if (val && val.charAt() == "#") {
                    val = val.substring(1);
                } else {
                    return;
                }
                if (val) {
                    uses[val] = (uses[val] || []).concat(function (id) {
                        var attr = {};
                        attr[name] = URL(id);
                        $(it.node, attr);
                    });
                }
            }
            function linktest(it) {
                var val = $(it.node, "xlink:href");
                if (val && val.charAt() == "#") {
                    val = val.substring(1);
                } else {
                    return;
                }
                if (val) {
                    uses[val] = (uses[val] || []).concat(function (id) {
                        it.attr("xlink:href", "#" + id);
                    });
                }
            }
            for (var i = 0, ii = els.length; i < ii; i++) {
                it = els[i];
                urltest(it, "fill");
                urltest(it, "stroke");
                urltest(it, "filter");
                urltest(it, "mask");
                urltest(it, "clip-path");
                linktest(it);
                var oldid = $(it.node, "id");
                if (oldid) {
                    $(it.node, { id: it.id });
                    ids.push({
                        old: oldid,
                        id: it.id
                    });
                }
            }
            for (i = 0, ii = ids.length; i < ii; i++) {
                var fs = uses[ids[i].old];
                if (fs) {
                    for (var j = 0, jj = fs.length; j < jj; j++) {
                        fs[j](ids[i].id);
                    }
                }
            }
        }
        /*\
         * Element.clone
         [ method ]
         **
         * Creates a clone of the element and inserts it after the element
         **
         = (Element) the clone
        \*/
        elproto.clone = function () {
            var clone = wrap(this.node.cloneNode(true));
            if ($(clone.node, "id")) {
                $(clone.node, { id: clone.id });
            }
            fixids(clone);
            clone.insertAfter(this);
            return clone;
        };
        /*\
         * Element.toDefs
         [ method ]
         **
         * Moves element to the shared `<defs>` area
         **
         = (Element) the element
        \*/
        elproto.toDefs = function () {
            var defs = getSomeDefs(this);
            defs.appendChild(this.node);
            return this;
        };
        /*\
         * Element.toPattern
         [ method ]
         **
         * Creates a `<pattern>` element from the current element
         **
         * To create a pattern you have to specify the pattern rect:
         - x (string|number)
         - y (string|number)
         - width (string|number)
         - height (string|number)
         = (Element) the `<pattern>` element
         * You can use pattern later on as an argument for `fill` attribute:
         | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
         |         fill: "none",
         |         stroke: "#bada55",
         |         strokeWidth: 5
         |     }).pattern(0, 0, 10, 10),
         |     c = paper.circle(200, 200, 100);
         | c.attr({
         |     fill: p
         | });
        \*/
        elproto.pattern = elproto.toPattern = function (x, y, width, height) {
            var p = make("pattern", getSomeDefs(this));
            if (x == null) {
                x = this.getBBox();
            }
            if (is(x, "object") && "x" in x) {
                y = x.y;
                width = x.width;
                height = x.height;
                x = x.x;
            }
            $(p.node, {
                x: x,
                y: y,
                width: width,
                height: height,
                patternUnits: "userSpaceOnUse",
                id: p.id,
                viewBox: [x, y, width, height].join(" ")
            });
            p.node.appendChild(this.node);
            return p;
        };
        // SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
        // SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
        /*\
         * Element.marker
         [ method ]
         **
         * Creates a `<marker>` element from the current element
         **
         * To create a marker you have to specify the bounding rect and reference point:
         - x (number)
         - y (number)
         - width (number)
         - height (number)
         - refX (number)
         - refY (number)
         = (Element) the `<marker>` element
         * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
        \*/
        // TODO add usage for markers
        elproto.marker = function (x, y, width, height, refX, refY) {
            var p = make("marker", getSomeDefs(this));
            if (x == null) {
                x = this.getBBox();
            }
            if (is(x, "object") && "x" in x) {
                y = x.y;
                width = x.width;
                height = x.height;
                refX = x.refX || x.cx;
                refY = x.refY || x.cy;
                x = x.x;
            }
            $(p.node, {
                viewBox: [x, y, width, height].join(" "),
                markerWidth: width,
                markerHeight: height,
                orient: "auto",
                refX: refX || 0,
                refY: refY || 0,
                id: p.id
            });
            p.node.appendChild(this.node);
            return p;
        };
        // animation
        function slice(from, to, f) {
            return function (arr) {
                var res = arr.slice(from, to);
                if (res.length == 1) {
                    res = res[0];
                }
                return f ? f(res) : res;
            };
        }
        var Animation = function (attr, ms, easing, callback) {
            if (typeof easing == "function" && !easing.length) {
                callback = easing;
                easing = mina.linear;
            }
            this.attr = attr;
            this.dur = ms;
            easing && (this.easing = easing);
            callback && (this.callback = callback);
        };
        Snap._.Animation = Animation;
        /*\
         * Snap.animation
         [ method ]
         **
         * Creates an animation object
         **
         - attr (object) attributes of final destination
         - duration (number) duration of the animation, in milliseconds
         - easing (function) #optional one of easing functions of @mina or custom one
         - callback (function) #optional callback function that fires when animation ends
         = (object) animation object
        \*/
        Snap.animation = function (attr, ms, easing, callback) {
            return new Animation(attr, ms, easing, callback);
        };
        /*\
         * Element.inAnim
         [ method ]
         **
         * Returns a set of animations that may be able to manipulate the current element
         **
         = (object) in format:
         o {
         o     anim (object) animation object,
         o     mina (object) @mina object,
         o     curStatus (number) 0..1  status of the animation: 0  just started, 1  just finished,
         o     status (function) gets or sets the status of the animation,
         o     stop (function) stops the animation
         o }
        \*/
        elproto.inAnim = function () {
            var el = this,
                res = [];
            for (var id in el.anims) {
                if (el.anims[has](id)) {
                    (function (a) {
                        res.push({
                            anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
                            mina: a,
                            curStatus: a.status(),
                            status: function (val) {
                                return a.status(val);
                            },
                            stop: function () {
                                a.stop();
                            }
                        });
                    })(el.anims[id]);
                }
            }return res;
        };
        /*\
         * Snap.animate
         [ method ]
         **
         * Runs generic animation of one number into another with a caring function
         **
         - from (number|array) number or array of numbers
         - to (number|array) number or array of numbers
         - setter (function) caring function that accepts one number argument
         - duration (number) duration, in milliseconds
         - easing (function) #optional easing function from @mina or custom
         - callback (function) #optional callback function to execute when animation ends
         = (object) animation object in @mina format
         o {
         o     id (string) animation id, consider it read-only,
         o     duration (function) gets or sets the duration of the animation,
         o     easing (function) easing,
         o     speed (function) gets or sets the speed of the animation,
         o     status (function) gets or sets the status of the animation,
         o     stop (function) stops the animation
         o }
         | var rect = Snap().rect(0, 0, 10, 10);
         | Snap.animate(0, 10, function (val) {
         |     rect.attr({
         |         x: val
         |     });
         | }, 1000);
         | // in given context is equivalent to
         | rect.animate({x: 10}, 1000);
        \*/
        Snap.animate = function (from, to, setter, ms, easing, callback) {
            if (typeof easing == "function" && !easing.length) {
                callback = easing;
                easing = mina.linear;
            }
            var now = mina.time(),
                anim = mina(from, to, now, now + ms, mina.time, setter, easing);
            callback && eve.once("mina.finish." + anim.id, callback);
            return anim;
        };
        /*\
         * Element.stop
         [ method ]
         **
         * Stops all the animations for the current element
         **
         = (Element) the current element
        \*/
        elproto.stop = function () {
            var anims = this.inAnim();
            for (var i = 0, ii = anims.length; i < ii; i++) {
                anims[i].stop();
            }
            return this;
        };
        /*\
         * Element.animate
         [ method ]
         **
         * Animates the given attributes of the element
         **
         - attrs (object) key-value pairs of destination attributes
         - duration (number) duration of the animation in milliseconds
         - easing (function) #optional easing function from @mina or custom
         - callback (function) #optional callback function that executes when the animation ends
         = (Element) the current element
        \*/
        elproto.animate = function (attrs, ms, easing, callback) {
            if (typeof easing == "function" && !easing.length) {
                callback = easing;
                easing = mina.linear;
            }
            if (attrs instanceof Animation) {
                callback = attrs.callback;
                easing = attrs.easing;
                ms = attrs.dur;
                attrs = attrs.attr;
            }
            var fkeys = [],
                tkeys = [],
                keys = {},
                from,
                to,
                f,
                eq,
                el = this;
            for (var key in attrs) {
                if (attrs[has](key)) {
                    if (el.equal) {
                        eq = el.equal(key, Str(attrs[key]));
                        from = eq.from;
                        to = eq.to;
                        f = eq.f;
                    } else {
                        from = +el.attr(key);
                        to = +attrs[key];
                    }
                    var len = is(from, "array") ? from.length : 1;
                    keys[key] = slice(fkeys.length, fkeys.length + len, f);
                    fkeys = fkeys.concat(from);
                    tkeys = tkeys.concat(to);
                }
            }var now = mina.time(),
                anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
                var attr = {};
                for (var key in keys) {
                    if (keys[has](key)) {
                        attr[key] = keys[key](val);
                    }
                }el.attr(attr);
            }, easing);
            el.anims[anim.id] = anim;
            anim._attrs = attrs;
            anim._callback = callback;
            eve("snap.animcreated." + el.id, anim);
            eve.once("mina.finish." + anim.id, function () {
                delete el.anims[anim.id];
                callback && callback.call(el);
            });
            eve.once("mina.stop." + anim.id, function () {
                delete el.anims[anim.id];
            });
            return el;
        };
        var eldata = {};
        /*\
         * Element.data
         [ method ]
         **
         * Adds or retrieves given value associated with given key. (Dont confuse
         * with `data-` attributes)
         *
         * See also @Element.removeData
         - key (string) key to store data
         - value (any) #optional value to store
         = (object) @Element
         * or, if value is not specified:
         = (any) value
         > Usage
         | for (var i = 0, i < 5, i++) {
         |     paper.circle(10 + 15 * i, 10, 10)
         |          .attr({fill: "#000"})
         |          .data("i", i)
         |          .click(function () {
         |             alert(this.data("i"));
         |          });
         | }
        \*/
        elproto.data = function (key, value) {
            var data = eldata[this.id] = eldata[this.id] || {};
            if (arguments.length == 0) {
                eve("snap.data.get." + this.id, this, data, null);
                return data;
            }
            if (arguments.length == 1) {
                if (Snap.is(key, "object")) {
                    for (var i in key) {
                        if (key[has](i)) {
                            this.data(i, key[i]);
                        }
                    }return this;
                }
                eve("snap.data.get." + this.id, this, data[key], key);
                return data[key];
            }
            data[key] = value;
            eve("snap.data.set." + this.id, this, value, key);
            return this;
        };
        /*\
         * Element.removeData
         [ method ]
         **
         * Removes value associated with an element by given key.
         * If key is not provided, removes all the data of the element.
         - key (string) #optional key
         = (object) @Element
        \*/
        elproto.removeData = function (key) {
            if (key == null) {
                eldata[this.id] = {};
            } else {
                eldata[this.id] && delete eldata[this.id][key];
            }
            return this;
        };
        /*\
         * Element.outerSVG
         [ method ]
         **
         * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
         *
         * See also @Element.innerSVG
         = (string) SVG code for the element
        \*/
        /*\
         * Element.toString
         [ method ]
         **
         * See @Element.outerSVG
        \*/
        elproto.outerSVG = elproto.toString = toString(1);
        /*\
         * Element.innerSVG
         [ method ]
         **
         * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
         = (string) SVG code for the element
        \*/
        elproto.innerSVG = toString();
        function toString(type) {
            return function () {
                var res = type ? "<" + this.type : "",
                    attr = this.node.attributes,
                    chld = this.node.childNodes;
                if (type) {
                    for (var i = 0, ii = attr.length; i < ii; i++) {
                        res += " " + attr[i].name + '="' + attr[i].value.replace(/"/g, '\\"') + '"';
                    }
                }
                if (chld.length) {
                    type && (res += ">");
                    for (i = 0, ii = chld.length; i < ii; i++) {
                        if (chld[i].nodeType == 3) {
                            res += chld[i].nodeValue;
                        } else if (chld[i].nodeType == 1) {
                            res += wrap(chld[i]).toString();
                        }
                    }
                    type && (res += "</" + this.type + ">");
                } else {
                    type && (res += "/>");
                }
                return res;
            };
        }
        elproto.toDataURL = function () {
            if (window && window.btoa) {
                var bb = this.getBBox(),
                    svg = Snap.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>', {
                    x: +bb.x.toFixed(3),
                    y: +bb.y.toFixed(3),
                    width: +bb.width.toFixed(3),
                    height: +bb.height.toFixed(3),
                    contents: this.outerSVG()
                });
                return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
            }
        };
        /*\
         * Fragment.select
         [ method ]
         **
         * See @Element.select
        \*/
        Fragment.prototype.select = elproto.select;
        /*\
         * Fragment.selectAll
         [ method ]
         **
         * See @Element.selectAll
        \*/
        Fragment.prototype.selectAll = elproto.selectAll;
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var objectToString = Object.prototype.toString,
            Str = String,
            math = Math,
            E = "";
        function Matrix(a, b, c, d, e, f) {
            if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
                this.a = a.a;
                this.b = a.b;
                this.c = a.c;
                this.d = a.d;
                this.e = a.e;
                this.f = a.f;
                return;
            }
            if (a != null) {
                this.a = +a;
                this.b = +b;
                this.c = +c;
                this.d = +d;
                this.e = +e;
                this.f = +f;
            } else {
                this.a = 1;
                this.b = 0;
                this.c = 0;
                this.d = 1;
                this.e = 0;
                this.f = 0;
            }
        }
        (function (matrixproto) {
            /*\
             * Matrix.add
             [ method ]
             **
             * Adds the given matrix to existing one
             - a (number)
             - b (number)
             - c (number)
             - d (number)
             - e (number)
             - f (number)
             * or
             - matrix (object) @Matrix
            \*/
            matrixproto.add = function (a, b, c, d, e, f) {
                var out = [[], [], []],
                    m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                    matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                    x,
                    y,
                    z,
                    res;

                if (a && a instanceof Matrix) {
                    matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
                }

                for (x = 0; x < 3; x++) {
                    for (y = 0; y < 3; y++) {
                        res = 0;
                        for (z = 0; z < 3; z++) {
                            res += m[x][z] * matrix[z][y];
                        }
                        out[x][y] = res;
                    }
                }
                this.a = out[0][0];
                this.b = out[1][0];
                this.c = out[0][1];
                this.d = out[1][1];
                this.e = out[0][2];
                this.f = out[1][2];
                return this;
            };
            /*\
             * Matrix.invert
             [ method ]
             **
             * Returns an inverted version of the matrix
             = (object) @Matrix
            \*/
            matrixproto.invert = function () {
                var me = this,
                    x = me.a * me.d - me.b * me.c;
                return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
            };
            /*\
             * Matrix.clone
             [ method ]
             **
             * Returns a copy of the matrix
             = (object) @Matrix
            \*/
            matrixproto.clone = function () {
                return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
            };
            /*\
             * Matrix.translate
             [ method ]
             **
             * Translate the matrix
             - x (number) horizontal offset distance
             - y (number) vertical offset distance
            \*/
            matrixproto.translate = function (x, y) {
                return this.add(1, 0, 0, 1, x, y);
            };
            /*\
             * Matrix.scale
             [ method ]
             **
             * Scales the matrix
             - x (number) amount to be scaled, with `1` resulting in no change
             - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
             - cx (number) #optional horizontal origin point from which to scale
             - cy (number) #optional vertical origin point from which to scale
             * Default cx, cy is the middle point of the element.
            \*/
            matrixproto.scale = function (x, y, cx, cy) {
                y == null && (y = x);
                (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
                this.add(x, 0, 0, y, 0, 0);
                (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
                return this;
            };
            /*\
             * Matrix.rotate
             [ method ]
             **
             * Rotates the matrix
             - a (number) angle of rotation, in degrees
             - x (number) horizontal origin point from which to rotate
             - y (number) vertical origin point from which to rotate
            \*/
            matrixproto.rotate = function (a, x, y) {
                a = Snap.rad(a);
                x = x || 0;
                y = y || 0;
                var cos = +math.cos(a).toFixed(9),
                    sin = +math.sin(a).toFixed(9);
                this.add(cos, sin, -sin, cos, x, y);
                return this.add(1, 0, 0, 1, -x, -y);
            };
            /*\
             * Matrix.x
             [ method ]
             **
             * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
             - x (number)
             - y (number)
             = (number) x
            \*/
            matrixproto.x = function (x, y) {
                return x * this.a + y * this.c + this.e;
            };
            /*\
             * Matrix.y
             [ method ]
             **
             * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
             - x (number)
             - y (number)
             = (number) y
            \*/
            matrixproto.y = function (x, y) {
                return x * this.b + y * this.d + this.f;
            };
            matrixproto.get = function (i) {
                return +this[Str.fromCharCode(97 + i)].toFixed(4);
            };
            matrixproto.toString = function () {
                return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
            };
            matrixproto.offset = function () {
                return [this.e.toFixed(4), this.f.toFixed(4)];
            };
            function norm(a) {
                return a[0] * a[0] + a[1] * a[1];
            }
            function normalize(a) {
                var mag = math.sqrt(norm(a));
                a[0] && (a[0] /= mag);
                a[1] && (a[1] /= mag);
            }
            /*\
             * Matrix.determinant
             [ method ]
             **
             * Finds determinant of the given matrix.
             = (number) determinant
            \*/
            matrixproto.determinant = function () {
                return this.a * this.d - this.b * this.c;
            };
            /*\
             * Matrix.split
             [ method ]
             **
             * Splits matrix into primitive transformations
             = (object) in format:
             o dx (number) translation by x
             o dy (number) translation by y
             o scalex (number) scale by x
             o scaley (number) scale by y
             o shear (number) shear
             o rotate (number) rotation in deg
             o isSimple (boolean) could it be represented via simple transformations
            \*/
            matrixproto.split = function () {
                var out = {};
                // translation
                out.dx = this.e;
                out.dy = this.f;

                // scale and shear
                var row = [[this.a, this.c], [this.b, this.d]];
                out.scalex = math.sqrt(norm(row[0]));
                normalize(row[0]);

                out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
                row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

                out.scaley = math.sqrt(norm(row[1]));
                normalize(row[1]);
                out.shear /= out.scaley;

                if (this.determinant() < 0) {
                    out.scalex = -out.scalex;
                }

                // rotation
                var sin = -row[0][1],
                    cos = row[1][1];
                if (cos < 0) {
                    out.rotate = Snap.deg(math.acos(cos));
                    if (sin < 0) {
                        out.rotate = 360 - out.rotate;
                    }
                } else {
                    out.rotate = Snap.deg(math.asin(sin));
                }

                out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
                out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
                out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
                return out;
            };
            /*\
             * Matrix.toTransformString
             [ method ]
             **
             * Returns transform string that represents given matrix
             = (string) transform string
            \*/
            matrixproto.toTransformString = function (shorter) {
                var s = shorter || this.split();
                if (!+s.shear.toFixed(9)) {
                    s.scalex = +s.scalex.toFixed(4);
                    s.scaley = +s.scaley.toFixed(4);
                    s.rotate = +s.rotate.toFixed(4);
                    return (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) + (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) + (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E);
                } else {
                    return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
                }
            };
        })(Matrix.prototype);
        /*\
         * Snap.Matrix
         [ method ]
         **
         * Matrix constructor, extend on your own risk.
         * To create matrices use @Snap.matrix.
        \*/
        Snap.Matrix = Matrix;
        /*\
         * Snap.matrix
         [ method ]
         **
         * Utility method
         **
         * Returns a matrix based on the given parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         * or
         - svgMatrix (SVGMatrix)
         = (object) @Matrix
        \*/
        Snap.matrix = function (a, b, c, d, e, f) {
            return new Matrix(a, b, c, d, e, f);
        };
    });
    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var has = "hasOwnProperty",
            make = Snap._.make,
            wrap = Snap._.wrap,
            is = Snap.is,
            getSomeDefs = Snap._.getSomeDefs,
            reURLValue = /^url\(#?([^)]+)\)$/,
            $ = Snap._.$,
            URL = Snap.url,
            Str = String,
            separator = Snap._.separator,
            E = "";
        // Attributes event handlers
        eve.on("snap.util.attr.mask", function (value) {
            if (value instanceof Element || value instanceof Fragment) {
                eve.stop();
                if (value instanceof Fragment && value.node.childNodes.length == 1) {
                    value = value.node.firstChild;
                    getSomeDefs(this).appendChild(value);
                    value = wrap(value);
                }
                if (value.type == "mask") {
                    var mask = value;
                } else {
                    mask = make("mask", getSomeDefs(this));
                    mask.node.appendChild(value.node);
                }
                !mask.node.id && $(mask.node, {
                    id: mask.id
                });
                $(this.node, {
                    mask: URL(mask.id)
                });
            }
        });
        (function (clipIt) {
            eve.on("snap.util.attr.clip", clipIt);
            eve.on("snap.util.attr.clip-path", clipIt);
            eve.on("snap.util.attr.clipPath", clipIt);
        })(function (value) {
            if (value instanceof Element || value instanceof Fragment) {
                eve.stop();
                if (value.type == "clipPath") {
                    var clip = value;
                } else {
                    clip = make("clipPath", getSomeDefs(this));
                    clip.node.appendChild(value.node);
                    !clip.node.id && $(clip.node, {
                        id: clip.id
                    });
                }
                $(this.node, {
                    "clip-path": URL(clip.node.id || clip.id)
                });
            }
        });
        function fillStroke(name) {
            return function (value) {
                eve.stop();
                if (value instanceof Fragment && value.node.childNodes.length == 1 && (value.node.firstChild.tagName == "radialGradient" || value.node.firstChild.tagName == "linearGradient" || value.node.firstChild.tagName == "pattern")) {
                    value = value.node.firstChild;
                    getSomeDefs(this).appendChild(value);
                    value = wrap(value);
                }
                if (value instanceof Element) {
                    if (value.type == "radialGradient" || value.type == "linearGradient" || value.type == "pattern") {
                        if (!value.node.id) {
                            $(value.node, {
                                id: value.id
                            });
                        }
                        var fill = URL(value.node.id);
                    } else {
                        fill = value.attr(name);
                    }
                } else {
                    fill = Snap.color(value);
                    if (fill.error) {
                        var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);
                        if (grad) {
                            if (!grad.node.id) {
                                $(grad.node, {
                                    id: grad.id
                                });
                            }
                            fill = URL(grad.node.id);
                        } else {
                            fill = value;
                        }
                    } else {
                        fill = Str(fill);
                    }
                }
                var attrs = {};
                attrs[name] = fill;
                $(this.node, attrs);
                this.node.style[name] = E;
            };
        }
        eve.on("snap.util.attr.fill", fillStroke("fill"));
        eve.on("snap.util.attr.stroke", fillStroke("stroke"));
        var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
        eve.on("snap.util.grad.parse", function parseGrad(string) {
            string = Str(string);
            var tokens = string.match(gradrg);
            if (!tokens) {
                return null;
            }
            var type = tokens[1],
                params = tokens[2],
                stops = tokens[3];
            params = params.split(/\s*,\s*/).map(function (el) {
                return +el == el ? +el : el;
            });
            if (params.length == 1 && params[0] == 0) {
                params = [];
            }
            stops = stops.split("-");
            stops = stops.map(function (el) {
                el = el.split(":");
                var out = {
                    color: el[0]
                };
                if (el[1]) {
                    out.offset = parseFloat(el[1]);
                }
                return out;
            });
            return {
                type: type,
                params: params,
                stops: stops
            };
        });

        eve.on("snap.util.attr.d", function (value) {
            eve.stop();
            if (is(value, "array") && is(value[0], "array")) {
                value = Snap.path.toString.call(value);
            }
            value = Str(value);
            if (value.match(/[ruo]/i)) {
                value = Snap.path.toAbsolute(value);
            }
            $(this.node, { d: value });
        })(-1);
        eve.on("snap.util.attr.#text", function (value) {
            eve.stop();
            value = Str(value);
            var txt = glob.doc.createTextNode(value);
            while (this.node.firstChild) {
                this.node.removeChild(this.node.firstChild);
            }
            this.node.appendChild(txt);
        })(-1);
        eve.on("snap.util.attr.path", function (value) {
            eve.stop();
            this.attr({ d: value });
        })(-1);
        eve.on("snap.util.attr.class", function (value) {
            eve.stop();
            this.node.className.baseVal = value;
        })(-1);
        eve.on("snap.util.attr.viewBox", function (value) {
            var vb;
            if (is(value, "object") && "x" in value) {
                vb = [value.x, value.y, value.width, value.height].join(" ");
            } else if (is(value, "array")) {
                vb = value.join(" ");
            } else {
                vb = value;
            }
            $(this.node, {
                viewBox: vb
            });
            eve.stop();
        })(-1);
        eve.on("snap.util.attr.transform", function (value) {
            this.transform(value);
            eve.stop();
        })(-1);
        eve.on("snap.util.attr.r", function (value) {
            if (this.type == "rect") {
                eve.stop();
                $(this.node, {
                    rx: value,
                    ry: value
                });
            }
        })(-1);
        eve.on("snap.util.attr.textpath", function (value) {
            eve.stop();
            if (this.type == "text") {
                var id, tp, node;
                if (!value && this.textPath) {
                    tp = this.textPath;
                    while (tp.node.firstChild) {
                        this.node.appendChild(tp.node.firstChild);
                    }
                    tp.remove();
                    delete this.textPath;
                    return;
                }
                if (is(value, "string")) {
                    var defs = getSomeDefs(this),
                        path = wrap(defs.parentNode).path(value);
                    defs.appendChild(path.node);
                    id = path.id;
                    path.attr({ id: id });
                } else {
                    value = wrap(value);
                    if (value instanceof Element) {
                        id = value.attr("id");
                        if (!id) {
                            id = value.id;
                            value.attr({ id: id });
                        }
                    }
                }
                if (id) {
                    tp = this.textPath;
                    node = this.node;
                    if (tp) {
                        tp.attr({ "xlink:href": "#" + id });
                    } else {
                        tp = $("textPath", {
                            "xlink:href": "#" + id
                        });
                        while (node.firstChild) {
                            tp.appendChild(node.firstChild);
                        }
                        node.appendChild(tp);
                        this.textPath = wrap(tp);
                    }
                }
            }
        })(-1);
        eve.on("snap.util.attr.text", function (value) {
            if (this.type == "text") {
                var i = 0,
                    node = this.node,
                    tuner = function (chunk) {
                    var out = $("tspan");
                    if (is(chunk, "array")) {
                        for (var i = 0; i < chunk.length; i++) {
                            out.appendChild(tuner(chunk[i]));
                        }
                    } else {
                        out.appendChild(glob.doc.createTextNode(chunk));
                    }
                    out.normalize && out.normalize();
                    return out;
                };
                while (node.firstChild) {
                    node.removeChild(node.firstChild);
                }
                var tuned = tuner(value);
                while (tuned.firstChild) {
                    node.appendChild(tuned.firstChild);
                }
            }
            eve.stop();
        })(-1);
        function setFontSize(value) {
            eve.stop();
            if (value == +value) {
                value += "px";
            }
            this.node.style.fontSize = value;
        }
        eve.on("snap.util.attr.fontSize", setFontSize)(-1);
        eve.on("snap.util.attr.font-size", setFontSize)(-1);

        eve.on("snap.util.getattr.transform", function () {
            eve.stop();
            return this.transform();
        })(-1);
        eve.on("snap.util.getattr.textpath", function () {
            eve.stop();
            return this.textPath;
        })(-1);
        // Markers
        (function () {
            function getter(end) {
                return function () {
                    eve.stop();
                    var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
                    if (style == "none") {
                        return style;
                    } else {
                        return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
                    }
                };
            }
            function setter(end) {
                return function (value) {
                    eve.stop();
                    var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
                    if (value == "" || !value) {
                        this.node.style[name] = "none";
                        return;
                    }
                    if (value.type == "marker") {
                        var id = value.node.id;
                        if (!id) {
                            $(value.node, { id: value.id });
                        }
                        this.node.style[name] = URL(id);
                        return;
                    }
                };
            }
            eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
            eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
            eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
            eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
            eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
            eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
            eve.on("snap.util.attr.marker-end", setter("end"))(-1);
            eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
            eve.on("snap.util.attr.marker-start", setter("start"))(-1);
            eve.on("snap.util.attr.markerStart", setter("start"))(-1);
            eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
            eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
        })();
        eve.on("snap.util.getattr.r", function () {
            if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
                eve.stop();
                return $(this.node, "rx");
            }
        })(-1);
        function textExtract(node) {
            var out = [];
            var children = node.childNodes;
            for (var i = 0, ii = children.length; i < ii; i++) {
                var chi = children[i];
                if (chi.nodeType == 3) {
                    out.push(chi.nodeValue);
                }
                if (chi.tagName == "tspan") {
                    if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
                        out.push(chi.firstChild.nodeValue);
                    } else {
                        out.push(textExtract(chi));
                    }
                }
            }
            return out;
        }
        eve.on("snap.util.getattr.text", function () {
            if (this.type == "text" || this.type == "tspan") {
                eve.stop();
                var out = textExtract(this.node);
                return out.length == 1 ? out[0] : out;
            }
        })(-1);
        eve.on("snap.util.getattr.#text", function () {
            return this.node.textContent;
        })(-1);
        eve.on("snap.util.getattr.viewBox", function () {
            eve.stop();
            var vb = $(this.node, "viewBox");
            if (vb) {
                vb = vb.split(separator);
                return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
            } else {
                return;
            }
        })(-1);
        eve.on("snap.util.getattr.points", function () {
            var p = $(this.node, "points");
            eve.stop();
            if (p) {
                return p.split(separator);
            } else {
                return;
            }
        })(-1);
        eve.on("snap.util.getattr.path", function () {
            var p = $(this.node, "d");
            eve.stop();
            return p;
        })(-1);
        eve.on("snap.util.getattr.class", function () {
            return this.node.className.baseVal;
        })(-1);
        function getFontSize() {
            eve.stop();
            return this.node.style.fontSize;
        }
        eve.on("snap.util.getattr.fontSize", getFontSize)(-1);
        eve.on("snap.util.getattr.font-size", getFontSize)(-1);
    });

    // Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    // http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var rgNotSpace = /\S+/g,
            rgBadSpace = /[\t\r\n\f]/g,
            rgTrim = /(^\s+|\s+$)/g,
            Str = String,
            elproto = Element.prototype;
        /*\
         * Element.addClass
         [ method ]
         **
         * Adds given class name or list of class names to the element.
         - value (string) class name or space separated list of class names
         **
         = (Element) original element.
        \*/
        elproto.addClass = function (value) {
            var classes = Str(value || "").match(rgNotSpace) || [],
                elem = this.node,
                className = elem.className.baseVal,
                curClasses = className.match(rgNotSpace) || [],
                j,
                pos,
                clazz,
                finalValue;

            if (classes.length) {
                j = 0;
                while (clazz = classes[j++]) {
                    pos = curClasses.indexOf(clazz);
                    if (!~pos) {
                        curClasses.push(clazz);
                    }
                }

                finalValue = curClasses.join(" ");
                if (className != finalValue) {
                    elem.className.baseVal = finalValue;
                }
            }
            return this;
        };
        /*\
         * Element.removeClass
         [ method ]
         **
         * Removes given class name or list of class names from the element.
         - value (string) class name or space separated list of class names
         **
         = (Element) original element.
        \*/
        elproto.removeClass = function (value) {
            var classes = Str(value || "").match(rgNotSpace) || [],
                elem = this.node,
                className = elem.className.baseVal,
                curClasses = className.match(rgNotSpace) || [],
                j,
                pos,
                clazz,
                finalValue;
            if (curClasses.length) {
                j = 0;
                while (clazz = classes[j++]) {
                    pos = curClasses.indexOf(clazz);
                    if (~pos) {
                        curClasses.splice(pos, 1);
                    }
                }

                finalValue = curClasses.join(" ");
                if (className != finalValue) {
                    elem.className.baseVal = finalValue;
                }
            }
            return this;
        };
        /*\
         * Element.hasClass
         [ method ]
         **
         * Checks if the element has a given class name in the list of class names applied to it.
         - value (string) class name
         **
         = (boolean) `true` if the element has given class
        \*/
        elproto.hasClass = function (value) {
            var elem = this.node,
                className = elem.className.baseVal,
                curClasses = className.match(rgNotSpace) || [];
            return !!~curClasses.indexOf(value);
        };
        /*\
         * Element.toggleClass
         [ method ]
         **
         * Add or remove one or more classes from the element, depending on either
         * the classs presence or the value of the `flag` argument.
         - value (string) class name or space separated list of class names
         - flag (boolean) value to determine whether the class should be added or removed
         **
         = (Element) original element.
        \*/
        elproto.toggleClass = function (value, flag) {
            if (flag != null) {
                if (flag) {
                    return this.addClass(value);
                } else {
                    return this.removeClass(value);
                }
            }
            var classes = (value || "").match(rgNotSpace) || [],
                elem = this.node,
                className = elem.className.baseVal,
                curClasses = className.match(rgNotSpace) || [],
                j,
                pos,
                clazz,
                finalValue;
            j = 0;
            while (clazz = classes[j++]) {
                pos = curClasses.indexOf(clazz);
                if (~pos) {
                    curClasses.splice(pos, 1);
                } else {
                    curClasses.push(clazz);
                }
            }

            finalValue = curClasses.join(" ");
            if (className != finalValue) {
                elem.className.baseVal = finalValue;
            }
            return this;
        };
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var operators = {
            "+": function (x, y) {
                return x + y;
            },
            "-": function (x, y) {
                return x - y;
            },
            "/": function (x, y) {
                return x / y;
            },
            "*": function (x, y) {
                return x * y;
            }
        },
            Str = String,
            reUnit = /[a-z]+$/i,
            reAddon = /^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;
        function getNumber(val) {
            return val;
        }
        function getUnit(unit) {
            return function (val) {
                return +val.toFixed(3) + unit;
            };
        }
        eve.on("snap.util.attr", function (val) {
            var plus = Str(val).match(reAddon);
            if (plus) {
                var evnt = eve.nt(),
                    name = evnt.substring(evnt.lastIndexOf(".") + 1),
                    a = this.attr(name),
                    atr = {};
                eve.stop();
                var unit = plus[3] || "",
                    aUnit = a.match(reUnit),
                    op = operators[plus[1]];
                if (aUnit && aUnit == unit) {
                    val = op(parseFloat(a), +plus[2]);
                } else {
                    a = this.asPX(name);
                    val = op(this.asPX(name), this.asPX(name, plus[2] + unit));
                }
                if (isNaN(a) || isNaN(val)) {
                    return;
                }
                atr[name] = val;
                this.attr(atr);
            }
        })(-10);
        eve.on("snap.util.equal", function (name, b) {
            var A,
                B,
                a = Str(this.attr(name) || ""),
                el = this,
                bplus = Str(b).match(reAddon);
            if (bplus) {
                eve.stop();
                var unit = bplus[3] || "",
                    aUnit = a.match(reUnit),
                    op = operators[bplus[1]];
                if (aUnit && aUnit == unit) {
                    return {
                        from: parseFloat(a),
                        to: op(parseFloat(a), +bplus[2]),
                        f: getUnit(aUnit)
                    };
                } else {
                    a = this.asPX(name);
                    return {
                        from: a,
                        to: op(a, this.asPX(name, bplus[2] + unit)),
                        f: getNumber
                    };
                }
            }
        })(-10);
    });
    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var proto = Paper.prototype,
            is = Snap.is;
        /*\
         * Paper.rect
         [ method ]
         *
         * Draws a rectangle
         **
         - x (number) x coordinate of the top left corner
         - y (number) y coordinate of the top left corner
         - width (number) width
         - height (number) height
         - rx (number) #optional horizontal radius for rounded corners, default is 0
         - ry (number) #optional vertical radius for rounded corners, default is rx or 0
         = (object) the `rect` element
         **
         > Usage
         | // regular rectangle
         | var c = paper.rect(10, 10, 50, 50);
         | // rectangle with rounded corners
         | var c = paper.rect(40, 40, 50, 50, 10);
        \*/
        proto.rect = function (x, y, w, h, rx, ry) {
            var attr;
            if (ry == null) {
                ry = rx;
            }
            if (is(x, "object") && x == "[object Object]") {
                attr = x;
            } else if (x != null) {
                attr = {
                    x: x,
                    y: y,
                    width: w,
                    height: h
                };
                if (rx != null) {
                    attr.rx = rx;
                    attr.ry = ry;
                }
            }
            return this.el("rect", attr);
        };
        /*\
         * Paper.circle
         [ method ]
         **
         * Draws a circle
         **
         - x (number) x coordinate of the centre
         - y (number) y coordinate of the centre
         - r (number) radius
         = (object) the `circle` element
         **
         > Usage
         | var c = paper.circle(50, 50, 40);
        \*/
        proto.circle = function (cx, cy, r) {
            var attr;
            if (is(cx, "object") && cx == "[object Object]") {
                attr = cx;
            } else if (cx != null) {
                attr = {
                    cx: cx,
                    cy: cy,
                    r: r
                };
            }
            return this.el("circle", attr);
        };

        var preload = function () {
            function onerror() {
                this.parentNode.removeChild(this);
            }
            return function (src, f) {
                var img = glob.doc.createElement("img"),
                    body = glob.doc.body;
                img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
                img.onload = function () {
                    f.call(img);
                    img.onload = img.onerror = null;
                    body.removeChild(img);
                };
                img.onerror = onerror;
                body.appendChild(img);
                img.src = src;
            };
        }();

        /*\
         * Paper.image
         [ method ]
         **
         * Places an image on the surface
         **
         - src (string) URI of the source image
         - x (number) x offset position
         - y (number) y offset position
         - width (number) width of the image
         - height (number) height of the image
         = (object) the `image` element
         * or
         = (object) Snap element object with type `image`
         **
         > Usage
         | var c = paper.image("apple.png", 10, 10, 80, 80);
        \*/
        proto.image = function (src, x, y, width, height) {
            var el = this.el("image");
            if (is(src, "object") && "src" in src) {
                el.attr(src);
            } else if (src != null) {
                var set = {
                    "xlink:href": src,
                    preserveAspectRatio: "none"
                };
                if (x != null && y != null) {
                    set.x = x;
                    set.y = y;
                }
                if (width != null && height != null) {
                    set.width = width;
                    set.height = height;
                } else {
                    preload(src, function () {
                        Snap._.$(el.node, {
                            width: this.offsetWidth,
                            height: this.offsetHeight
                        });
                    });
                }
                Snap._.$(el.node, set);
            }
            return el;
        };
        /*\
         * Paper.ellipse
         [ method ]
         **
         * Draws an ellipse
         **
         - x (number) x coordinate of the centre
         - y (number) y coordinate of the centre
         - rx (number) horizontal radius
         - ry (number) vertical radius
         = (object) the `ellipse` element
         **
         > Usage
         | var c = paper.ellipse(50, 50, 40, 20);
        \*/
        proto.ellipse = function (cx, cy, rx, ry) {
            var attr;
            if (is(cx, "object") && cx == "[object Object]") {
                attr = cx;
            } else if (cx != null) {
                attr = {
                    cx: cx,
                    cy: cy,
                    rx: rx,
                    ry: ry
                };
            }
            return this.el("ellipse", attr);
        };
        // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
        /*\
         * Paper.path
         [ method ]
         **
         * Creates a `<path>` element using the given string as the path's definition
         - pathString (string) #optional path string in SVG format
         * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
         | "M10,20L30,40"
         * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
         *
         # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
         # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
         # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
         # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
         # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
         # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
         # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
         # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
         # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
         # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>
         # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>
         # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
         # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
         * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
         * Note: there is a special case when a path consists of only three commands: `M10,10Rz`. In this case the path connects back to its starting point.
         > Usage
         | var c = paper.path("M10 10L90 90");
         | // draw a diagonal line:
         | // move to 10,10, line to 90,90
        \*/
        proto.path = function (d) {
            var attr;
            if (is(d, "object") && !is(d, "array")) {
                attr = d;
            } else if (d) {
                attr = { d: d };
            }
            return this.el("path", attr);
        };
        /*\
         * Paper.g
         [ method ]
         **
         * Creates a group element
         **
         - varargs () #optional elements to nest within the group
         = (object) the `g` element
         **
         > Usage
         | var c1 = paper.circle(),
         |     c2 = paper.rect(),
         |     g = paper.g(c2, c1); // note that the order of elements is different
         * or
         | var c1 = paper.circle(),
         |     c2 = paper.rect(),
         |     g = paper.g();
         | g.add(c2, c1);
        \*/
        /*\
         * Paper.group
         [ method ]
         **
         * See @Paper.g
        \*/
        proto.group = proto.g = function (first) {
            var attr,
                el = this.el("g");
            if (arguments.length == 1 && first && !first.type) {
                el.attr(first);
            } else if (arguments.length) {
                el.add(Array.prototype.slice.call(arguments, 0));
            }
            return el;
        };
        /*\
         * Paper.svg
         [ method ]
         **
         * Creates a nested SVG element.
         - x (number) @optional X of the element
         - y (number) @optional Y of the element
         - width (number) @optional width of the element
         - height (number) @optional height of the element
         - vbx (number) @optional viewbox X
         - vby (number) @optional viewbox Y
         - vbw (number) @optional viewbox width
         - vbh (number) @optional viewbox height
         **
         = (object) the `svg` element
         **
        \*/
        proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {
            var attrs = {};
            if (is(x, "object") && y == null) {
                attrs = x;
            } else {
                if (x != null) {
                    attrs.x = x;
                }
                if (y != null) {
                    attrs.y = y;
                }
                if (width != null) {
                    attrs.width = width;
                }
                if (height != null) {
                    attrs.height = height;
                }
                if (vbx != null && vby != null && vbw != null && vbh != null) {
                    attrs.viewBox = [vbx, vby, vbw, vbh];
                }
            }
            return this.el("svg", attrs);
        };
        /*\
         * Paper.mask
         [ method ]
         **
         * Equivalent in behaviour to @Paper.g, except its a mask.
         **
         = (object) the `mask` element
         **
        \*/
        proto.mask = function (first) {
            var attr,
                el = this.el("mask");
            if (arguments.length == 1 && first && !first.type) {
                el.attr(first);
            } else if (arguments.length) {
                el.add(Array.prototype.slice.call(arguments, 0));
            }
            return el;
        };
        /*\
         * Paper.ptrn
         [ method ]
         **
         * Equivalent in behaviour to @Paper.g, except its a pattern.
         - x (number) @optional X of the element
         - y (number) @optional Y of the element
         - width (number) @optional width of the element
         - height (number) @optional height of the element
         - vbx (number) @optional viewbox X
         - vby (number) @optional viewbox Y
         - vbw (number) @optional viewbox width
         - vbh (number) @optional viewbox height
         **
         = (object) the `pattern` element
         **
        \*/
        proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {
            if (is(x, "object")) {
                var attr = x;
            } else {
                attr = { patternUnits: "userSpaceOnUse" };
                if (x) {
                    attr.x = x;
                }
                if (y) {
                    attr.y = y;
                }
                if (width != null) {
                    attr.width = width;
                }
                if (height != null) {
                    attr.height = height;
                }
                if (vx != null && vy != null && vw != null && vh != null) {
                    attr.viewBox = [vx, vy, vw, vh];
                } else {
                    attr.viewBox = [x || 0, y || 0, width || 0, height || 0];
                }
            }
            return this.el("pattern", attr);
        };
        /*\
         * Paper.use
         [ method ]
         **
         * Creates a <use> element.
         - id (string) @optional id of element to link
         * or
         - id (Element) @optional element to link
         **
         = (object) the `use` element
         **
        \*/
        proto.use = function (id) {
            if (id != null) {
                if (id instanceof Element) {
                    if (!id.attr("id")) {
                        id.attr({ id: Snap._.id(id) });
                    }
                    id = id.attr("id");
                }
                if (String(id).charAt() == "#") {
                    id = id.substring(1);
                }
                return this.el("use", { "xlink:href": "#" + id });
            } else {
                return Element.prototype.use.call(this);
            }
        };
        /*\
         * Paper.symbol
         [ method ]
         **
         * Creates a <symbol> element.
         - vbx (number) @optional viewbox X
         - vby (number) @optional viewbox Y
         - vbw (number) @optional viewbox width
         - vbh (number) @optional viewbox height
         = (object) the `symbol` element
         **
        \*/
        proto.symbol = function (vx, vy, vw, vh) {
            var attr = {};
            if (vx != null && vy != null && vw != null && vh != null) {
                attr.viewBox = [vx, vy, vw, vh];
            }

            return this.el("symbol", attr);
        };
        /*\
         * Paper.text
         [ method ]
         **
         * Draws a text string
         **
         - x (number) x coordinate position
         - y (number) y coordinate position
         - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
         = (object) the `text` element
         **
         > Usage
         | var t1 = paper.text(50, 50, "Snap");
         | var t2 = paper.text(50, 50, ["S","n","a","p"]);
         | // Text path usage
         | t1.attr({textpath: "M10,10L100,100"});
         | // or
         | var pth = paper.path("M10,10L100,100");
         | t1.attr({textpath: pth});
        \*/
        proto.text = function (x, y, text) {
            var attr = {};
            if (is(x, "object")) {
                attr = x;
            } else if (x != null) {
                attr = {
                    x: x,
                    y: y,
                    text: text || ""
                };
            }
            return this.el("text", attr);
        };
        /*\
         * Paper.line
         [ method ]
         **
         * Draws a line
         **
         - x1 (number) x coordinate position of the start
         - y1 (number) y coordinate position of the start
         - x2 (number) x coordinate position of the end
         - y2 (number) y coordinate position of the end
         = (object) the `line` element
         **
         > Usage
         | var t1 = paper.line(50, 50, 100, 100);
        \*/
        proto.line = function (x1, y1, x2, y2) {
            var attr = {};
            if (is(x1, "object")) {
                attr = x1;
            } else if (x1 != null) {
                attr = {
                    x1: x1,
                    x2: x2,
                    y1: y1,
                    y2: y2
                };
            }
            return this.el("line", attr);
        };
        /*\
         * Paper.polyline
         [ method ]
         **
         * Draws a polyline
         **
         - points (array) array of points
         * or
         - varargs () points
         = (object) the `polyline` element
         **
         > Usage
         | var p1 = paper.polyline([10, 10, 100, 100]);
         | var p2 = paper.polyline(10, 10, 100, 100);
        \*/
        proto.polyline = function (points) {
            if (arguments.length > 1) {
                points = Array.prototype.slice.call(arguments, 0);
            }
            var attr = {};
            if (is(points, "object") && !is(points, "array")) {
                attr = points;
            } else if (points != null) {
                attr = { points: points };
            }
            return this.el("polyline", attr);
        };
        /*\
         * Paper.polygon
         [ method ]
         **
         * Draws a polygon. See @Paper.polyline
        \*/
        proto.polygon = function (points) {
            if (arguments.length > 1) {
                points = Array.prototype.slice.call(arguments, 0);
            }
            var attr = {};
            if (is(points, "object") && !is(points, "array")) {
                attr = points;
            } else if (points != null) {
                attr = { points: points };
            }
            return this.el("polygon", attr);
        };
        // gradients
        (function () {
            var $ = Snap._.$;
            // gradients' helpers
            function Gstops() {
                return this.selectAll("stop");
            }
            function GaddStop(color, offset) {
                var stop = $("stop"),
                    attr = {
                    offset: +offset + "%"
                };
                color = Snap.color(color);
                attr["stop-color"] = color.hex;
                if (color.opacity < 1) {
                    attr["stop-opacity"] = color.opacity;
                }
                $(stop, attr);
                this.node.appendChild(stop);
                return this;
            }
            function GgetBBox() {
                if (this.type == "linearGradient") {
                    var x1 = $(this.node, "x1") || 0,
                        x2 = $(this.node, "x2") || 1,
                        y1 = $(this.node, "y1") || 0,
                        y2 = $(this.node, "y2") || 0;
                    return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
                } else {
                    var cx = this.node.cx || .5,
                        cy = this.node.cy || .5,
                        r = this.node.r || 0;
                    return Snap._.box(cx - r, cy - r, r * 2, r * 2);
                }
            }
            function gradient(defs, str) {
                var grad = eve("snap.util.grad.parse", null, str).firstDefined(),
                    el;
                if (!grad) {
                    return null;
                }
                grad.params.unshift(defs);
                if (grad.type.toLowerCase() == "l") {
                    el = gradientLinear.apply(0, grad.params);
                } else {
                    el = gradientRadial.apply(0, grad.params);
                }
                if (grad.type != grad.type.toLowerCase()) {
                    $(el.node, {
                        gradientUnits: "userSpaceOnUse"
                    });
                }
                var stops = grad.stops,
                    len = stops.length,
                    start = 0,
                    j = 0;
                function seed(i, end) {
                    var step = (end - start) / (i - j);
                    for (var k = j; k < i; k++) {
                        stops[k].offset = +(+start + step * (k - j)).toFixed(2);
                    }
                    j = i;
                    start = end;
                }
                len--;
                for (var i = 0; i < len; i++) {
                    if ("offset" in stops[i]) {
                        seed(i, stops[i].offset);
                    }
                }stops[len].offset = stops[len].offset || 100;
                seed(len, stops[len].offset);
                for (i = 0; i <= len; i++) {
                    var stop = stops[i];
                    el.addStop(stop.color, stop.offset);
                }
                return el;
            }
            function gradientLinear(defs, x1, y1, x2, y2) {
                var el = Snap._.make("linearGradient", defs);
                el.stops = Gstops;
                el.addStop = GaddStop;
                el.getBBox = GgetBBox;
                if (x1 != null) {
                    $(el.node, {
                        x1: x1,
                        y1: y1,
                        x2: x2,
                        y2: y2
                    });
                }
                return el;
            }
            function gradientRadial(defs, cx, cy, r, fx, fy) {
                var el = Snap._.make("radialGradient", defs);
                el.stops = Gstops;
                el.addStop = GaddStop;
                el.getBBox = GgetBBox;
                if (cx != null) {
                    $(el.node, {
                        cx: cx,
                        cy: cy,
                        r: r
                    });
                }
                if (fx != null && fy != null) {
                    $(el.node, {
                        fx: fx,
                        fy: fy
                    });
                }
                return el;
            }
            /*\
             * Paper.gradient
             [ method ]
             **
             * Creates a gradient element
             **
             - gradient (string) gradient descriptor
             > Gradient Descriptor
             * The gradient descriptor is an expression formatted as
             * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
             * either linear or radial.  The uppercase `L` or `R` letters
             * indicate absolute coordinates offset from the SVG surface.
             * Lowercase `l` or `r` letters indicate coordinates
             * calculated relative to the element to which the gradient is
             * applied.  Coordinates specify a linear gradient vector as
             * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
             * `r` and optional `fx`, `fy` specifying a focal point away
             * from the center of the circle. Specify `<colors>` as a list
             * of dash-separated CSS color values.  Each color may be
             * followed by a custom offset value, separated with a colon
             * character.
             > Examples
             * Linear gradient, relative from top-left corner to bottom-right
             * corner, from black through red to white:
             | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
             * Linear gradient, absolute from (0, 0) to (100, 100), from black
             * through red at 25% to white:
             | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25-#fff");
             * Radial gradient, relative from the center of the element with radius
             * half the width, from black to white:
             | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
             * To apply the gradient:
             | paper.circle(50, 50, 40).attr({
             |     fill: g
             | });
             = (object) the `gradient` element
            \*/
            proto.gradient = function (str) {
                return gradient(this.defs, str);
            };
            proto.gradientLinear = function (x1, y1, x2, y2) {
                return gradientLinear(this.defs, x1, y1, x2, y2);
            };
            proto.gradientRadial = function (cx, cy, r, fx, fy) {
                return gradientRadial(this.defs, cx, cy, r, fx, fy);
            };
            /*\
             * Paper.toString
             [ method ]
             **
             * Returns SVG code for the @Paper
             = (string) SVG code for the @Paper
            \*/
            proto.toString = function () {
                var doc = this.node.ownerDocument,
                    f = doc.createDocumentFragment(),
                    d = doc.createElement("div"),
                    svg = this.node.cloneNode(true),
                    res;
                f.appendChild(d);
                d.appendChild(svg);
                Snap._.$(svg, { xmlns: "http://www.w3.org/2000/svg" });
                res = d.innerHTML;
                f.removeChild(f.firstChild);
                return res;
            };
            /*\
             * Paper.toDataURL
             [ method ]
             **
             * Returns SVG code for the @Paper as Data URI string.
             = (string) Data URI string
            \*/
            proto.toDataURL = function () {
                if (window && window.btoa) {
                    return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(this)));
                }
            };
            /*\
             * Paper.clear
             [ method ]
             **
             * Removes all child nodes of the paper, except <defs>.
            \*/
            proto.clear = function () {
                var node = this.node.firstChild,
                    next;
                while (node) {
                    next = node.nextSibling;
                    if (node.tagName != "defs") {
                        node.parentNode.removeChild(node);
                    } else {
                        proto.clear.call({ node: node });
                    }
                    node = next;
                }
            };
        })();
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob) {
        var elproto = Element.prototype,
            is = Snap.is,
            clone = Snap._.clone,
            has = "hasOwnProperty",
            p2s = /,?([a-z]),?/gi,
            toFloat = parseFloat,
            math = Math,
            PI = math.PI,
            mmin = math.min,
            mmax = math.max,
            pow = math.pow,
            abs = math.abs;
        function paths(ps) {
            var p = paths.ps = paths.ps || {};
            if (p[ps]) {
                p[ps].sleep = 100;
            } else {
                p[ps] = {
                    sleep: 100
                };
            }
            setTimeout(function () {
                for (var key in p) {
                    if (p[has](key) && key != ps) {
                        p[key].sleep--;
                        !p[key].sleep && delete p[key];
                    }
                }
            });
            return p[ps];
        }
        function box(x, y, width, height) {
            if (x == null) {
                x = y = width = height = 0;
            }
            if (y == null) {
                y = x.y;
                width = x.width;
                height = x.height;
                x = x.x;
            }
            return {
                x: x,
                y: y,
                width: width,
                w: width,
                height: height,
                h: height,
                x2: x + width,
                y2: y + height,
                cx: x + width / 2,
                cy: y + height / 2,
                r1: math.min(width, height) / 2,
                r2: math.max(width, height) / 2,
                r0: math.sqrt(width * width + height * height) / 2,
                path: rectPath(x, y, width, height),
                vb: [x, y, width, height].join(" ")
            };
        }
        function toString() {
            return this.join(",").replace(p2s, "$1");
        }
        function pathClone(pathArray) {
            var res = clone(pathArray);
            res.toString = toString;
            return res;
        }
        function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
            if (length == null) {
                return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
            } else {
                return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
            }
        }
        function getLengthFactory(istotal, subpath) {
            function O(val) {
                return +(+val).toFixed(3);
            }
            return Snap._.cacher(function (path, length, onlystart) {
                if (path instanceof Element) {
                    path = path.attr("d");
                }
                path = path2curve(path);
                var x,
                    y,
                    p,
                    l,
                    sp = "",
                    subpaths = {},
                    point,
                    len = 0;
                for (var i = 0, ii = path.length; i < ii; i++) {
                    p = path[i];
                    if (p[0] == "M") {
                        x = +p[1];
                        y = +p[2];
                    } else {
                        l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                        if (len + l > length) {
                            if (subpath && !subpaths.start) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                sp += ["C" + O(point.start.x), O(point.start.y), O(point.m.x), O(point.m.y), O(point.x), O(point.y)];
                                if (onlystart) {
                                    return sp;
                                }
                                subpaths.start = sp;
                                sp = ["M" + O(point.x), O(point.y) + "C" + O(point.n.x), O(point.n.y), O(point.end.x), O(point.end.y), O(p[5]), O(p[6])].join();
                                len += l;
                                x = +p[5];
                                y = +p[6];
                                continue;
                            }
                            if (!istotal && !subpath) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                return point;
                            }
                        }
                        len += l;
                        x = +p[5];
                        y = +p[6];
                    }
                    sp += p.shift() + p;
                }
                subpaths.end = sp;
                point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                return point;
            }, null, Snap._.clone);
        }
        var getTotalLength = getLengthFactory(1),
            getPointAtLength = getLengthFactory(),
            getSubpathsAtLength = getLengthFactory(0, 1);
        function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t,
                t13 = pow(t1, 3),
                t12 = pow(t1, 2),
                t2 = t * t,
                t3 = t2 * t,
                x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
                y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
                mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
                my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
                nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
                ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
                ax = t1 * p1x + t * c1x,
                ay = t1 * p1y + t * c1y,
                cx = t1 * c2x + t * p2x,
                cy = t1 * c2y + t * p2y,
                alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
            // (mx > nx || my < ny) && (alpha += 180);
            return {
                x: x,
                y: y,
                m: { x: mx, y: my },
                n: { x: nx, y: ny },
                start: { x: ax, y: ay },
                end: { x: cx, y: cy },
                alpha: alpha
            };
        }
        function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            if (!Snap.is(p1x, "array")) {
                p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
            }
            var bbox = curveDim.apply(null, p1x);
            return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
        }
        function isPointInsideBBox(bbox, x, y) {
            return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
        }
        function isBBoxIntersect(bbox1, bbox2) {
            bbox1 = box(bbox1);
            bbox2 = box(bbox2);
            return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
        }
        function base3(t, p1, p2, p3, p4) {
            var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
                t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
            return t * t2 - 3 * p1 + 3 * p2;
        }
        function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
            if (z == null) {
                z = 1;
            }
            z = z > 1 ? 1 : z < 0 ? 0 : z;
            var z2 = z / 2,
                n = 12,
                Tvalues = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816],
                Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
                sum = 0;
            for (var i = 0; i < n; i++) {
                var ct = z2 * Tvalues[i] + z2,
                    xbase = base3(ct, x1, x2, x3, x4),
                    ybase = base3(ct, y1, y2, y3, y4),
                    comb = xbase * xbase + ybase * ybase;
                sum += Cvalues[i] * math.sqrt(comb);
            }
            return z2 * sum;
        }
        function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
            if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
                return;
            }
            var t = 1,
                step = t / 2,
                t2 = t - step,
                l,
                e = .01;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
            while (abs(l - ll) > e) {
                step /= 2;
                t2 += (l < ll ? 1 : -1) * step;
                l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
            }
            return t2;
        }
        function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {
                return;
            }
            var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
                ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
                denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

            if (!denominator) {
                return;
            }
            var px = nx / denominator,
                py = ny / denominator,
                px2 = +px.toFixed(2),
                py2 = +py.toFixed(2);
            if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {
                return;
            }
            return { x: px, y: py };
        }
        function inter(bez1, bez2) {
            return interHelper(bez1, bez2);
        }
        function interCount(bez1, bez2) {
            return interHelper(bez1, bez2, 1);
        }
        function interHelper(bez1, bez2, justCount) {
            var bbox1 = bezierBBox(bez1),
                bbox2 = bezierBBox(bez2);
            if (!isBBoxIntersect(bbox1, bbox2)) {
                return justCount ? 0 : [];
            }
            var l1 = bezlen.apply(0, bez1),
                l2 = bezlen.apply(0, bez2),
                n1 = ~~(l1 / 8),
                n2 = ~~(l2 / 8),
                dots1 = [],
                dots2 = [],
                xy = {},
                res = justCount ? 0 : [];
            for (var i = 0; i < n1 + 1; i++) {
                var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
                dots1.push({ x: p.x, y: p.y, t: i / n1 });
            }
            for (i = 0; i < n2 + 1; i++) {
                p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
                dots2.push({ x: p.x, y: p.y, t: i / n2 });
            }
            for (i = 0; i < n1; i++) {
                for (var j = 0; j < n2; j++) {
                    var di = dots1[i],
                        di1 = dots1[i + 1],
                        dj = dots2[j],
                        dj1 = dots2[j + 1],
                        ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                        cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                        is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                    if (is) {
                        if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                            continue;
                        }
                        xy[is.x.toFixed(4)] = is.y.toFixed(4);
                        var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                            t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                            if (justCount) {
                                res++;
                            } else {
                                res.push({
                                    x: is.x,
                                    y: is.y,
                                    t1: t1,
                                    t2: t2
                                });
                            }
                        }
                    }
                }
            }
            return res;
        }
        function pathIntersection(path1, path2) {
            return interPathHelper(path1, path2);
        }
        function pathIntersectionNumber(path1, path2) {
            return interPathHelper(path1, path2, 1);
        }
        function interPathHelper(path1, path2, justCount) {
            path1 = path2curve(path1);
            path2 = path2curve(path2);
            var x1,
                y1,
                x2,
                y2,
                x1m,
                y1m,
                x2m,
                y2m,
                bez1,
                bez2,
                res = justCount ? 0 : [];
            for (var i = 0, ii = path1.length; i < ii; i++) {
                var pi = path1[i];
                if (pi[0] == "M") {
                    x1 = x1m = pi[1];
                    y1 = y1m = pi[2];
                } else {
                    if (pi[0] == "C") {
                        bez1 = [x1, y1].concat(pi.slice(1));
                        x1 = bez1[6];
                        y1 = bez1[7];
                    } else {
                        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                        x1 = x1m;
                        y1 = y1m;
                    }
                    for (var j = 0, jj = path2.length; j < jj; j++) {
                        var pj = path2[j];
                        if (pj[0] == "M") {
                            x2 = x2m = pj[1];
                            y2 = y2m = pj[2];
                        } else {
                            if (pj[0] == "C") {
                                bez2 = [x2, y2].concat(pj.slice(1));
                                x2 = bez2[6];
                                y2 = bez2[7];
                            } else {
                                bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                                x2 = x2m;
                                y2 = y2m;
                            }
                            var intr = interHelper(bez1, bez2, justCount);
                            if (justCount) {
                                res += intr;
                            } else {
                                for (var k = 0, kk = intr.length; k < kk; k++) {
                                    intr[k].segment1 = i;
                                    intr[k].segment2 = j;
                                    intr[k].bez1 = bez1;
                                    intr[k].bez2 = bez2;
                                }
                                res = res.concat(intr);
                            }
                        }
                    }
                }
            }
            return res;
        }
        function isPointInsidePath(path, x, y) {
            var bbox = pathBBox(path);
            return isPointInsideBBox(bbox, x, y) && interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
        }
        function pathBBox(path) {
            var pth = paths(path);
            if (pth.bbox) {
                return clone(pth.bbox);
            }
            if (!path) {
                return box();
            }
            path = path2curve(path);
            var x = 0,
                y = 0,
                X = [],
                Y = [],
                p;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = p[1];
                    y = p[2];
                    X.push(x);
                    Y.push(y);
                } else {
                    var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    X = X.concat(dim.min.x, dim.max.x);
                    Y = Y.concat(dim.min.y, dim.max.y);
                    x = p[5];
                    y = p[6];
                }
            }
            var xmin = mmin.apply(0, X),
                ymin = mmin.apply(0, Y),
                xmax = mmax.apply(0, X),
                ymax = mmax.apply(0, Y),
                bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
            pth.bbox = clone(bb);
            return bb;
        }
        function rectPath(x, y, w, h, r) {
            if (r) {
                return [["M", +x + +r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
            res.toString = toString;
            return res;
        }
        function ellipsePath(x, y, rx, ry, a) {
            if (a == null && ry == null) {
                ry = rx;
            }
            x = +x;
            y = +y;
            rx = +rx;
            ry = +ry;
            if (a != null) {
                var rad = Math.PI / 180,
                    x1 = x + rx * Math.cos(-ry * rad),
                    x2 = x + rx * Math.cos(-a * rad),
                    y1 = y + rx * Math.sin(-ry * rad),
                    y2 = y + rx * Math.sin(-a * rad),
                    res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
            } else {
                res = [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
            }
            res.toString = toString;
            return res;
        }
        var unit2px = Snap._unit2px,
            getPath = {
            path: function (el) {
                return el.attr("path");
            },
            circle: function (el) {
                var attr = unit2px(el);
                return ellipsePath(attr.cx, attr.cy, attr.r);
            },
            ellipse: function (el) {
                var attr = unit2px(el);
                return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);
            },
            rect: function (el) {
                var attr = unit2px(el);
                return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);
            },
            image: function (el) {
                var attr = unit2px(el);
                return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);
            },
            line: function (el) {
                return "M" + [el.attr("x1") || 0, el.attr("y1") || 0, el.attr("x2"), el.attr("y2")];
            },
            polyline: function (el) {
                return "M" + el.attr("points");
            },
            polygon: function (el) {
                return "M" + el.attr("points") + "z";
            },
            deflt: function (el) {
                var bbox = el.node.getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        };
        function pathToRelative(pathArray) {
            var pth = paths(pathArray),
                lowerCase = String.prototype.toLowerCase;
            if (pth.rel) {
                return pathClone(pth.rel);
            }
            if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
                pathArray = Snap.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res.push(["M", x, y]);
            }
            for (var i = start, ii = pathArray.length; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i].length;
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res.toString = toString;
            pth.rel = pathClone(res);
            return res;
        }
        function pathToAbsolute(pathArray) {
            var pth = paths(pathArray);
            if (pth.abs) {
                return pathClone(pth.abs);
            }
            if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) {
                // rough assumption
                pathArray = Snap.parsePathString(pathArray);
            }
            if (!pathArray || !pathArray.length) {
                return [["M", 0, 0]];
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0,
                pa0;
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                pa0 = pa[0];
                if (pa0 != pa0.toUpperCase()) {
                    r[0] = pa0.toUpperCase();
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +pa[6] + x;
                            r[7] = +pa[7] + y;
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "R":
                            var dots = [x, y].concat(pa.slice(1));
                            for (var j = 2, jj = dots.length; j < jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }
                            res.pop();
                            res = res.concat(catmullRom2bezier(dots, crz));
                            break;
                        case "O":
                            res.pop();
                            dots = ellipsePath(x, y, pa[1], pa[2]);
                            dots.push(dots[0]);
                            res = res.concat(dots);
                            break;
                        case "U":
                            res.pop();
                            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                            r = ["U"].concat(res[res.length - 1].slice(-2));
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +pa[j] + (j % 2 ? x : y);
                            }
                    }
                } else if (pa0 == "R") {
                    dots = [x, y].concat(pa.slice(1));
                    res.pop();
                    res = res.concat(catmullRom2bezier(dots, crz));
                    r = ["R"].concat(pa.slice(-2));
                } else if (pa0 == "O") {
                    res.pop();
                    dots = ellipsePath(x, y, pa[1], pa[2]);
                    dots.push(dots[0]);
                    res = res.concat(dots);
                } else if (pa0 == "U") {
                    res.pop();
                    res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                    r = ["U"].concat(res[res.length - 1].slice(-2));
                } else {
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        r[k] = pa[k];
                    }
                }
                pa0 = pa0.toUpperCase();
                if (pa0 != "O") {
                    switch (r[0]) {
                        case "Z":
                            x = +mx;
                            y = +my;
                            break;
                        case "H":
                            x = r[1];
                            break;
                        case "V":
                            y = r[1];
                            break;
                        case "M":
                            mx = r[r.length - 2];
                            my = r[r.length - 1];
                        default:
                            x = r[r.length - 2];
                            y = r[r.length - 1];
                    }
                }
            }
            res.toString = toString;
            pth.abs = pathClone(res);
            return res;
        }
        function l2c(x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        }
        function q2c(x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;
            return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
        }
        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = Snap._.cacher(function (x, y, rad) {
                var X = x * math.cos(rad) - y * math.sin(rad),
                    Y = x * math.sin(rad) + y * math.cos(rad);
                return { x: X, y: Y };
            });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = math.cos(PI / 180 * angle),
                    sin = math.sin(PI / 180 * angle),
                    x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;
                var h = x * x / (rx * rx) + y * y / (ry * ry);
                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4].concat(res);
            } else {
                res = [m2, m3, m4].concat(res).join().split(",");
                var newres = [];
                for (var i = 0, ii = res.length; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        }
        function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        }

        // Returns bounding box of cubic bezier curve.
        // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
        // Original version: NISHIO Hirokazu
        // Modifications: https://github.com/timo22345
        function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
            var tvalues = [],
                bounds = [[], []],
                a,
                b,
                c,
                t,
                t1,
                t2,
                b2ac,
                sqrtb2ac;
            for (var i = 0; i < 2; ++i) {
                if (i == 0) {
                    b = 6 * x0 - 12 * x1 + 6 * x2;
                    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                    c = 3 * x1 - 3 * x0;
                } else {
                    b = 6 * y0 - 12 * y1 + 6 * y2;
                    a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                    c = 3 * y1 - 3 * y0;
                }
                if (abs(a) < 1e-12) {
                    if (abs(b) < 1e-12) {
                        continue;
                    }
                    t = -c / b;
                    if (0 < t && t < 1) {
                        tvalues.push(t);
                    }
                    continue;
                }
                b2ac = b * b - 4 * c * a;
                sqrtb2ac = math.sqrt(b2ac);
                if (b2ac < 0) {
                    continue;
                }
                t1 = (-b + sqrtb2ac) / (2 * a);
                if (0 < t1 && t1 < 1) {
                    tvalues.push(t1);
                }
                t2 = (-b - sqrtb2ac) / (2 * a);
                if (0 < t2 && t2 < 1) {
                    tvalues.push(t2);
                }
            }

            var x,
                y,
                j = tvalues.length,
                jlen = j,
                mt;
            while (j--) {
                t = tvalues[j];
                mt = 1 - t;
                bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
                bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
            }

            bounds[0][jlen] = x0;
            bounds[1][jlen] = y0;
            bounds[0][jlen + 1] = x3;
            bounds[1][jlen + 1] = y3;
            bounds[0].length = bounds[1].length = jlen + 2;

            return {
                min: { x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1]) },
                max: { x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1]) }
            };
        }

        function path2curve(path, path2) {
            var pth = !path2 && paths(path);
            if (!path2 && pth.curve) {
                return pathClone(pth.curve);
            }
            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
                attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
                processPath = function (path, d, pcom) {
                var nx, ny;
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                        break;
                    case "S":
                        if (pcom == "C" || pcom == "S") {
                            // In "S" case we have to take into account, if the previous command is C/S.
                            nx = d.x * 2 - d.bx; // And reflect the previous
                            ny = d.y * 2 - d.by; // command's control point relative to the current point.
                        } else {
                            // or some else or nothing
                            nx = d.x;
                            ny = d.y;
                        }
                        path = ["C", nx, ny].concat(path.slice(1));
                        break;
                    case "T":
                        if (pcom == "Q" || pcom == "T") {
                            // In "T" case we have to take into account, if the previous command is Q/T.
                            d.qx = d.x * 2 - d.qx; // And make a reflection similar
                            d.qy = d.y * 2 - d.qy; // to case "S".
                        } else {
                            // or something else or nothing
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
                fixArc = function (pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
                        p2 && (pcoms2[i] = "A"); // the same as above
                        pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
                fixM = function (path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
                pcoms1 = [],
                // path commands of original path p
            pcoms2 = [],
                // path commands of original path p2
            pfirst = "",
                // temporary holder for original path command
            pcom = ""; // holder for previous path command of original path
            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                p[i] && (pfirst = p[i][0]); // save current path command

                if (pfirst != "C") // C is not saved yet, because it may be result of conversion
                    {
                        pcoms1[i] = pfirst; // Save current path command
                        i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
                    }
                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

                if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
                // which may produce multiple C:s
                // so we have to make sure that C is also C in original path

                fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

                if (p2) {
                    // the same procedures is done to p2
                    p2[i] && (pfirst = p2[i][0]);
                    if (pfirst != "C") {
                        pcoms2[i] = pfirst;
                        i && (pcom = pcoms2[i - 1]);
                    }
                    p2[i] = processPath(p2[i], attrs2, pcom);

                    if (pcoms2[i] != "A" && pfirst == "C") {
                        pcoms2[i] = "C";
                    }

                    fixArc(p2, i);
                }
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg.length,
                    seg2len = p2 && seg2.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            if (!p2) {
                pth.curve = pathClone(p);
            }
            return p2 ? [p, p2] : p;
        }
        function mapPath(path, matrix) {
            if (!matrix) {
                return path;
            }
            var x, y, i, j, ii, jj, pathi;
            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        }

        // http://schepers.cc/getting-to-the-point
        function catmullRom2bezier(crp, z) {
            var d = [];
            for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
                var p = [{ x: +crp[i - 2], y: +crp[i - 1] }, { x: +crp[i], y: +crp[i + 1] }, { x: +crp[i + 2], y: +crp[i + 3] }, { x: +crp[i + 4], y: +crp[i + 5] }];
                if (z) {
                    if (!i) {
                        p[0] = { x: +crp[iLen - 2], y: +crp[iLen - 1] };
                    } else if (iLen - 4 == i) {
                        p[3] = { x: +crp[0], y: +crp[1] };
                    } else if (iLen - 2 == i) {
                        p[2] = { x: +crp[0], y: +crp[1] };
                        p[3] = { x: +crp[2], y: +crp[3] };
                    }
                } else {
                    if (iLen - 4 == i) {
                        p[3] = p[2];
                    } else if (!i) {
                        p[0] = { x: +crp[i], y: +crp[i + 1] };
                    }
                }
                d.push(["C", (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
            }

            return d;
        }

        // export
        Snap.path = paths;

        /*\
         * Snap.path.getTotalLength
         [ method ]
         **
         * Returns the length of the given path in pixels
         **
         - path (string) SVG path string
         **
         = (number) length
        \*/
        Snap.path.getTotalLength = getTotalLength;
        /*\
         * Snap.path.getPointAtLength
         [ method ]
         **
         * Returns the coordinates of the point located at the given length along the given path
         **
         - path (string) SVG path string
         - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
         **
         = (object) representation of the point:
         o {
         o     x: (number) x coordinate,
         o     y: (number) y coordinate,
         o     alpha: (number) angle of derivative
         o }
        \*/
        Snap.path.getPointAtLength = getPointAtLength;
        /*\
         * Snap.path.getSubpath
         [ method ]
         **
         * Returns the subpath of a given path between given start and end lengths
         **
         - path (string) SVG path string
         - from (number) length, in pixels, from the start of the path to the start of the segment
         - to (number) length, in pixels, from the start of the path to the end of the segment
         **
         = (string) path string definition for the segment
        \*/
        Snap.path.getSubpath = function (path, from, to) {
            if (this.getTotalLength(path) - to < 1e-6) {
                return getSubpathsAtLength(path, from).end;
            }
            var a = getSubpathsAtLength(path, to, 1);
            return from ? getSubpathsAtLength(a, from).end : a;
        };
        /*\
         * Element.getTotalLength
         [ method ]
         **
         * Returns the length of the path in pixels (only works for `path` elements)
         = (number) length
        \*/
        elproto.getTotalLength = function () {
            if (this.node.getTotalLength) {
                return this.node.getTotalLength();
            }
        };
        // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
        /*\
         * Element.getPointAtLength
         [ method ]
         **
         * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
         **
         - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
         **
         = (object) representation of the point:
         o {
         o     x: (number) x coordinate,
         o     y: (number) y coordinate,
         o     alpha: (number) angle of derivative
         o }
        \*/
        elproto.getPointAtLength = function (length) {
            return getPointAtLength(this.attr("d"), length);
        };
        // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
        /*\
         * Element.getSubpath
         [ method ]
         **
         * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
         **
         - from (number) length, in pixels, from the start of the path to the start of the segment
         - to (number) length, in pixels, from the start of the path to the end of the segment
         **
         = (string) path string definition for the segment
        \*/
        elproto.getSubpath = function (from, to) {
            return Snap.path.getSubpath(this.attr("d"), from, to);
        };
        Snap._.box = box;
        /*\
         * Snap.path.findDotsAtSegment
         [ method ]
         **
         * Utility method
         **
         * Finds dot coordinates on the given cubic bezir curve at the given t
         - p1x (number) x of the first point of the curve
         - p1y (number) y of the first point of the curve
         - c1x (number) x of the first anchor of the curve
         - c1y (number) y of the first anchor of the curve
         - c2x (number) x of the second anchor of the curve
         - c2y (number) y of the second anchor of the curve
         - p2x (number) x of the second point of the curve
         - p2y (number) y of the second point of the curve
         - t (number) position on the curve (0..1)
         = (object) point information in format:
         o {
         o     x: (number) x coordinate of the point,
         o     y: (number) y coordinate of the point,
         o     m: {
         o         x: (number) x coordinate of the left anchor,
         o         y: (number) y coordinate of the left anchor
         o     },
         o     n: {
         o         x: (number) x coordinate of the right anchor,
         o         y: (number) y coordinate of the right anchor
         o     },
         o     start: {
         o         x: (number) x coordinate of the start of the curve,
         o         y: (number) y coordinate of the start of the curve
         o     },
         o     end: {
         o         x: (number) x coordinate of the end of the curve,
         o         y: (number) y coordinate of the end of the curve
         o     },
         o     alpha: (number) angle of the curve derivative at the point
         o }
        \*/
        Snap.path.findDotsAtSegment = findDotsAtSegment;
        /*\
         * Snap.path.bezierBBox
         [ method ]
         **
         * Utility method
         **
         * Returns the bounding box of a given cubic bezir curve
         - p1x (number) x of the first point of the curve
         - p1y (number) y of the first point of the curve
         - c1x (number) x of the first anchor of the curve
         - c1y (number) y of the first anchor of the curve
         - c2x (number) x of the second anchor of the curve
         - c2y (number) y of the second anchor of the curve
         - p2x (number) x of the second point of the curve
         - p2y (number) y of the second point of the curve
         * or
         - bez (array) array of six points for bezir curve
         = (object) bounding box
         o {
         o     x: (number) x coordinate of the left top point of the box,
         o     y: (number) y coordinate of the left top point of the box,
         o     x2: (number) x coordinate of the right bottom point of the box,
         o     y2: (number) y coordinate of the right bottom point of the box,
         o     width: (number) width of the box,
         o     height: (number) height of the box
         o }
        \*/
        Snap.path.bezierBBox = bezierBBox;
        /*\
         * Snap.path.isPointInsideBBox
         [ method ]
         **
         * Utility method
         **
         * Returns `true` if given point is inside bounding box
         - bbox (string) bounding box
         - x (string) x coordinate of the point
         - y (string) y coordinate of the point
         = (boolean) `true` if point is inside
        \*/
        Snap.path.isPointInsideBBox = isPointInsideBBox;
        Snap.closest = function (x, y, X, Y) {
            var r = 100,
                b = box(x - r / 2, y - r / 2, r, r),
                inside = [],
                getter = X[0].hasOwnProperty("x") ? function (i) {
                return {
                    x: X[i].x,
                    y: X[i].y
                };
            } : function (i) {
                return {
                    x: X[i],
                    y: Y[i]
                };
            },
                found = 0;
            while (r <= 1e6 && !found) {
                for (var i = 0, ii = X.length; i < ii; i++) {
                    var xy = getter(i);
                    if (isPointInsideBBox(b, xy.x, xy.y)) {
                        found++;
                        inside.push(xy);
                        break;
                    }
                }
                if (!found) {
                    r *= 2;
                    b = box(x - r / 2, y - r / 2, r, r);
                }
            }
            if (r == 1e6) {
                return;
            }
            var len = Infinity,
                res;
            for (i = 0, ii = inside.length; i < ii; i++) {
                var l = Snap.len(x, y, inside[i].x, inside[i].y);
                if (len > l) {
                    len = l;
                    inside[i].len = l;
                    res = inside[i];
                }
            }
            return res;
        };
        /*\
         * Snap.path.isBBoxIntersect
         [ method ]
         **
         * Utility method
         **
         * Returns `true` if two bounding boxes intersect
         - bbox1 (string) first bounding box
         - bbox2 (string) second bounding box
         = (boolean) `true` if bounding boxes intersect
        \*/
        Snap.path.isBBoxIntersect = isBBoxIntersect;
        /*\
         * Snap.path.intersection
         [ method ]
         **
         * Utility method
         **
         * Finds intersections of two paths
         - path1 (string) path string
         - path2 (string) path string
         = (array) dots of intersection
         o [
         o     {
         o         x: (number) x coordinate of the point,
         o         y: (number) y coordinate of the point,
         o         t1: (number) t value for segment of path1,
         o         t2: (number) t value for segment of path2,
         o         segment1: (number) order number for segment of path1,
         o         segment2: (number) order number for segment of path2,
         o         bez1: (array) eight coordinates representing bezir curve for the segment of path1,
         o         bez2: (array) eight coordinates representing bezir curve for the segment of path2
         o     }
         o ]
        \*/
        Snap.path.intersection = pathIntersection;
        Snap.path.intersectionNumber = pathIntersectionNumber;
        /*\
         * Snap.path.isPointInside
         [ method ]
         **
         * Utility method
         **
         * Returns `true` if given point is inside a given closed path.
         *
         * Note: fill mode doesnt affect the result of this method.
         - path (string) path string
         - x (number) x of the point
         - y (number) y of the point
         = (boolean) `true` if point is inside the path
        \*/
        Snap.path.isPointInside = isPointInsidePath;
        /*\
         * Snap.path.getBBox
         [ method ]
         **
         * Utility method
         **
         * Returns the bounding box of a given path
         - path (string) path string
         = (object) bounding box
         o {
         o     x: (number) x coordinate of the left top point of the box,
         o     y: (number) y coordinate of the left top point of the box,
         o     x2: (number) x coordinate of the right bottom point of the box,
         o     y2: (number) y coordinate of the right bottom point of the box,
         o     width: (number) width of the box,
         o     height: (number) height of the box
         o }
        \*/
        Snap.path.getBBox = pathBBox;
        Snap.path.get = getPath;
        /*\
         * Snap.path.toRelative
         [ method ]
         **
         * Utility method
         **
         * Converts path coordinates into relative values
         - path (string) path string
         = (array) path string
        \*/
        Snap.path.toRelative = pathToRelative;
        /*\
         * Snap.path.toAbsolute
         [ method ]
         **
         * Utility method
         **
         * Converts path coordinates into absolute values
         - path (string) path string
         = (array) path string
        \*/
        Snap.path.toAbsolute = pathToAbsolute;
        /*\
         * Snap.path.toCubic
         [ method ]
         **
         * Utility method
         **
         * Converts path to a new path where all segments are cubic bezir curves
         - pathString (string|array) path string or array of segments
         = (array) array of segments
        \*/
        Snap.path.toCubic = path2curve;
        /*\
         * Snap.path.map
         [ method ]
         **
         * Transform the path string with the given matrix
         - path (string) path string
         - matrix (object) see @Matrix
         = (string) transformed path string
        \*/
        Snap.path.map = mapPath;
        Snap.path.toString = toString;
        Snap.path.clone = pathClone;
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob) {
        var mmax = Math.max,
            mmin = Math.min;

        // Set
        var Set = function (items) {
            this.items = [];
            this.bindings = {};
            this.length = 0;
            this.type = "set";
            if (items) {
                for (var i = 0, ii = items.length; i < ii; i++) {
                    if (items[i]) {
                        this[this.items.length] = this.items[this.items.length] = items[i];
                        this.length++;
                    }
                }
            }
        },
            setproto = Set.prototype;
        /*\
         * Set.push
         [ method ]
         **
         * Adds each argument to the current set
         = (object) original element
        \*/
        setproto.push = function () {
            var item, len;
            for (var i = 0, ii = arguments.length; i < ii; i++) {
                item = arguments[i];
                if (item) {
                    len = this.items.length;
                    this[len] = this.items[len] = item;
                    this.length++;
                }
            }
            return this;
        };
        /*\
         * Set.pop
         [ method ]
         **
         * Removes last element and returns it
         = (object) element
        \*/
        setproto.pop = function () {
            this.length && delete this[this.length--];
            return this.items.pop();
        };
        /*\
         * Set.forEach
         [ method ]
         **
         * Executes given function for each element in the set
         *
         * If the function returns `false`, the loop stops running.
         **
         - callback (function) function to run
         - thisArg (object) context object for the callback
         = (object) Set object
        \*/
        setproto.forEach = function (callback, thisArg) {
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                if (callback.call(thisArg, this.items[i], i) === false) {
                    return this;
                }
            }
            return this;
        };
        /*\
         * Set.animate
         [ method ]
         **
         * Animates each element in set in sync.
         *
         **
         - attrs (object) key-value pairs of destination attributes
         - duration (number) duration of the animation in milliseconds
         - easing (function) #optional easing function from @mina or custom
         - callback (function) #optional callback function that executes when the animation ends
         * or
         - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`
         > Usage
         | // animate all elements in set to radius 10
         | set.animate({r: 10}, 500, mina.easein);
         | // or
         | // animate first element to radius 10, but second to radius 20 and in different time
         | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);
         = (Element) the current element
        \*/
        setproto.animate = function (attrs, ms, easing, callback) {
            if (typeof easing == "function" && !easing.length) {
                callback = easing;
                easing = mina.linear;
            }
            if (attrs instanceof Snap._.Animation) {
                callback = attrs.callback;
                easing = attrs.easing;
                ms = easing.dur;
                attrs = attrs.attr;
            }
            var args = arguments;
            if (Snap.is(attrs, "array") && Snap.is(args[args.length - 1], "array")) {
                var each = true;
            }
            var begin,
                handler = function () {
                if (begin) {
                    this.b = begin;
                } else {
                    begin = this.b;
                }
            },
                cb = 0,
                set = this,
                callbacker = callback && function () {
                if (++cb == set.length) {
                    callback.call(this);
                }
            };
            return this.forEach(function (el, i) {
                eve.once("snap.animcreated." + el.id, handler);
                if (each) {
                    args[i] && el.animate.apply(el, args[i]);
                } else {
                    el.animate(attrs, ms, easing, callbacker);
                }
            });
        };
        setproto.remove = function () {
            while (this.length) {
                this.pop().remove();
            }
            return this;
        };
        /*\
         * Set.bind
         [ method ]
         **
         * Specifies how to handle a specific attribute when applied
         * to a set.
         *
         **
         - attr (string) attribute name
         - callback (function) function to run
         * or
         - attr (string) attribute name
         - element (Element) specific element in the set to apply the attribute to
         * or
         - attr (string) attribute name
         - element (Element) specific element in the set to apply the attribute to
         - eattr (string) attribute on the element to bind the attribute to
         = (object) Set object
        \*/
        setproto.bind = function (attr, a, b) {
            var data = {};
            if (typeof a == "function") {
                this.bindings[attr] = a;
            } else {
                var aname = b || attr;
                this.bindings[attr] = function (v) {
                    data[aname] = v;
                    a.attr(data);
                };
            }
            return this;
        };
        setproto.attr = function (value) {
            var unbound = {};
            for (var k in value) {
                if (this.bindings[k]) {
                    this.bindings[k](value[k]);
                } else {
                    unbound[k] = value[k];
                }
            }
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                this.items[i].attr(unbound);
            }
            return this;
        };
        /*\
         * Set.clear
         [ method ]
         **
         * Removes all elements from the set
        \*/
        setproto.clear = function () {
            while (this.length) {
                this.pop();
            }
        };
        /*\
         * Set.splice
         [ method ]
         **
         * Removes range of elements from the set
         **
         - index (number) position of the deletion
         - count (number) number of element to remove
         - insertion (object) #optional elements to insert
         = (object) set elements that were deleted
        \*/
        setproto.splice = function (index, count, insertion) {
            index = index < 0 ? mmax(this.length + index, 0) : index;
            count = mmax(0, mmin(this.length - index, count));
            var tail = [],
                todel = [],
                args = [],
                i;
            for (i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            for (i = 0; i < count; i++) {
                todel.push(this[index + i]);
            }
            for (; i < this.length - index; i++) {
                tail.push(this[index + i]);
            }
            var arglen = args.length;
            for (i = 0; i < arglen + tail.length; i++) {
                this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
            }
            i = this.items.length = this.length -= count - arglen;
            while (this[i]) {
                delete this[i++];
            }
            return new Set(todel);
        };
        /*\
         * Set.exclude
         [ method ]
         **
         * Removes given element from the set
         **
         - element (object) element to remove
         = (boolean) `true` if object was found and removed from the set
        \*/
        setproto.exclude = function (el) {
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (this[i] == el) {
                    this.splice(i, 1);
                    return true;
                }
            }return false;
        };
        setproto.insertAfter = function (el) {
            var i = this.items.length;
            while (i--) {
                this.items[i].insertAfter(el);
            }
            return this;
        };
        setproto.getBBox = function () {
            var x = [],
                y = [],
                x2 = [],
                y2 = [];
            for (var i = this.items.length; i--;) {
                if (!this.items[i].removed) {
                    var box = this.items[i].getBBox();
                    x.push(box.x);
                    y.push(box.y);
                    x2.push(box.x + box.width);
                    y2.push(box.y + box.height);
                }
            }x = mmin.apply(0, x);
            y = mmin.apply(0, y);
            x2 = mmax.apply(0, x2);
            y2 = mmax.apply(0, y2);
            return {
                x: x,
                y: y,
                x2: x2,
                y2: y2,
                width: x2 - x,
                height: y2 - y,
                cx: x + (x2 - x) / 2,
                cy: y + (y2 - y) / 2
            };
        };
        setproto.clone = function (s) {
            s = new Set();
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                s.push(this.items[i].clone());
            }
            return s;
        };
        setproto.toString = function () {
            return "Snap\u2018s set";
        };
        setproto.type = "set";
        // export
        Snap.Set = Set;
        Snap.set = function () {
            var set = new Set();
            if (arguments.length) {
                set.push.apply(set, Array.prototype.slice.call(arguments, 0));
            }
            return set;
        };
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob) {
        var names = {},
            reUnit = /[a-z]+$/i,
            Str = String;
        names.stroke = names.fill = "colour";
        function getEmpty(item) {
            var l = item[0];
            switch (l.toLowerCase()) {
                case "t":
                    return [l, 0, 0];
                case "m":
                    return [l, 1, 0, 0, 1, 0, 0];
                case "r":
                    if (item.length == 4) {
                        return [l, 0, item[2], item[3]];
                    } else {
                        return [l, 0];
                    }
                case "s":
                    if (item.length == 5) {
                        return [l, 1, 1, item[3], item[4]];
                    } else if (item.length == 3) {
                        return [l, 1, 1];
                    } else {
                        return [l, 1];
                    }
            }
        }
        function equaliseTransform(t1, t2, getBBox) {
            t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
            t1 = Snap.parseTransformString(t1) || [];
            t2 = Snap.parseTransformString(t2) || [];
            var maxlength = Math.max(t1.length, t2.length),
                from = [],
                to = [],
                i = 0,
                j,
                jj,
                tt1,
                tt2;
            for (; i < maxlength; i++) {
                tt1 = t1[i] || getEmpty(t2[i]);
                tt2 = t2[i] || getEmpty(tt1);
                if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) {
                    t1 = Snap._.transform2matrix(t1, getBBox());
                    t2 = Snap._.transform2matrix(t2, getBBox());
                    from = [["m", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];
                    to = [["m", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];
                    break;
                }
                from[i] = [];
                to[i] = [];
                for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {
                    j in tt1 && (from[i][j] = tt1[j]);
                    j in tt2 && (to[i][j] = tt2[j]);
                }
            }
            return {
                from: path2array(from),
                to: path2array(to),
                f: getPath(from)
            };
        }
        function getNumber(val) {
            return val;
        }
        function getUnit(unit) {
            return function (val) {
                return +val.toFixed(3) + unit;
            };
        }
        function getViewBox(val) {
            return val.join(" ");
        }
        function getColour(clr) {
            return Snap.rgb(clr[0], clr[1], clr[2]);
        }
        function getPath(path) {
            var k = 0,
                i,
                ii,
                j,
                jj,
                out,
                a,
                b = [];
            for (i = 0, ii = path.length; i < ii; i++) {
                out = "[";
                a = ['"' + path[i][0] + '"'];
                for (j = 1, jj = path[i].length; j < jj; j++) {
                    a[j] = "val[" + k++ + "]";
                }
                out += a + "]";
                b[i] = out;
            }
            return Function("val", "return Snap.path.toString.call([" + b + "])");
        }
        function path2array(path) {
            var out = [];
            for (var i = 0, ii = path.length; i < ii; i++) {
                for (var j = 1, jj = path[i].length; j < jj; j++) {
                    out.push(path[i][j]);
                }
            }
            return out;
        }
        function isNumeric(obj) {
            return isFinite(parseFloat(obj));
        }
        function arrayEqual(arr1, arr2) {
            if (!Snap.is(arr1, "array") || !Snap.is(arr2, "array")) {
                return false;
            }
            return arr1.toString() == arr2.toString();
        }
        Element.prototype.equal = function (name, b) {
            return eve("snap.util.equal", this, name, b).firstDefined();
        };
        eve.on("snap.util.equal", function (name, b) {
            var A,
                B,
                a = Str(this.attr(name) || ""),
                el = this;
            if (isNumeric(a) && isNumeric(b)) {
                return {
                    from: parseFloat(a),
                    to: parseFloat(b),
                    f: getNumber
                };
            }
            if (names[name] == "colour") {
                A = Snap.color(a);
                B = Snap.color(b);
                return {
                    from: [A.r, A.g, A.b, A.opacity],
                    to: [B.r, B.g, B.b, B.opacity],
                    f: getColour
                };
            }
            if (name == "viewBox") {
                A = this.attr(name).vb.split(" ").map(Number);
                B = b.split(" ").map(Number);
                return {
                    from: A,
                    to: B,
                    f: getViewBox
                };
            }
            if (name == "transform" || name == "gradientTransform" || name == "patternTransform") {
                if (b instanceof Snap.Matrix) {
                    b = b.toTransformString();
                }
                if (!Snap._.rgTransform.test(b)) {
                    b = Snap._.svgTransform2string(b);
                }
                return equaliseTransform(a, b, function () {
                    return el.getBBox(1);
                });
            }
            if (name == "d" || name == "path") {
                A = Snap.path.toCubic(a, b);
                return {
                    from: path2array(A[0]),
                    to: path2array(A[1]),
                    f: getPath(A[0])
                };
            }
            if (name == "points") {
                A = Str(a).split(Snap._.separator);
                B = Str(b).split(Snap._.separator);
                return {
                    from: A,
                    to: B,
                    f: function (val) {
                        return val;
                    }
                };
            }
            var aUnit = a.match(reUnit),
                bUnit = Str(b).match(reUnit);
            if (aUnit && arrayEqual(aUnit, bUnit)) {
                return {
                    from: parseFloat(a),
                    to: parseFloat(b),
                    f: getUnit(aUnit)
                };
            } else {
                return {
                    from: this.asPX(name),
                    to: this.asPX(name, b),
                    f: getNumber
                };
            }
        });
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob) {
        var elproto = Element.prototype,
            has = "hasOwnProperty",
            supportsTouch = "createTouch" in glob.doc,
            events = ["click", "dblclick", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "touchstart", "touchmove", "touchend", "touchcancel"],
            touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
            getScroll = function (xy, el) {
            var name = xy == "y" ? "scrollTop" : "scrollLeft",
                doc = el && el.node ? el.node.ownerDocument : glob.doc;
            return doc[name in doc.documentElement ? "documentElement" : "body"][name];
        },
            preventDefault = function () {
            this.returnValue = false;
        },
            preventTouch = function () {
            return this.originalEvent.preventDefault();
        },
            stopPropagation = function () {
            this.cancelBubble = true;
        },
            stopTouch = function () {
            return this.originalEvent.stopPropagation();
        },
            addEvent = function (obj, type, fn, element) {
            var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
                f = function (e) {
                var scrollY = getScroll("y", element),
                    scrollX = getScroll("x", element);
                if (supportsTouch && touchMap[has](type)) {
                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
                            var olde = e;
                            e = e.targetTouches[i];
                            e.originalEvent = olde;
                            e.preventDefault = preventTouch;
                            e.stopPropagation = stopTouch;
                            break;
                        }
                    }
                }
                var x = e.clientX + scrollX,
                    y = e.clientY + scrollY;
                return fn.call(element, e, x, y);
            };

            if (type !== realName) {
                obj.addEventListener(type, f, false);
            }

            obj.addEventListener(realName, f, false);

            return function () {
                if (type !== realName) {
                    obj.removeEventListener(type, f, false);
                }

                obj.removeEventListener(realName, f, false);
                return true;
            };
        },
            drag = [],
            dragMove = function (e) {
            var x = e.clientX,
                y = e.clientY,
                scrollY = getScroll("y"),
                scrollX = getScroll("x"),
                dragi,
                j = drag.length;
            while (j--) {
                dragi = drag[j];
                if (supportsTouch) {
                    var i = e.touches && e.touches.length,
                        touch;
                    while (i--) {
                        touch = e.touches[i];
                        if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
                            x = touch.clientX;
                            y = touch.clientY;
                            (e.originalEvent ? e.originalEvent : e).preventDefault();
                            break;
                        }
                    }
                } else {
                    e.preventDefault();
                }
                var node = dragi.el.node,
                    o,
                    next = node.nextSibling,
                    parent = node.parentNode,
                    display = node.style.display;
                // glob.win.opera && parent.removeChild(node);
                // node.style.display = "none";
                // o = dragi.el.paper.getElementByPoint(x, y);
                // node.style.display = display;
                // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
                x += scrollX;
                y += scrollY;
                eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
            }
        },
            dragUp = function (e) {
            Snap.unmousemove(dragMove).unmouseup(dragUp);
            var i = drag.length,
                dragi;
            while (i--) {
                dragi = drag[i];
                dragi.el._drag = {};
                eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
                eve.off("snap.drag.*." + dragi.el.id);
            }
            drag = [];
        };
        /*\
         * Element.click
         [ method ]
         **
         * Adds a click event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unclick
         [ method ]
         **
         * Removes a click event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.dblclick
         [ method ]
         **
         * Adds a double click event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.undblclick
         [ method ]
         **
         * Removes a double click event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.mousedown
         [ method ]
         **
         * Adds a mousedown event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unmousedown
         [ method ]
         **
         * Removes a mousedown event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.mousemove
         [ method ]
         **
         * Adds a mousemove event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unmousemove
         [ method ]
         **
         * Removes a mousemove event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.mouseout
         [ method ]
         **
         * Adds a mouseout event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unmouseout
         [ method ]
         **
         * Removes a mouseout event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.mouseover
         [ method ]
         **
         * Adds a mouseover event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unmouseover
         [ method ]
         **
         * Removes a mouseover event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.mouseup
         [ method ]
         **
         * Adds a mouseup event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.unmouseup
         [ method ]
         **
         * Removes a mouseup event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.touchstart
         [ method ]
         **
         * Adds a touchstart event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.untouchstart
         [ method ]
         **
         * Removes a touchstart event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.touchmove
         [ method ]
         **
         * Adds a touchmove event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.untouchmove
         [ method ]
         **
         * Removes a touchmove event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.touchend
         [ method ]
         **
         * Adds a touchend event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.untouchend
         [ method ]
         **
         * Removes a touchend event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/

        /*\
         * Element.touchcancel
         [ method ]
         **
         * Adds a touchcancel event handler to the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        /*\
         * Element.untouchcancel
         [ method ]
         **
         * Removes a touchcancel event handler from the element
         - handler (function) handler for the event
         = (object) @Element
        \*/
        for (var i = events.length; i--;) {
            (function (eventName) {
                Snap[eventName] = elproto[eventName] = function (fn, scope) {
                    if (Snap.is(fn, "function")) {
                        this.events = this.events || [];
                        this.events.push({
                            name: eventName,
                            f: fn,
                            unbind: addEvent(this.node || document, eventName, fn, scope || this)
                        });
                    } else {
                        for (var i = 0, ii = this.events.length; i < ii; i++) {
                            if (this.events[i].name == eventName) {
                                try {
                                    this.events[i].f.call(this);
                                } catch (e) {}
                            }
                        }
                    }
                    return this;
                };
                Snap["un" + eventName] = elproto["un" + eventName] = function (fn) {
                    var events = this.events || [],
                        l = events.length;
                    while (l--) {
                        if (events[l].name == eventName && (events[l].f == fn || !fn)) {
                            events[l].unbind();
                            events.splice(l, 1);
                            !events.length && delete this.events;
                            return this;
                        }
                    }return this;
                };
            })(events[i]);
        }
        /*\
         * Element.hover
         [ method ]
         **
         * Adds hover event handlers to the element
         - f_in (function) handler for hover in
         - f_out (function) handler for hover out
         - icontext (object) #optional context for hover in handler
         - ocontext (object) #optional context for hover out handler
         = (object) @Element
        \*/
        elproto.hover = function (f_in, f_out, scope_in, scope_out) {
            return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
        };
        /*\
         * Element.unhover
         [ method ]
         **
         * Removes hover event handlers from the element
         - f_in (function) handler for hover in
         - f_out (function) handler for hover out
         = (object) @Element
        \*/
        elproto.unhover = function (f_in, f_out) {
            return this.unmouseover(f_in).unmouseout(f_out);
        };
        var draggable = [];
        // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
        // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
        // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
        // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
        /*\
         * Element.drag
         [ method ]
         **
         * Adds event handlers for an element's drag gesture
         **
         - onmove (function) handler for moving
         - onstart (function) handler for drag start
         - onend (function) handler for drag end
         - mcontext (object) #optional context for moving handler
         - scontext (object) #optional context for drag start handler
         - econtext (object) #optional context for drag end handler
         * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, 
         * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element 
         * `drag.over.<id>` fires as well.
         *
         * Start event and start handler are called in specified context or in context of the element with following parameters:
         o x (number) x position of the mouse
         o y (number) y position of the mouse
         o event (object) DOM event object
         * Move event and move handler are called in specified context or in context of the element with following parameters:
         o dx (number) shift by x from the start point
         o dy (number) shift by y from the start point
         o x (number) x position of the mouse
         o y (number) y position of the mouse
         o event (object) DOM event object
         * End event and end handler are called in specified context or in context of the element with following parameters:
         o event (object) DOM event object
         = (object) @Element
        \*/
        elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
            var el = this;
            if (!arguments.length) {
                var origTransform;
                return el.drag(function (dx, dy) {
                    this.attr({
                        transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
                    });
                }, function () {
                    origTransform = this.transform().local;
                });
            }
            function start(e, x, y) {
                (e.originalEvent || e).preventDefault();
                el._drag.x = x;
                el._drag.y = y;
                el._drag.id = e.identifier;
                !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
                drag.push({ el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope });
                onstart && eve.on("snap.drag.start." + el.id, onstart);
                onmove && eve.on("snap.drag.move." + el.id, onmove);
                onend && eve.on("snap.drag.end." + el.id, onend);
                eve("snap.drag.start." + el.id, start_scope || move_scope || el, x, y, e);
            }
            function init(e, x, y) {
                eve("snap.draginit." + el.id, el, e, x, y);
            }
            eve.on("snap.draginit." + el.id, start);
            el._drag = {};
            draggable.push({ el: el, start: start, init: init });
            el.mousedown(init);
            return el;
        };
        /*
         * Element.onDragOver
         [ method ]
         **
         * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
         - f (function) handler for event, first argument would be the element you are dragging over
        \*/
        // elproto.onDragOver = function (f) {
        //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
        // };
        /*\
         * Element.undrag
         [ method ]
         **
         * Removes all drag event handlers from the given element
        \*/
        elproto.undrag = function () {
            var i = draggable.length;
            while (i--) {
                if (draggable[i].el == this) {
                    this.unmousedown(draggable[i].init);
                    draggable.splice(i, 1);
                    eve.unbind("snap.drag.*." + this.id);
                    eve.unbind("snap.draginit." + this.id);
                }
            }!draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
            return this;
        };
    });

    // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
    // 
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    // 
    // http://www.apache.org/licenses/LICENSE-2.0
    // 
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob) {
        var elproto = Element.prototype,
            pproto = Paper.prototype,
            rgurl = /^\s*url\((.+)\)/,
            Str = String,
            $ = Snap._.$;
        Snap.filter = {};
        /*\
         * Paper.filter
         [ method ]
         **
         * Creates a `<filter>` element
         **
         - filstr (string) SVG fragment of filter provided as a string
         = (object) @Element
         * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
         > Usage
         | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
         |     c = paper.circle(10, 10, 10).attr({
         |         filter: f
         |     });
        \*/
        pproto.filter = function (filstr) {
            var paper = this;
            if (paper.type != "svg") {
                paper = paper.paper;
            }
            var f = Snap.parse(Str(filstr)),
                id = Snap._.id(),
                width = paper.node.offsetWidth,
                height = paper.node.offsetHeight,
                filter = $("filter");
            $(filter, {
                id: id,
                filterUnits: "userSpaceOnUse"
            });
            filter.appendChild(f.node);
            paper.defs.appendChild(filter);
            return new Element(filter);
        };

        eve.on("snap.util.getattr.filter", function () {
            eve.stop();
            var p = $(this.node, "filter");
            if (p) {
                var match = Str(p).match(rgurl);
                return match && Snap.select(match[1]);
            }
        });
        eve.on("snap.util.attr.filter", function (value) {
            if (value instanceof Element && value.type == "filter") {
                eve.stop();
                var id = value.node.id;
                if (!id) {
                    $(value.node, { id: value.id });
                    id = value.id;
                }
                $(this.node, {
                    filter: Snap.url(id)
                });
            }
            if (!value || value == "none") {
                eve.stop();
                this.node.removeAttribute("filter");
            }
        });
        /*\
         * Snap.filter.blur
         [ method ]
         **
         * Returns an SVG markup string for the blur filter
         **
         - x (number) amount of horizontal blur, in pixels
         - y (number) #optional amount of vertical blur, in pixels
         = (string) filter representation
         > Usage
         | var f = paper.filter(Snap.filter.blur(5, 10)),
         |     c = paper.circle(10, 10, 10).attr({
         |         filter: f
         |     });
        \*/
        Snap.filter.blur = function (x, y) {
            if (x == null) {
                x = 2;
            }
            var def = y == null ? x : [x, y];
            return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
                def: def
            });
        };
        Snap.filter.blur.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.shadow
         [ method ]
         **
         * Returns an SVG markup string for the shadow filter
         **
         - dx (number) #optional horizontal shift of the shadow, in pixels
         - dy (number) #optional vertical shift of the shadow, in pixels
         - blur (number) #optional amount of blur
         - color (string) #optional color of the shadow
         - opacity (number) #optional `0..1` opacity of the shadow
         * or
         - dx (number) #optional horizontal shift of the shadow, in pixels
         - dy (number) #optional vertical shift of the shadow, in pixels
         - color (string) #optional color of the shadow
         - opacity (number) #optional `0..1` opacity of the shadow
         * which makes blur default to `4`. Or
         - dx (number) #optional horizontal shift of the shadow, in pixels
         - dy (number) #optional vertical shift of the shadow, in pixels
         - opacity (number) #optional `0..1` opacity of the shadow
         = (string) filter representation
         > Usage
         | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),
         |     c = paper.circle(10, 10, 10).attr({
         |         filter: f
         |     });
        \*/
        Snap.filter.shadow = function (dx, dy, blur, color, opacity) {
            if (typeof blur == "string") {
                color = blur;
                opacity = color;
                blur = 4;
            }
            if (typeof color != "string") {
                opacity = color;
                color = "#000";
            }
            color = color || "#000";
            if (blur == null) {
                blur = 4;
            }
            if (opacity == null) {
                opacity = 1;
            }
            if (dx == null) {
                dx = 0;
                dy = 2;
            }
            if (dy == null) {
                dy = dx;
            }
            color = Snap.color(color);
            return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
                color: color,
                dx: dx,
                dy: dy,
                blur: blur,
                opacity: opacity
            });
        };
        Snap.filter.shadow.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.grayscale
         [ method ]
         **
         * Returns an SVG markup string for the grayscale filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.grayscale = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
                a: 0.2126 + 0.7874 * (1 - amount),
                b: 0.7152 - 0.7152 * (1 - amount),
                c: 0.0722 - 0.0722 * (1 - amount),
                d: 0.2126 - 0.2126 * (1 - amount),
                e: 0.7152 + 0.2848 * (1 - amount),
                f: 0.0722 - 0.0722 * (1 - amount),
                g: 0.2126 - 0.2126 * (1 - amount),
                h: 0.0722 + 0.9278 * (1 - amount)
            });
        };
        Snap.filter.grayscale.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.sepia
         [ method ]
         **
         * Returns an SVG markup string for the sepia filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.sepia = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
                a: 0.393 + 0.607 * (1 - amount),
                b: 0.769 - 0.769 * (1 - amount),
                c: 0.189 - 0.189 * (1 - amount),
                d: 0.349 - 0.349 * (1 - amount),
                e: 0.686 + 0.314 * (1 - amount),
                f: 0.168 - 0.168 * (1 - amount),
                g: 0.272 - 0.272 * (1 - amount),
                h: 0.534 - 0.534 * (1 - amount),
                i: 0.131 + 0.869 * (1 - amount)
            });
        };
        Snap.filter.sepia.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.saturate
         [ method ]
         **
         * Returns an SVG markup string for the saturate filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.saturate = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
                amount: 1 - amount
            });
        };
        Snap.filter.saturate.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.hueRotate
         [ method ]
         **
         * Returns an SVG markup string for the hue-rotate filter
         **
         - angle (number) angle of rotation
         = (string) filter representation
        \*/
        Snap.filter.hueRotate = function (angle) {
            angle = angle || 0;
            return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
                angle: angle
            });
        };
        Snap.filter.hueRotate.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.invert
         [ method ]
         **
         * Returns an SVG markup string for the invert filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.invert = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            //        <feColorMatrix type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0" color-interpolation-filters="sRGB"/>
            return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
                amount: amount,
                amount2: 1 - amount
            });
        };
        Snap.filter.invert.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.brightness
         [ method ]
         **
         * Returns an SVG markup string for the brightness filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.brightness = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
                amount: amount
            });
        };
        Snap.filter.brightness.toString = function () {
            return this();
        };
        /*\
         * Snap.filter.contrast
         [ method ]
         **
         * Returns an SVG markup string for the contrast filter
         **
         - amount (number) amount of filter (`0..1`)
         = (string) filter representation
        \*/
        Snap.filter.contrast = function (amount) {
            if (amount == null) {
                amount = 1;
            }
            return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
                amount: amount,
                amount2: .5 - amount / 2
            });
        };
        Snap.filter.contrast.toString = function () {
            return this();
        };
    });

    // Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    // http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
        var box = Snap._.box,
            is = Snap.is,
            firstLetter = /^[^a-z]*([tbmlrc])/i,
            toString = function () {
            return "T" + this.dx + "," + this.dy;
        };
        /*\
         * Element.getAlign
         [ method ]
         **
         * Returns shift needed to align the element relatively to given element.
         * If no elements specified, parent `<svg>` container will be used.
         - el (object) @optional alignment element
         - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
         = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string
         > Usage
         | el.transform(el.getAlign(el2, "top"));
         * or
         | var dy = el.getAlign(el2, "top").dy;
        \*/
        Element.prototype.getAlign = function (el, way) {
            if (way == null && is(el, "string")) {
                way = el;
                el = null;
            }
            el = el || this.paper;
            var bx = el.getBBox ? el.getBBox() : box(el),
                bb = this.getBBox(),
                out = {};
            way = way && way.match(firstLetter);
            way = way ? way[1].toLowerCase() : "c";
            switch (way) {
                case "t":
                    out.dx = 0;
                    out.dy = bx.y - bb.y;
                    break;
                case "b":
                    out.dx = 0;
                    out.dy = bx.y2 - bb.y2;
                    break;
                case "m":
                    out.dx = 0;
                    out.dy = bx.cy - bb.cy;
                    break;
                case "l":
                    out.dx = bx.x - bb.x;
                    out.dy = 0;
                    break;
                case "r":
                    out.dx = bx.x2 - bb.x2;
                    out.dy = 0;
                    break;
                default:
                    out.dx = bx.cx - bb.cx;
                    out.dy = 0;
                    break;
            }
            out.toString = toString;
            return out;
        };
        /*\
         * Element.align
         [ method ]
         **
         * Aligns the element relatively to given one via transformation.
         * If no elements specified, parent `<svg>` container will be used.
         - el (object) @optional alignment element
         - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
         = (object) this element
         > Usage
         | el.align(el2, "top");
         * or
         | el.align("middle");
        \*/
        Element.prototype.align = function (el, way) {
            return this.transform("..." + this.getAlign(el, way));
        };
    });

    return Snap;
});
;'use strict';

/////    /////    /////    /////
/////    /////    /////    /////
/////    /////    /////    /////
/////    /////    /////    /////
/////             /////    /////
/////             /////    /////
/////    /////    /////    /////
/////    /////    /////    /////
/////    /////
/////    /////
/////    /////    /////    /////
/////    /////    /////    /////
/////    /////    /////    /////
/////    /////    /////    /////

/**
 * ScrollReveal
 * ------------
 * Version : 3.3.1
 * Website : scrollrevealjs.org
 * Repo    : github.com/jlmakes/scrollreveal.js
 * Author  : Julian Lloyd (@jlmakes)
 */

;(function () {
  'use strict';

  var sr;
  var _requestAnimationFrame;

  function ScrollReveal(config) {
    // Support instantiation without the `new` keyword.
    if (typeof this === 'undefined' || Object.getPrototypeOf(this) !== ScrollReveal.prototype) {
      return new ScrollReveal(config);
    }

    sr = this; // Save reference to instance.
    sr.version = '3.3.1';
    sr.tools = new Tools(); // *required utilities

    if (sr.isSupported()) {
      sr.tools.extend(sr.defaults, config || {});

      _resolveContainer(sr.defaults);

      sr.store = {
        elements: {},
        containers: []
      };

      sr.sequences = {};
      sr.history = [];
      sr.uid = 0;
      sr.initialized = false;
    } else if (typeof console !== 'undefined' && console !== null) {
      // Note: IE9 only supports console if devtools are open.
      console.log('ScrollReveal is not supported in this browser.');
    }

    return sr;
  }

  /**
   * Configuration
   * -------------
   * This object signature can be passed directly to the ScrollReveal constructor,
   * or as the second argument of the `reveal()` method.
   */

  ScrollReveal.prototype.defaults = {
    // 'bottom', 'left', 'top', 'right'
    origin: 'bottom',

    // Can be any valid CSS distance, e.g. '5rem', '10%', '20vw', etc.
    distance: '20px',

    // Time in milliseconds.
    duration: 500,
    delay: 0,

    // Starting angles in degrees, will transition from these values to 0 in all axes.
    rotate: { x: 0, y: 0, z: 0 },

    // Starting opacity value, before transitioning to the computed opacity.
    opacity: 0,

    // Starting scale value, will transition from this value to 1
    scale: 0.9,

    // Accepts any valid CSS easing, e.g. 'ease', 'ease-in-out', 'linear', etc.
    easing: 'cubic-bezier(0.6, 0.2, 0.1, 1)',

    // `<html>` is the default reveal container. You can pass either:
    // DOM Node, e.g. document.querySelector('.fooContainer')
    // Selector, e.g. '.fooContainer'
    container: window.document.documentElement,

    // true/false to control reveal animations on mobile.
    mobile: true,

    // true:  reveals occur every time elements become visible
    // false: reveals occur once as elements become visible
    reset: false,

    // 'always'  delay for all reveal animations
    // 'once'    delay only the first time reveals occur
    // 'onload' - delay only for animations triggered by first load
    useDelay: 'always',

    // Change when an element is considered in the viewport. The default value
    // of 0.20 means 20% of an element must be visible for its reveal to occur.
    viewFactor: 0.2,

    // Pixel values that alter the container boundaries.
    // e.g. Set `{ top: 48 }`, if you have a 48px tall fixed toolbar.
    // --
    // Visual Aid: https://scrollrevealjs.org/assets/viewoffset.png
    viewOffset: { top: 0, right: 0, bottom: 0, left: 0 },

    // Callbacks that fire for each completed element reveal, and if
    // `config.reset = true`, for each completed element reset. When creating your
    // callbacks, remember they are passed the elements DOM node that triggered
    // it as the first argument.
    beforeReveal: function (domEl) {},
    afterReveal: function (domEl) {},
    beforeReset: function (domEl) {},
    afterReset: function (domEl) {}
  };

  /**
   * Check if client supports CSS Transform and CSS Transition.
   * @return {boolean}
   */
  ScrollReveal.prototype.isSupported = function () {
    var style = document.documentElement.style;
    return 'WebkitTransition' in style && 'WebkitTransform' in style || 'transition' in style && 'transform' in style;
  };

  /**
   * Creates a reveal set, a group of elements that will animate when they
   * become visible. If [interval] is provided, a new sequence is created
   * that will ensure elements reveal in the order they appear in the DOM.
   *
   * @param {Node|NodeList|string} [target]   The node, node list or selector to use for animation.
   * @param {Object}               [config]   Override the defaults for this reveal set.
   * @param {number}               [interval] Time between sequenced element animations (milliseconds).
   * @param {boolean}              [sync]     Used internally when updating reveals for async content.
   *
   * @return {Object} The current ScrollReveal instance.
   */
  ScrollReveal.prototype.reveal = function (target, config, interval, sync) {
    var container;
    var elements;
    var elem;
    var elemId;
    var sequence;
    var sequenceId;

    // No custom configuration was passed, but a sequence interval instead.
    // lets shuffle things around to make sure everything works.
    if (config !== undefined && typeof config === 'number') {
      interval = config;
      config = {};
    } else if (config === undefined || config === null) {
      config = {};
    }

    container = _resolveContainer(config);
    elements = _getRevealElements(target, container);

    if (!elements.length) {
      console.log('ScrollReveal: reveal on "' + target + '" failed, no elements found.');
      return sr;
    }

    // Prepare a new sequence if an interval is passed.
    if (interval && typeof interval === 'number') {
      sequenceId = _nextUid();

      sequence = sr.sequences[sequenceId] = {
        id: sequenceId,
        interval: interval,
        elemIds: [],
        active: false
      };
    }

    // Begin main loop to configure ScrollReveal elements.
    for (var i = 0; i < elements.length; i++) {
      // Check if the element has already been configured and grab it from the store.
      elemId = elements[i].getAttribute('data-sr-id');
      if (elemId) {
        elem = sr.store.elements[elemId];
      } else {
        // Otherwise, lets do some basic setup.
        elem = {
          id: _nextUid(),
          domEl: elements[i],
          seen: false,
          revealing: false
        };
        elem.domEl.setAttribute('data-sr-id', elem.id);
      }

      // Sequence only setup
      if (sequence) {
        elem.sequence = {
          id: sequence.id,
          index: sequence.elemIds.length
        };

        sequence.elemIds.push(elem.id);
      }

      // New or existing element, its time to update its configuration, styles,
      // and send the updates to our store.
      _configure(elem, config, container);
      _style(elem);
      _updateStore(elem);

      // We need to make sure elements are set to visibility: visible, even when
      // on mobile and `config.mobile === false`, or if unsupported.
      if (sr.tools.isMobile() && !elem.config.mobile || !sr.isSupported()) {
        elem.domEl.setAttribute('style', elem.styles.inline);
        elem.disabled = true;
      } else if (!elem.revealing) {
        // Otherwise, proceed normally.
        elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.initial);
      }
    }

    // Each `reveal()` is recorded so that when calling `sync()` while working
    // with asynchronously loaded content, it can re-trace your steps but with
    // all your new elements now in the DOM.

    // Since `reveal()` is called internally by `sync()`, we dont want to
    // record or intiialize each reveal during syncing.
    if (!sync && sr.isSupported()) {
      _record(target, config, interval);

      // We push initialization to the event queue using setTimeout, so that we can
      // give ScrollReveal room to process all reveal calls before putting things into motion.
      // --
      // Philip Roberts - What the heck is the event loop anyway? (JSConf EU 2014)
      // https://www.youtube.com/watch?v=8aGhZQkoFbQ
      if (sr.initTimeout) {
        window.clearTimeout(sr.initTimeout);
      }
      sr.initTimeout = window.setTimeout(_init, 0);
    }

    return sr;
  };

  /**
   * Re-runs `reveal()` for each record stored in history, effectively capturing
   * any content loaded asynchronously that matches existing reveal set targets.
   * @return {Object} The current ScrollReveal instance.
   */
  ScrollReveal.prototype.sync = function () {
    if (sr.history.length && sr.isSupported()) {
      for (var i = 0; i < sr.history.length; i++) {
        var record = sr.history[i];
        sr.reveal(record.target, record.config, record.interval, true);
      }
      _init();
    } else {
      console.log('ScrollReveal: sync failed, no reveals found.');
    }
    return sr;
  };

  /**
   * Private Methods
   * ---------------
   */

  function _resolveContainer(config) {
    if (config && config.container) {
      if (typeof config.container === 'string') {
        return window.document.documentElement.querySelector(config.container);
      } else if (sr.tools.isNode(config.container)) {
        return config.container;
      } else {
        console.log('ScrollReveal: invalid container "' + config.container + '" provided.');
        console.log('ScrollReveal: falling back to default container.');
      }
    }
    return sr.defaults.container;
  }

  /**
   * check to see if a node or node list was passed in as the target,
   * otherwise query the container using target as a selector.
   *
   * @param {Node|NodeList|string} [target]    client input for reveal target.
   * @param {Node}                 [container] parent element for selector queries.
   *
   * @return {array} elements to be revealed.
   */
  function _getRevealElements(target, container) {
    if (typeof target === 'string') {
      return Array.prototype.slice.call(container.querySelectorAll(target));
    } else if (sr.tools.isNode(target)) {
      return [target];
    } else if (sr.tools.isNodeList(target)) {
      return Array.prototype.slice.call(target);
    }
    return [];
  }

  /**
   * A consistent way of creating unique IDs.
   * @returns {number}
   */
  function _nextUid() {
    return ++sr.uid;
  }

  function _configure(elem, config, container) {
    // If a container was passed as a part of the config object,
    // lets overwrite it with the resolved container passed in.
    if (config.container) config.container = container;
    // If the element hasnt already been configured, lets use a clone of the
    // defaults extended by the configuration passed as the second argument.
    if (!elem.config) {
      elem.config = sr.tools.extendClone(sr.defaults, config);
    } else {
      // Otherwise, lets use a clone of the existing element configuration extended
      // by the configuration passed as the second argument.
      elem.config = sr.tools.extendClone(elem.config, config);
    }

    // Infer CSS Transform axis from origin string.
    if (elem.config.origin === 'top' || elem.config.origin === 'bottom') {
      elem.config.axis = 'Y';
    } else {
      elem.config.axis = 'X';
    }
  }

  function _style(elem) {
    var computed = window.getComputedStyle(elem.domEl);

    if (!elem.styles) {
      elem.styles = {
        transition: {},
        transform: {},
        computed: {}
      };

      // Capture any existing inline styles, and add our visibility override.
      // --
      // See section 4.2. in the Documentation:
      // https://github.com/jlmakes/scrollreveal.js#42-improve-user-experience
      elem.styles.inline = elem.domEl.getAttribute('style') || '';
      elem.styles.inline += '; visibility: visible; ';

      // grab the elements existing opacity.
      elem.styles.computed.opacity = computed.opacity;

      // grab the elements existing transitions.
      if (!computed.transition || computed.transition === 'all 0s ease 0s') {
        elem.styles.computed.transition = '';
      } else {
        elem.styles.computed.transition = computed.transition + ', ';
      }
    }

    // Create transition styles
    elem.styles.transition.instant = _generateTransition(elem, 0);
    elem.styles.transition.delayed = _generateTransition(elem, elem.config.delay);

    // Generate transform styles, first with the webkit prefix.
    elem.styles.transform.initial = ' -webkit-transform:';
    elem.styles.transform.target = ' -webkit-transform:';
    _generateTransform(elem);

    // And again without any prefix.
    elem.styles.transform.initial += 'transform:';
    elem.styles.transform.target += 'transform:';
    _generateTransform(elem);
  }

  function _generateTransition(elem, delay) {
    var config = elem.config;

    return '-webkit-transition: ' + elem.styles.computed.transition + '-webkit-transform ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's, opacity ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's; ' + 'transition: ' + elem.styles.computed.transition + 'transform ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's, opacity ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's; ';
  }

  function _generateTransform(elem) {
    var config = elem.config;
    var cssDistance;
    var transform = elem.styles.transform;

    // Lets make sure our our pixel distances are negative for top and left.
    // e.g. origin = 'top' and distance = '25px' starts at `top: -25px` in CSS.
    if (config.origin === 'top' || config.origin === 'left') {
      cssDistance = /^-/.test(config.distance) ? config.distance.substr(1) : '-' + config.distance;
    } else {
      cssDistance = config.distance;
    }

    if (parseInt(config.distance)) {
      transform.initial += ' translate' + config.axis + '(' + cssDistance + ')';
      transform.target += ' translate' + config.axis + '(0)';
    }
    if (config.scale) {
      transform.initial += ' scale(' + config.scale + ')';
      transform.target += ' scale(1)';
    }
    if (config.rotate.x) {
      transform.initial += ' rotateX(' + config.rotate.x + 'deg)';
      transform.target += ' rotateX(0)';
    }
    if (config.rotate.y) {
      transform.initial += ' rotateY(' + config.rotate.y + 'deg)';
      transform.target += ' rotateY(0)';
    }
    if (config.rotate.z) {
      transform.initial += ' rotateZ(' + config.rotate.z + 'deg)';
      transform.target += ' rotateZ(0)';
    }
    transform.initial += '; opacity: ' + config.opacity + ';';
    transform.target += '; opacity: ' + elem.styles.computed.opacity + ';';
  }

  function _updateStore(elem) {
    var container = elem.config.container;

    // If this elements container isnt already in the store, lets add it.
    if (container && sr.store.containers.indexOf(container) === -1) {
      sr.store.containers.push(elem.config.container);
    }

    // Update the element stored with our new element.
    sr.store.elements[elem.id] = elem;
  }

  function _record(target, config, interval) {
    // Save the `reveal()` arguments that triggered this `_record()` call, so we
    // can re-trace our steps when calling the `sync()` method.
    var record = {
      target: target,
      config: config,
      interval: interval
    };
    sr.history.push(record);
  }

  function _init() {
    if (sr.isSupported()) {
      // Initial animate call triggers valid reveal animations on first load.
      // Subsequent animate calls are made inside the event handler.
      _animate();

      // Then we loop through all container nodes in the store and bind event
      // listeners to each.
      for (var i = 0; i < sr.store.containers.length; i++) {
        sr.store.containers[i].addEventListener('scroll', _handler);
        sr.store.containers[i].addEventListener('resize', _handler);
      }

      // Lets also do a one-time binding of window event listeners.
      if (!sr.initialized) {
        window.addEventListener('scroll', _handler);
        window.addEventListener('resize', _handler);
        sr.initialized = true;
      }
    }
    return sr;
  }

  function _handler() {
    _requestAnimationFrame(_animate);
  }

  function _setActiveSequences() {
    var active;
    var elem;
    var elemId;
    var sequence;

    // Loop through all sequences
    sr.tools.forOwn(sr.sequences, function (sequenceId) {
      sequence = sr.sequences[sequenceId];
      active = false;

      // For each sequenced elemenet, lets check visibility and if
      // any are visible, set its sequence to active.
      for (var i = 0; i < sequence.elemIds.length; i++) {
        elemId = sequence.elemIds[i];
        elem = sr.store.elements[elemId];
        if (_isElemVisible(elem) && !active) {
          active = true;
        }
      }

      sequence.active = active;
    });
  }

  function _animate() {
    var delayed;
    var elem;

    _setActiveSequences();

    // Loop through all elements in the store
    sr.tools.forOwn(sr.store.elements, function (elemId) {
      elem = sr.store.elements[elemId];
      delayed = _shouldUseDelay(elem);

      // Lets see if we should revealand if so,
      // trigger the `beforeReveal` callback and
      // determine whether or not to use delay.
      if (_shouldReveal(elem)) {
        elem.config.beforeReveal(elem.domEl);
        if (delayed) {
          elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.target + elem.styles.transition.delayed);
        } else {
          elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.target + elem.styles.transition.instant);
        }

        // Lets queue the `afterReveal` callback
        // and mark the element as seen and revealing.
        _queueCallback('reveal', elem, delayed);
        elem.revealing = true;
        elem.seen = true;

        if (elem.sequence) {
          _queueNextInSequence(elem, delayed);
        }
      } else if (_shouldReset(elem)) {
        //Otherwise reset our element and
        // trigger the `beforeReset` callback.
        elem.config.beforeReset(elem.domEl);
        elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.initial + elem.styles.transition.instant);
        // And queue the `afterReset` callback.
        _queueCallback('reset', elem);
        elem.revealing = false;
      }
    });
  }

  function _queueNextInSequence(elem, delayed) {
    var elapsed = 0;
    var delay = 0;
    var sequence = sr.sequences[elem.sequence.id];

    // Were processing a sequenced element, so let's block other elements in this sequence.
    sequence.blocked = true;

    // Since were triggering animations a part of a sequence after animations on first load,
    // we need to check for that condition and explicitly add the delay to our timer.
    if (delayed && elem.config.useDelay === 'onload') {
      delay = elem.config.delay;
    }

    // If a sequence timer is already running, capture the elapsed time and clear it.
    if (elem.sequence.timer) {
      elapsed = Math.abs(elem.sequence.timer.started - new Date());
      window.clearTimeout(elem.sequence.timer);
    }

    // Start a new timer.
    elem.sequence.timer = { started: new Date() };
    elem.sequence.timer.clock = window.setTimeout(function () {
      // Sequence interval has passed, so unblock the sequence and re-run the handler.
      sequence.blocked = false;
      elem.sequence.timer = null;
      _handler();
    }, Math.abs(sequence.interval) + delay - elapsed);
  }

  function _queueCallback(type, elem, delayed) {
    var elapsed = 0;
    var duration = 0;
    var callback = 'after';

    // Check which callback were working with.
    switch (type) {
      case 'reveal':
        duration = elem.config.duration;
        if (delayed) {
          duration += elem.config.delay;
        }
        callback += 'Reveal';
        break;

      case 'reset':
        duration = elem.config.duration;
        callback += 'Reset';
        break;
    }

    // If a timer is already running, capture the elapsed time and clear it.
    if (elem.timer) {
      elapsed = Math.abs(elem.timer.started - new Date());
      window.clearTimeout(elem.timer.clock);
    }

    // Start a new timer.
    elem.timer = { started: new Date() };
    elem.timer.clock = window.setTimeout(function () {
      // The timer completed, so lets fire the callback and null the timer.
      elem.config[callback](elem.domEl);
      elem.timer = null;
    }, duration - elapsed);
  }

  function _shouldReveal(elem) {
    if (elem.sequence) {
      var sequence = sr.sequences[elem.sequence.id];
      return sequence.active && !sequence.blocked && !elem.revealing && !elem.disabled;
    }
    return _isElemVisible(elem) && !elem.revealing && !elem.disabled;
  }

  function _shouldUseDelay(elem) {
    var config = elem.config.useDelay;
    return config === 'always' || config === 'onload' && !sr.initialized || config === 'once' && !elem.seen;
  }

  function _shouldReset(elem) {
    if (elem.sequence) {
      var sequence = sr.sequences[elem.sequence.id];
      return !sequence.active && elem.config.reset && elem.revealing && !elem.disabled;
    }
    return !_isElemVisible(elem) && elem.config.reset && elem.revealing && !elem.disabled;
  }

  function _getContainer(container) {
    return {
      width: container.clientWidth,
      height: container.clientHeight
    };
  }

  function _getScrolled(container) {
    // Return the container scroll values, plus the its offset.
    if (container && container !== window.document.documentElement) {
      var offset = _getOffset(container);
      return {
        x: container.scrollLeft + offset.left,
        y: container.scrollTop + offset.top
      };
    } else {
      // Otherwise, default to the window objects scroll values.
      return {
        x: window.pageXOffset,
        y: window.pageYOffset
      };
    }
  }

  function _getOffset(domEl) {
    var offsetTop = 0;
    var offsetLeft = 0;

    // Grab the elements dimensions.
    var offsetHeight = domEl.offsetHeight;
    var offsetWidth = domEl.offsetWidth;

    // Now calculate the distance between the element and its parent, then
    // again for the parent to its parent, and again etc... until we have the
    // total distance of the element to the documents top and left origin.
    do {
      if (!isNaN(domEl.offsetTop)) {
        offsetTop += domEl.offsetTop;
      }
      if (!isNaN(domEl.offsetLeft)) {
        offsetLeft += domEl.offsetLeft;
      }
      domEl = domEl.offsetParent;
    } while (domEl);

    return {
      top: offsetTop,
      left: offsetLeft,
      height: offsetHeight,
      width: offsetWidth
    };
  }

  function _isElemVisible(elem) {
    var offset = _getOffset(elem.domEl);
    var container = _getContainer(elem.config.container);
    var scrolled = _getScrolled(elem.config.container);
    var vF = elem.config.viewFactor;

    // Define the element geometry.
    var elemHeight = offset.height;
    var elemWidth = offset.width;
    var elemTop = offset.top;
    var elemLeft = offset.left;
    var elemBottom = elemTop + elemHeight;
    var elemRight = elemLeft + elemWidth;

    return confirmBounds() || isPositionFixed();

    function confirmBounds() {
      // Define the elements functional boundaries using its view factor.
      var top = elemTop + elemHeight * vF;
      var left = elemLeft + elemWidth * vF;
      var bottom = elemBottom - elemHeight * vF;
      var right = elemRight - elemWidth * vF;

      // Define the container functional boundaries using its view offset.
      var viewTop = scrolled.y + elem.config.viewOffset.top;
      var viewLeft = scrolled.x + elem.config.viewOffset.left;
      var viewBottom = scrolled.y - elem.config.viewOffset.bottom + container.height;
      var viewRight = scrolled.x - elem.config.viewOffset.right + container.width;

      return top < viewBottom && bottom > viewTop && left > viewLeft && right < viewRight;
    }

    function isPositionFixed() {
      return window.getComputedStyle(elem.domEl).position === 'fixed';
    }
  }

  /**
   * Utilities
   * ---------
   */

  function Tools() {}

  Tools.prototype.isObject = function (object) {
    return object !== null && typeof object === 'object' && object.constructor === Object;
  };

  Tools.prototype.isNode = function (object) {
    return typeof window.Node === 'object' ? object instanceof window.Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
  };

  Tools.prototype.isNodeList = function (object) {
    var prototypeToString = Object.prototype.toString.call(object);
    var regex = /^\[object (HTMLCollection|NodeList|Object)\]$/;

    return typeof window.NodeList === 'object' ? object instanceof window.NodeList : object && typeof object === 'object' && regex.test(prototypeToString) && typeof object.length === 'number' && (object.length === 0 || this.isNode(object[0]));
  };

  Tools.prototype.forOwn = function (object, callback) {
    if (!this.isObject(object)) {
      throw new TypeError('Expected "object", but received "' + typeof object + '".');
    } else {
      for (var property in object) {
        if (object.hasOwnProperty(property)) {
          callback(property);
        }
      }
    }
  };

  Tools.prototype.extend = function (target, source) {
    this.forOwn(source, function (property) {
      if (this.isObject(source[property])) {
        if (!target[property] || !this.isObject(target[property])) {
          target[property] = {};
        }
        this.extend(target[property], source[property]);
      } else {
        target[property] = source[property];
      }
    }.bind(this));
    return target;
  };

  Tools.prototype.extendClone = function (target, source) {
    return this.extend(this.extend({}, target), source);
  };

  Tools.prototype.isMobile = function () {
    return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    );
  };

  /**
   * Polyfills
   * --------
   */

  _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };

  /**
   * Module Wrapper
   * --------------
   */
  if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
    define(function () {
      return ScrollReveal;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = ScrollReveal;
  } else {
    window.ScrollReveal = ScrollReveal;
  }
})();
;'use strict';

var BR = {
	addListeners: function () {
		// $('a.link').hover( 
		// 	function(){
		// 		var redHover = $(this).find('span');
		// 		$(redHover).animate({"marginBottom":"10px"}, 300);
		// 		$(redHover).animate({"opacity":"1"}, 300);

		// 	},
		// 	function(){
		// 		var redHover = $(this).find('span');
		// 		$(redHover).animate({"marginBottom":"0"}, 300);
		// 		$(redHover).animate({"opacity":"0"}, 300);
		// 	}
		// )
		$('.close__modal').click(function (event) {
			$(this).closest('.modal__background').fadeOut('300').addClass('hidden');
		});
		$('.accordion__trigger').click(function (e) {
			var triggerId = $(this).data('trigger-target');
			var accordion = $('#' + triggerId);
			$(accordion).slideToggle(400);
			// $(accordion).slideToggle(300, function(){
			// 	$(this).toggleClass('hidden');
			// })
		});

		$('#diversityModalTrigger').click(function (event) {
			BR_COOKIES.visitDiversity();
			BR_COOKIES.showDiversityModal();
		});
	}
};

$(function () {
	BR.addListeners();
});
;"use strict";

var BR_COOKIES = {
  onLoad: function () {
    console.log("BR Cookie Scripts loaded!");
  },
  createCookie: function (name, value, days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
      var expires = "; expires=" + date.toGMTString();
    } else var expires = "";

    document.cookie = name + "=" + value + expires + "; path=/";
  },
  readCookie: function (name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') {
        c = c.substring(1, c.length);
      }if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },

  eraseCookie: function (name) {
    BR_COOKIES.createCookie(name, "", -1);
  },
  visitDiversity: function () {
    BR_COOKIES.createCookie("visitedDiversity", "true");
    var visitedDiversity = BR_COOKIES.readCookie("visitedDiversity");
    console.log(visitedDiversity);
  },
  showDiversityModal: function () {
    console.log("Showing EOE Modal!");
    var diversityModal = $('.modal__background.diversity');
    diversityModal.removeClass('hidden').fadeIn('slow');
  }
};

$(document).ready(function () {
  BR_COOKIES.onLoad();
});
;'use strict';

var EXPANDER = {
	addListeners: function () {
		$('#showMoreRelatedExperiences, .experience_expander').click(function (event) {
			$(document.body).trigger("sticky_kit:recalc");
			var hiddenExperiences = $('.sidebar__color-block--outer-wrapper.hidden__exp');
			$(hiddenExperiences).toggleClass('hidden');
			var hiddenMenuItems = $('.sidebar-items__wrapper');
			$(hiddenMenuItems).slideToggle('300');
			var expander = $('.experience_expander');
			$(expander).toggleClass('expanded');
			if ($('#showMoreRelatedExperiences').hasClass('more')) {
				$('#showMoreRelatedExperiences').removeClass('more').addClass('less').text("SHOW LESS");
			} else {
				$('#showMoreRelatedExperiences').removeClass('less').addClass('more').text("SHOW MORE");
			}
		});
		$('.job_expander').click(function (event) {
			var expander = $(this);
			var hiddenJobDescripton = $(expander).parent().parent().next('tr').find('td');
			$(hiddenJobDescripton).slideToggle(400);
			$(expander).toggleClass('expanded');
		});
		$('.mobile__sidebar--expander').click(function (event) {
			var expander = $(this);
			var triggerId = $(expander).data('show-target');
			var hiddenMenuItems = $('#' + triggerId);
			$(hiddenMenuItems).slideToggle(400);
			console.log('expanded');
			$(expander).toggleClass('expanded');
		});
	}
};

$(document).ready(function () {
	EXPANDER.addListeners();
});
;'use strict';

jQuery('iframe[src*="youtube.com"]').wrap("<div class='flex-video widescreen'/>");
jQuery('iframe[src*="vimeo.com"]').wrap("<div class='flex-video widescreen vimeo'/>");
;// $(document).ready(function(){
// 	if ( $("body").hasClass("page-template-homepage") ){
// 		// animate grid elements on homepage
// 		window.sr = ScrollReveal({distance:'10%', duration: 900, delay: 1, reset:false, scale:0.99, easing: 'linear'});
// 		sr.reveal('.homepage-grid-element');
// 	}
// });
"use strict";
;"use strict";

jQuery(document).foundation();
;'use strict';

var INSIGHTS = {
	listeners: function () {
		console.log('Insights listeners js loaded');
		$('select.insight').change(function (event) {
			var selects = $('select');
			var queryStringBase = location.origin + location.pathname;
			var queryString = "";
			var filters = [];
			for (var i = selects.length - 1; i >= 0; i--) {
				var select = selects[i];
				if ($(select).val().length > 0 && $(select).val() !== "") {
					filters.push($(select));
				}
			}
			console.log("filters" + filters);
			for (var i = filters.length - 1; i >= 0; i--) {
				var paramName = $(filters[i]).attr('name');
				var paramValue = $(filters[i]).val();
				if (paramValue.length > 0 && i === filters.length - 1) {
					queryString = queryStringBase + "?" + paramName + "=" + paramValue;
					console.log(queryString);
				} else if (paramValue.length > 0) {
					queryString = queryString + "&" + paramName + "=" + paramValue;
					console.log(queryString);
				}
			}
			// set back the url to the base if there are no queries left
			if (queryString.length > 0) {
				window.location.replace(queryString);
			} else {
				window.location.replace(queryStringBase);
			}
		});
	},
	onLoad: function () {
		// Get search param values from url
		var selectedDate = $.url().param('date_query', 'strict') || "";
		var selectedGeography = $.url().param('geography_query', 'strict') || "";
		var selectedIndustry = $.url().param('industry_query', 'strict') || "";
		var selectedPractice = $.url().param('practice_query', 'strict') || "";
		var selectedLanguage = $.url().param('language_query', 'strict') || "";
		var selectedLocations = $.url().param('location_query', 'strict') || "";
		var selectedAdmission = $.url().param('admission_query', 'strict') || "";
		var selectedEducation = $.url().param('education_query', 'strict') || "";
		var selectedKeyword = $.url().param('keyword', 'strict') || "";

		// Set vars for selects for all search params
		var dateSelect = $('select#dateSelect');
		var geographySelect = $('select#geographySelect');
		var industrySelect = $('select#industrySelect');
		var practiceSelect = $('select#practiceSelect');
		var languageSelect = $('select#languageSelect');
		var locationSelect = $('select#locationSelect');
		var admissionSelect = $('select#admissionSelect');
		var educationSelect = $('select#educationSelect');
		var keywordInput = $('input#keywordInput');

		// Change value of selects based on url params
		dateSelect.val(decodeURIComponent(selectedDate));
		geographySelect.val(decodeURIComponent(selectedGeography));
		industrySelect.val(decodeURIComponent(selectedIndustry));
		practiceSelect.val(decodeURIComponent(selectedPractice));
		languageSelect.val(decodeURIComponent(selectedLanguage));
		locationSelect.val(decodeURIComponent(selectedLocations));
		admissionSelect.val(decodeURIComponent(selectedAdmission));
		educationSelect.val(decodeURIComponent(selectedEducation));
		keywordInput.val(decodeURIComponent(selectedKeyword));
	}
};

$(document).ready(function () {
	INSIGHTS.listeners();
	INSIGHTS.onLoad();
});
;'use strict';

// Joyride demo
$('#start-jr').on('click', function () {
  $(document).foundation('joyride', 'start');
});
;'use strict';

var LOCATIONSEARCHER = {
	detectChange: function () {
		// listen for changes in select options element
		$('#locationSelect').change(function (event) {
			// build query string
			var keyword = $('#locationSelect').val() || "";
			var queryStringBase = location.origin + location.pathname;
			var queryString = "" + "?job_location_query=" + keyword;
			// reload the page with the keyword as the url
			window.location.replace(queryString);
		});
	},
	// make select value reflect your most recent search param
	onLoad: function () {
		var jobKeyword = $.url().param('job_location_query', 'strict');
		var locationSelect = $('#locationSelect');
		if (jobKeyword !== undefined) {
			locationSelect.val(decodeURIComponent(jobKeyword));
		}
	}
};

$('document').ready(function () {
	LOCATIONSEARCHER.detectChange();
	LOCATIONSEARCHER.onLoad();
});
;'use strict';

var mobileMenu = {
	openDropdown: function () {
		// enable or disable scroll for mobile dropdown function
		var checkScroll = function () {
			if ($('body').hasClass('no-scroll')) {
				disableScroll.on();
			} else {
				disableScroll.off();
			}
		};

		$('#open-mobile-menu').click(function () {
			$('#menu-mobile-menu').slideToggle();
			$('#search__icon__mobile').slideToggle();
			$('#mobile__logo__container').slideToggle();
			$('#open-mobile-menu').toggleClass('mobile-active');
			$('#open-mobile-menu').toggleClass('close__modal');
			$('#open-mobile-menu').css({ 'top': '5px', 'left': '0' });
			$('.mobile__menu__bottom').toggle();
			$('body').toggleClass('no-scroll');
			$('.human-icon').slideToggle();
			// call check scroll function defined above
			checkScroll();
		});
	}
};

$(document).ready(function () {
	mobileMenu.openDropdown();
});
;'use strict';

// desktop navigation hover interactions

// edited foundation.dropdownMenu.js line 368 to make delay on closing time after mouseout event shorter 
// to restore to default, set this number to '500'

var NAV = {
	// listeners: function(){
	// 		// medium breakpoint hover interaction for navigation
	// 	// if ($(window).innerWidth() > 700 ) {
	// 	// 		$('.menu-item-has-children').on({
	// 	// 			mouseover: function(){					
	// 	// 				$('.subnav__color-block').stop().show(310);
	// 	// 			},
	// 	// 			mouseout: function(){						
	// 	// 				$('.subnav__color-block').stop().hide(310);
	// 	// 			}
	// 	// 		});	
	// 	// 	}

	// 		if ($(window).innerWidth() > 768 ) {
	// 			$('.menu-item-has-children').on({
	// 				mouseover: function(){					
	// 					//$('.subnav__color-block').stop().show(310);
	// 				},
	// 				mouseout: function(){						
	// 					//$('.subnav__color-block').stop().hide(310);
	// 				}
	// 			});	
	// 		}

	// },
	desktopMenu: $('#masthead'),
	// hide or show scroll nav bar
	scrollEvents: function () {
		// differentiate btw mobile and all else
		var desktopCheck = $(window).scrollTop() >= NAV.desktopMenu.height();
		var mobileCheck = $(window).scrollTop() > 250;
		var check;
		if ($(document).width() >= 640) {
			check = desktopCheck;
		} else {
			check = mobileCheck;
		}
		if (check) {
			$(NAV.desktopMenu).css('opacity', '0');
			$('.menu__outer-wrapper--desktop-on-scroll').slideDown('fast');
			$('#menu-nested-pages-1').addClass('scrolled');
		} else {
			$(NAV.desktopMenu).css('opacity', '1');
			$('.menu__outer-wrapper--desktop-on-scroll').slideUp('fast');
			$('#menu-nested-pages-1').removeClass('scrolled');
		}
	},
	// corrects spacing of last and first submenu item
	submenuCorrection: function () {
		// for regular menu
		$('.is-dropdown-submenu:eq(0)').addClass('first-submenu-item');
		$('.is-dropdown-submenu:eq(2)').addClass('before-last-submenu-item');
		$('.is-dropdown-submenu:eq(3)').addClass('last-submenu-item');
		// for scroll menu
		$('.is-dropdown-submenu:eq(4)').addClass('first-submenu-item-scroll');
		$('.is-dropdown-submenu:eq(6)').addClass('before-last-submenu-item-scroll');
		$('.is-dropdown-submenu:eq(7)').addClass('last-submenu-item-scroll');
	}

};

$(document).ready(function () {
	//NAV.listeners();
	NAV.submenuCorrection();
	$(document).scroll(function () {
		NAV.scrollEvents();
	});

	if ($(window).scrollTop() >= NAV.desktopMenu.height() && $(document).width() >= 768) {
		var mouseEvent = function (e) {
			userScroll = true;
		};
		// only hide if user has scrolled


		// differentiate between page load and user scroll
		// otherwise regular menu is always hidden on page load at scroll location :P
		var userScroll = false;
		if (userScroll) {
			$(NAV.desktopMenu).hide();
		}
	}
});

// var navbar = {
// 	onHover: function(){
// 		// medium breakpoint
// 		if ($(window).innerWidth() > 700 ) {
// 				$('.menu-item-has-children').on({
// 					mouseover: function(){
// 						$('.subnav__color-block').stop().show(410);
// 					},
// 					mouseout: function(){
// 						$('.subnav__color-block').stop().hide(410);
// 					}
// 				});	
// 			}
// 		},
// 		desktopMenu: $('#masthead')

// 	}

// $(document).ready(function(){

// 		navbar.onHover();


// 			if ( $(window).scrollTop() >= navbar.desktopMenu.height() ) {
// 				navbar.desktopMenu.hide();
// 				$('.menu__outer-wrapper--desktop-on-scroll').fadeIn();
// 				console.log('nav is hidden')
// 			} else {
// 				navbar.desktopMenu.show();
// 				$('.menu__outer-wrapper--desktop-on-scroll').hide();
// 			}


// 	// if ( $(document).width() > 640) {
// 	// 		$(document).scroll( function(){
// 	// 			navbar.onScroll();
// 	// 		})
// 	// 	}
// 	if ( $(window).scrollTop() >= navbar.desktopMenu.height() && $(document).width() > 640) {
// 		navbar.desktopMenu.hide();
// 	}
// 	// }
// });
;"use strict";
;'use strict';

var PEOPLE = {
	listeners: function () {
		console.log('People js loaded');

		// navigate to letter anchor
		$('.letter__link').click(function (event) {

			var letterlLinkInnerWrappers = $('.letter__link--inner-wrapper');
			var letter = $(this).data('letter');
			var letterAnchor = $("div[data-letter-anchor=" + letter + "]");
			if (letterAnchor.offset() !== undefined) {
				letterlLinkInnerWrappers.removeClass('active');
				var selectedletterlLinkInnerWrapper = $(this).parent();
				selectedletterlLinkInnerWrapper.addClass('active');
				$('html,body').animate({
					scrollTop: letterAnchor.offset().top - 200
				}, 1000);
				console.log("Scrolling to " + letter);
				$('.back__to__top').slideToggle();
				return false;
			} else {
				// handle the case when there is no element with that letter 
				// letter is not clickable
				letterAnchor.click(function (event) {
					event.preventDefault();
				});
			}
		});
		// $(document).resize(function(event) {
		// 	if ( $(document).width() > 640) {
		// 		PEOPLE.scrollEvents();
		// 		$(document).scroll( function(){
		// 			PEOPLE.scrollEvents();
		// 		});
		// 	}
		// });
		$('#advancedPeopleSearch').click(function (event) {
			PEOPLE.revealAdvancedSearch();
		});
		$('#peopleAdvancedSearchButton').click(function (event) {
			event.preventDefault();
			console.log("prevented!");
			var selects = $('select');
			var keyword = $("#keywordInput").val() || "";
			var queryStringBase = location.origin + location.pathname;
			var queryString = "";
			var filters = [];
			// selects values from dropdown options and determines number of filters from these
			for (var i = selects.length - 1; i >= 0; i--) {
				var select = selects[i];
				if ($(select).val().length > 0) {
					filters.push($(select));
				}
			}
			console.log(filters);
			// passes the parameters from each of the selected filters
			for (var i = filters.length - 1; i >= 0; i--) {
				var paramName = $(filters[i]).attr('name');
				var paramValue = $(filters[i]).val();
				if (paramValue.length > 0 && i === filters.length - 1) {
					queryString = queryStringBase + "?" + paramName + "=" + paramValue;
				} else if (paramValue.length > 0) {
					queryString = queryString + "&" + paramName + "=" + paramValue;
				}
			}
			if (queryString.length > 0) {
				if (keyword.length > 0) {
					queryString = queryString + "&keyword=" + keyword;
				}
			} else {
				if (keyword.length > 0) {
					queryString = queryString + "?keyword=" + keyword;
				}
			}
			// debugger;
			window.location.replace(queryString);
		});
	},
	stickySideBar: $('.sidebar__on-scroll--fixed'),
	// scrollEvents: function(){
	// 	var heightAdjustment;
	// 	if ( $('.page-template-people').length > 0 &&  $('.people__details--container').height() > $('.sidebar__on-scroll--fixed').height() ){
	// 		heightAdjustment = 800;
	// 	} else {
	// 		heightAdjustment = 263;
	// 	}
	// 	var scrollStopperOffset = $('#masthead').height() + $('.body__wrapper').height() - heightAdjustment;
	// 	if ( $(window).scrollTop() >= ($('#featuredImage').height()) && $(window).scrollTop() <= scrollStopperOffset ) {
	// 		PEOPLE.stickSideBar('top');
	// 	} else if ( $(window).scrollTop() >= scrollStopperOffset ) {
	// 		PEOPLE.stickSideBar('bottom');
	// 		console.log('bottom sticker');
	// 	} else {
	// 		PEOPLE.unstickSideBar();
	// 	}
	// },
	// stickSideBar: function(location) {
	// 	var sideBarWidth;
	// 	if ( location === 'top' ) {	
	// 		if ( $(window).width() < 1000 ) {
	// 			sideBarWidth = 'calc(75em / 4)';
	// 		} else {
	// 			sideBarWidth = 'calc(75em / 6)';
	// 		}
	// 		PEOPLE.stickySideBar.css({
	// 			position: 'fixed',
	// 			width: sideBarWidth,
	// 			top: '160px'
	// 		});
	// 	} else {
	// 		if ( $(window).width() < 1000 ) {
	// 			sideBarWidth = '25%';
	// 		} else {
	// 			sideBarWidth = '16.66667%';
	// 		}
	// 		PEOPLE.stickySideBar.css({
	// 			position: 'absolute',
	// 			width: sideBarWidth,
	// 			top: 'initial',
	// 			bottom: '60px'
	// 		});
	// 	}	
	// },
	// unstickSideBar: function() {
	// 	var sideBarWidth;
	// 	if ( $(window).width() < 1000 ) {
	// 		sideBarWidth = '25%';
	// 	} else {
	// 		sideBarWidth = '16.66667%';
	// 	}
	// 	PEOPLE.stickySideBar.css({
	// 		position: 'relative',
	// 		width: sideBarWidth,
	// 		top: 'initial'			
	// 	});
	// },
	revealAdvancedSearch: function () {
		$('#advancedSearchModal').removeClass('hidden').fadeIn('slow');
		console.log("advanced search revealed!");
	},
	hideAdvancedSearch: function () {
		$('#advancedSearchModal').addClass('hidden').fadeOut('slow');
		console.log("advanced search hidden!");
	},

	scrollBackToTop: function () {
		$('.back__to__top').click(function (event) {
			$('html,body').animate({
				scrollTop: $('.letter__links_wrapper').offset().top - 200
			}, 1000);
			if ($(this).is(":visible")) {
				$(this).slideToggle();
			}
		});
	}
};

$(window).on('resize', function (event) {
	var headerHeight = $('#mastheadOnScroll').height() + 160;
	var elementToStick = $('.sidebar__on-scroll--fixed');
	if ($('.sidebar__on-scroll--fixed').length > 0 && $(document).width() >= 768) {
		console.log("STICKY");
		elementToStick.css('width', '175px !important');
		elementToStick.stick_in_parent({ offset_top: headerHeight });
	} else {
		elementToStick.trigger("sticky_kit:detach");
	}
});

$(document).ready(function () {
	PEOPLE.listeners();
	PEOPLE.scrollBackToTop();
	// if ( $(document).width() > 640) {
	// 	PEOPLE.scrollEvents();
	// 	$(document).scroll( function(){
	// 		PEOPLE.scrollEvents();
	// 	});
	// }
	var headerHeight = $('#mastheadOnScroll').height() + 160;
	var elementToStick = $('.sidebar__on-scroll--fixed');
	if ($('.sidebar__on-scroll--fixed').length > 0) {
		console.log("STICKY");
		if ($(document).width() >= 768) {
			console.log(headerHeight);
			elementToStick.stick_in_parent({ offset_top: headerHeight });
		}
	}
	$(window).trigger('resize');
});
;'use strict';

var homepage = {
	initializeSlider: function () {

		// create SVG
		var s = Snap("#slider-svg");
		var line = s.paper.line(0, 0, 2500, 0);

		// set SVG attributes
		var animateSvg = function () {
			line.attr({
				stroke: 'transparent',
				fill: 'none',
				strokeWidth: 5,
				"fill-opacity": 0
			});
			// animate SVG line	
			line.animate({ stroke: '#c10819', fill: 'none' }, 3900, mina.linear);
		};
		animateSvg();
		// animate SVG on slide change
		$('.slider-container').on('beforeChange', function (slick, currentSlide, nextSlide) {
			animateSvg();
		});

		if ($("body").hasClass("page-template-homepage")) {
			// start Slick slider
			$('.slider-container').slick({
				slide: '.slide',
				slidesToShow: 1,
				slidesToScroll: 1,
				autoplay: true,
				autoplaySpeed: 4000,
				arrows: true,
				fade: true,
				infinite: true,
				prevArrow: $('.prev-slider-home'),
				nextArrow: $('.next-slider-home')
			});
		}
	}
};

$(document).ready(function () {
	if ($('#slider-svg').length) {
		homepage.initializeSlider();
	}
});
;'use strict';

$(window).bind(' load resize orientationChange ', function () {
  var footer = $("#footer-container");
  var pos = footer.position();
  var height = $(window).height();
  height = height - pos.top;
  height = height - footer.height() - 1;

  function stickyFooter() {
    footer.css({
      'margin-top': height + 'px'
    });
  }
  if (height > 0) {
    stickyFooter();
  }
});
;'use strict';

var SUMMER = {
	expandSchedule: function () {
		$('#recruitingModal').click(function (event) {
			console.log('recruting');
			var summerModal = $('.modal__background.diversity');
			summerModal.removeClass('hidden').fadeIn('slow');
		});
	}
};

$(document).ready(function () {
	SUMMER.expandSchedule();
});
;"use strict";

// Generated by CoffeeScript 1.9.2

/**
@license Sticky-kit v1.1.2 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
 */

(function () {
  var $, win;

  $ = this.jQuery || window.jQuery;

  win = $(window);

  $.fn.stick_in_parent = function (opts) {
    var doc, elm, enable_bottoming, fn, i, inner_scrolling, len, manual_spacer, offset_top, parent_selector, recalc_every, sticky_class;
    if (opts == null) {
      opts = {};
    }
    sticky_class = opts.sticky_class, inner_scrolling = opts.inner_scrolling, recalc_every = opts.recalc_every, parent_selector = opts.parent, offset_top = opts.offset_top, manual_spacer = opts.spacer, enable_bottoming = opts.bottoming;
    if (offset_top == null) {
      offset_top = 0;
    }
    if (parent_selector == null) {
      parent_selector = void 0;
    }
    if (inner_scrolling == null) {
      inner_scrolling = true;
    }
    if (sticky_class == null) {
      sticky_class = "is_stuck";
    }
    doc = $(document);
    if (enable_bottoming == null) {
      enable_bottoming = true;
    }
    fn = function (elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
      var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
      if (elm.data("sticky_kit")) {
        return;
      }
      elm.data("sticky_kit", true);
      last_scroll_height = doc.height();
      parent = elm.parent();
      if (parent_selector != null) {
        parent = parent.closest(parent_selector);
      }
      if (!parent.length) {
        throw "failed to find stick parent";
      }
      fixed = false;
      bottomed = false;
      spacer = manual_spacer != null ? manual_spacer && elm.closest(manual_spacer) : $("<div />");
      if (spacer) {
        spacer.css('position', elm.css('position'));
      }
      recalc = function () {
        var border_top, padding_top, restore;
        if (detached) {
          return;
        }
        last_scroll_height = doc.height();
        border_top = parseInt(parent.css("border-top-width"), 10);
        padding_top = parseInt(parent.css("padding-top"), 10);
        padding_bottom = parseInt(parent.css("padding-bottom"), 10);
        parent_top = parent.offset().top + border_top + padding_top;
        parent_height = parent.height();
        if (fixed) {
          fixed = false;
          bottomed = false;
          if (manual_spacer == null) {
            elm.insertAfter(spacer);
            spacer.detach();
          }
          elm.css({
            position: "",
            top: "",
            width: "",
            bottom: ""
          }).removeClass(sticky_class);
          restore = true;
        }
        top = elm.offset().top - (parseInt(elm.css("margin-top"), 10) || 0) - offset_top;
        height = elm.outerHeight(true);
        el_float = elm.css("float");
        if (spacer) {
          spacer.css({
            width: elm.outerWidth(true),
            height: height,
            display: elm.css("display"),
            "vertical-align": elm.css("vertical-align"),
            "float": el_float
          });
        }
        if (restore) {
          return tick();
        }
      };
      recalc();
      if (height === parent_height) {
        return;
      }
      last_pos = void 0;
      offset = offset_top;
      recalc_counter = recalc_every;
      tick = function () {
        var css, delta, recalced, scroll, will_bottom, win_height;
        if (detached) {
          return;
        }
        recalced = false;
        if (recalc_counter != null) {
          recalc_counter -= 1;
          if (recalc_counter <= 0) {
            recalc_counter = recalc_every;
            recalc();
            recalced = true;
          }
        }
        if (!recalced && doc.height() !== last_scroll_height) {
          recalc();
          recalced = true;
        }
        scroll = win.scrollTop();
        if (last_pos != null) {
          delta = scroll - last_pos;
        }
        last_pos = scroll;
        if (fixed) {
          if (enable_bottoming) {
            will_bottom = scroll + height + offset > parent_height + parent_top;
            if (bottomed && !will_bottom) {
              bottomed = false;
              elm.css({
                position: "fixed",
                bottom: "",
                top: offset
              }).trigger("sticky_kit:unbottom");
            }
          }
          if (scroll < top) {
            fixed = false;
            offset = offset_top;
            if (manual_spacer == null) {
              if (el_float === "left" || el_float === "right") {
                elm.insertAfter(spacer);
              }
              spacer.detach();
            }
            css = {
              position: "",
              width: "",
              top: ""
            };
            elm.css(css).removeClass(sticky_class).trigger("sticky_kit:unstick");
          }
          if (inner_scrolling) {
            win_height = win.height();
            if (height + offset_top > win_height) {
              if (!bottomed) {
                offset -= delta;
                offset = Math.max(win_height - height, offset);
                offset = Math.min(offset_top, offset);
                if (fixed) {
                  elm.css({
                    top: offset + "px"
                  });
                }
              }
            }
          }
        } else {
          if (scroll > top) {
            fixed = true;
            css = {
              position: "fixed",
              top: offset
            };
            css.width = elm.css("box-sizing") === "border-box" ? elm.outerWidth() + "px" : elm.width() + "px";
            elm.css(css).addClass(sticky_class);
            if (manual_spacer == null) {
              elm.after(spacer);
              if (el_float === "left" || el_float === "right") {
                spacer.append(elm);
              }
            }
            elm.trigger("sticky_kit:stick");
          }
        }
        if (fixed && enable_bottoming) {
          if (will_bottom == null) {
            will_bottom = scroll + height + offset > parent_height + parent_top;
          }
          if (!bottomed && will_bottom) {
            bottomed = true;
            if (parent.css("position") === "static") {
              parent.css({
                position: "relative"
              });
            }
            return elm.css({
              position: "absolute",
              bottom: padding_bottom,
              top: "auto"
            }).trigger("sticky_kit:bottom");
          }
        }
      };
      recalc_and_tick = function () {
        recalc();
        return tick();
      };
      detach = function () {
        detached = true;
        win.off("touchmove", tick);
        win.off("scroll", tick);
        win.off("resize", recalc_and_tick);
        $(document.body).off("sticky_kit:recalc", recalc_and_tick);
        elm.off("sticky_kit:detach", detach);
        elm.removeData("sticky_kit");
        elm.css({
          position: "",
          bottom: "",
          top: "",
          width: ""
        });
        parent.position("position", "");
        if (fixed) {
          if (manual_spacer == null) {
            if (el_float === "left" || el_float === "right") {
              elm.insertAfter(spacer);
            }
            spacer.remove();
          }
          return elm.removeClass(sticky_class);
        }
      };
      win.on("touchmove", tick);
      win.on("scroll", tick);
      win.on("resize", recalc_and_tick);
      $(document.body).on("sticky_kit:recalc", recalc_and_tick);
      elm.on("sticky_kit:detach", detach);
      return setTimeout(tick, 0);
    };
    for (i = 0, len = this.length; i < len; i++) {
      elm = this[i];
      fn($(elm));
    }
    return this;
  };
}).call(this);
;"use strict";

!function (e, t) {
  "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? module.exports = t() : e.disableScroll = t();
}(this, function () {
  var e = { options: { disableWheel: !0, disableScrollbar: !0, disableKeys: !0, scrollEventKeys: [32, 33, 34, 35, 36, 37, 38, 39, 40] }, element: document.body, lockToScrollPos: [0, 0], on: function (e, t) {
      this.element = e || document.body, this.options = this._extend(this.options, t), this.options.disableWheel && (document.addEventListener("mousewheel", this._handleWheel), document.addEventListener("DOMMouseScroll", this._handleWheel), document.addEventListener("touchmove", this._handleWheel)), this.options.disableScrollbar && (this.lockToScrollPos = [this.element.scrollLeft, this.element.scrollTop], this._disableScrollbarFn = this._handleScrollbar.bind(this), document.addEventListener("scroll", this._disableScrollbarFn)), this.options.disableKeys && (this._disableKeysFn = this._handleKeydown.bind(this), document.addEventListener("keydown", this._disableKeysFn));
    }, off: function () {
      document.removeEventListener("mousewheel", this._handleWheel), document.removeEventListener("DOMMouseScroll", this._handleWheel), document.removeEventListener("touchmove", this._handleWheel), document.removeEventListener("scroll", this._disableScrollbarFn), document.removeEventListener("keydown", this._disableKeysFn);
    }, _handleWheel: function (e) {
      e.preventDefault();
    }, _handleScrollbar: function () {
      window.scrollTo(this.lockToScrollPos[0], this.lockToScrollPos[1]);
    }, _handleKeydown: function (e) {
      for (var t = 0; t < this.options.scrollEventKeys.length; t++) {
        if (e.keyCode === this.options.scrollEventKeys[t]) return e.preventDefault(), !1;
      }
    }, _extend: function (e) {
      return Object.keys(Array.prototype.slice(arguments, 1)).forEach(function (t) {
        for (var o in t) {
          t.hasOwnProperty(o) && (e[o] = t[o]);
        }
      }), e;
    } };return e;
});
;"use strict";

/*! Backstretch - v2.0.4 - 2013-06-19
* http://srobbin.com/jquery-plugins/backstretch/
* Copyright (c) 2013 Scott Robbin; Licensed MIT */
(function (a, d, p) {
  a.fn.backstretch = function (c, b) {
    (c === p || 0 === c.length) && a.error("No images were supplied for Backstretch");0 === a(d).scrollTop() && d.scrollTo(0, 0);return this.each(function () {
      var d = a(this),
          g = d.data("backstretch");if (g) {
        if ("string" == typeof c && "function" == typeof g[c]) {
          g[c](b);return;
        }b = a.extend(g.options, b);g.destroy(!0);
      }g = new q(this, c, b);d.data("backstretch", g);
    });
  };a.backstretch = function (c, b) {
    return a("body").backstretch(c, b).data("backstretch");
  };a.expr[":"].backstretch = function (c) {
    return a(c).data("backstretch") !== p;
  };a.fn.backstretch.defaults = { centeredX: !0, centeredY: !0, duration: 5E3, fade: 0 };var r = { left: 0, top: 0, overflow: "hidden", margin: 0, padding: 0, height: "100%", width: "100%", zIndex: -999999 },
      s = { position: "absolute", display: "none", margin: 0, padding: 0, border: "none", width: "auto", height: "auto", maxHeight: "none", maxWidth: "none", zIndex: -999999 },
      q = function (c, b, e) {
    this.options = a.extend({}, a.fn.backstretch.defaults, e || {});this.images = a.isArray(b) ? b : [b];a.each(this.images, function () {
      a("<img />")[0].src = this;
    });this.isBody = c === document.body;this.$container = a(c);this.$root = this.isBody ? l ? a(d) : a(document) : this.$container;c = this.$container.children(".backstretch").first();this.$wrap = c.length ? c : a('<div class="backstretch"></div>').css(r).appendTo(this.$container);this.isBody || (c = this.$container.css("position"), b = this.$container.css("zIndex"), this.$container.css({ position: "static" === c ? "relative" : c, zIndex: "auto" === b ? 0 : b, background: "none" }), this.$wrap.css({ zIndex: -999998 }));this.$wrap.css({ position: this.isBody && l ? "fixed" : "absolute" });this.index = 0;this.show(this.index);a(d).on("resize.backstretch", a.proxy(this.resize, this)).on("orientationchange.backstretch", a.proxy(function () {
      this.isBody && 0 === d.pageYOffset && (d.scrollTo(0, 1), this.resize());
    }, this));
  };q.prototype = { resize: function () {
      try {
        var a = { left: 0, top: 0 },
            b = this.isBody ? this.$root.width() : this.$root.innerWidth(),
            e = b,
            g = this.isBody ? d.innerHeight ? d.innerHeight : this.$root.height() : this.$root.innerHeight(),
            j = e / this.$img.data("ratio"),
            f;j >= g ? (f = (j - g) / 2, this.options.centeredY && (a.top = "-" + f + "px")) : (j = g, e = j * this.$img.data("ratio"), f = (e - b) / 2, this.options.centeredX && (a.left = "-" + f + "px"));this.$wrap.css({ width: b, height: g }).find("img:not(.deleteable)").css({ width: e, height: j }).css(a);
      } catch (h) {}return this;
    }, show: function (c) {
      if (!(Math.abs(c) > this.images.length - 1)) {
        var b = this,
            e = b.$wrap.find("img").addClass("deleteable"),
            d = { relatedTarget: b.$container[0] };b.$container.trigger(a.Event("backstretch.before", d), [b, c]);this.index = c;clearInterval(b.interval);b.$img = a("<img />").css(s).bind("load", function (f) {
          var h = this.width || a(f.target).width();f = this.height || a(f.target).height();a(this).data("ratio", h / f);a(this).fadeIn(b.options.speed || b.options.fade, function () {
            e.remove();b.paused || b.cycle();a(["after", "show"]).each(function () {
              b.$container.trigger(a.Event("backstretch." + this, d), [b, c]);
            });
          });b.resize();
        }).appendTo(b.$wrap);b.$img.attr("src", b.images[c]);return b;
      }
    }, next: function () {
      return this.show(this.index < this.images.length - 1 ? this.index + 1 : 0);
    }, prev: function () {
      return this.show(0 === this.index ? this.images.length - 1 : this.index - 1);
    }, pause: function () {
      this.paused = !0;return this;
    }, resume: function () {
      this.paused = !1;this.next();return this;
    }, cycle: function () {
      1 < this.images.length && (clearInterval(this.interval), this.interval = setInterval(a.proxy(function () {
        this.paused || this.next();
      }, this), this.options.duration));return this;
    }, destroy: function (c) {
      a(d).off("resize.backstretch orientationchange.backstretch");clearInterval(this.interval);c || this.$wrap.remove();this.$container.removeData("backstretch");
    } };var l,
      f = navigator.userAgent,
      m = navigator.platform,
      e = f.match(/AppleWebKit\/([0-9]+)/),
      e = !!e && e[1],
      h = f.match(/Fennec\/([0-9]+)/),
      h = !!h && h[1],
      n = f.match(/Opera Mobi\/([0-9]+)/),
      t = !!n && n[1],
      k = f.match(/MSIE ([0-9]+)/),
      k = !!k && k[1];l = !((-1 < m.indexOf("iPhone") || -1 < m.indexOf("iPad") || -1 < m.indexOf("iPod")) && e && 534 > e || d.operamini && "[object OperaMini]" === {}.toString.call(d.operamini) || n && 7458 > t || -1 < f.indexOf("Android") && e && 533 > e || h && 6 > h || "palmGetResource" in d && e && 534 > e || -1 < f.indexOf("MeeGo") && -1 < f.indexOf("NokiaBrowser/8.5.0") || k && 6 >= k);
})(jQuery, window);
;'use strict';

/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.6.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
(function (factory) {
    'use strict';

    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports !== 'undefined') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery);
    }
})(function ($) {
    'use strict';

    var Slick = window.Slick || {};

    Slick = function () {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this,
                dataSettings;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>',
                nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function (slider, i) {
                    return $('<button type="button" data-role="none" role="button" tabindex="0" />').text(i + 1);
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnFocus: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                useTransform: true,
                variableWidth: false,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true,
                zIndex: 1000
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                $list: null,
                touchObject: {},
                transformsEnabled: false,
                unslicked: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.focussed = false;
            _.interrupted = false;
            _.hidden = 'hidden';
            _.paused = true;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, settings, dataSettings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

            _.registerBreakpoints();
            _.init(true);
        }

        return Slick;
    }();

    Slick.prototype.activateADA = function () {
        var _ = this;

        _.$slideTrack.find('.slick-active').attr({
            'aria-hidden': 'false'
        }).find('a, input, button, select').attr({
            'tabindex': '0'
        });
    };

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function (markup, index, addBefore) {

        var _ = this;

        if (typeof index === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || index >= _.slideCount) {
            return false;
        }

        _.unload();

        if (typeof index === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function (index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();
    };

    Slick.prototype.animateHeight = function () {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };

    Slick.prototype.animateSlide = function (targetLeft, callback) {

        var animProps = {},
            _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }
        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -_.currentLeft;
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function (now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' + now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' + now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function () {
                        if (callback) {
                            callback.call();
                        }
                    }
                });
            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function () {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }
            }
        }
    };

    Slick.prototype.getNavTarget = function () {

        var _ = this,
            asNavFor = _.options.asNavFor;

        if (asNavFor && asNavFor !== null) {
            asNavFor = $(asNavFor).not(_.$slider);
        }

        return asNavFor;
    };

    Slick.prototype.asNavFor = function (index) {

        var _ = this,
            asNavFor = _.getNavTarget();

        if (asNavFor !== null && typeof asNavFor === 'object') {
            asNavFor.each(function () {
                var target = $(this).slick('getSlick');
                if (!target.unslicked) {
                    target.slideHandler(index, true);
                }
            });
        }
    };

    Slick.prototype.applyTransition = function (slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }
    };

    Slick.prototype.autoPlay = function () {

        var _ = this;

        _.autoPlayClear();

        if (_.slideCount > _.options.slidesToShow) {
            _.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);
        }
    };

    Slick.prototype.autoPlayClear = function () {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }
    };

    Slick.prototype.autoPlayIterator = function () {

        var _ = this,
            slideTo = _.currentSlide + _.options.slidesToScroll;

        if (!_.paused && !_.interrupted && !_.focussed) {

            if (_.options.infinite === false) {

                if (_.direction === 1 && _.currentSlide + 1 === _.slideCount - 1) {
                    _.direction = 0;
                } else if (_.direction === 0) {

                    slideTo = _.currentSlide - _.options.slidesToScroll;

                    if (_.currentSlide - 1 === 0) {
                        _.direction = 1;
                    }
                }
            }

            _.slideHandler(slideTo);
        }
    };

    Slick.prototype.buildArrows = function () {

        var _ = this;

        if (_.options.arrows === true) {

            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

            if (_.slideCount > _.options.slidesToShow) {

                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                if (_.htmlExpr.test(_.options.prevArrow)) {
                    _.$prevArrow.prependTo(_.options.appendArrows);
                }

                if (_.htmlExpr.test(_.options.nextArrow)) {
                    _.$nextArrow.appendTo(_.options.appendArrows);
                }

                if (_.options.infinite !== true) {
                    _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                }
            } else {

                _.$prevArrow.add(_.$nextArrow).addClass('slick-hidden').attr({
                    'aria-disabled': 'true',
                    'tabindex': '-1'
                });
            }
        }
    };

    Slick.prototype.buildDots = function () {

        var _ = this,
            i,
            dot;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$slider.addClass('slick-dotted');

            dot = $('<ul />').addClass(_.options.dotsClass);

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
            }

            _.$dots = dot.appendTo(_.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active').attr('aria-hidden', 'false');
        }
    };

    Slick.prototype.buildOut = function () {

        var _ = this;

        _.$slides = _.$slider.children(_.options.slide + ':not(.slick-cloned)').addClass('slick-slide');

        _.slideCount = _.$slides.length;

        _.$slides.each(function (index, element) {
            $(element).attr('data-slick-index', index).data('originalStyling', $(element).attr('style') || '');
        });

        _.$slider.addClass('slick-slider');

        _.$slideTrack = _.slideCount === 0 ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }
    };

    Slick.prototype.buildRows = function () {

        var _ = this,
            a,
            b,
            c,
            newSlides,
            numOfSlides,
            originalSlides,
            slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if (_.options.rows > 1) {

            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(originalSlides.length / slidesPerSection);

            for (a = 0; a < numOfSlides; a++) {
                var slide = document.createElement('div');
                for (b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for (c = 0; c < _.options.slidesPerRow; c++) {
                        var target = a * slidesPerSection + (b * _.options.slidesPerRow + c);
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }

            _.$slider.empty().append(newSlides);
            _.$slider.children().children().children().css({
                'width': 100 / _.options.slidesPerRow + '%',
                'display': 'inline-block'
            });
        }
    };

    Slick.prototype.checkResponsive = function (initial, forceUpdate) {

        var _ = this,
            breakpoint,
            targetBreakpoint,
            respondToWidth,
            triggerBreakpoint = false;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();

        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if (_.options.responsive && _.options.responsive.length && _.options.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                        _.activeBreakpoint = targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick(targetBreakpoint);
                        } else {
                            _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                            if (initial === true) {
                                _.currentSlide = _.options.initialSlide;
                            }
                            _.refresh(initial);
                        }
                        triggerBreakpoint = targetBreakpoint;
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick(targetBreakpoint);
                    } else {
                        _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                        if (initial === true) {
                            _.currentSlide = _.options.initialSlide;
                        }
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true) {
                        _.currentSlide = _.options.initialSlide;
                    }
                    _.refresh(initial);
                    triggerBreakpoint = targetBreakpoint;
                }
            }

            // only trigger breakpoints during an actual break. not on initialize.
            if (!initial && triggerBreakpoint !== false) {
                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
            }
        }
    };

    Slick.prototype.changeSlide = function (event, dontAnimate) {

        var _ = this,
            $target = $(event.currentTarget),
            indexOffset,
            slideOffset,
            unevenOffset;

        // If target is a link, prevent default action.
        if ($target.is('a')) {
            event.preventDefault();
        }

        // If target is not the <li> element (ie: a child), find the <li>.
        if (!$target.is('li')) {
            $target = $target.closest('li');
        }

        unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

            case 'previous':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                }
                break;

            case 'next':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                }
                break;

            case 'index':
                var index = event.data.index === 0 ? 0 : event.data.index || $target.index() * _.options.slidesToScroll;

                _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                $target.children().trigger('focus');
                break;

            default:
                return;
        }
    };

    Slick.prototype.checkNavigable = function (index) {

        var _ = this,
            navigables,
            prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    };

    Slick.prototype.cleanUpEvents = function () {

        var _ = this;

        if (_.options.dots && _.$dots !== null) {

            $('li', _.$dots).off('click.slick', _.changeSlide).off('mouseenter.slick', $.proxy(_.interrupt, _, true)).off('mouseleave.slick', $.proxy(_.interrupt, _, false));
        }

        _.$slider.off('focus.slick blur.slick');

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        $(document).off(_.visibilityChange, _.visibility);

        _.cleanUpSlideEvents();

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).off('ready.slick.slick-' + _.instanceUid, _.setPosition);
    };

    Slick.prototype.cleanUpSlideEvents = function () {

        var _ = this;

        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));
    };

    Slick.prototype.cleanUpRows = function () {

        var _ = this,
            originalSlides;

        if (_.options.rows > 1) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.empty().append(originalSlides);
        }
    };

    Slick.prototype.clickHandler = function (event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }
    };

    Slick.prototype.destroy = function (refresh) {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).detach();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.$prevArrow.length) {

            _.$prevArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

            if (_.htmlExpr.test(_.options.prevArrow)) {
                _.$prevArrow.remove();
            }
        }

        if (_.$nextArrow && _.$nextArrow.length) {

            _.$nextArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

            if (_.htmlExpr.test(_.options.nextArrow)) {
                _.$nextArrow.remove();
            }
        }

        if (_.$slides) {

            _.$slides.removeClass('slick-slide slick-active slick-center slick-visible slick-current').removeAttr('aria-hidden').removeAttr('data-slick-index').each(function () {
                $(this).attr('style', $(this).data('originalStyling'));
            });

            _.$slideTrack.children(this.options.slide).detach();

            _.$slideTrack.detach();

            _.$list.detach();

            _.$slider.append(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');
        _.$slider.removeClass('slick-dotted');

        _.unslicked = true;

        if (!refresh) {
            _.$slider.trigger('destroy', [_]);
        }
    };

    Slick.prototype.disableTransition = function (slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }
    };

    Slick.prototype.fadeSlide = function (slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);
        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });

            if (callback) {
                setTimeout(function () {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }
        }
    };

    Slick.prototype.fadeSlideOut = function (slideIndex) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).animate({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            }, _.options.speed, _.options.easing);
        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });
        }
    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function (filter) {

        var _ = this;

        if (filter !== null) {

            _.$slidesCache = _.$slides;

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();
        }
    };

    Slick.prototype.focusHandler = function () {

        var _ = this;

        _.$slider.off('focus.slick blur.slick').on('focus.slick blur.slick', '*:not(.slick-arrow)', function (event) {

            event.stopImmediatePropagation();
            var $sf = $(this);

            setTimeout(function () {

                if (_.options.pauseOnFocus) {
                    _.focussed = $sf.is(':focus');
                    _.autoPlay();
                }
            }, 0);
        });
    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function () {

        var _ = this;
        return _.currentSlide;
    };

    Slick.prototype.getDotCount = function () {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if (_.options.infinite === true) {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else if (!_.options.asNavFor) {
            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
        } else {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;
    };

    Slick.prototype.getLeft = function (slideIndex) {

        var _ = this,
            targetLeft,
            verticalHeight,
            verticalOffset = 0,
            targetSlide;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(true);

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = _.slideWidth * _.options.slidesToShow * -1;
                verticalOffset = verticalHeight * _.options.slidesToShow * -1;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1;
                        verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1;
                    } else {
                        _.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1;
                        verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;
                verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = slideIndex * _.slideWidth * -1 + _.slideOffset;
        } else {
            targetLeft = slideIndex * verticalHeight * -1 + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            if (_.options.rtl === true) {
                if (targetSlide[0]) {
                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                } else {
                    targetLeft = 0;
                }
            } else {
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
            }

            if (_.options.centerMode === true) {
                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }

                if (_.options.rtl === true) {
                    if (targetSlide[0]) {
                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                    } else {
                        targetLeft = 0;
                    }
                } else {
                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                }

                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;
    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function (option) {

        var _ = this;

        return _.options[option];
    };

    Slick.prototype.getNavigableIndexes = function () {

        var _ = this,
            breakPoint = 0,
            counter = 0,
            indexes = [],
            max;

        if (_.options.infinite === false) {
            max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;
    };

    Slick.prototype.getSlick = function () {

        return this;
    };

    Slick.prototype.getSlideCount = function () {

        var _ = this,
            slidesTraversed,
            swipedSlide,
            centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function (index, slide) {
                if (slide.offsetLeft - centerOffset + $(slide).outerWidth() / 2 > _.swipeLeft * -1) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;
        } else {
            return _.options.slidesToScroll;
        }
    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function (slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);
    };

    Slick.prototype.init = function (creation) {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');

            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
            _.checkResponsive(true);
            _.focusHandler();
        }

        if (creation) {
            _.$slider.trigger('init', [_]);
        }

        if (_.options.accessibility === true) {
            _.initADA();
        }

        if (_.options.autoplay) {

            _.paused = false;
            _.autoPlay();
        }
    };

    Slick.prototype.initADA = function () {
        var _ = this;
        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
            'aria-hidden': 'true',
            'tabindex': '-1'
        }).find('a, input, button, select').attr({
            'tabindex': '-1'
        });

        _.$slideTrack.attr('role', 'listbox');

        _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function (i) {
            $(this).attr({
                'role': 'option',
                'aria-describedby': 'slick-slide' + _.instanceUid + i + ''
            });
        });

        if (_.$dots !== null) {
            _.$dots.attr('role', 'tablist').find('li').each(function (i) {
                $(this).attr({
                    'role': 'presentation',
                    'aria-selected': 'false',
                    'aria-controls': 'navigation' + _.instanceUid + i + '',
                    'id': 'slick-slide' + _.instanceUid + i + ''
                });
            }).first().attr('aria-selected', 'true').end().find('button').attr('role', 'button').end().closest('div').attr('role', 'toolbar');
        }
        _.activateADA();
    };

    Slick.prototype.initArrowEvents = function () {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.off('click.slick').on('click.slick', {
                message: 'previous'
            }, _.changeSlide);
            _.$nextArrow.off('click.slick').on('click.slick', {
                message: 'next'
            }, _.changeSlide);
        }
    };

    Slick.prototype.initDotEvents = function () {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);
        }

        if (_.options.dots === true && _.options.pauseOnDotsHover === true) {

            $('li', _.$dots).on('mouseenter.slick', $.proxy(_.interrupt, _, true)).on('mouseleave.slick', $.proxy(_.interrupt, _, false));
        }
    };

    Slick.prototype.initSlideEvents = function () {

        var _ = this;

        if (_.options.pauseOnHover) {

            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));
        }
    };

    Slick.prototype.initializeEvents = function () {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();
        _.initSlideEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);
    };

    Slick.prototype.initUI = function () {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();
        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();
        }
    };

    Slick.prototype.keyHandler = function (event) {

        var _ = this;
        //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
            if (event.keyCode === 37 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'next' : 'previous'
                    }
                });
            } else if (event.keyCode === 39 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'previous' : 'next'
                    }
                });
            }
        }
    };

    Slick.prototype.lazyLoad = function () {

        var _ = this,
            loadRange,
            cloneRange,
            rangeStart,
            rangeEnd;

        function loadImages(imagesScope) {

            $('img[data-lazy]', imagesScope).each(function () {

                var image = $(this),
                    imageSource = $(this).attr('data-lazy'),
                    imageToLoad = document.createElement('img');

                imageToLoad.onload = function () {

                    image.animate({ opacity: 0 }, 100, function () {
                        image.attr('src', imageSource).animate({ opacity: 1 }, 200, function () {
                            image.removeAttr('data-lazy').removeClass('slick-loading');
                        });
                        _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                    });
                };

                imageToLoad.onerror = function () {

                    image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

                    _.$slider.trigger('lazyLoadError', [_, image, imageSource]);
                };

                imageToLoad.src = imageSource;
            });
        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
            if (_.options.fade === true) {
                if (rangeStart > 0) rangeStart--;
                if (rangeEnd <= _.slideCount) rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);
        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }
    };

    Slick.prototype.loadSlider = function () {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }
    };

    Slick.prototype.next = Slick.prototype.slickNext = function () {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });
    };

    Slick.prototype.orientationChange = function () {

        var _ = this;

        _.checkResponsive();
        _.setPosition();
    };

    Slick.prototype.pause = Slick.prototype.slickPause = function () {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;
    };

    Slick.prototype.play = Slick.prototype.slickPlay = function () {

        var _ = this;

        _.autoPlay();
        _.options.autoplay = true;
        _.paused = false;
        _.focussed = false;
        _.interrupted = false;
    };

    Slick.prototype.postSlide = function (index) {

        var _ = this;

        if (!_.unslicked) {

            _.$slider.trigger('afterChange', [_, index]);

            _.animating = false;

            _.setPosition();

            _.swipeLeft = null;

            if (_.options.autoplay) {
                _.autoPlay();
            }

            if (_.options.accessibility === true) {
                _.initADA();
            }
        }
    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function () {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });
    };

    Slick.prototype.preventDefault = function (event) {

        event.preventDefault();
    };

    Slick.prototype.progressiveLazyLoad = function (tryCount) {

        tryCount = tryCount || 1;

        var _ = this,
            $imgsToLoad = $('img[data-lazy]', _.$slider),
            image,
            imageSource,
            imageToLoad;

        if ($imgsToLoad.length) {

            image = $imgsToLoad.first();
            imageSource = image.attr('data-lazy');
            imageToLoad = document.createElement('img');

            imageToLoad.onload = function () {

                image.attr('src', imageSource).removeAttr('data-lazy').removeClass('slick-loading');

                if (_.options.adaptiveHeight === true) {
                    _.setPosition();
                }

                _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                _.progressiveLazyLoad();
            };

            imageToLoad.onerror = function () {

                if (tryCount < 3) {

                    /**
                     * try to load the image 3 times,
                     * leave a slight delay so we don't get
                     * servers blocking the request.
                     */
                    setTimeout(function () {
                        _.progressiveLazyLoad(tryCount + 1);
                    }, 500);
                } else {

                    image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

                    _.$slider.trigger('lazyLoadError', [_, image, imageSource]);

                    _.progressiveLazyLoad();
                }
            };

            imageToLoad.src = imageSource;
        } else {

            _.$slider.trigger('allImagesLoaded', [_]);
        }
    };

    Slick.prototype.refresh = function (initializing) {

        var _ = this,
            currentSlide,
            lastVisibleIndex;

        lastVisibleIndex = _.slideCount - _.options.slidesToShow;

        // in non-infinite sliders, we don't want to go past the
        // last visible index.
        if (!_.options.infinite && _.currentSlide > lastVisibleIndex) {
            _.currentSlide = lastVisibleIndex;
        }

        // if less slides than to show, go to start.
        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        currentSlide = _.currentSlide;

        _.destroy(true);

        $.extend(_, _.initials, { currentSlide: currentSlide });

        _.init();

        if (!initializing) {

            _.changeSlide({
                data: {
                    message: 'index',
                    index: currentSlide
                }
            }, false);
        }
    };

    Slick.prototype.registerBreakpoints = function () {

        var _ = this,
            breakpoint,
            currentBreakpoint,
            l,
            responsiveSettings = _.options.responsive || null;

        if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {

            _.respondTo = _.options.respondTo || 'window';

            for (breakpoint in responsiveSettings) {

                l = _.breakpoints.length - 1;
                currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                if (responsiveSettings.hasOwnProperty(breakpoint)) {

                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    while (l >= 0) {
                        if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {
                            _.breakpoints.splice(l, 1);
                        }
                        l--;
                    }

                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;
                }
            }

            _.breakpoints.sort(function (a, b) {
                return _.options.mobileFirst ? a - b : b - a;
            });
        }
    };

    Slick.prototype.reinit = function () {

        var _ = this;

        _.$slides = _.$slideTrack.children(_.options.slide).addClass('slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.registerBreakpoints();

        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.cleanUpSlideEvents();
        _.initSlideEvents();

        _.checkResponsive(false, true);

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        _.setPosition();
        _.focusHandler();

        _.paused = !_.options.autoplay;
        _.autoPlay();

        _.$slider.trigger('reInit', [_]);
    };

    Slick.prototype.resize = function () {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function () {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                if (!_.unslicked) {
                    _.setPosition();
                }
            }, 50);
        }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function (index, removeBefore, removeAll) {

        var _ = this;

        if (typeof index === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();
    };

    Slick.prototype.setCSS = function (position) {

        var _ = this,
            positionProps = {},
            x,
            y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }
    };

    Slick.prototype.setDimensions = function () {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: '0px ' + _.options.centerPadding
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: _.options.centerPadding + ' 0px'
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();

        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children('.slick-slide').length));
        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);
    };

    Slick.prototype.setFade = function () {

        var _ = this,
            targetLeft;

        _.$slides.each(function (index, element) {
            targetLeft = _.slideWidth * index * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });
    };

    Slick.prototype.setHeight = function () {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }
    };

    Slick.prototype.setOption = Slick.prototype.slickSetOption = function () {

        /**
         * accepts arguments in format of:
         *
         *  - for changing a single option's value:
         *     .slick("setOption", option, value, refresh )
         *
         *  - for changing a set of responsive options:
         *     .slick("setOption", 'responsive', [{}, ...], refresh )
         *
         *  - for updating multiple values at once (not responsive)
         *     .slick("setOption", { 'option': value, ... }, refresh )
         */

        var _ = this,
            l,
            item,
            option,
            value,
            refresh = false,
            type;

        if ($.type(arguments[0]) === 'object') {

            option = arguments[0];
            refresh = arguments[1];
            type = 'multiple';
        } else if ($.type(arguments[0]) === 'string') {

            option = arguments[0];
            value = arguments[1];
            refresh = arguments[2];

            if (arguments[0] === 'responsive' && $.type(arguments[1]) === 'array') {

                type = 'responsive';
            } else if (typeof arguments[1] !== 'undefined') {

                type = 'single';
            }
        }

        if (type === 'single') {

            _.options[option] = value;
        } else if (type === 'multiple') {

            $.each(option, function (opt, val) {

                _.options[opt] = val;
            });
        } else if (type === 'responsive') {

            for (item in value) {

                if ($.type(_.options.responsive) !== 'array') {

                    _.options.responsive = [value[item]];
                } else {

                    l = _.options.responsive.length - 1;

                    // loop through the responsive object and splice out duplicates.
                    while (l >= 0) {

                        if (_.options.responsive[l].breakpoint === value[item].breakpoint) {

                            _.options.responsive.splice(l, 1);
                        }

                        l--;
                    }

                    _.options.responsive.push(value[item]);
                }
            }
        }

        if (refresh) {

            _.unload();
            _.reinit();
        }
    };

    Slick.prototype.setPosition = function () {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);
    };

    Slick.prototype.setProps = function () {

        var _ = this,
            bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined || bodyStyle.MozTransition !== undefined || bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if (_.options.fade) {
            if (typeof _.options.zIndex === 'number') {
                if (_.options.zIndex < 3) {
                    _.options.zIndex = 3;
                }
            } else {
                _.options.zIndex = _.defaults.zIndex;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined) _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = _.options.useTransform && _.animType !== null && _.animType !== false;
    };

    Slick.prototype.setSlideClasses = function (index) {

        var _ = this,
            centerOffset,
            allSlides,
            indexOffset,
            remainder;

        allSlides = _.$slider.find('.slick-slide').removeClass('slick-active slick-center slick-current').attr('aria-hidden', 'true');

        _.$slides.eq(index).addClass('slick-current');

        if (_.options.centerMode === true) {

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) {

                    _.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass('slick-active').attr('aria-hidden', 'false');
                } else {

                    indexOffset = _.options.slidesToShow + index;
                    allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass('slick-active').attr('aria-hidden', 'false');
                }

                if (index === 0) {

                    allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slick-center');
                } else if (index === _.slideCount - 1) {

                    allSlides.eq(_.options.slidesToShow).addClass('slick-center');
                }
            }

            _.$slides.eq(index).addClass('slick-center');
        } else {

            if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) {

                _.$slides.slice(index, index + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
            } else if (allSlides.length <= _.options.slidesToShow) {

                allSlides.addClass('slick-active').attr('aria-hidden', 'false');
            } else {

                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                if (_.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow) {

                    allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass('slick-active').attr('aria-hidden', 'false');
                } else {

                    allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
                }
            }
        }

        if (_.options.lazyLoad === 'ondemand') {
            _.lazyLoad();
        }
    };

    Slick.prototype.setupInfinite = function () {

        var _ = this,
            i,
            slideIndex,
            infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function () {
                    $(this).attr('id', '');
                });
            }
        }
    };

    Slick.prototype.interrupt = function (toggle) {

        var _ = this;

        if (!toggle) {
            _.autoPlay();
        }
        _.interrupted = toggle;
    };

    Slick.prototype.selectHandler = function (event) {

        var _ = this;

        var targetElement = $(event.target).is('.slick-slide') ? $(event.target) : $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));

        if (!index) index = 0;

        if (_.slideCount <= _.options.slidesToShow) {

            _.setSlideClasses(index);
            _.asNavFor(index);
            return;
        }

        _.slideHandler(index);
    };

    Slick.prototype.slideHandler = function (index, sync, dontAnimate) {

        var targetSlide,
            animSlide,
            oldSlide,
            slideLeft,
            targetLeft = null,
            _ = this,
            navTarget;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function () {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > _.slideCount - _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function () {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if (_.options.autoplay) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - _.slideCount % _.options.slidesToScroll;
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        if (_.options.asNavFor) {

            navTarget = _.getNavTarget();
            navTarget = navTarget.slick('getSlick');

            if (navTarget.slideCount <= navTarget.options.slidesToShow) {
                navTarget.setSlideClasses(_.currentSlide);
            }
        }

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {

                _.fadeSlideOut(oldSlide);

                _.fadeSlide(animSlide, function () {
                    _.postSlide(animSlide);
                });
            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true) {
            _.animateSlide(targetLeft, function () {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }
    };

    Slick.prototype.startLoad = function () {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();
        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();
        }

        _.$slider.addClass('slick-loading');
    };

    Slick.prototype.swipeDirection = function () {

        var xDist,
            yDist,
            r,
            swipeAngle,
            _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if (swipeAngle <= 45 && swipeAngle >= 0) {
            return _.options.rtl === false ? 'left' : 'right';
        }
        if (swipeAngle <= 360 && swipeAngle >= 315) {
            return _.options.rtl === false ? 'left' : 'right';
        }
        if (swipeAngle >= 135 && swipeAngle <= 225) {
            return _.options.rtl === false ? 'right' : 'left';
        }
        if (_.options.verticalSwiping === true) {
            if (swipeAngle >= 35 && swipeAngle <= 135) {
                return 'down';
            } else {
                return 'up';
            }
        }

        return 'vertical';
    };

    Slick.prototype.swipeEnd = function (event) {

        var _ = this,
            slideCount,
            direction;

        _.dragging = false;
        _.interrupted = false;
        _.shouldClick = _.touchObject.swipeLength > 10 ? false : true;

        if (_.touchObject.curX === undefined) {
            return false;
        }

        if (_.touchObject.edgeHit === true) {
            _.$slider.trigger('edge', [_, _.swipeDirection()]);
        }

        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {

            direction = _.swipeDirection();

            switch (direction) {

                case 'left':
                case 'down':

                    slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();

                    _.currentDirection = 0;

                    break;

                case 'right':
                case 'up':

                    slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();

                    _.currentDirection = 1;

                    break;

                default:

            }

            if (direction != 'vertical') {

                _.slideHandler(slideCount);
                _.touchObject = {};
                _.$slider.trigger('swipe', [_, direction]);
            }
        } else {

            if (_.touchObject.startX !== _.touchObject.curX) {

                _.slideHandler(_.currentSlide);
                _.touchObject = {};
            }
        }
    };

    Slick.prototype.swipeHandler = function (event) {

        var _ = this;

        if (_.options.swipe === false || 'ontouchend' in document && _.options.swipe === false) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ? event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options.touchThreshold;
        }

        switch (event.data.action) {

            case 'start':
                _.swipeStart(event);
                break;

            case 'move':
                _.swipeMove(event);
                break;

            case 'end':
                _.swipeEnd(event);
                break;

        }
    };

    Slick.prototype.swipeMove = function (event) {

        var _ = this,
            edgeWasHit = false,
            curLeft,
            swipeDirection,
            swipeLength,
            positionOffset,
            touches;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));
        }

        swipeDirection = _.swipeDirection();

        if (swipeDirection === 'vertical') {
            return;
        }

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }

        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if (_.currentSlide === 0 && swipeDirection === 'right' || _.currentSlide >= _.getDotCount() && swipeDirection === 'left') {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + swipeLength * (_.$list.height() / _.listWidth) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);
    };

    Slick.prototype.swipeStart = function (event) {

        var _ = this,
            touches;

        _.interrupted = true;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;
    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function () {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();
        }
    };

    Slick.prototype.unload = function () {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.remove();
        }

        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.remove();
        }

        _.$slides.removeClass('slick-slide slick-active slick-visible slick-current').attr('aria-hidden', 'true').css('width', '');
    };

    Slick.prototype.unslick = function (fromBreakpoint) {

        var _ = this;
        _.$slider.trigger('unslick', [_, fromBreakpoint]);
        _.destroy();
    };

    Slick.prototype.updateArrows = function () {

        var _ = this,
            centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow && !_.options.infinite) {

            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            if (_.currentSlide === 0) {

                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            }
        }
    };

    Slick.prototype.updateDots = function () {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots.find('li').removeClass('slick-active').attr('aria-hidden', 'true');

            _.$dots.find('li').eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass('slick-active').attr('aria-hidden', 'false');
        }
    };

    Slick.prototype.visibility = function () {

        var _ = this;

        if (_.options.autoplay) {

            if (document[_.hidden]) {

                _.interrupted = true;
            } else {

                _.interrupted = false;
            }
        }
    };

    $.fn.slick = function () {
        var _ = this,
            opt = arguments[0],
            args = Array.prototype.slice.call(arguments, 1),
            l = _.length,
            i,
            ret;
        for (i = 0; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined') _[i].slick = new Slick(_[i], opt);else ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined') return ret;
        }
        return _;
    };
});
;"use strict";

/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.6.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
!function (a) {
  "use strict";
  "function" == typeof define && define.amd ? define(["jquery"], a) : "undefined" != typeof exports ? module.exports = a(require("jquery")) : a(jQuery);
}(function (a) {
  "use strict";
  var b = window.Slick || {};b = function () {
    function c(c, d) {
      var f,
          e = this;e.defaults = { accessibility: !0, adaptiveHeight: !1, appendArrows: a(c), appendDots: a(c), arrows: !0, asNavFor: null, prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>', nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>', autoplay: !1, autoplaySpeed: 3e3, centerMode: !1, centerPadding: "50px", cssEase: "ease", customPaging: function (b, c) {
          return a('<button type="button" data-role="none" role="button" tabindex="0" />').text(c + 1);
        }, dots: !1, dotsClass: "slick-dots", draggable: !0, easing: "linear", edgeFriction: .35, fade: !1, focusOnSelect: !1, infinite: !0, initialSlide: 0, lazyLoad: "ondemand", mobileFirst: !1, pauseOnHover: !0, pauseOnFocus: !0, pauseOnDotsHover: !1, respondTo: "window", responsive: null, rows: 1, rtl: !1, slide: "", slidesPerRow: 1, slidesToShow: 1, slidesToScroll: 1, speed: 500, swipe: !0, swipeToSlide: !1, touchMove: !0, touchThreshold: 5, useCSS: !0, useTransform: !0, variableWidth: !1, vertical: !1, verticalSwiping: !1, waitForAnimate: !0, zIndex: 1e3 }, e.initials = { animating: !1, dragging: !1, autoPlayTimer: null, currentDirection: 0, currentLeft: null, currentSlide: 0, direction: 1, $dots: null, listWidth: null, listHeight: null, loadIndex: 0, $nextArrow: null, $prevArrow: null, slideCount: null, slideWidth: null, $slideTrack: null, $slides: null, sliding: !1, slideOffset: 0, swipeLeft: null, $list: null, touchObject: {}, transformsEnabled: !1, unslicked: !1 }, a.extend(e, e.initials), e.activeBreakpoint = null, e.animType = null, e.animProp = null, e.breakpoints = [], e.breakpointSettings = [], e.cssTransitions = !1, e.focussed = !1, e.interrupted = !1, e.hidden = "hidden", e.paused = !0, e.positionProp = null, e.respondTo = null, e.rowCount = 1, e.shouldClick = !0, e.$slider = a(c), e.$slidesCache = null, e.transformType = null, e.transitionType = null, e.visibilityChange = "visibilitychange", e.windowWidth = 0, e.windowTimer = null, f = a(c).data("slick") || {}, e.options = a.extend({}, e.defaults, d, f), e.currentSlide = e.options.initialSlide, e.originalSettings = e.options, "undefined" != typeof document.mozHidden ? (e.hidden = "mozHidden", e.visibilityChange = "mozvisibilitychange") : "undefined" != typeof document.webkitHidden && (e.hidden = "webkitHidden", e.visibilityChange = "webkitvisibilitychange"), e.autoPlay = a.proxy(e.autoPlay, e), e.autoPlayClear = a.proxy(e.autoPlayClear, e), e.autoPlayIterator = a.proxy(e.autoPlayIterator, e), e.changeSlide = a.proxy(e.changeSlide, e), e.clickHandler = a.proxy(e.clickHandler, e), e.selectHandler = a.proxy(e.selectHandler, e), e.setPosition = a.proxy(e.setPosition, e), e.swipeHandler = a.proxy(e.swipeHandler, e), e.dragHandler = a.proxy(e.dragHandler, e), e.keyHandler = a.proxy(e.keyHandler, e), e.instanceUid = b++, e.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, e.registerBreakpoints(), e.init(!0);
    }var b = 0;return c;
  }(), b.prototype.activateADA = function () {
    var a = this;a.$slideTrack.find(".slick-active").attr({ "aria-hidden": "false" }).find("a, input, button, select").attr({ tabindex: "0" });
  }, b.prototype.addSlide = b.prototype.slickAdd = function (b, c, d) {
    var e = this;if ("boolean" == typeof c) d = c, c = null;else if (0 > c || c >= e.slideCount) return !1;e.unload(), "number" == typeof c ? 0 === c && 0 === e.$slides.length ? a(b).appendTo(e.$slideTrack) : d ? a(b).insertBefore(e.$slides.eq(c)) : a(b).insertAfter(e.$slides.eq(c)) : d === !0 ? a(b).prependTo(e.$slideTrack) : a(b).appendTo(e.$slideTrack), e.$slides = e.$slideTrack.children(this.options.slide), e.$slideTrack.children(this.options.slide).detach(), e.$slideTrack.append(e.$slides), e.$slides.each(function (b, c) {
      a(c).attr("data-slick-index", b);
    }), e.$slidesCache = e.$slides, e.reinit();
  }, b.prototype.animateHeight = function () {
    var a = this;if (1 === a.options.slidesToShow && a.options.adaptiveHeight === !0 && a.options.vertical === !1) {
      var b = a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.animate({ height: b }, a.options.speed);
    }
  }, b.prototype.animateSlide = function (b, c) {
    var d = {},
        e = this;e.animateHeight(), e.options.rtl === !0 && e.options.vertical === !1 && (b = -b), e.transformsEnabled === !1 ? e.options.vertical === !1 ? e.$slideTrack.animate({ left: b }, e.options.speed, e.options.easing, c) : e.$slideTrack.animate({ top: b }, e.options.speed, e.options.easing, c) : e.cssTransitions === !1 ? (e.options.rtl === !0 && (e.currentLeft = -e.currentLeft), a({ animStart: e.currentLeft }).animate({ animStart: b }, { duration: e.options.speed, easing: e.options.easing, step: function (a) {
        a = Math.ceil(a), e.options.vertical === !1 ? (d[e.animType] = "translate(" + a + "px, 0px)", e.$slideTrack.css(d)) : (d[e.animType] = "translate(0px," + a + "px)", e.$slideTrack.css(d));
      }, complete: function () {
        c && c.call();
      } })) : (e.applyTransition(), b = Math.ceil(b), e.options.vertical === !1 ? d[e.animType] = "translate3d(" + b + "px, 0px, 0px)" : d[e.animType] = "translate3d(0px," + b + "px, 0px)", e.$slideTrack.css(d), c && setTimeout(function () {
      e.disableTransition(), c.call();
    }, e.options.speed));
  }, b.prototype.getNavTarget = function () {
    var b = this,
        c = b.options.asNavFor;return c && null !== c && (c = a(c).not(b.$slider)), c;
  }, b.prototype.asNavFor = function (b) {
    var c = this,
        d = c.getNavTarget();null !== d && "object" == typeof d && d.each(function () {
      var c = a(this).slick("getSlick");c.unslicked || c.slideHandler(b, !0);
    });
  }, b.prototype.applyTransition = function (a) {
    var b = this,
        c = {};b.options.fade === !1 ? c[b.transitionType] = b.transformType + " " + b.options.speed + "ms " + b.options.cssEase : c[b.transitionType] = "opacity " + b.options.speed + "ms " + b.options.cssEase, b.options.fade === !1 ? b.$slideTrack.css(c) : b.$slides.eq(a).css(c);
  }, b.prototype.autoPlay = function () {
    var a = this;a.autoPlayClear(), a.slideCount > a.options.slidesToShow && (a.autoPlayTimer = setInterval(a.autoPlayIterator, a.options.autoplaySpeed));
  }, b.prototype.autoPlayClear = function () {
    var a = this;a.autoPlayTimer && clearInterval(a.autoPlayTimer);
  }, b.prototype.autoPlayIterator = function () {
    var a = this,
        b = a.currentSlide + a.options.slidesToScroll;a.paused || a.interrupted || a.focussed || (a.options.infinite === !1 && (1 === a.direction && a.currentSlide + 1 === a.slideCount - 1 ? a.direction = 0 : 0 === a.direction && (b = a.currentSlide - a.options.slidesToScroll, a.currentSlide - 1 === 0 && (a.direction = 1))), a.slideHandler(b));
  }, b.prototype.buildArrows = function () {
    var b = this;b.options.arrows === !0 && (b.$prevArrow = a(b.options.prevArrow).addClass("slick-arrow"), b.$nextArrow = a(b.options.nextArrow).addClass("slick-arrow"), b.slideCount > b.options.slidesToShow ? (b.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), b.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), b.htmlExpr.test(b.options.prevArrow) && b.$prevArrow.prependTo(b.options.appendArrows), b.htmlExpr.test(b.options.nextArrow) && b.$nextArrow.appendTo(b.options.appendArrows), b.options.infinite !== !0 && b.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : b.$prevArrow.add(b.$nextArrow).addClass("slick-hidden").attr({ "aria-disabled": "true", tabindex: "-1" }));
  }, b.prototype.buildDots = function () {
    var c,
        d,
        b = this;if (b.options.dots === !0 && b.slideCount > b.options.slidesToShow) {
      for (b.$slider.addClass("slick-dotted"), d = a("<ul />").addClass(b.options.dotsClass), c = 0; c <= b.getDotCount(); c += 1) {
        d.append(a("<li />").append(b.options.customPaging.call(this, b, c)));
      }b.$dots = d.appendTo(b.options.appendDots), b.$dots.find("li").first().addClass("slick-active").attr("aria-hidden", "false");
    }
  }, b.prototype.buildOut = function () {
    var b = this;b.$slides = b.$slider.children(b.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), b.slideCount = b.$slides.length, b.$slides.each(function (b, c) {
      a(c).attr("data-slick-index", b).data("originalStyling", a(c).attr("style") || "");
    }), b.$slider.addClass("slick-slider"), b.$slideTrack = 0 === b.slideCount ? a('<div class="slick-track"/>').appendTo(b.$slider) : b.$slides.wrapAll('<div class="slick-track"/>').parent(), b.$list = b.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent(), b.$slideTrack.css("opacity", 0), (b.options.centerMode === !0 || b.options.swipeToSlide === !0) && (b.options.slidesToScroll = 1), a("img[data-lazy]", b.$slider).not("[src]").addClass("slick-loading"), b.setupInfinite(), b.buildArrows(), b.buildDots(), b.updateDots(), b.setSlideClasses("number" == typeof b.currentSlide ? b.currentSlide : 0), b.options.draggable === !0 && b.$list.addClass("draggable");
  }, b.prototype.buildRows = function () {
    var b,
        c,
        d,
        e,
        f,
        g,
        h,
        a = this;if (e = document.createDocumentFragment(), g = a.$slider.children(), a.options.rows > 1) {
      for (h = a.options.slidesPerRow * a.options.rows, f = Math.ceil(g.length / h), b = 0; f > b; b++) {
        var i = document.createElement("div");for (c = 0; c < a.options.rows; c++) {
          var j = document.createElement("div");for (d = 0; d < a.options.slidesPerRow; d++) {
            var k = b * h + (c * a.options.slidesPerRow + d);g.get(k) && j.appendChild(g.get(k));
          }i.appendChild(j);
        }e.appendChild(i);
      }a.$slider.empty().append(e), a.$slider.children().children().children().css({ width: 100 / a.options.slidesPerRow + "%", display: "inline-block" });
    }
  }, b.prototype.checkResponsive = function (b, c) {
    var e,
        f,
        g,
        d = this,
        h = !1,
        i = d.$slider.width(),
        j = window.innerWidth || a(window).width();if ("window" === d.respondTo ? g = j : "slider" === d.respondTo ? g = i : "min" === d.respondTo && (g = Math.min(j, i)), d.options.responsive && d.options.responsive.length && null !== d.options.responsive) {
      f = null;for (e in d.breakpoints) {
        d.breakpoints.hasOwnProperty(e) && (d.originalSettings.mobileFirst === !1 ? g < d.breakpoints[e] && (f = d.breakpoints[e]) : g > d.breakpoints[e] && (f = d.breakpoints[e]));
      }null !== f ? null !== d.activeBreakpoint ? (f !== d.activeBreakpoint || c) && (d.activeBreakpoint = f, "unslick" === d.breakpointSettings[f] ? d.unslick(f) : (d.options = a.extend({}, d.originalSettings, d.breakpointSettings[f]), b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b)), h = f) : (d.activeBreakpoint = f, "unslick" === d.breakpointSettings[f] ? d.unslick(f) : (d.options = a.extend({}, d.originalSettings, d.breakpointSettings[f]), b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b)), h = f) : null !== d.activeBreakpoint && (d.activeBreakpoint = null, d.options = d.originalSettings, b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b), h = f), b || h === !1 || d.$slider.trigger("breakpoint", [d, h]);
    }
  }, b.prototype.changeSlide = function (b, c) {
    var f,
        g,
        h,
        d = this,
        e = a(b.currentTarget);switch (e.is("a") && b.preventDefault(), e.is("li") || (e = e.closest("li")), h = d.slideCount % d.options.slidesToScroll !== 0, f = h ? 0 : (d.slideCount - d.currentSlide) % d.options.slidesToScroll, b.data.message) {case "previous":
        g = 0 === f ? d.options.slidesToScroll : d.options.slidesToShow - f, d.slideCount > d.options.slidesToShow && d.slideHandler(d.currentSlide - g, !1, c);break;case "next":
        g = 0 === f ? d.options.slidesToScroll : f, d.slideCount > d.options.slidesToShow && d.slideHandler(d.currentSlide + g, !1, c);break;case "index":
        var i = 0 === b.data.index ? 0 : b.data.index || e.index() * d.options.slidesToScroll;d.slideHandler(d.checkNavigable(i), !1, c), e.children().trigger("focus");break;default:
        return;}
  }, b.prototype.checkNavigable = function (a) {
    var c,
        d,
        b = this;if (c = b.getNavigableIndexes(), d = 0, a > c[c.length - 1]) a = c[c.length - 1];else for (var e in c) {
      if (a < c[e]) {
        a = d;break;
      }d = c[e];
    }return a;
  }, b.prototype.cleanUpEvents = function () {
    var b = this;b.options.dots && null !== b.$dots && a("li", b.$dots).off("click.slick", b.changeSlide).off("mouseenter.slick", a.proxy(b.interrupt, b, !0)).off("mouseleave.slick", a.proxy(b.interrupt, b, !1)), b.$slider.off("focus.slick blur.slick"), b.options.arrows === !0 && b.slideCount > b.options.slidesToShow && (b.$prevArrow && b.$prevArrow.off("click.slick", b.changeSlide), b.$nextArrow && b.$nextArrow.off("click.slick", b.changeSlide)), b.$list.off("touchstart.slick mousedown.slick", b.swipeHandler), b.$list.off("touchmove.slick mousemove.slick", b.swipeHandler), b.$list.off("touchend.slick mouseup.slick", b.swipeHandler), b.$list.off("touchcancel.slick mouseleave.slick", b.swipeHandler), b.$list.off("click.slick", b.clickHandler), a(document).off(b.visibilityChange, b.visibility), b.cleanUpSlideEvents(), b.options.accessibility === !0 && b.$list.off("keydown.slick", b.keyHandler), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().off("click.slick", b.selectHandler), a(window).off("orientationchange.slick.slick-" + b.instanceUid, b.orientationChange), a(window).off("resize.slick.slick-" + b.instanceUid, b.resize), a("[draggable!=true]", b.$slideTrack).off("dragstart", b.preventDefault), a(window).off("load.slick.slick-" + b.instanceUid, b.setPosition), a(document).off("ready.slick.slick-" + b.instanceUid, b.setPosition);
  }, b.prototype.cleanUpSlideEvents = function () {
    var b = this;b.$list.off("mouseenter.slick", a.proxy(b.interrupt, b, !0)), b.$list.off("mouseleave.slick", a.proxy(b.interrupt, b, !1));
  }, b.prototype.cleanUpRows = function () {
    var b,
        a = this;a.options.rows > 1 && (b = a.$slides.children().children(), b.removeAttr("style"), a.$slider.empty().append(b));
  }, b.prototype.clickHandler = function (a) {
    var b = this;b.shouldClick === !1 && (a.stopImmediatePropagation(), a.stopPropagation(), a.preventDefault());
  }, b.prototype.destroy = function (b) {
    var c = this;c.autoPlayClear(), c.touchObject = {}, c.cleanUpEvents(), a(".slick-cloned", c.$slider).detach(), c.$dots && c.$dots.remove(), c.$prevArrow && c.$prevArrow.length && (c.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), c.htmlExpr.test(c.options.prevArrow) && c.$prevArrow.remove()), c.$nextArrow && c.$nextArrow.length && (c.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), c.htmlExpr.test(c.options.nextArrow) && c.$nextArrow.remove()), c.$slides && (c.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function () {
      a(this).attr("style", a(this).data("originalStyling"));
    }), c.$slideTrack.children(this.options.slide).detach(), c.$slideTrack.detach(), c.$list.detach(), c.$slider.append(c.$slides)), c.cleanUpRows(), c.$slider.removeClass("slick-slider"), c.$slider.removeClass("slick-initialized"), c.$slider.removeClass("slick-dotted"), c.unslicked = !0, b || c.$slider.trigger("destroy", [c]);
  }, b.prototype.disableTransition = function (a) {
    var b = this,
        c = {};c[b.transitionType] = "", b.options.fade === !1 ? b.$slideTrack.css(c) : b.$slides.eq(a).css(c);
  }, b.prototype.fadeSlide = function (a, b) {
    var c = this;c.cssTransitions === !1 ? (c.$slides.eq(a).css({ zIndex: c.options.zIndex }), c.$slides.eq(a).animate({ opacity: 1 }, c.options.speed, c.options.easing, b)) : (c.applyTransition(a), c.$slides.eq(a).css({ opacity: 1, zIndex: c.options.zIndex }), b && setTimeout(function () {
      c.disableTransition(a), b.call();
    }, c.options.speed));
  }, b.prototype.fadeSlideOut = function (a) {
    var b = this;b.cssTransitions === !1 ? b.$slides.eq(a).animate({ opacity: 0, zIndex: b.options.zIndex - 2 }, b.options.speed, b.options.easing) : (b.applyTransition(a), b.$slides.eq(a).css({ opacity: 0, zIndex: b.options.zIndex - 2 }));
  }, b.prototype.filterSlides = b.prototype.slickFilter = function (a) {
    var b = this;null !== a && (b.$slidesCache = b.$slides, b.unload(), b.$slideTrack.children(this.options.slide).detach(), b.$slidesCache.filter(a).appendTo(b.$slideTrack), b.reinit());
  }, b.prototype.focusHandler = function () {
    var b = this;b.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*:not(.slick-arrow)", function (c) {
      c.stopImmediatePropagation();var d = a(this);setTimeout(function () {
        b.options.pauseOnFocus && (b.focussed = d.is(":focus"), b.autoPlay());
      }, 0);
    });
  }, b.prototype.getCurrent = b.prototype.slickCurrentSlide = function () {
    var a = this;return a.currentSlide;
  }, b.prototype.getDotCount = function () {
    var a = this,
        b = 0,
        c = 0,
        d = 0;if (a.options.infinite === !0) for (; b < a.slideCount;) {
      ++d, b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
    } else if (a.options.centerMode === !0) d = a.slideCount;else if (a.options.asNavFor) for (; b < a.slideCount;) {
      ++d, b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
    } else d = 1 + Math.ceil((a.slideCount - a.options.slidesToShow) / a.options.slidesToScroll);return d - 1;
  }, b.prototype.getLeft = function (a) {
    var c,
        d,
        f,
        b = this,
        e = 0;return b.slideOffset = 0, d = b.$slides.first().outerHeight(!0), b.options.infinite === !0 ? (b.slideCount > b.options.slidesToShow && (b.slideOffset = b.slideWidth * b.options.slidesToShow * -1, e = d * b.options.slidesToShow * -1), b.slideCount % b.options.slidesToScroll !== 0 && a + b.options.slidesToScroll > b.slideCount && b.slideCount > b.options.slidesToShow && (a > b.slideCount ? (b.slideOffset = (b.options.slidesToShow - (a - b.slideCount)) * b.slideWidth * -1, e = (b.options.slidesToShow - (a - b.slideCount)) * d * -1) : (b.slideOffset = b.slideCount % b.options.slidesToScroll * b.slideWidth * -1, e = b.slideCount % b.options.slidesToScroll * d * -1))) : a + b.options.slidesToShow > b.slideCount && (b.slideOffset = (a + b.options.slidesToShow - b.slideCount) * b.slideWidth, e = (a + b.options.slidesToShow - b.slideCount) * d), b.slideCount <= b.options.slidesToShow && (b.slideOffset = 0, e = 0), b.options.centerMode === !0 && b.options.infinite === !0 ? b.slideOffset += b.slideWidth * Math.floor(b.options.slidesToShow / 2) - b.slideWidth : b.options.centerMode === !0 && (b.slideOffset = 0, b.slideOffset += b.slideWidth * Math.floor(b.options.slidesToShow / 2)), c = b.options.vertical === !1 ? a * b.slideWidth * -1 + b.slideOffset : a * d * -1 + e, b.options.variableWidth === !0 && (f = b.slideCount <= b.options.slidesToShow || b.options.infinite === !1 ? b.$slideTrack.children(".slick-slide").eq(a) : b.$slideTrack.children(".slick-slide").eq(a + b.options.slidesToShow), c = b.options.rtl === !0 ? f[0] ? -1 * (b.$slideTrack.width() - f[0].offsetLeft - f.width()) : 0 : f[0] ? -1 * f[0].offsetLeft : 0, b.options.centerMode === !0 && (f = b.slideCount <= b.options.slidesToShow || b.options.infinite === !1 ? b.$slideTrack.children(".slick-slide").eq(a) : b.$slideTrack.children(".slick-slide").eq(a + b.options.slidesToShow + 1), c = b.options.rtl === !0 ? f[0] ? -1 * (b.$slideTrack.width() - f[0].offsetLeft - f.width()) : 0 : f[0] ? -1 * f[0].offsetLeft : 0, c += (b.$list.width() - f.outerWidth()) / 2)), c;
  }, b.prototype.getOption = b.prototype.slickGetOption = function (a) {
    var b = this;return b.options[a];
  }, b.prototype.getNavigableIndexes = function () {
    var e,
        a = this,
        b = 0,
        c = 0,
        d = [];for (a.options.infinite === !1 ? e = a.slideCount : (b = -1 * a.options.slidesToScroll, c = -1 * a.options.slidesToScroll, e = 2 * a.slideCount); e > b;) {
      d.push(b), b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
    }return d;
  }, b.prototype.getSlick = function () {
    return this;
  }, b.prototype.getSlideCount = function () {
    var c,
        d,
        e,
        b = this;return e = b.options.centerMode === !0 ? b.slideWidth * Math.floor(b.options.slidesToShow / 2) : 0, b.options.swipeToSlide === !0 ? (b.$slideTrack.find(".slick-slide").each(function (c, f) {
      return f.offsetLeft - e + a(f).outerWidth() / 2 > -1 * b.swipeLeft ? (d = f, !1) : void 0;
    }), c = Math.abs(a(d).attr("data-slick-index") - b.currentSlide) || 1) : b.options.slidesToScroll;
  }, b.prototype.goTo = b.prototype.slickGoTo = function (a, b) {
    var c = this;c.changeSlide({ data: { message: "index", index: parseInt(a) } }, b);
  }, b.prototype.init = function (b) {
    var c = this;a(c.$slider).hasClass("slick-initialized") || (a(c.$slider).addClass("slick-initialized"), c.buildRows(), c.buildOut(), c.setProps(), c.startLoad(), c.loadSlider(), c.initializeEvents(), c.updateArrows(), c.updateDots(), c.checkResponsive(!0), c.focusHandler()), b && c.$slider.trigger("init", [c]), c.options.accessibility === !0 && c.initADA(), c.options.autoplay && (c.paused = !1, c.autoPlay());
  }, b.prototype.initADA = function () {
    var b = this;b.$slides.add(b.$slideTrack.find(".slick-cloned")).attr({ "aria-hidden": "true", tabindex: "-1" }).find("a, input, button, select").attr({ tabindex: "-1" }), b.$slideTrack.attr("role", "listbox"), b.$slides.not(b.$slideTrack.find(".slick-cloned")).each(function (c) {
      a(this).attr({ role: "option", "aria-describedby": "slick-slide" + b.instanceUid + c });
    }), null !== b.$dots && b.$dots.attr("role", "tablist").find("li").each(function (c) {
      a(this).attr({ role: "presentation", "aria-selected": "false", "aria-controls": "navigation" + b.instanceUid + c, id: "slick-slide" + b.instanceUid + c });
    }).first().attr("aria-selected", "true").end().find("button").attr("role", "button").end().closest("div").attr("role", "toolbar"), b.activateADA();
  }, b.prototype.initArrowEvents = function () {
    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.off("click.slick").on("click.slick", { message: "previous" }, a.changeSlide), a.$nextArrow.off("click.slick").on("click.slick", { message: "next" }, a.changeSlide));
  }, b.prototype.initDotEvents = function () {
    var b = this;b.options.dots === !0 && b.slideCount > b.options.slidesToShow && a("li", b.$dots).on("click.slick", { message: "index" }, b.changeSlide), b.options.dots === !0 && b.options.pauseOnDotsHover === !0 && a("li", b.$dots).on("mouseenter.slick", a.proxy(b.interrupt, b, !0)).on("mouseleave.slick", a.proxy(b.interrupt, b, !1));
  }, b.prototype.initSlideEvents = function () {
    var b = this;b.options.pauseOnHover && (b.$list.on("mouseenter.slick", a.proxy(b.interrupt, b, !0)), b.$list.on("mouseleave.slick", a.proxy(b.interrupt, b, !1)));
  }, b.prototype.initializeEvents = function () {
    var b = this;b.initArrowEvents(), b.initDotEvents(), b.initSlideEvents(), b.$list.on("touchstart.slick mousedown.slick", { action: "start" }, b.swipeHandler), b.$list.on("touchmove.slick mousemove.slick", { action: "move" }, b.swipeHandler), b.$list.on("touchend.slick mouseup.slick", { action: "end" }, b.swipeHandler), b.$list.on("touchcancel.slick mouseleave.slick", { action: "end" }, b.swipeHandler), b.$list.on("click.slick", b.clickHandler), a(document).on(b.visibilityChange, a.proxy(b.visibility, b)), b.options.accessibility === !0 && b.$list.on("keydown.slick", b.keyHandler), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().on("click.slick", b.selectHandler), a(window).on("orientationchange.slick.slick-" + b.instanceUid, a.proxy(b.orientationChange, b)), a(window).on("resize.slick.slick-" + b.instanceUid, a.proxy(b.resize, b)), a("[draggable!=true]", b.$slideTrack).on("dragstart", b.preventDefault), a(window).on("load.slick.slick-" + b.instanceUid, b.setPosition), a(document).on("ready.slick.slick-" + b.instanceUid, b.setPosition);
  }, b.prototype.initUI = function () {
    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.show(), a.$nextArrow.show()), a.options.dots === !0 && a.slideCount > a.options.slidesToShow && a.$dots.show();
  }, b.prototype.keyHandler = function (a) {
    var b = this;a.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === a.keyCode && b.options.accessibility === !0 ? b.changeSlide({ data: { message: b.options.rtl === !0 ? "next" : "previous" } }) : 39 === a.keyCode && b.options.accessibility === !0 && b.changeSlide({ data: { message: b.options.rtl === !0 ? "previous" : "next" } }));
  }, b.prototype.lazyLoad = function () {
    function g(c) {
      a("img[data-lazy]", c).each(function () {
        var c = a(this),
            d = a(this).attr("data-lazy"),
            e = document.createElement("img");e.onload = function () {
          c.animate({ opacity: 0 }, 100, function () {
            c.attr("src", d).animate({ opacity: 1 }, 200, function () {
              c.removeAttr("data-lazy").removeClass("slick-loading");
            }), b.$slider.trigger("lazyLoaded", [b, c, d]);
          });
        }, e.onerror = function () {
          c.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), b.$slider.trigger("lazyLoadError", [b, c, d]);
        }, e.src = d;
      });
    }var c,
        d,
        e,
        f,
        b = this;b.options.centerMode === !0 ? b.options.infinite === !0 ? (e = b.currentSlide + (b.options.slidesToShow / 2 + 1), f = e + b.options.slidesToShow + 2) : (e = Math.max(0, b.currentSlide - (b.options.slidesToShow / 2 + 1)), f = 2 + (b.options.slidesToShow / 2 + 1) + b.currentSlide) : (e = b.options.infinite ? b.options.slidesToShow + b.currentSlide : b.currentSlide, f = Math.ceil(e + b.options.slidesToShow), b.options.fade === !0 && (e > 0 && e--, f <= b.slideCount && f++)), c = b.$slider.find(".slick-slide").slice(e, f), g(c), b.slideCount <= b.options.slidesToShow ? (d = b.$slider.find(".slick-slide"), g(d)) : b.currentSlide >= b.slideCount - b.options.slidesToShow ? (d = b.$slider.find(".slick-cloned").slice(0, b.options.slidesToShow), g(d)) : 0 === b.currentSlide && (d = b.$slider.find(".slick-cloned").slice(-1 * b.options.slidesToShow), g(d));
  }, b.prototype.loadSlider = function () {
    var a = this;a.setPosition(), a.$slideTrack.css({ opacity: 1 }), a.$slider.removeClass("slick-loading"), a.initUI(), "progressive" === a.options.lazyLoad && a.progressiveLazyLoad();
  }, b.prototype.next = b.prototype.slickNext = function () {
    var a = this;a.changeSlide({ data: { message: "next" } });
  }, b.prototype.orientationChange = function () {
    var a = this;a.checkResponsive(), a.setPosition();
  }, b.prototype.pause = b.prototype.slickPause = function () {
    var a = this;a.autoPlayClear(), a.paused = !0;
  }, b.prototype.play = b.prototype.slickPlay = function () {
    var a = this;a.autoPlay(), a.options.autoplay = !0, a.paused = !1, a.focussed = !1, a.interrupted = !1;
  }, b.prototype.postSlide = function (a) {
    var b = this;b.unslicked || (b.$slider.trigger("afterChange", [b, a]), b.animating = !1, b.setPosition(), b.swipeLeft = null, b.options.autoplay && b.autoPlay(), b.options.accessibility === !0 && b.initADA());
  }, b.prototype.prev = b.prototype.slickPrev = function () {
    var a = this;a.changeSlide({ data: { message: "previous" } });
  }, b.prototype.preventDefault = function (a) {
    a.preventDefault();
  }, b.prototype.progressiveLazyLoad = function (b) {
    b = b || 1;var e,
        f,
        g,
        c = this,
        d = a("img[data-lazy]", c.$slider);d.length ? (e = d.first(), f = e.attr("data-lazy"), g = document.createElement("img"), g.onload = function () {
      e.attr("src", f).removeAttr("data-lazy").removeClass("slick-loading"), c.options.adaptiveHeight === !0 && c.setPosition(), c.$slider.trigger("lazyLoaded", [c, e, f]), c.progressiveLazyLoad();
    }, g.onerror = function () {
      3 > b ? setTimeout(function () {
        c.progressiveLazyLoad(b + 1);
      }, 500) : (e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), c.$slider.trigger("lazyLoadError", [c, e, f]), c.progressiveLazyLoad());
    }, g.src = f) : c.$slider.trigger("allImagesLoaded", [c]);
  }, b.prototype.refresh = function (b) {
    var d,
        e,
        c = this;e = c.slideCount - c.options.slidesToShow, !c.options.infinite && c.currentSlide > e && (c.currentSlide = e), c.slideCount <= c.options.slidesToShow && (c.currentSlide = 0), d = c.currentSlide, c.destroy(!0), a.extend(c, c.initials, { currentSlide: d }), c.init(), b || c.changeSlide({ data: { message: "index", index: d } }, !1);
  }, b.prototype.registerBreakpoints = function () {
    var c,
        d,
        e,
        b = this,
        f = b.options.responsive || null;if ("array" === a.type(f) && f.length) {
      b.respondTo = b.options.respondTo || "window";for (c in f) {
        if (e = b.breakpoints.length - 1, d = f[c].breakpoint, f.hasOwnProperty(c)) {
          for (; e >= 0;) {
            b.breakpoints[e] && b.breakpoints[e] === d && b.breakpoints.splice(e, 1), e--;
          }b.breakpoints.push(d), b.breakpointSettings[d] = f[c].settings;
        }
      }b.breakpoints.sort(function (a, c) {
        return b.options.mobileFirst ? a - c : c - a;
      });
    }
  }, b.prototype.reinit = function () {
    var b = this;b.$slides = b.$slideTrack.children(b.options.slide).addClass("slick-slide"), b.slideCount = b.$slides.length, b.currentSlide >= b.slideCount && 0 !== b.currentSlide && (b.currentSlide = b.currentSlide - b.options.slidesToScroll), b.slideCount <= b.options.slidesToShow && (b.currentSlide = 0), b.registerBreakpoints(), b.setProps(), b.setupInfinite(), b.buildArrows(), b.updateArrows(), b.initArrowEvents(), b.buildDots(), b.updateDots(), b.initDotEvents(), b.cleanUpSlideEvents(), b.initSlideEvents(), b.checkResponsive(!1, !0), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().on("click.slick", b.selectHandler), b.setSlideClasses("number" == typeof b.currentSlide ? b.currentSlide : 0), b.setPosition(), b.focusHandler(), b.paused = !b.options.autoplay, b.autoPlay(), b.$slider.trigger("reInit", [b]);
  }, b.prototype.resize = function () {
    var b = this;a(window).width() !== b.windowWidth && (clearTimeout(b.windowDelay), b.windowDelay = window.setTimeout(function () {
      b.windowWidth = a(window).width(), b.checkResponsive(), b.unslicked || b.setPosition();
    }, 50));
  }, b.prototype.removeSlide = b.prototype.slickRemove = function (a, b, c) {
    var d = this;return "boolean" == typeof a ? (b = a, a = b === !0 ? 0 : d.slideCount - 1) : a = b === !0 ? --a : a, d.slideCount < 1 || 0 > a || a > d.slideCount - 1 ? !1 : (d.unload(), c === !0 ? d.$slideTrack.children().remove() : d.$slideTrack.children(this.options.slide).eq(a).remove(), d.$slides = d.$slideTrack.children(this.options.slide), d.$slideTrack.children(this.options.slide).detach(), d.$slideTrack.append(d.$slides), d.$slidesCache = d.$slides, void d.reinit());
  }, b.prototype.setCSS = function (a) {
    var d,
        e,
        b = this,
        c = {};b.options.rtl === !0 && (a = -a), d = "left" == b.positionProp ? Math.ceil(a) + "px" : "0px", e = "top" == b.positionProp ? Math.ceil(a) + "px" : "0px", c[b.positionProp] = a, b.transformsEnabled === !1 ? b.$slideTrack.css(c) : (c = {}, b.cssTransitions === !1 ? (c[b.animType] = "translate(" + d + ", " + e + ")", b.$slideTrack.css(c)) : (c[b.animType] = "translate3d(" + d + ", " + e + ", 0px)", b.$slideTrack.css(c)));
  }, b.prototype.setDimensions = function () {
    var a = this;a.options.vertical === !1 ? a.options.centerMode === !0 && a.$list.css({ padding: "0px " + a.options.centerPadding }) : (a.$list.height(a.$slides.first().outerHeight(!0) * a.options.slidesToShow), a.options.centerMode === !0 && a.$list.css({ padding: a.options.centerPadding + " 0px" })), a.listWidth = a.$list.width(), a.listHeight = a.$list.height(), a.options.vertical === !1 && a.options.variableWidth === !1 ? (a.slideWidth = Math.ceil(a.listWidth / a.options.slidesToShow), a.$slideTrack.width(Math.ceil(a.slideWidth * a.$slideTrack.children(".slick-slide").length))) : a.options.variableWidth === !0 ? a.$slideTrack.width(5e3 * a.slideCount) : (a.slideWidth = Math.ceil(a.listWidth), a.$slideTrack.height(Math.ceil(a.$slides.first().outerHeight(!0) * a.$slideTrack.children(".slick-slide").length)));var b = a.$slides.first().outerWidth(!0) - a.$slides.first().width();a.options.variableWidth === !1 && a.$slideTrack.children(".slick-slide").width(a.slideWidth - b);
  }, b.prototype.setFade = function () {
    var c,
        b = this;b.$slides.each(function (d, e) {
      c = b.slideWidth * d * -1, b.options.rtl === !0 ? a(e).css({ position: "relative", right: c, top: 0, zIndex: b.options.zIndex - 2, opacity: 0 }) : a(e).css({ position: "relative", left: c, top: 0, zIndex: b.options.zIndex - 2, opacity: 0 });
    }), b.$slides.eq(b.currentSlide).css({ zIndex: b.options.zIndex - 1, opacity: 1 });
  }, b.prototype.setHeight = function () {
    var a = this;if (1 === a.options.slidesToShow && a.options.adaptiveHeight === !0 && a.options.vertical === !1) {
      var b = a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.css("height", b);
    }
  }, b.prototype.setOption = b.prototype.slickSetOption = function () {
    var c,
        d,
        e,
        f,
        h,
        b = this,
        g = !1;if ("object" === a.type(arguments[0]) ? (e = arguments[0], g = arguments[1], h = "multiple") : "string" === a.type(arguments[0]) && (e = arguments[0], f = arguments[1], g = arguments[2], "responsive" === arguments[0] && "array" === a.type(arguments[1]) ? h = "responsive" : "undefined" != typeof arguments[1] && (h = "single")), "single" === h) b.options[e] = f;else if ("multiple" === h) a.each(e, function (a, c) {
      b.options[a] = c;
    });else if ("responsive" === h) for (d in f) {
      if ("array" !== a.type(b.options.responsive)) b.options.responsive = [f[d]];else {
        for (c = b.options.responsive.length - 1; c >= 0;) {
          b.options.responsive[c].breakpoint === f[d].breakpoint && b.options.responsive.splice(c, 1), c--;
        }b.options.responsive.push(f[d]);
      }
    }g && (b.unload(), b.reinit());
  }, b.prototype.setPosition = function () {
    var a = this;a.setDimensions(), a.setHeight(), a.options.fade === !1 ? a.setCSS(a.getLeft(a.currentSlide)) : a.setFade(), a.$slider.trigger("setPosition", [a]);
  }, b.prototype.setProps = function () {
    var a = this,
        b = document.body.style;a.positionProp = a.options.vertical === !0 ? "top" : "left", "top" === a.positionProp ? a.$slider.addClass("slick-vertical") : a.$slider.removeClass("slick-vertical"), (void 0 !== b.WebkitTransition || void 0 !== b.MozTransition || void 0 !== b.msTransition) && a.options.useCSS === !0 && (a.cssTransitions = !0), a.options.fade && ("number" == typeof a.options.zIndex ? a.options.zIndex < 3 && (a.options.zIndex = 3) : a.options.zIndex = a.defaults.zIndex), void 0 !== b.OTransform && (a.animType = "OTransform", a.transformType = "-o-transform", a.transitionType = "OTransition", void 0 === b.perspectiveProperty && void 0 === b.webkitPerspective && (a.animType = !1)), void 0 !== b.MozTransform && (a.animType = "MozTransform", a.transformType = "-moz-transform", a.transitionType = "MozTransition", void 0 === b.perspectiveProperty && void 0 === b.MozPerspective && (a.animType = !1)), void 0 !== b.webkitTransform && (a.animType = "webkitTransform", a.transformType = "-webkit-transform", a.transitionType = "webkitTransition", void 0 === b.perspectiveProperty && void 0 === b.webkitPerspective && (a.animType = !1)), void 0 !== b.msTransform && (a.animType = "msTransform", a.transformType = "-ms-transform", a.transitionType = "msTransition", void 0 === b.msTransform && (a.animType = !1)), void 0 !== b.transform && a.animType !== !1 && (a.animType = "transform", a.transformType = "transform", a.transitionType = "transition"), a.transformsEnabled = a.options.useTransform && null !== a.animType && a.animType !== !1;
  }, b.prototype.setSlideClasses = function (a) {
    var c,
        d,
        e,
        f,
        b = this;d = b.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), b.$slides.eq(a).addClass("slick-current"), b.options.centerMode === !0 ? (c = Math.floor(b.options.slidesToShow / 2), b.options.infinite === !0 && (a >= c && a <= b.slideCount - 1 - c ? b.$slides.slice(a - c, a + c + 1).addClass("slick-active").attr("aria-hidden", "false") : (e = b.options.slidesToShow + a, d.slice(e - c + 1, e + c + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === a ? d.eq(d.length - 1 - b.options.slidesToShow).addClass("slick-center") : a === b.slideCount - 1 && d.eq(b.options.slidesToShow).addClass("slick-center")), b.$slides.eq(a).addClass("slick-center")) : a >= 0 && a <= b.slideCount - b.options.slidesToShow ? b.$slides.slice(a, a + b.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : d.length <= b.options.slidesToShow ? d.addClass("slick-active").attr("aria-hidden", "false") : (f = b.slideCount % b.options.slidesToShow, e = b.options.infinite === !0 ? b.options.slidesToShow + a : a, b.options.slidesToShow == b.options.slidesToScroll && b.slideCount - a < b.options.slidesToShow ? d.slice(e - (b.options.slidesToShow - f), e + f).addClass("slick-active").attr("aria-hidden", "false") : d.slice(e, e + b.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false")), "ondemand" === b.options.lazyLoad && b.lazyLoad();
  }, b.prototype.setupInfinite = function () {
    var c,
        d,
        e,
        b = this;if (b.options.fade === !0 && (b.options.centerMode = !1), b.options.infinite === !0 && b.options.fade === !1 && (d = null, b.slideCount > b.options.slidesToShow)) {
      for (e = b.options.centerMode === !0 ? b.options.slidesToShow + 1 : b.options.slidesToShow, c = b.slideCount; c > b.slideCount - e; c -= 1) {
        d = c - 1, a(b.$slides[d]).clone(!0).attr("id", "").attr("data-slick-index", d - b.slideCount).prependTo(b.$slideTrack).addClass("slick-cloned");
      }for (c = 0; e > c; c += 1) {
        d = c, a(b.$slides[d]).clone(!0).attr("id", "").attr("data-slick-index", d + b.slideCount).appendTo(b.$slideTrack).addClass("slick-cloned");
      }b.$slideTrack.find(".slick-cloned").find("[id]").each(function () {
        a(this).attr("id", "");
      });
    }
  }, b.prototype.interrupt = function (a) {
    var b = this;a || b.autoPlay(), b.interrupted = a;
  }, b.prototype.selectHandler = function (b) {
    var c = this,
        d = a(b.target).is(".slick-slide") ? a(b.target) : a(b.target).parents(".slick-slide"),
        e = parseInt(d.attr("data-slick-index"));return e || (e = 0), c.slideCount <= c.options.slidesToShow ? (c.setSlideClasses(e), void c.asNavFor(e)) : void c.slideHandler(e);
  }, b.prototype.slideHandler = function (a, b, c) {
    var d,
        e,
        f,
        g,
        j,
        h = null,
        i = this;return b = b || !1, i.animating === !0 && i.options.waitForAnimate === !0 || i.options.fade === !0 && i.currentSlide === a || i.slideCount <= i.options.slidesToShow ? void 0 : (b === !1 && i.asNavFor(a), d = a, h = i.getLeft(d), g = i.getLeft(i.currentSlide), i.currentLeft = null === i.swipeLeft ? g : i.swipeLeft, i.options.infinite === !1 && i.options.centerMode === !1 && (0 > a || a > i.getDotCount() * i.options.slidesToScroll) ? void (i.options.fade === !1 && (d = i.currentSlide, c !== !0 ? i.animateSlide(g, function () {
      i.postSlide(d);
    }) : i.postSlide(d))) : i.options.infinite === !1 && i.options.centerMode === !0 && (0 > a || a > i.slideCount - i.options.slidesToScroll) ? void (i.options.fade === !1 && (d = i.currentSlide, c !== !0 ? i.animateSlide(g, function () {
      i.postSlide(d);
    }) : i.postSlide(d))) : (i.options.autoplay && clearInterval(i.autoPlayTimer), e = 0 > d ? i.slideCount % i.options.slidesToScroll !== 0 ? i.slideCount - i.slideCount % i.options.slidesToScroll : i.slideCount + d : d >= i.slideCount ? i.slideCount % i.options.slidesToScroll !== 0 ? 0 : d - i.slideCount : d, i.animating = !0, i.$slider.trigger("beforeChange", [i, i.currentSlide, e]), f = i.currentSlide, i.currentSlide = e, i.setSlideClasses(i.currentSlide), i.options.asNavFor && (j = i.getNavTarget(), j = j.slick("getSlick"), j.slideCount <= j.options.slidesToShow && j.setSlideClasses(i.currentSlide)), i.updateDots(), i.updateArrows(), i.options.fade === !0 ? (c !== !0 ? (i.fadeSlideOut(f), i.fadeSlide(e, function () {
      i.postSlide(e);
    })) : i.postSlide(e), void i.animateHeight()) : void (c !== !0 ? i.animateSlide(h, function () {
      i.postSlide(e);
    }) : i.postSlide(e))));
  }, b.prototype.startLoad = function () {
    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.hide(), a.$nextArrow.hide()), a.options.dots === !0 && a.slideCount > a.options.slidesToShow && a.$dots.hide(), a.$slider.addClass("slick-loading");
  }, b.prototype.swipeDirection = function () {
    var a,
        b,
        c,
        d,
        e = this;return a = e.touchObject.startX - e.touchObject.curX, b = e.touchObject.startY - e.touchObject.curY, c = Math.atan2(b, a), d = Math.round(180 * c / Math.PI), 0 > d && (d = 360 - Math.abs(d)), 45 >= d && d >= 0 ? e.options.rtl === !1 ? "left" : "right" : 360 >= d && d >= 315 ? e.options.rtl === !1 ? "left" : "right" : d >= 135 && 225 >= d ? e.options.rtl === !1 ? "right" : "left" : e.options.verticalSwiping === !0 ? d >= 35 && 135 >= d ? "down" : "up" : "vertical";
  }, b.prototype.swipeEnd = function (a) {
    var c,
        d,
        b = this;if (b.dragging = !1, b.interrupted = !1, b.shouldClick = b.touchObject.swipeLength > 10 ? !1 : !0, void 0 === b.touchObject.curX) return !1;if (b.touchObject.edgeHit === !0 && b.$slider.trigger("edge", [b, b.swipeDirection()]), b.touchObject.swipeLength >= b.touchObject.minSwipe) {
      switch (d = b.swipeDirection()) {case "left":case "down":
          c = b.options.swipeToSlide ? b.checkNavigable(b.currentSlide + b.getSlideCount()) : b.currentSlide + b.getSlideCount(), b.currentDirection = 0;break;case "right":case "up":
          c = b.options.swipeToSlide ? b.checkNavigable(b.currentSlide - b.getSlideCount()) : b.currentSlide - b.getSlideCount(), b.currentDirection = 1;}"vertical" != d && (b.slideHandler(c), b.touchObject = {}, b.$slider.trigger("swipe", [b, d]));
    } else b.touchObject.startX !== b.touchObject.curX && (b.slideHandler(b.currentSlide), b.touchObject = {});
  }, b.prototype.swipeHandler = function (a) {
    var b = this;if (!(b.options.swipe === !1 || "ontouchend" in document && b.options.swipe === !1 || b.options.draggable === !1 && -1 !== a.type.indexOf("mouse"))) switch (b.touchObject.fingerCount = a.originalEvent && void 0 !== a.originalEvent.touches ? a.originalEvent.touches.length : 1, b.touchObject.minSwipe = b.listWidth / b.options.touchThreshold, b.options.verticalSwiping === !0 && (b.touchObject.minSwipe = b.listHeight / b.options.touchThreshold), a.data.action) {case "start":
        b.swipeStart(a);break;case "move":
        b.swipeMove(a);break;case "end":
        b.swipeEnd(a);}
  }, b.prototype.swipeMove = function (a) {
    var d,
        e,
        f,
        g,
        h,
        b = this;return h = void 0 !== a.originalEvent ? a.originalEvent.touches : null, !b.dragging || h && 1 !== h.length ? !1 : (d = b.getLeft(b.currentSlide), b.touchObject.curX = void 0 !== h ? h[0].pageX : a.clientX, b.touchObject.curY = void 0 !== h ? h[0].pageY : a.clientY, b.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(b.touchObject.curX - b.touchObject.startX, 2))), b.options.verticalSwiping === !0 && (b.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(b.touchObject.curY - b.touchObject.startY, 2)))), e = b.swipeDirection(), "vertical" !== e ? (void 0 !== a.originalEvent && b.touchObject.swipeLength > 4 && a.preventDefault(), g = (b.options.rtl === !1 ? 1 : -1) * (b.touchObject.curX > b.touchObject.startX ? 1 : -1), b.options.verticalSwiping === !0 && (g = b.touchObject.curY > b.touchObject.startY ? 1 : -1), f = b.touchObject.swipeLength, b.touchObject.edgeHit = !1, b.options.infinite === !1 && (0 === b.currentSlide && "right" === e || b.currentSlide >= b.getDotCount() && "left" === e) && (f = b.touchObject.swipeLength * b.options.edgeFriction, b.touchObject.edgeHit = !0), b.options.vertical === !1 ? b.swipeLeft = d + f * g : b.swipeLeft = d + f * (b.$list.height() / b.listWidth) * g, b.options.verticalSwiping === !0 && (b.swipeLeft = d + f * g), b.options.fade === !0 || b.options.touchMove === !1 ? !1 : b.animating === !0 ? (b.swipeLeft = null, !1) : void b.setCSS(b.swipeLeft)) : void 0);
  }, b.prototype.swipeStart = function (a) {
    var c,
        b = this;return b.interrupted = !0, 1 !== b.touchObject.fingerCount || b.slideCount <= b.options.slidesToShow ? (b.touchObject = {}, !1) : (void 0 !== a.originalEvent && void 0 !== a.originalEvent.touches && (c = a.originalEvent.touches[0]), b.touchObject.startX = b.touchObject.curX = void 0 !== c ? c.pageX : a.clientX, b.touchObject.startY = b.touchObject.curY = void 0 !== c ? c.pageY : a.clientY, void (b.dragging = !0));
  }, b.prototype.unfilterSlides = b.prototype.slickUnfilter = function () {
    var a = this;null !== a.$slidesCache && (a.unload(), a.$slideTrack.children(this.options.slide).detach(), a.$slidesCache.appendTo(a.$slideTrack), a.reinit());
  }, b.prototype.unload = function () {
    var b = this;a(".slick-cloned", b.$slider).remove(), b.$dots && b.$dots.remove(), b.$prevArrow && b.htmlExpr.test(b.options.prevArrow) && b.$prevArrow.remove(), b.$nextArrow && b.htmlExpr.test(b.options.nextArrow) && b.$nextArrow.remove(), b.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "");
  }, b.prototype.unslick = function (a) {
    var b = this;b.$slider.trigger("unslick", [b, a]), b.destroy();
  }, b.prototype.updateArrows = function () {
    var b,
        a = this;b = Math.floor(a.options.slidesToShow / 2), a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && !a.options.infinite && (a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === a.currentSlide ? (a.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : a.currentSlide >= a.slideCount - a.options.slidesToShow && a.options.centerMode === !1 ? (a.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : a.currentSlide >= a.slideCount - 1 && a.options.centerMode === !0 && (a.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")));
  }, b.prototype.updateDots = function () {
    var a = this;null !== a.$dots && (a.$dots.find("li").removeClass("slick-active").attr("aria-hidden", "true"), a.$dots.find("li").eq(Math.floor(a.currentSlide / a.options.slidesToScroll)).addClass("slick-active").attr("aria-hidden", "false"));
  }, b.prototype.visibility = function () {
    var a = this;a.options.autoplay && (document[a.hidden] ? a.interrupted = !0 : a.interrupted = !1);
  }, a.fn.slick = function () {
    var f,
        g,
        a = this,
        c = arguments[0],
        d = Array.prototype.slice.call(arguments, 1),
        e = a.length;for (f = 0; e > f; f++) {
      if ("object" == typeof c || "undefined" == typeof c ? a[f].slick = new b(a[f], c) : g = a[f].slick[c].apply(a[f].slick, d), "undefined" != typeof g) return g;
    }return a;
  };
});
;"use strict";

/*! purl v2.3.1 | MIT */
(function (factory) {
  if (typeof define === "function" && define.amd) {
    define(factory);
  } else {
    window.purl = factory();
  }
})(function () {
  var tag2attr = { a: "href", img: "src", form: "action", base: "href", script: "src", iframe: "src", link: "href" },
      key = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "fragment"],
      aliases = { anchor: "fragment" },
      parser = { strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ },
      isint = /^[0-9]+$/;function parseUri(url, strictMode) {
    var str = decodeURI(url),
        res = parser[strictMode || false ? "strict" : "loose"].exec(str),
        uri = { attr: {}, param: {}, seg: {} },
        i = 14;while (i--) {
      uri.attr[key[i]] = res[i] || "";
    }uri.param["query"] = parseString(uri.attr["query"]);uri.param["fragment"] = parseString(uri.attr["fragment"]);uri.seg["path"] = uri.attr.path.replace(/^\/+|\/+$/g, "").split("/");uri.seg["fragment"] = uri.attr.fragment.replace(/^\/+|\/+$/g, "").split("/");uri.attr["base"] = uri.attr.host ? (uri.attr.protocol ? uri.attr.protocol + "://" + uri.attr.host : uri.attr.host) + (uri.attr.port ? ":" + uri.attr.port : "") : "";return uri;
  }function getAttrName(elm) {
    var tn = elm.tagName;if (typeof tn !== "undefined") return tag2attr[tn.toLowerCase()];return tn;
  }function promote(parent, key) {
    if (parent[key].length === 0) return parent[key] = {};var t = {};for (var i in parent[key]) {
      t[i] = parent[key][i];
    }parent[key] = t;return t;
  }function parse(parts, parent, key, val) {
    var part = parts.shift();if (!part) {
      if (isArray(parent[key])) {
        parent[key].push(val);
      } else if ("object" == typeof parent[key]) {
        parent[key] = val;
      } else if ("undefined" == typeof parent[key]) {
        parent[key] = val;
      } else {
        parent[key] = [parent[key], val];
      }
    } else {
      var obj = parent[key] = parent[key] || [];if ("]" == part) {
        if (isArray(obj)) {
          if ("" !== val) obj.push(val);
        } else if ("object" == typeof obj) {
          obj[keys(obj).length] = val;
        } else {
          obj = parent[key] = [parent[key], val];
        }
      } else if (~part.indexOf("]")) {
        part = part.substr(0, part.length - 1);if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);parse(parts, obj, part, val);
      } else {
        if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);parse(parts, obj, part, val);
      }
    }
  }function merge(parent, key, val) {
    if (~key.indexOf("]")) {
      var parts = key.split("[");parse(parts, parent, "base", val);
    } else {
      if (!isint.test(key) && isArray(parent.base)) {
        var t = {};for (var k in parent.base) {
          t[k] = parent.base[k];
        }parent.base = t;
      }if (key !== "") {
        set(parent.base, key, val);
      }
    }return parent;
  }function parseString(str) {
    return reduce(String(str).split(/&|;/), function (ret, pair) {
      try {
        pair = decodeURIComponent(pair.replace(/\+/g, " "));
      } catch (e) {}var eql = pair.indexOf("="),
          brace = lastBraceInKey(pair),
          key = pair.substr(0, brace || eql),
          val = pair.substr(brace || eql, pair.length);val = val.substr(val.indexOf("=") + 1, val.length);if (key === "") {
        key = pair;val = "";
      }return merge(ret, key, val);
    }, { base: {} }).base;
  }function set(obj, key, val) {
    var v = obj[key];if (typeof v === "undefined") {
      obj[key] = val;
    } else if (isArray(v)) {
      v.push(val);
    } else {
      obj[key] = [v, val];
    }
  }function lastBraceInKey(str) {
    var len = str.length,
        brace,
        c;for (var i = 0; i < len; ++i) {
      c = str[i];if ("]" == c) brace = false;if ("[" == c) brace = true;if ("=" == c && !brace) return i;
    }
  }function reduce(obj, accumulator) {
    var i = 0,
        l = obj.length >> 0,
        curr = arguments[2];while (i < l) {
      if (i in obj) curr = accumulator.call(undefined, curr, obj[i], i, obj);++i;
    }return curr;
  }function isArray(vArg) {
    return Object.prototype.toString.call(vArg) === "[object Array]";
  }function keys(obj) {
    var key_array = [];for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) key_array.push(prop);
    }return key_array;
  }function purl(url, strictMode) {
    if (arguments.length === 1 && url === true) {
      strictMode = true;url = undefined;
    }strictMode = strictMode || false;url = url || window.location.toString();return { data: parseUri(url, strictMode), attr: function (attr) {
        attr = aliases[attr] || attr;return typeof attr !== "undefined" ? this.data.attr[attr] : this.data.attr;
      }, param: function (param) {
        return typeof param !== "undefined" ? this.data.param.query[param] : this.data.param.query;
      }, fparam: function (param) {
        return typeof param !== "undefined" ? this.data.param.fragment[param] : this.data.param.fragment;
      }, segment: function (seg) {
        if (typeof seg === "undefined") {
          return this.data.seg.path;
        } else {
          seg = seg < 0 ? this.data.seg.path.length + seg : seg - 1;return this.data.seg.path[seg];
        }
      }, fsegment: function (seg) {
        if (typeof seg === "undefined") {
          return this.data.seg.fragment;
        } else {
          seg = seg < 0 ? this.data.seg.fragment.length + seg : seg - 1;return this.data.seg.fragment[seg];
        }
      } };
  }purl.jQuery = function ($) {
    if ($ != null) {
      $.fn.url = function (strictMode) {
        var url = "";if (this.length) {
          url = $(this).attr(getAttrName(this[0])) || "";
        }return purl(url, strictMode);
      };$.url = purl;
    }
  };purl.jQuery(window.jQuery);return purl;
});
;"use strict";

/*
 Sticky-kit v1.1.2 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
*/
(function () {
  var b, f;b = this.jQuery || window.jQuery;f = b(window);b.fn.stick_in_parent = function (d) {
    var A, w, J, n, B, K, p, q, k, E, t;null == d && (d = {});t = d.sticky_class;B = d.inner_scrolling;E = d.recalc_every;k = d.parent;q = d.offset_top;p = d.spacer;w = d.bottoming;null == q && (q = 0);null == k && (k = void 0);null == B && (B = !0);null == t && (t = "is_stuck");A = b(document);null == w && (w = !0);J = function (a, d, n, C, F, u, r, G) {
      var v, H, m, D, I, c, g, x, y, z, h, l;if (!a.data("sticky_kit")) {
        a.data("sticky_kit", !0);I = A.height();g = a.parent();null != k && (g = g.closest(k));
        if (!g.length) throw "failed to find stick parent";v = m = !1;(h = null != p ? p && a.closest(p) : b("<div />")) && h.css("position", a.css("position"));x = function () {
          var c, f, e;if (!G && (I = A.height(), c = parseInt(g.css("border-top-width"), 10), f = parseInt(g.css("padding-top"), 10), d = parseInt(g.css("padding-bottom"), 10), n = g.offset().top + c + f, C = g.height(), m && (v = m = !1, null == p && (a.insertAfter(h), h.detach()), a.css({ position: "", top: "", width: "", bottom: "" }).removeClass(t), e = !0), F = a.offset().top - (parseInt(a.css("margin-top"), 10) || 0) - q, u = a.outerHeight(!0), r = a.css("float"), h && h.css({ width: a.outerWidth(!0), height: u, display: a.css("display"), "vertical-align": a.css("vertical-align"), "float": r }), e)) return l();
        };x();if (u !== C) return D = void 0, c = q, z = E, l = function () {
          var b, l, e, k;if (!G && (e = !1, null != z && (--z, 0 >= z && (z = E, x(), e = !0)), e || A.height() === I || x(), e = f.scrollTop(), null != D && (l = e - D), D = e, m ? (w && (k = e + u + c > C + n, v && !k && (v = !1, a.css({ position: "fixed", bottom: "", top: c }).trigger("sticky_kit:unbottom"))), e < F && (m = !1, c = q, null == p && ("left" !== r && "right" !== r || a.insertAfter(h), h.detach()), b = { position: "", width: "", top: "" }, a.css(b).removeClass(t).trigger("sticky_kit:unstick")), B && (b = f.height(), u + q > b && !v && (c -= l, c = Math.max(b - u, c), c = Math.min(q, c), m && a.css({ top: c + "px" })))) : e > F && (m = !0, b = { position: "fixed", top: c }, b.width = "border-box" === a.css("box-sizing") ? a.outerWidth() + "px" : a.width() + "px", a.css(b).addClass(t), null == p && (a.after(h), "left" !== r && "right" !== r || h.append(a)), a.trigger("sticky_kit:stick")), m && w && (null == k && (k = e + u + c > C + n), !v && k))) return v = !0, "static" === g.css("position") && g.css({ position: "relative" }), a.css({ position: "absolute", bottom: d, top: "auto" }).trigger("sticky_kit:bottom");
        }, y = function () {
          x();return l();
        }, H = function () {
          G = !0;f.off("touchmove", l);f.off("scroll", l);f.off("resize", y);b(document.body).off("sticky_kit:recalc", y);a.off("sticky_kit:detach", H);a.removeData("sticky_kit");a.css({ position: "", bottom: "", top: "", width: "" });g.position("position", "");if (m) return null == p && ("left" !== r && "right" !== r || a.insertAfter(h), h.remove()), a.removeClass(t);
        }, f.on("touchmove", l), f.on("scroll", l), f.on("resize", y), b(document.body).on("sticky_kit:recalc", y), a.on("sticky_kit:detach", H), setTimeout(l, 0);
      }
    };n = 0;for (K = this.length; n < K; n++) {
      d = this[n], J(b(d));
    }return this;
  };
}).call(this);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndoYXQtaW5wdXQuanMiLCJmb3VuZGF0aW9uLmNvcmUuanMiLCJmb3VuZGF0aW9uLnV0aWwuYm94LmpzIiwiZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzIiwiZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanMiLCJmb3VuZGF0aW9uLnV0aWwubW90aW9uLmpzIiwiZm91bmRhdGlvbi51dGlsLm5lc3QuanMiLCJmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlci5qcyIsImZvdW5kYXRpb24udXRpbC50b3VjaC5qcyIsImZvdW5kYXRpb24udXRpbC50cmlnZ2Vycy5qcyIsImZvdW5kYXRpb24uYWJpZGUuanMiLCJmb3VuZGF0aW9uLmFjY29yZGlvbi5qcyIsImZvdW5kYXRpb24uYWNjb3JkaW9uTWVudS5qcyIsImZvdW5kYXRpb24uZHJpbGxkb3duLmpzIiwiZm91bmRhdGlvbi5kcm9wZG93bi5qcyIsImZvdW5kYXRpb24uZHJvcGRvd25NZW51LmpzIiwiZm91bmRhdGlvbi5lcXVhbGl6ZXIuanMiLCJmb3VuZGF0aW9uLmludGVyY2hhbmdlLmpzIiwiZm91bmRhdGlvbi5tYWdlbGxhbi5qcyIsImZvdW5kYXRpb24ub2ZmY2FudmFzLmpzIiwiZm91bmRhdGlvbi5vcmJpdC5qcyIsImZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnUuanMiLCJmb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGUuanMiLCJmb3VuZGF0aW9uLnJldmVhbC5qcyIsImZvdW5kYXRpb24uc2xpZGVyLmpzIiwiZm91bmRhdGlvbi5zdGlja3kuanMiLCJmb3VuZGF0aW9uLnRhYnMuanMiLCJmb3VuZGF0aW9uLnRvZ2dsZXIuanMiLCJmb3VuZGF0aW9uLnRvb2x0aXAuanMiLCJtb3Rpb24tdWkuanMiLCJzbmFwLnN2Zy5qcyIsInNjcm9sbHJldmVhbC5qcyIsImFwcGxpY2F0aW9uLmpzIiwiYnItY29va2llcy5qcyIsImV4cGFuZGVyLmpzIiwiZmxleC12aWRlby5qcyIsImhvbWVwYWdlLWFuaW1hdGlvbnMuanMiLCJpbml0LWZvdW5kYXRpb24uanMiLCJpbnNpZ2h0LmpzIiwiam95cmlkZS1kZW1vLmpzIiwibGF3eWVycy5qcyIsIm1vYmlsZS1tZW51LmpzIiwibmF2LmpzIiwib2ZmQ2FudmFzLmpzIiwicGVvcGxlLmpzIiwic2xpY2stc2xpZGVyLmpzIiwic3RpY2t5Zm9vdGVyLmpzIiwic3VtbWVyLW1vZGFsLmpzIiwic3RpY2t5LWtpdC5qcyIsImRpc2FibGVzY3JvbGwubWluLmpzIiwiYmFja3N0cmV0Y2gubWluLmpzIiwic2xpY2suanMiLCJzbGljay5taW4uanMiLCJwdXJsLmpzIl0sIm5hbWVzIjpbIndpbmRvdyIsIndoYXRJbnB1dCIsImFjdGl2ZUtleXMiLCJib2R5IiwiYnVmZmVyIiwiY3VycmVudElucHV0Iiwibm9uVHlwaW5nSW5wdXRzIiwibW91c2VXaGVlbCIsImRldGVjdFdoZWVsIiwiaWdub3JlTWFwIiwiaW5wdXRNYXAiLCJpbnB1dFR5cGVzIiwia2V5TWFwIiwicG9pbnRlck1hcCIsInRpbWVyIiwiZXZlbnRCdWZmZXIiLCJjbGVhclRpbWVyIiwic2V0SW5wdXQiLCJldmVudCIsInNldFRpbWVvdXQiLCJidWZmZXJlZEV2ZW50IiwidW5CdWZmZXJlZEV2ZW50IiwiY2xlYXJUaW1lb3V0IiwiZXZlbnRLZXkiLCJrZXkiLCJ2YWx1ZSIsInR5cGUiLCJwb2ludGVyVHlwZSIsImV2ZW50VGFyZ2V0IiwidGFyZ2V0IiwiZXZlbnRUYXJnZXROb2RlIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImV2ZW50VGFyZ2V0VHlwZSIsImdldEF0dHJpYnV0ZSIsImhhc0F0dHJpYnV0ZSIsImluZGV4T2YiLCJzd2l0Y2hJbnB1dCIsImxvZ0tleXMiLCJzdHJpbmciLCJzZXRBdHRyaWJ1dGUiLCJwdXNoIiwia2V5Q29kZSIsIndoaWNoIiwic3JjRWxlbWVudCIsInVuTG9nS2V5cyIsImFycmF5UG9zIiwic3BsaWNlIiwiYmluZEV2ZW50cyIsImRvY3VtZW50IiwiUG9pbnRlckV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsIk1TUG9pbnRlckV2ZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ubW91c2V3aGVlbCIsInVuZGVmaW5lZCIsIkFycmF5IiwicHJvdG90eXBlIiwiYXNrIiwia2V5cyIsInR5cGVzIiwic2V0IiwiJCIsIkZPVU5EQVRJT05fVkVSU0lPTiIsIkZvdW5kYXRpb24iLCJ2ZXJzaW9uIiwiX3BsdWdpbnMiLCJfdXVpZHMiLCJydGwiLCJhdHRyIiwicGx1Z2luIiwibmFtZSIsImNsYXNzTmFtZSIsImZ1bmN0aW9uTmFtZSIsImF0dHJOYW1lIiwiaHlwaGVuYXRlIiwicmVnaXN0ZXJQbHVnaW4iLCJwbHVnaW5OYW1lIiwiY29uc3RydWN0b3IiLCJ1dWlkIiwiR2V0WW9EaWdpdHMiLCIkZWxlbWVudCIsImRhdGEiLCJ0cmlnZ2VyIiwidW5yZWdpc3RlclBsdWdpbiIsInJlbW92ZUF0dHIiLCJyZW1vdmVEYXRhIiwicHJvcCIsInJlSW5pdCIsInBsdWdpbnMiLCJpc0pRIiwiZWFjaCIsIl9pbml0IiwiX3RoaXMiLCJmbnMiLCJwbGdzIiwiZm9yRWFjaCIsInAiLCJmb3VuZGF0aW9uIiwiT2JqZWN0IiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwibGVuZ3RoIiwibmFtZXNwYWNlIiwiTWF0aCIsInJvdW5kIiwicG93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsInJlZmxvdyIsImVsZW0iLCJpIiwiJGVsZW0iLCJmaW5kIiwiYWRkQmFjayIsIiRlbCIsIm9wdHMiLCJ3YXJuIiwidGhpbmciLCJzcGxpdCIsImUiLCJvcHQiLCJtYXAiLCJlbCIsInRyaW0iLCJwYXJzZVZhbHVlIiwiZXIiLCJnZXRGbk5hbWUiLCJ0cmFuc2l0aW9uZW5kIiwidHJhbnNpdGlvbnMiLCJlbmQiLCJ0Iiwic3R5bGUiLCJ0cmlnZ2VySGFuZGxlciIsInV0aWwiLCJ0aHJvdHRsZSIsImZ1bmMiLCJkZWxheSIsImNvbnRleHQiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJtZXRob2QiLCIkbWV0YSIsIiRub0pTIiwiYXBwZW5kVG8iLCJoZWFkIiwicmVtb3ZlQ2xhc3MiLCJNZWRpYVF1ZXJ5IiwiY2FsbCIsInBsdWdDbGFzcyIsIlJlZmVyZW5jZUVycm9yIiwiVHlwZUVycm9yIiwiZm4iLCJEYXRlIiwibm93IiwiZ2V0VGltZSIsInZlbmRvcnMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ2cCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImxhc3RUaW1lIiwiY2FsbGJhY2siLCJuZXh0VGltZSIsIm1heCIsInBlcmZvcm1hbmNlIiwic3RhcnQiLCJGdW5jdGlvbiIsImJpbmQiLCJvVGhpcyIsImFBcmdzIiwiZlRvQmluZCIsImZOT1AiLCJmQm91bmQiLCJjb25jYXQiLCJmdW5jTmFtZVJlZ2V4IiwicmVzdWx0cyIsImV4ZWMiLCJzdHIiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJyZXBsYWNlIiwialF1ZXJ5IiwiQm94IiwiSW1Ob3RUb3VjaGluZ1lvdSIsIkdldERpbWVuc2lvbnMiLCJHZXRPZmZzZXRzIiwiZWxlbWVudCIsInBhcmVudCIsImxyT25seSIsInRiT25seSIsImVsZURpbXMiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJwYXJEaW1zIiwib2Zmc2V0IiwiaGVpZ2h0Iiwid2lkdGgiLCJ3aW5kb3dEaW1zIiwiYWxsRGlycyIsIkVycm9yIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhclJlY3QiLCJwYXJlbnROb2RlIiwid2luUmVjdCIsIndpblkiLCJwYWdlWU9mZnNldCIsIndpblgiLCJwYWdlWE9mZnNldCIsInBhcmVudERpbXMiLCJhbmNob3IiLCJwb3NpdGlvbiIsInZPZmZzZXQiLCJoT2Zmc2V0IiwiaXNPdmVyZmxvdyIsIiRlbGVEaW1zIiwiJGFuY2hvckRpbXMiLCJrZXlDb2RlcyIsImNvbW1hbmRzIiwiS2V5Ym9hcmQiLCJnZXRLZXlDb2RlcyIsInBhcnNlS2V5IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwidG9VcHBlckNhc2UiLCJzaGlmdEtleSIsImN0cmxLZXkiLCJhbHRLZXkiLCJoYW5kbGVLZXkiLCJjb21wb25lbnQiLCJmdW5jdGlvbnMiLCJjb21tYW5kTGlzdCIsImNtZHMiLCJjb21tYW5kIiwibHRyIiwiZXh0ZW5kIiwicmV0dXJuVmFsdWUiLCJoYW5kbGVkIiwidW5oYW5kbGVkIiwiZmluZEZvY3VzYWJsZSIsImZpbHRlciIsImlzIiwicmVnaXN0ZXIiLCJjb21wb25lbnROYW1lIiwia2NzIiwiayIsImtjIiwiZGVmYXVsdFF1ZXJpZXMiLCJsYW5kc2NhcGUiLCJwb3J0cmFpdCIsInJldGluYSIsInF1ZXJpZXMiLCJjdXJyZW50Iiwic2VsZiIsImV4dHJhY3RlZFN0eWxlcyIsImNzcyIsIm5hbWVkUXVlcmllcyIsInBhcnNlU3R5bGVUb09iamVjdCIsImhhc093blByb3BlcnR5IiwiX2dldEN1cnJlbnRTaXplIiwiX3dhdGNoZXIiLCJhdExlYXN0Iiwic2l6ZSIsInF1ZXJ5IiwiZ2V0IiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJtYXRjaGVkIiwib24iLCJuZXdTaXplIiwiY3VycmVudFNpemUiLCJzdHlsZU1lZGlhIiwibWVkaWEiLCJzY3JpcHQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImluZm8iLCJpZCIsImluc2VydEJlZm9yZSIsImdldENvbXB1dGVkU3R5bGUiLCJjdXJyZW50U3R5bGUiLCJtYXRjaE1lZGl1bSIsInRleHQiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCIsInRleHRDb250ZW50Iiwic3R5bGVPYmplY3QiLCJyZWR1Y2UiLCJyZXQiLCJwYXJhbSIsInBhcnRzIiwidmFsIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaXNBcnJheSIsImluaXRDbGFzc2VzIiwiYWN0aXZlQ2xhc3NlcyIsIk1vdGlvbiIsImFuaW1hdGVJbiIsImFuaW1hdGlvbiIsImNiIiwiYW5pbWF0ZSIsImFuaW1hdGVPdXQiLCJNb3ZlIiwiZHVyYXRpb24iLCJhbmltIiwicHJvZyIsIm1vdmUiLCJ0cyIsImlzSW4iLCJlcSIsImluaXRDbGFzcyIsImFjdGl2ZUNsYXNzIiwicmVzZXQiLCJhZGRDbGFzcyIsInNob3ciLCJvZmZzZXRXaWR0aCIsIm9uZSIsImZpbmlzaCIsImhpZGUiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJOZXN0IiwiRmVhdGhlciIsIm1lbnUiLCJpdGVtcyIsInN1Yk1lbnVDbGFzcyIsInN1Ykl0ZW1DbGFzcyIsImhhc1N1YkNsYXNzIiwiJGl0ZW0iLCIkc3ViIiwiY2hpbGRyZW4iLCJCdXJuIiwiVGltZXIiLCJvcHRpb25zIiwibmFtZVNwYWNlIiwicmVtYWluIiwiaXNQYXVzZWQiLCJyZXN0YXJ0IiwiaW5maW5pdGUiLCJwYXVzZSIsIm9uSW1hZ2VzTG9hZGVkIiwiaW1hZ2VzIiwidW5sb2FkZWQiLCJjb21wbGV0ZSIsInNpbmdsZUltYWdlTG9hZGVkIiwibmF0dXJhbFdpZHRoIiwic3BvdFN3aXBlIiwiZW5hYmxlZCIsImRvY3VtZW50RWxlbWVudCIsInByZXZlbnREZWZhdWx0IiwibW92ZVRocmVzaG9sZCIsInRpbWVUaHJlc2hvbGQiLCJzdGFydFBvc1giLCJzdGFydFBvc1kiLCJzdGFydFRpbWUiLCJlbGFwc2VkVGltZSIsImlzTW92aW5nIiwib25Ub3VjaEVuZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvblRvdWNoTW92ZSIsIngiLCJ0b3VjaGVzIiwicGFnZVgiLCJ5IiwicGFnZVkiLCJkeCIsImR5IiwiZGlyIiwiYWJzIiwib25Ub3VjaFN0YXJ0IiwiaW5pdCIsInRlYXJkb3duIiwic3BlY2lhbCIsInN3aXBlIiwic2V0dXAiLCJub29wIiwiYWRkVG91Y2giLCJoYW5kbGVUb3VjaCIsImNoYW5nZWRUb3VjaGVzIiwiZmlyc3QiLCJldmVudFR5cGVzIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwic2ltdWxhdGVkRXZlbnQiLCJNb3VzZUV2ZW50Iiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsImNyZWF0ZUV2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiTXV0YXRpb25PYnNlcnZlciIsInByZWZpeGVzIiwidHJpZ2dlcnMiLCJzdG9wUHJvcGFnYXRpb24iLCJmYWRlT3V0IiwibG9hZCIsImNoZWNrTGlzdGVuZXJzIiwiZXZlbnRzTGlzdGVuZXIiLCJyZXNpemVMaXN0ZW5lciIsInNjcm9sbExpc3RlbmVyIiwiY2xvc2VtZUxpc3RlbmVyIiwieWV0aUJveGVzIiwicGx1Z05hbWVzIiwibGlzdGVuZXJzIiwiam9pbiIsIm9mZiIsInBsdWdpbklkIiwibm90IiwiZGVib3VuY2UiLCIkbm9kZXMiLCJub2RlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uIiwibXV0YXRpb25SZWNvcmRzTGlzdCIsIiR0YXJnZXQiLCJlbGVtZW50T2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJzdWJ0cmVlIiwiYXR0cmlidXRlRmlsdGVyIiwiSUhlYXJZb3UiLCJBYmlkZSIsImRlZmF1bHRzIiwiJGlucHV0cyIsIl9ldmVudHMiLCJyZXNldEZvcm0iLCJ2YWxpZGF0ZUZvcm0iLCJ2YWxpZGF0ZU9uIiwidmFsaWRhdGVJbnB1dCIsImxpdmVWYWxpZGF0ZSIsImlzR29vZCIsImNoZWNrZWQiLCIkZXJyb3IiLCJzaWJsaW5ncyIsImZvcm1FcnJvclNlbGVjdG9yIiwiJGxhYmVsIiwiY2xvc2VzdCIsIiRlbHMiLCJsYWJlbHMiLCJmaW5kTGFiZWwiLCIkZm9ybUVycm9yIiwiZmluZEZvcm1FcnJvciIsImxhYmVsRXJyb3JDbGFzcyIsImZvcm1FcnJvckNsYXNzIiwiaW5wdXRFcnJvckNsYXNzIiwiZ3JvdXBOYW1lIiwiJGxhYmVscyIsImZpbmRSYWRpb0xhYmVscyIsIiRmb3JtRXJyb3JzIiwicmVtb3ZlUmFkaW9FcnJvckNsYXNzZXMiLCJjbGVhclJlcXVpcmUiLCJyZXF1aXJlZENoZWNrIiwidmFsaWRhdGVkIiwiY3VzdG9tVmFsaWRhdG9yIiwidmFsaWRhdG9yIiwiZXF1YWxUbyIsInZhbGlkYXRlUmFkaW8iLCJ2YWxpZGF0ZVRleHQiLCJtYXRjaFZhbGlkYXRpb24iLCJ2YWxpZGF0b3JzIiwiZ29vZFRvR28iLCJtZXNzYWdlIiwiYWNjIiwibm9FcnJvciIsInBhdHRlcm4iLCJpbnB1dFRleHQiLCJ2YWxpZCIsInBhdHRlcm5zIiwiUmVnRXhwIiwiJGdyb3VwIiwicmVxdWlyZWQiLCJjbGVhciIsInYiLCIkZm9ybSIsInJlbW92ZUVycm9yQ2xhc3NlcyIsImFscGhhIiwiYWxwaGFfbnVtZXJpYyIsImludGVnZXIiLCJudW1iZXIiLCJjYXJkIiwiY3Z2IiwiZW1haWwiLCJ1cmwiLCJkb21haW4iLCJkYXRldGltZSIsImRhdGUiLCJ0aW1lIiwiZGF0ZUlTTyIsIm1vbnRoX2RheV95ZWFyIiwiZGF5X21vbnRoX3llYXIiLCJjb2xvciIsIkFjY29yZGlvbiIsIiR0YWJzIiwiaWR4IiwiJGNvbnRlbnQiLCJsaW5rSWQiLCIkaW5pdEFjdGl2ZSIsImRvd24iLCIkdGFiQ29udGVudCIsImhhc0NsYXNzIiwiYWxsb3dBbGxDbG9zZWQiLCJ1cCIsInRvZ2dsZSIsIm5leHQiLCIkYSIsImZvY3VzIiwibXVsdGlFeHBhbmQiLCJwcmV2aW91cyIsInByZXYiLCJmaXJzdFRpbWUiLCIkY3VycmVudEFjdGl2ZSIsInNsaWRlRG93biIsInNsaWRlU3BlZWQiLCIkYXVudHMiLCJjYW5DbG9zZSIsInNsaWRlVXAiLCJzdG9wIiwiQWNjb3JkaW9uTWVudSIsIm11bHRpT3BlbiIsIiRtZW51TGlua3MiLCJzdWJJZCIsImlzQWN0aXZlIiwiaW5pdFBhbmVzIiwiJHN1Ym1lbnUiLCIkZWxlbWVudHMiLCIkcHJldkVsZW1lbnQiLCIkbmV4dEVsZW1lbnQiLCJtaW4iLCJwYXJlbnRzIiwib3BlbiIsImNsb3NlIiwiY2xvc2VBbGwiLCJoaWRlQWxsIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicGFyZW50c1VudGlsIiwiYWRkIiwiJG1lbnVzIiwiRHJpbGxkb3duIiwiJHN1Ym1lbnVBbmNob3JzIiwiJHN1Ym1lbnVzIiwiJG1lbnVJdGVtcyIsIl9wcmVwYXJlTWVudSIsIl9rZXlib2FyZEV2ZW50cyIsIiRsaW5rIiwicGFyZW50TGluayIsImNsb25lIiwicHJlcGVuZFRvIiwid3JhcCIsIiRtZW51IiwiJGJhY2siLCJwcmVwZW5kIiwiYmFja0J1dHRvbiIsIl9iYWNrIiwiJHdyYXBwZXIiLCJ3cmFwcGVyIiwiX2dldE1heERpbXMiLCJfc2hvdyIsImNsb3NlT25DbGljayIsIiRib2R5IiwiY29udGFpbnMiLCJfaGlkZUFsbCIsIl9oaWRlIiwiYmx1ciIsInJlc3VsdCIsIm51bU9mRWxlbXMiLCJ1bndyYXAiLCJyZW1vdmUiLCJEcm9wZG93biIsIiRpZCIsIiRhbmNob3IiLCJwb3NpdGlvbkNsYXNzIiwiZ2V0UG9zaXRpb25DbGFzcyIsImNvdW50ZXIiLCJ1c2VkUG9zaXRpb25zIiwidmVydGljYWxQb3NpdGlvbiIsIm1hdGNoIiwiaG9yaXpvbnRhbFBvc2l0aW9uIiwiY2xhc3NDaGFuZ2VkIiwiZGlyZWN0aW9uIiwiX3JlcG9zaXRpb24iLCJfc2V0UG9zaXRpb24iLCJob3ZlciIsInRpbWVvdXQiLCJob3ZlckRlbGF5IiwiaG92ZXJQYW5lIiwidmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzIiwidGFiX2ZvcndhcmQiLCJ0cmFwRm9jdXMiLCJ0YWJfYmFja3dhcmQiLCJhdXRvRm9jdXMiLCIkZm9jdXNhYmxlIiwiX2FkZEJvZHlIYW5kbGVyIiwiY3VyUG9zaXRpb25DbGFzcyIsIkRyb3Bkb3duTWVudSIsInN1YnMiLCJ2ZXJ0aWNhbENsYXNzIiwicmlnaHRDbGFzcyIsImFsaWdubWVudCIsImNoYW5nZWQiLCJoYXNUb3VjaCIsIm9udG91Y2hzdGFydCIsInBhckNsYXNzIiwiaGFuZGxlQ2xpY2tGbiIsImhhc1N1YiIsImhhc0NsaWNrZWQiLCJjbGlja09wZW4iLCJmb3JjZUZvbGxvdyIsImRpc2FibGVIb3ZlciIsImF1dG9jbG9zZSIsImNsb3NpbmdUaW1lIiwiaXNUYWIiLCJpbmRleCIsIm5leHRTaWJsaW5nIiwicHJldlNpYmxpbmciLCJvcGVuU3ViIiwiY2xvc2VTdWIiLCIkc2licyIsIm9sZENsYXNzIiwiJHBhcmVudExpIiwiJHRvQ2xvc2UiLCJzb21ldGhpbmdUb0Nsb3NlIiwiRXF1YWxpemVyIiwiZXFJZCIsIiR3YXRjaGVkIiwiaGFzTmVzdGVkIiwiaXNOZXN0ZWQiLCJpc09uIiwiX2JpbmRIYW5kbGVyIiwib25SZXNpemVNZUJvdW5kIiwiX29uUmVzaXplTWUiLCJvblBvc3RFcXVhbGl6ZWRCb3VuZCIsIl9vblBvc3RFcXVhbGl6ZWQiLCJpbWdzIiwidG9vU21hbGwiLCJlcXVhbGl6ZU9uIiwiX2NoZWNrTVEiLCJfcmVmbG93IiwiX3BhdXNlRXZlbnRzIiwiZXF1YWxpemVPblN0YWNrIiwiX2lzU3RhY2tlZCIsImVxdWFsaXplQnlSb3ciLCJnZXRIZWlnaHRzQnlSb3ciLCJhcHBseUhlaWdodEJ5Um93IiwiZ2V0SGVpZ2h0cyIsImFwcGx5SGVpZ2h0IiwiaGVpZ2h0cyIsImxlbiIsIm9mZnNldEhlaWdodCIsImxhc3RFbFRvcE9mZnNldCIsImdyb3VwcyIsImdyb3VwIiwiZWxPZmZzZXRUb3AiLCJqIiwibG4iLCJncm91cHNJTGVuZ3RoIiwibGVuSiIsIkludGVyY2hhbmdlIiwicnVsZXMiLCJjdXJyZW50UGF0aCIsIl9hZGRCcmVha3BvaW50cyIsIl9nZW5lcmF0ZVJ1bGVzIiwicnVsZSIsInBhdGgiLCJTUEVDSUFMX1FVRVJJRVMiLCJydWxlc0xpc3QiLCJyZXNwb25zZSIsImh0bWwiLCJNYWdlbGxhbiIsIiR0YXJnZXRzIiwiJGxpbmtzIiwiJGFjdGl2ZSIsInNjcm9sbFBvcyIsInBhcnNlSW50IiwicG9pbnRzIiwid2luSGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJkb2NIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCIkdGFyIiwicHQiLCJ0aHJlc2hvbGQiLCJ0YXJnZXRQb2ludCIsImFuaW1hdGlvbkR1cmF0aW9uIiwiZWFzaW5nIiwiYW5pbWF0aW9uRWFzaW5nIiwiZGVlcExpbmtpbmciLCJsb2NhdGlvbiIsImhhc2giLCJzY3JvbGxUb0xvYyIsImNhbGNQb2ludHMiLCJfdXBkYXRlQWN0aXZlIiwiYXJyaXZhbCIsImxvYyIsImJhck9mZnNldCIsInNjcm9sbFRvcCIsIndpblBvcyIsImN1cklkeCIsImlzRG93biIsImN1clZpc2libGUiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwiT2ZmQ2FudmFzIiwiJGxhc3RUcmlnZ2VyIiwiJHRyaWdnZXJzIiwiJGV4aXRlciIsImV4aXRlciIsImFwcGVuZCIsImlzUmV2ZWFsZWQiLCJyZXZlYWxDbGFzcyIsInJldmVhbE9uIiwiX3NldE1RQ2hlY2tlciIsInRyYW5zaXRpb25UaW1lIiwiX2hhbmRsZUtleWJvYXJkIiwicmV2ZWFsIiwiJGNsb3NlciIsImZvcmNlVG9wIiwiX3RyYXBGb2N1cyIsImZvY3VzYWJsZSIsImxhc3QiLCJrZXljb2RlIiwiT3JiaXQiLCJjb250YWluZXJDbGFzcyIsIiRzbGlkZXMiLCJzbGlkZUNsYXNzIiwiJGltYWdlcyIsImluaXRBY3RpdmUiLCJ1c2VNVUkiLCJfcHJlcGFyZUZvck9yYml0IiwiYnVsbGV0cyIsIl9sb2FkQnVsbGV0cyIsImF1dG9QbGF5IiwiZ2VvU3luYyIsImFjY2Vzc2libGUiLCIkYnVsbGV0cyIsImJveE9mQnVsbGV0cyIsInRpbWVyRGVsYXkiLCJjaGFuZ2VTbGlkZSIsIl9zZXRXcmFwcGVySGVpZ2h0IiwiX3NldFNsaWRlSGVpZ2h0IiwidGVtcCIsInBhdXNlT25Ib3ZlciIsIm5hdkJ1dHRvbnMiLCIkY29udHJvbHMiLCJuZXh0Q2xhc3MiLCJwcmV2Q2xhc3MiLCIkc2xpZGUiLCJpc0xUUiIsImNob3NlblNsaWRlIiwiJGN1clNsaWRlIiwiJGZpcnN0U2xpZGUiLCIkbGFzdFNsaWRlIiwiZGlySW4iLCJkaXJPdXQiLCIkbmV3U2xpZGUiLCJpbmZpbml0ZVdyYXAiLCJfdXBkYXRlQnVsbGV0cyIsIiRvbGRCdWxsZXQiLCJzcGFuIiwiZGV0YWNoIiwiJG5ld0J1bGxldCIsImFuaW1JbkZyb21SaWdodCIsImFuaW1PdXRUb1JpZ2h0IiwiYW5pbUluRnJvbUxlZnQiLCJhbmltT3V0VG9MZWZ0IiwiUmVzcG9uc2l2ZU1lbnUiLCJjdXJyZW50TXEiLCJjdXJyZW50UGx1Z2luIiwicnVsZXNUcmVlIiwicnVsZVNpemUiLCJydWxlUGx1Z2luIiwiTWVudVBsdWdpbnMiLCJpc0VtcHR5T2JqZWN0IiwiX2NoZWNrTWVkaWFRdWVyaWVzIiwibWF0Y2hlZE1xIiwiY3NzQ2xhc3MiLCJkZXN0cm95IiwiZHJvcGRvd24iLCJkcmlsbGRvd24iLCJhY2NvcmRpb24iLCJSZXNwb25zaXZlVG9nZ2xlIiwidGFyZ2V0SUQiLCIkdGFyZ2V0TWVudSIsIiR0b2dnbGVyIiwiX3VwZGF0ZSIsIl91cGRhdGVNcUhhbmRsZXIiLCJ0b2dnbGVNZW51IiwiaGlkZUZvciIsIlJldmVhbCIsImNhY2hlZCIsIm1xIiwiaXNNb2JpbGUiLCJtb2JpbGVTbmlmZiIsImZ1bGxTY3JlZW4iLCJvdmVybGF5IiwiJG92ZXJsYXkiLCJfbWFrZU92ZXJsYXkiLCJkZWVwTGluayIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsIm1hcmdpbiIsIl91cGRhdGVQb3NpdGlvbiIsIl9oYW5kbGVTdGF0ZSIsIm11bHRpcGxlT3BlbmVkIiwiYW5pbWF0aW9uSW4iLCJhZnRlckFuaW1hdGlvbkZvY3VzIiwibG9nIiwiZm9jdXNhYmxlRWxlbWVudHMiLCJzaG93RGVsYXkiLCJvcmlnaW5hbFNjcm9sbFBvcyIsIl9leHRyYUhhbmRsZXJzIiwiY2xvc2VPbkVzYyIsImFuaW1hdGlvbk91dCIsImZpbmlzaFVwIiwiaGlkZURlbGF5IiwicmVzZXRPbkNsb3NlIiwicmVwbGFjZVN0YXRlIiwidGl0bGUiLCJwYXRobmFtZSIsImJ0bU9mZnNldFBjdCIsImlQaG9uZVNuaWZmIiwiYW5kcm9pZFNuaWZmIiwiU2xpZGVyIiwiaW5wdXRzIiwiaGFuZGxlcyIsIiRoYW5kbGUiLCIkaW5wdXQiLCIkZmlsbCIsInZlcnRpY2FsIiwiaXNEYmwiLCJkaXNhYmxlZCIsImRpc2FibGVkQ2xhc3MiLCJiaW5kaW5nIiwiX3NldEluaXRBdHRyIiwiZG91YmxlU2lkZWQiLCIkaGFuZGxlMiIsIiRpbnB1dDIiLCJfc2V0SGFuZGxlUG9zIiwiaW5pdGlhbFN0YXJ0IiwiaW5pdGlhbEVuZCIsIiRobmRsIiwibm9JbnZlcnQiLCJoMlZhbCIsInN0ZXAiLCJoMVZhbCIsInZlcnQiLCJoT3JXIiwibE9yVCIsImhhbmRsZURpbSIsImVsZW1EaW0iLCJwY3RPZkJhciIsInBlcmNlbnQiLCJ0b0ZpeGVkIiwicHhUb01vdmUiLCJtb3ZlbWVudCIsImRlY2ltYWwiLCJfc2V0VmFsdWVzIiwiaXNMZWZ0SG5kbCIsImRpbSIsImhhbmRsZVBjdCIsImhhbmRsZVBvcyIsIm1vdmVUaW1lIiwiY2hhbmdlZERlbGF5IiwiaGFzVmFsIiwiZXZlbnRPZmZzZXQiLCJoYWxmT2ZIYW5kbGUiLCJiYXJEaW0iLCJ3aW5kb3dTY3JvbGwiLCJzY3JvbGxMZWZ0IiwiZWxlbU9mZnNldCIsImV2ZW50RnJvbUJhciIsImJhclhZIiwib2Zmc2V0UGN0IiwiX2FkanVzdFZhbHVlIiwiZmlyc3RIbmRsUG9zIiwiYWJzUG9zaXRpb24iLCJzZWNuZEhuZGxQb3MiLCJkaXYiLCJwcmV2X3ZhbCIsIm5leHRfdmFsIiwiY3VySGFuZGxlIiwiX2hhbmRsZUV2ZW50IiwiY2xpY2tTZWxlY3QiLCJkcmFnZ2FibGUiLCJjdXJyZW50VGFyZ2V0IiwiXyRoYW5kbGUiLCJvbGRWYWx1ZSIsIm5ld1ZhbHVlIiwiZGVjcmVhc2UiLCJpbmNyZWFzZSIsImRlY3JlYXNlX2Zhc3QiLCJpbmNyZWFzZV9mYXN0IiwiaW52ZXJ0VmVydGljYWwiLCJmcmFjIiwibnVtIiwiY2xpY2tQb3MiLCJTdGlja3kiLCIkcGFyZW50Iiwid2FzV3JhcHBlZCIsIiRjb250YWluZXIiLCJjb250YWluZXIiLCJ3cmFwSW5uZXIiLCJzdGlja3lDbGFzcyIsInNjcm9sbENvdW50IiwiY2hlY2tFdmVyeSIsImlzU3R1Y2siLCJfcGFyc2VQb2ludHMiLCJfc2V0U2l6ZXMiLCJfY2FsYyIsInJldmVyc2UiLCJ0b3BBbmNob3IiLCJidG0iLCJidG1BbmNob3IiLCJwdHMiLCJicmVha3MiLCJwbGFjZSIsImNhblN0aWNrIiwiX3BhdXNlTGlzdGVuZXJzIiwiY2hlY2tTaXplcyIsInNjcm9sbCIsIl9yZW1vdmVTdGlja3kiLCJ0b3BQb2ludCIsImJvdHRvbVBvaW50IiwiX3NldFN0aWNreSIsInN0aWNrVG8iLCJtcmduIiwibm90U3R1Y2tUbyIsImlzVG9wIiwic3RpY2tUb1RvcCIsImFuY2hvclB0IiwiYW5jaG9ySGVpZ2h0IiwiZWxlbUhlaWdodCIsInRvcE9yQm90dG9tIiwic3RpY2t5T24iLCJuZXdFbGVtV2lkdGgiLCJjb21wIiwicGRuZyIsIm5ld0NvbnRhaW5lckhlaWdodCIsImNvbnRhaW5lckhlaWdodCIsIl9zZXRCcmVha1BvaW50cyIsIm1Ub3AiLCJlbUNhbGMiLCJtYXJnaW5Ub3AiLCJtQnRtIiwibWFyZ2luQm90dG9tIiwiZW0iLCJmb250U2l6ZSIsIlRhYnMiLCIkdGFiVGl0bGVzIiwibGlua0NsYXNzIiwibWF0Y2hIZWlnaHQiLCJfc2V0SGVpZ2h0IiwiX2FkZEtleUhhbmRsZXIiLCJfYWRkQ2xpY2tIYW5kbGVyIiwiX3NldEhlaWdodE1xSGFuZGxlciIsIl9oYW5kbGVUYWJDaGFuZ2UiLCIkZmlyc3RUYWIiLCIkbGFzdFRhYiIsIndyYXBPbktleXMiLCIkdGFiTGluayIsIiR0YXJnZXRDb250ZW50IiwiJG9sZFRhYiIsImlkU3RyIiwicGFuZWxDbGFzcyIsInBhbmVsIiwiY2hlY2tDbGFzcyIsIlRvZ2dsZXIiLCJpbnB1dCIsInRvZ2dsZUNsYXNzIiwiX3VwZGF0ZUFSSUEiLCJUb29sdGlwIiwiaXNDbGljayIsImVsZW1JZCIsIl9nZXRQb3NpdGlvbkNsYXNzIiwidGlwVGV4dCIsInRlbXBsYXRlIiwiX2J1aWxkVGVtcGxhdGUiLCJ0cmlnZ2VyQ2xhc3MiLCJ0ZW1wbGF0ZUNsYXNzZXMiLCJ0b29sdGlwQ2xhc3MiLCIkdGVtcGxhdGUiLCIkdGlwRGltcyIsInNob3dPbiIsImZhZGVJbiIsImZhZGVJbkR1cmF0aW9uIiwiZmFkZU91dER1cmF0aW9uIiwiaXNGb2N1cyIsImRpc2FibGVGb3JUb3VjaCIsInRvdWNoQ2xvc2VUZXh0IiwiZW5kRXZlbnQiLCJNb3Rpb25VSSIsImdsb2IiLCJoYXMiLCJzZXBhcmF0b3IiLCJjb21hc2VwYXJhdG9yIiwid2lsZGNhcmQiLCJmdW4iLCJudW1zb3J0IiwiYSIsImIiLCJjdXJyZW50X2V2ZW50IiwiZXZlbnRzIiwibiIsImZpcnN0RGVmaW5lZCIsImlpIiwibGFzdERlZmluZWQiLCJldmUiLCJzY29wZSIsIm9sZHN0b3AiLCJ6IiwiZiIsImwiLCJpbmRleGVkIiwicXVldWUiLCJvdXQiLCJjZSIsImVycm9ycyIsInpJbmRleCIsInNvcnQiLCJuYW1lcyIsIml0ZW0iLCJqaiIsIm5lcyIsImVzIiwiZXhpc3QiLCJhdHRycyIsIm50Iiwic3VibmFtZSIsIm50cyIsInVuYmluZCIsImN1ciIsImZ1bmNzIiwib25jZSIsImYyIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmluZSIsImFtZCIsImZhY3RvcnkiLCJyZXF1aXJlIiwibWluYSIsImFuaW1hdGlvbnMiLCJyZXF1ZXN0QW5pbUZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaWRnZW4iLCJpZHByZWZpeCIsIklEIiwiZGlmZiIsIkEiLCJCIiwicmVzIiwiZGlmIiwiYmIiLCJzdGEiLCJzIiwiZHMiLCJkdXIiLCJzcGVlZCIsInNwZCIsInN0b3BpdCIsInVwZGF0ZSIsInBkaWYiLCJyZXN1bWUiLCJmcmFtZSIsImxpbmVhciIsInN0YXR1cyIsImdldEJ5SWQiLCJlYXNlb3V0IiwiZWFzZWluIiwiZWFzZWlub3V0IiwicSIsIlEiLCJzcXJ0IiwiWCIsIlkiLCJiYWNraW4iLCJiYWNrb3V0IiwiZWxhc3RpYyIsInNpbiIsIlBJIiwiYm91bmNlIiwiU25hcCIsInJvb3QiLCJ3IiwiaCIsIm5vZGVUeXBlIiwiRWxlbWVudCIsImRvYyIsInF1ZXJ5U2VsZWN0b3IiLCJQYXBlciIsIl8iLCJ3aW4iLCJTdHIiLCJ0b0Zsb2F0IiwidG9JbnQiLCJtYXRoIiwibW1heCIsIm1taW4iLCJFIiwiUyIsIm9iamVjdFRvU3RyaW5nIiwiSVNVUkwiLCJjb2xvdXJSZWdFeHAiLCJiZXppZXJyZyIsInJlVVJMVmFsdWUiLCJ3aGl0ZXNwYWNlIiwiY29tbWFTcGFjZXMiLCJoc3JnIiwiaHMiLCJyZyIsInBhdGhDb21tYW5kIiwidENvbW1hbmQiLCJwYXRoVmFsdWVzIiwieGxpbmsiLCJ4bWxucyIsImh1YiIsIlVSTCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlQ29tbWVudCIsInN1YnN0cmluZyIsImdldEF0dHJpYnV0ZU5TIiwibm9kZVZhbHVlIiwic2V0QXR0cmlidXRlTlMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJnZXRBdHRycyIsIm5hbWVzcGFjZVVSSSIsIm8iLCJpc0Zpbml0ZSIsImZvcm1hdCIsInRva2VuUmVnZXgiLCJvYmpOb3RhdGlvblJlZ2V4IiwicmVwbGFjZXIiLCJhbGwiLCJvYmoiLCJxdW90ZSIsInF1b3RlZE5hbWUiLCJpc0Z1bmMiLCJyZXB1c2giLCJhcnJheSIsImNhY2hlciIsInBvc3Rwcm9jZXNzb3IiLCJuZXdmIiwiYXJnIiwiY2FjaGUiLCJjb3VudCIsInNoaWZ0IiwiYW5nbGUiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIngzIiwieTMiLCJhdGFuMiIsInJhZCIsImRlZyIsInhfeSIsInhfeV93X2giLCJ0YW4iLCJjb3MiLCJhc2luIiwiYWNvcyIsImF0YW4iLCJsZW4yIiwiY2xvc2VzdFBvaW50IiwiZGlzdGFuY2UyIiwicGF0aE5vZGUiLCJub2RlIiwicGF0aExlbmd0aCIsImdldFRvdGFsTGVuZ3RoIiwicHJlY2lzaW9uIiwicGF0aFNlZ0xpc3QiLCJudW1iZXJPZkl0ZW1zIiwiYmVzdCIsImJlc3RMZW5ndGgiLCJiZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsInNjYW4iLCJzY2FuTGVuZ3RoIiwic2NhbkRpc3RhbmNlIiwiZ2V0UG9pbnRBdExlbmd0aCIsImJlZm9yZSIsImFmdGVyIiwiYmVmb3JlTGVuZ3RoIiwiYWZ0ZXJMZW5ndGgiLCJiZWZvcmVEaXN0YW5jZSIsImFmdGVyRGlzdGFuY2UiLCJkaXN0YW5jZSIsInNuYXBUbyIsInZhbHVlcyIsInRvbGVyYW5jZSIsInJlbSIsImdldFJHQiIsImNvbG91ciIsInIiLCJnIiwiaGV4IiwicmdidG9TdHJpbmciLCJjaGFyQXQiLCJ0b0hleCIsInJlZCIsImdyZWVuIiwiYmx1ZSIsIm9wYWNpdHkiLCJyZ2IiLCJoc2IycmdiIiwiaHNsMnJnYiIsImhzYiIsImhzbCIsImRlZmF1bHRWaWV3IiwiZ2V0UHJvcGVydHlWYWx1ZSIsImhzYnRvU3RyaW5nIiwiaHNsdG9TdHJpbmciLCJwcmVwYXJlUkdCIiwiY2xyIiwicGFja2FnZVJHQiIsInJnYjJoc2wiLCJyZ2IyaHNiIiwiUiIsIkciLCJDIiwiSCIsIlYiLCJMIiwiTSIsIm0iLCJwYXJzZVBhdGhTdHJpbmciLCJwYXRoU3RyaW5nIiwicHRoIiwiYXJyIiwicGFyYW1Db3VudHMiLCJjIiwidSIsInBhcmFtcyIsInBhcnNlVHJhbnNmb3JtU3RyaW5nIiwiVFN0cmluZyIsInN2Z1RyYW5zZm9ybTJzdHJpbmciLCJ0c3RyIiwicmdUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0ybWF0cml4IiwiYmJveCIsInRkYXRhIiwiTWF0cml4IiwidGxlbiIsImFic29sdXRlIiwiaW52ZXIiLCJpbnZlcnQiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJzY2FsZSIsIl91bml0MnB4IiwidW5pdDJweCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiYWRvd24iLCJidXAiLCJnZXRTb21lRGVmcyIsIm93bmVyU1ZHRWxlbWVudCIsInNlbGVjdCIsInBkZWZzIiwiZGVmcyIsIm1ha2UiLCJnZXRTb21lU1ZHIiwic3ZnIiwibWdyIiwiZmlsbCIsImFwcGVuZENoaWxkIiwiZ2V0VyIsImdldEJCb3giLCJnZXRIIiwibmFtIiwicmVtb3ZlQ2hpbGQiLCJzZWxlY3RBbGwiLCJub2RlbGlzdCIsImFkZDJncm91cCIsImxpc3QiLCJjaGlsZE5vZGVzIiwic2V0SW50ZXJ2YWwiLCJzbmFwIiwicGFwZXIiLCJ0YWdOYW1lIiwiYW5pbXMiLCJ0cmFuc2Zvcm0iLCJtYXNrIiwic3ltYm9sIiwianNvbiIsImF0dCIsInBhcnNlIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImZ1bGwiLCJpbm5lckhUTUwiLCJmaXJzdENoaWxkIiwiRnJhZ21lbnQiLCJmcmFnIiwiZnJhZ21lbnQiLCJkZXNjIiwicHJvdG8iLCJvd25lckRvY3VtZW50IiwiZG9tIiwiY29udGVudERvY3VtZW50IiwiY2giLCJqc29uRmlsbGVyIiwidG9KU09OIiwibGFzdEluZGV4T2YiLCJsZXR0ZXIiLCJjc3NBdHRyIiwiYWpheCIsInBvc3REYXRhIiwicmVxIiwiWE1MSHR0cFJlcXVlc3QiLCJwZCIsImVuY29kZVVSSUNvbXBvbmVudCIsInNldFJlcXVlc3RIZWFkZXIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwic2VuZCIsInJlc3BvbnNlVGV4dCIsImdldE9mZnNldCIsImJveCIsImRvY0VsZW0iLCJjbGllbnRUb3AiLCJjbGllbnRMZWZ0IiwiZ2V0RWxlbWVudEJ5UG9pbnQiLCJjYW52YXMiLCJlbGVtZW50RnJvbVBvaW50Iiwib3BlcmEiLCJzbyIsInNyIiwiY3JlYXRlU1ZHUmVjdCIsImhpdHMiLCJnZXRJbnRlcnNlY3Rpb25MaXN0IiwiZWxwcm90byIsImlzV2l0aG91dFRyYW5zZm9ybSIsInJlbW92ZWQiLCJsb2NhbE1hdHJpeCIsIm9yaWdpbmFsIiwiaHJlZiIsImdldEVsZW1lbnRCeUlkIiwicGF0aGZpbmRlciIsImRlZmx0IiwiYmJveHd0IiwicmVhbFBhdGgiLCJtYXRyaXgiLCJwcm9wU3RyaW5nIiwiZXh0cmFjdFRyYW5zZm9ybSIsImRvUmV0dXJuIiwicGFwYSIsImdsb2JhbCIsImdldENUTSIsImxvY2FsIiwibXMiLCJsb2NhbFN0cmluZyIsInRvVHJhbnNmb3JtU3RyaW5nIiwiZ2xvYmFsTWF0cml4IiwidG90YWxNYXRyaXgiLCJkaWZmTWF0cml4IiwidG90YWwiLCJncmFkaWVudFRyYW5zZm9ybSIsInBhdHRlcm5UcmFuc2Zvcm0iLCJpdCIsImluc2VydEFmdGVyIiwiYXNQWCIsInVzZSIsImZpeGlkcyIsImVscyIsImlkcyIsInVzZXMiLCJ1cmx0ZXN0IiwibGlua3Rlc3QiLCJvbGRpZCIsIm9sZCIsImZzIiwiY2xvbmVOb2RlIiwidG9EZWZzIiwidG9QYXR0ZXJuIiwicGF0dGVyblVuaXRzIiwidmlld0JveCIsIm1hcmtlciIsInJlZlgiLCJyZWZZIiwiY3giLCJjeSIsIm1hcmtlcldpZHRoIiwibWFya2VySGVpZ2h0Iiwib3JpZW50IiwiZnJvbSIsInRvIiwiQW5pbWF0aW9uIiwiaW5BbmltIiwiX2F0dHJzIiwiX2NhbGxiYWNrIiwiY3VyU3RhdHVzIiwic2V0dGVyIiwiZmtleXMiLCJ0a2V5cyIsImVxdWFsIiwiZWxkYXRhIiwib3V0ZXJTVkciLCJpbm5lclNWRyIsImNobGQiLCJ0b0RhdGFVUkwiLCJidG9hIiwiY29udGVudHMiLCJ1bmVzY2FwZSIsImQiLCJtYXRyaXhwcm90byIsIm1lIiwibm9ybSIsIm5vcm1hbGl6ZSIsIm1hZyIsImRldGVybWluYW50Iiwicm93Iiwic2NhbGV4Iiwic2hlYXIiLCJzY2FsZXkiLCJpc1NpbXBsZSIsImlzU3VwZXJTaW1wbGUiLCJub1JvdGF0aW9uIiwic2hvcnRlciIsImNsaXBJdCIsImNsaXAiLCJmaWxsU3Ryb2tlIiwiZ3JhZCIsImdyYWRpZW50IiwiZ3JhZHJnIiwicGFyc2VHcmFkIiwidG9rZW5zIiwic3RvcHMiLCJ0b0Fic29sdXRlIiwidHh0IiwiYmFzZVZhbCIsInZiIiwicngiLCJyeSIsInRwIiwidGV4dFBhdGgiLCJ0dW5lciIsImNodW5rIiwidHVuZWQiLCJzZXRGb250U2l6ZSIsImdldHRlciIsInRleHRFeHRyYWN0IiwiY2hpIiwiZ2V0Rm9udFNpemUiLCJyZ05vdFNwYWNlIiwicmdCYWRTcGFjZSIsInJnVHJpbSIsImNsYXNzZXMiLCJjdXJDbGFzc2VzIiwicG9zIiwiY2xhenoiLCJmaW5hbFZhbHVlIiwiZmxhZyIsIm9wZXJhdG9ycyIsInJlVW5pdCIsInJlQWRkb24iLCJnZXROdW1iZXIiLCJnZXRVbml0IiwidW5pdCIsInBsdXMiLCJldm50IiwiYXRyIiwiYVVuaXQiLCJvcCIsImJwbHVzIiwiY2lyY2xlIiwicHJlbG9hZCIsIm9uZXJyb3IiLCJzcmMiLCJpbWciLCJvbmxvYWQiLCJpbWFnZSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJlbGxpcHNlIiwidmJ4IiwidmJ5IiwidmJ3IiwidmJoIiwicHRybiIsInZ4IiwidnkiLCJ2dyIsInZoIiwibGluZSIsInBvbHlsaW5lIiwicG9seWdvbiIsIkdzdG9wcyIsIkdhZGRTdG9wIiwiR2dldEJCb3giLCJ1bnNoaWZ0IiwiZ3JhZGllbnRMaW5lYXIiLCJncmFkaWVudFJhZGlhbCIsImdyYWRpZW50VW5pdHMiLCJzZWVkIiwiYWRkU3RvcCIsImZ4IiwiZnkiLCJwMnMiLCJwYXRocyIsInBzIiwic2xlZXAiLCJyMSIsInIyIiwicjAiLCJyZWN0UGF0aCIsInBhdGhDbG9uZSIsInBhdGhBcnJheSIsImdldFBvaW50QXRTZWdtZW50TGVuZ3RoIiwicDF4IiwicDF5IiwiYzF4IiwiYzF5IiwiYzJ4IiwiYzJ5IiwicDJ4IiwicDJ5IiwiYmV6bGVuIiwiZmluZERvdHNBdFNlZ21lbnQiLCJnZXRUb3RMZW4iLCJnZXRMZW5ndGhGYWN0b3J5IiwiaXN0b3RhbCIsInN1YnBhdGgiLCJPIiwib25seXN0YXJ0IiwicGF0aDJjdXJ2ZSIsInNwIiwic3VicGF0aHMiLCJwb2ludCIsImdldFN1YnBhdGhzQXRMZW5ndGgiLCJ0MSIsInQxMyIsInQxMiIsInQyIiwidDMiLCJteCIsIm15IiwibngiLCJueSIsImF4IiwiYXkiLCJiZXppZXJCQm94IiwiY3VydmVEaW0iLCJpc1BvaW50SW5zaWRlQkJveCIsImlzQkJveEludGVyc2VjdCIsImJib3gxIiwiYmJveDIiLCJiYXNlMyIsInAxIiwicDIiLCJwMyIsInA0IiwieDQiLCJ5NCIsInoyIiwiVHZhbHVlcyIsIkN2YWx1ZXMiLCJzdW0iLCJjdCIsInhiYXNlIiwieWJhc2UiLCJjb21iIiwibGwiLCJpbnRlcnNlY3QiLCJkZW5vbWluYXRvciIsInB4IiwicHkiLCJweDIiLCJweTIiLCJpbnRlciIsImJlejEiLCJiZXoyIiwiaW50ZXJIZWxwZXIiLCJpbnRlckNvdW50IiwianVzdENvdW50IiwibDEiLCJsMiIsIm4xIiwibjIiLCJkb3RzMSIsImRvdHMyIiwieHkiLCJkaSIsImRpMSIsImRqIiwiZGoxIiwiY2kiLCJjaiIsInBhdGhJbnRlcnNlY3Rpb24iLCJwYXRoMSIsInBhdGgyIiwiaW50ZXJQYXRoSGVscGVyIiwicGF0aEludGVyc2VjdGlvbk51bWJlciIsIngxbSIsInkxbSIsIngybSIsInkybSIsInBpIiwicGoiLCJpbnRyIiwia2siLCJzZWdtZW50MSIsInNlZ21lbnQyIiwiaXNQb2ludEluc2lkZVBhdGgiLCJwYXRoQkJveCIsInhtaW4iLCJ5bWluIiwieG1heCIsInltYXgiLCJlbGxpcHNlUGF0aCIsImdldFBhdGgiLCJwYXRoVG9SZWxhdGl2ZSIsImxvd2VyQ2FzZSIsInJlbCIsInBhIiwicGF0aFRvQWJzb2x1dGUiLCJwYTAiLCJjcnoiLCJkb3RzIiwicG9wIiwiY2F0bXVsbFJvbTJiZXppZXIiLCJsMmMiLCJxMmMiLCJfMTMiLCJfMjMiLCJhMmMiLCJsYXJnZV9hcmNfZmxhZyIsInN3ZWVwX2ZsYWciLCJyZWN1cnNpdmUiLCJfMTIwIiwicngyIiwicnkyIiwiZjEiLCJkZiIsImYyb2xkIiwieDJvbGQiLCJ5Mm9sZCIsImMxIiwiczEiLCJjMiIsInMyIiwiaHgiLCJoeSIsIm0xIiwibTIiLCJtMyIsIm00IiwibmV3cmVzIiwiZmluZERvdEF0U2VnbWVudCIsIngwIiwieTAiLCJ0dmFsdWVzIiwiYm91bmRzIiwiYjJhYyIsInNxcnRiMmFjIiwiamxlbiIsIm10IiwiY3VydmUiLCJieCIsImJ5IiwicXgiLCJxeSIsImF0dHJzMiIsInByb2Nlc3NQYXRoIiwicGNvbSIsIlQiLCJmaXhBcmMiLCJwcCIsInBjb21zMSIsInBjb21zMiIsImZpeE0iLCJhMSIsImEyIiwicGZpcnN0Iiwic2VnIiwic2VnMiIsInNlZ2xlbiIsInNlZzJsZW4iLCJtYXBQYXRoIiwicGF0aGkiLCJjcnAiLCJpTGVuIiwiZ2V0U3VicGF0aCIsImluc2lkZSIsImZvdW5kIiwiaW50ZXJzZWN0aW9uIiwiaW50ZXJzZWN0aW9uTnVtYmVyIiwiaXNQb2ludEluc2lkZSIsInRvUmVsYXRpdmUiLCJ0b0N1YmljIiwiU2V0IiwiYmluZGluZ3MiLCJzZXRwcm90byIsInRoaXNBcmciLCJiZWdpbiIsImhhbmRsZXIiLCJjYWxsYmFja2VyIiwiYW5hbWUiLCJ1bmJvdW5kIiwiaW5zZXJ0aW9uIiwidGFpbCIsInRvZGVsIiwiYXJnbGVuIiwiZXhjbHVkZSIsInN0cm9rZSIsImdldEVtcHR5IiwiZXF1YWxpc2VUcmFuc2Zvcm0iLCJtYXhsZW5ndGgiLCJ0dDEiLCJ0dDIiLCJwYXRoMmFycmF5IiwiZ2V0Vmlld0JveCIsImdldENvbG91ciIsImlzTnVtZXJpYyIsImFycmF5RXF1YWwiLCJhcnIxIiwiYXJyMiIsIk51bWJlciIsImJVbml0Iiwic3VwcG9ydHNUb3VjaCIsInRvdWNoTWFwIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsImdldFNjcm9sbCIsInByZXZlbnRUb3VjaCIsIm9yaWdpbmFsRXZlbnQiLCJjYW5jZWxCdWJibGUiLCJzdG9wVG91Y2giLCJhZGRFdmVudCIsInJlYWxOYW1lIiwic2Nyb2xsWSIsInNjcm9sbFgiLCJ0YXJnZXRUb3VjaGVzIiwib2xkZSIsImRyYWciLCJkcmFnTW92ZSIsImRyYWdpIiwidG91Y2giLCJpZGVudGlmaWVyIiwiX2RyYWciLCJkaXNwbGF5IiwibW92ZV9zY29wZSIsImRyYWdVcCIsInVubW91c2Vtb3ZlIiwidW5tb3VzZXVwIiwiZW5kX3Njb3BlIiwic3RhcnRfc2NvcGUiLCJldmVudE5hbWUiLCJmX2luIiwiZl9vdXQiLCJzY29wZV9pbiIsInNjb3BlX291dCIsIm1vdXNlb3ZlciIsIm1vdXNlb3V0IiwidW5ob3ZlciIsInVubW91c2VvdmVyIiwidW5tb3VzZW91dCIsIm9ubW92ZSIsIm9uc3RhcnQiLCJvbmVuZCIsIm9yaWdUcmFuc2Zvcm0iLCJ1bmRyYWciLCJ1bm1vdXNlZG93biIsInBwcm90byIsInJndXJsIiwiZmlsc3RyIiwiZmlsdGVyVW5pdHMiLCJkZWYiLCJzaGFkb3ciLCJncmF5c2NhbGUiLCJhbW91bnQiLCJzZXBpYSIsInNhdHVyYXRlIiwiaHVlUm90YXRlIiwiYW1vdW50MiIsImJyaWdodG5lc3MiLCJjb250cmFzdCIsImZpcnN0TGV0dGVyIiwiZ2V0QWxpZ24iLCJ3YXkiLCJhbGlnbiIsIl9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJTY3JvbGxSZXZlYWwiLCJjb25maWciLCJnZXRQcm90b3R5cGVPZiIsInRvb2xzIiwiVG9vbHMiLCJpc1N1cHBvcnRlZCIsIl9yZXNvbHZlQ29udGFpbmVyIiwic3RvcmUiLCJlbGVtZW50cyIsImNvbnRhaW5lcnMiLCJzZXF1ZW5jZXMiLCJ1aWQiLCJpbml0aWFsaXplZCIsIm9yaWdpbiIsIm1vYmlsZSIsInVzZURlbGF5Iiwidmlld0ZhY3RvciIsInZpZXdPZmZzZXQiLCJiZWZvcmVSZXZlYWwiLCJkb21FbCIsImFmdGVyUmV2ZWFsIiwiYmVmb3JlUmVzZXQiLCJhZnRlclJlc2V0IiwiaW50ZXJ2YWwiLCJzeW5jIiwic2VxdWVuY2UiLCJzZXF1ZW5jZUlkIiwiX2dldFJldmVhbEVsZW1lbnRzIiwiX25leHRVaWQiLCJlbGVtSWRzIiwiYWN0aXZlIiwic2VlbiIsInJldmVhbGluZyIsIl9jb25maWd1cmUiLCJfc3R5bGUiLCJfdXBkYXRlU3RvcmUiLCJzdHlsZXMiLCJpbmxpbmUiLCJpbml0aWFsIiwiX3JlY29yZCIsImluaXRUaW1lb3V0IiwicmVjb3JkIiwiaXNOb2RlIiwiaXNOb2RlTGlzdCIsImV4dGVuZENsb25lIiwiYXhpcyIsImNvbXB1dGVkIiwidHJhbnNpdGlvbiIsImluc3RhbnQiLCJfZ2VuZXJhdGVUcmFuc2l0aW9uIiwiZGVsYXllZCIsIl9nZW5lcmF0ZVRyYW5zZm9ybSIsImNzc0Rpc3RhbmNlIiwic3Vic3RyIiwiX2FuaW1hdGUiLCJfaGFuZGxlciIsIl9zZXRBY3RpdmVTZXF1ZW5jZXMiLCJmb3JPd24iLCJfaXNFbGVtVmlzaWJsZSIsIl9zaG91bGRVc2VEZWxheSIsIl9zaG91bGRSZXZlYWwiLCJfcXVldWVDYWxsYmFjayIsIl9xdWV1ZU5leHRJblNlcXVlbmNlIiwiX3Nob3VsZFJlc2V0IiwiZWxhcHNlZCIsImJsb2NrZWQiLCJzdGFydGVkIiwiY2xvY2siLCJfZ2V0Q29udGFpbmVyIiwiY2xpZW50V2lkdGgiLCJfZ2V0U2Nyb2xsZWQiLCJfZ2V0T2Zmc2V0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsIm9mZnNldFBhcmVudCIsInNjcm9sbGVkIiwidkYiLCJlbGVtV2lkdGgiLCJlbGVtVG9wIiwiZWxlbUxlZnQiLCJlbGVtQm90dG9tIiwiZWxlbVJpZ2h0IiwiY29uZmlybUJvdW5kcyIsImlzUG9zaXRpb25GaXhlZCIsInZpZXdUb3AiLCJ2aWV3TGVmdCIsInZpZXdCb3R0b20iLCJ2aWV3UmlnaHQiLCJpc09iamVjdCIsIm9iamVjdCIsIk5vZGUiLCJwcm90b3R5cGVUb1N0cmluZyIsInJlZ2V4IiwiTm9kZUxpc3QiLCJwcm9wZXJ0eSIsInNvdXJjZSIsIkJSIiwiYWRkTGlzdGVuZXJzIiwiY2xpY2siLCJ0cmlnZ2VySWQiLCJzbGlkZVRvZ2dsZSIsIkJSX0NPT0tJRVMiLCJ2aXNpdERpdmVyc2l0eSIsInNob3dEaXZlcnNpdHlNb2RhbCIsIm9uTG9hZCIsImNyZWF0ZUNvb2tpZSIsImRheXMiLCJzZXRUaW1lIiwiZXhwaXJlcyIsInRvR01UU3RyaW5nIiwiY29va2llIiwicmVhZENvb2tpZSIsIm5hbWVFUSIsImNhIiwiZXJhc2VDb29raWUiLCJ2aXNpdGVkRGl2ZXJzaXR5IiwiZGl2ZXJzaXR5TW9kYWwiLCJyZWFkeSIsIkVYUEFOREVSIiwiaGlkZGVuRXhwZXJpZW5jZXMiLCJoaWRkZW5NZW51SXRlbXMiLCJleHBhbmRlciIsImhpZGRlbkpvYkRlc2NyaXB0b24iLCJJTlNJR0hUUyIsImNoYW5nZSIsInNlbGVjdHMiLCJxdWVyeVN0cmluZ0Jhc2UiLCJxdWVyeVN0cmluZyIsImZpbHRlcnMiLCJwYXJhbU5hbWUiLCJwYXJhbVZhbHVlIiwic2VsZWN0ZWREYXRlIiwic2VsZWN0ZWRHZW9ncmFwaHkiLCJzZWxlY3RlZEluZHVzdHJ5Iiwic2VsZWN0ZWRQcmFjdGljZSIsInNlbGVjdGVkTGFuZ3VhZ2UiLCJzZWxlY3RlZExvY2F0aW9ucyIsInNlbGVjdGVkQWRtaXNzaW9uIiwic2VsZWN0ZWRFZHVjYXRpb24iLCJzZWxlY3RlZEtleXdvcmQiLCJkYXRlU2VsZWN0IiwiZ2VvZ3JhcGh5U2VsZWN0IiwiaW5kdXN0cnlTZWxlY3QiLCJwcmFjdGljZVNlbGVjdCIsImxhbmd1YWdlU2VsZWN0IiwibG9jYXRpb25TZWxlY3QiLCJhZG1pc3Npb25TZWxlY3QiLCJlZHVjYXRpb25TZWxlY3QiLCJrZXl3b3JkSW5wdXQiLCJMT0NBVElPTlNFQVJDSEVSIiwiZGV0ZWN0Q2hhbmdlIiwia2V5d29yZCIsImpvYktleXdvcmQiLCJtb2JpbGVNZW51Iiwib3BlbkRyb3Bkb3duIiwiY2hlY2tTY3JvbGwiLCJkaXNhYmxlU2Nyb2xsIiwiTkFWIiwiZGVza3RvcE1lbnUiLCJzY3JvbGxFdmVudHMiLCJkZXNrdG9wQ2hlY2siLCJtb2JpbGVDaGVjayIsImNoZWNrIiwic3VibWVudUNvcnJlY3Rpb24iLCJtb3VzZUV2ZW50IiwidXNlclNjcm9sbCIsIlBFT1BMRSIsImxldHRlcmxMaW5rSW5uZXJXcmFwcGVycyIsImxldHRlckFuY2hvciIsInNlbGVjdGVkbGV0dGVybExpbmtJbm5lcldyYXBwZXIiLCJyZXZlYWxBZHZhbmNlZFNlYXJjaCIsInN0aWNreVNpZGVCYXIiLCJoaWRlQWR2YW5jZWRTZWFyY2giLCJzY3JvbGxCYWNrVG9Ub3AiLCJoZWFkZXJIZWlnaHQiLCJlbGVtZW50VG9TdGljayIsInN0aWNrX2luX3BhcmVudCIsIm9mZnNldF90b3AiLCJob21lcGFnZSIsImluaXRpYWxpemVTbGlkZXIiLCJhbmltYXRlU3ZnIiwic3Ryb2tlV2lkdGgiLCJzbGljayIsImN1cnJlbnRTbGlkZSIsIm5leHRTbGlkZSIsInNsaWRlIiwic2xpZGVzVG9TaG93Iiwic2xpZGVzVG9TY3JvbGwiLCJhdXRvcGxheSIsImF1dG9wbGF5U3BlZWQiLCJhcnJvd3MiLCJmYWRlIiwicHJldkFycm93IiwibmV4dEFycm93IiwiZm9vdGVyIiwic3RpY2t5Rm9vdGVyIiwiU1VNTUVSIiwiZXhwYW5kU2NoZWR1bGUiLCJzdW1tZXJNb2RhbCIsImVsbSIsImVuYWJsZV9ib3R0b21pbmciLCJpbm5lcl9zY3JvbGxpbmciLCJtYW51YWxfc3BhY2VyIiwicGFyZW50X3NlbGVjdG9yIiwicmVjYWxjX2V2ZXJ5Iiwic3RpY2t5X2NsYXNzIiwic3BhY2VyIiwiYm90dG9taW5nIiwicGFkZGluZ19ib3R0b20iLCJwYXJlbnRfdG9wIiwicGFyZW50X2hlaWdodCIsImVsX2Zsb2F0IiwiZGV0YWNoZWQiLCJib3R0b21lZCIsImZpeGVkIiwibGFzdF9wb3MiLCJsYXN0X3Njcm9sbF9oZWlnaHQiLCJyZWNhbGMiLCJyZWNhbGNfYW5kX3RpY2siLCJyZWNhbGNfY291bnRlciIsInRpY2siLCJib3JkZXJfdG9wIiwicGFkZGluZ190b3AiLCJyZXN0b3JlIiwiZGVsdGEiLCJyZWNhbGNlZCIsIndpbGxfYm90dG9tIiwid2luX2hlaWdodCIsImRpc2FibGVXaGVlbCIsImRpc2FibGVTY3JvbGxiYXIiLCJkaXNhYmxlS2V5cyIsInNjcm9sbEV2ZW50S2V5cyIsImxvY2tUb1Njcm9sbFBvcyIsIl9leHRlbmQiLCJfaGFuZGxlV2hlZWwiLCJfZGlzYWJsZVNjcm9sbGJhckZuIiwiX2hhbmRsZVNjcm9sbGJhciIsIl9kaXNhYmxlS2V5c0ZuIiwiX2hhbmRsZUtleWRvd24iLCJzY3JvbGxUbyIsImJhY2tzdHJldGNoIiwiZXhwciIsImNlbnRlcmVkWCIsImNlbnRlcmVkWSIsIm92ZXJmbG93IiwicGFkZGluZyIsImJvcmRlciIsIm1heEhlaWdodCIsIm1heFdpZHRoIiwiaXNCb2R5IiwiJHJvb3QiLCIkd3JhcCIsImJhY2tncm91bmQiLCJwcm94eSIsInJlc2l6ZSIsImlubmVyV2lkdGgiLCIkaW1nIiwicmVsYXRlZFRhcmdldCIsIkV2ZW50IiwiY2xlYXJJbnRlcnZhbCIsInBhdXNlZCIsImN5Y2xlIiwicGxhdGZvcm0iLCJvcGVyYW1pbmkiLCJTbGljayIsImluc3RhbmNlVWlkIiwic2V0dGluZ3MiLCJkYXRhU2V0dGluZ3MiLCJhY2Nlc3NpYmlsaXR5IiwiYWRhcHRpdmVIZWlnaHQiLCJhcHBlbmRBcnJvd3MiLCJhcHBlbmREb3RzIiwiYXNOYXZGb3IiLCJjZW50ZXJNb2RlIiwiY2VudGVyUGFkZGluZyIsImNzc0Vhc2UiLCJjdXN0b21QYWdpbmciLCJzbGlkZXIiLCJkb3RzQ2xhc3MiLCJlZGdlRnJpY3Rpb24iLCJmb2N1c09uU2VsZWN0IiwiaW5pdGlhbFNsaWRlIiwibGF6eUxvYWQiLCJtb2JpbGVGaXJzdCIsInBhdXNlT25Gb2N1cyIsInBhdXNlT25Eb3RzSG92ZXIiLCJyZXNwb25kVG8iLCJyZXNwb25zaXZlIiwicm93cyIsInNsaWRlc1BlclJvdyIsInN3aXBlVG9TbGlkZSIsInRvdWNoTW92ZSIsInRvdWNoVGhyZXNob2xkIiwidXNlQ1NTIiwidXNlVHJhbnNmb3JtIiwidmFyaWFibGVXaWR0aCIsInZlcnRpY2FsU3dpcGluZyIsIndhaXRGb3JBbmltYXRlIiwiaW5pdGlhbHMiLCJhbmltYXRpbmciLCJkcmFnZ2luZyIsImF1dG9QbGF5VGltZXIiLCJjdXJyZW50RGlyZWN0aW9uIiwiY3VycmVudExlZnQiLCIkZG90cyIsImxpc3RXaWR0aCIsImxpc3RIZWlnaHQiLCJsb2FkSW5kZXgiLCIkbmV4dEFycm93IiwiJHByZXZBcnJvdyIsInNsaWRlQ291bnQiLCJzbGlkZVdpZHRoIiwiJHNsaWRlVHJhY2siLCJzbGlkaW5nIiwic2xpZGVPZmZzZXQiLCJzd2lwZUxlZnQiLCIkbGlzdCIsInRvdWNoT2JqZWN0IiwidHJhbnNmb3Jtc0VuYWJsZWQiLCJ1bnNsaWNrZWQiLCJhY3RpdmVCcmVha3BvaW50IiwiYW5pbVR5cGUiLCJhbmltUHJvcCIsImJyZWFrcG9pbnRzIiwiYnJlYWtwb2ludFNldHRpbmdzIiwiY3NzVHJhbnNpdGlvbnMiLCJmb2N1c3NlZCIsImludGVycnVwdGVkIiwiaGlkZGVuIiwicG9zaXRpb25Qcm9wIiwicm93Q291bnQiLCJzaG91bGRDbGljayIsIiRzbGlkZXIiLCIkc2xpZGVzQ2FjaGUiLCJ0cmFuc2Zvcm1UeXBlIiwidHJhbnNpdGlvblR5cGUiLCJ2aXNpYmlsaXR5Q2hhbmdlIiwid2luZG93V2lkdGgiLCJ3aW5kb3dUaW1lciIsIm9yaWdpbmFsU2V0dGluZ3MiLCJtb3pIaWRkZW4iLCJ3ZWJraXRIaWRkZW4iLCJhdXRvUGxheUNsZWFyIiwiYXV0b1BsYXlJdGVyYXRvciIsImNsaWNrSGFuZGxlciIsInNlbGVjdEhhbmRsZXIiLCJzZXRQb3NpdGlvbiIsInN3aXBlSGFuZGxlciIsImRyYWdIYW5kbGVyIiwia2V5SGFuZGxlciIsImh0bWxFeHByIiwicmVnaXN0ZXJCcmVha3BvaW50cyIsImFjdGl2YXRlQURBIiwiYWRkU2xpZGUiLCJzbGlja0FkZCIsIm1hcmt1cCIsImFkZEJlZm9yZSIsInVubG9hZCIsInJlaW5pdCIsImFuaW1hdGVIZWlnaHQiLCJ0YXJnZXRIZWlnaHQiLCJhbmltYXRlU2xpZGUiLCJ0YXJnZXRMZWZ0IiwiYW5pbVByb3BzIiwiYW5pbVN0YXJ0IiwiY2VpbCIsImFwcGx5VHJhbnNpdGlvbiIsImRpc2FibGVUcmFuc2l0aW9uIiwiZ2V0TmF2VGFyZ2V0Iiwic2xpZGVIYW5kbGVyIiwic2xpZGVUbyIsImJ1aWxkQXJyb3dzIiwiYnVpbGREb3RzIiwiZG90IiwiZ2V0RG90Q291bnQiLCJidWlsZE91dCIsIndyYXBBbGwiLCJzZXR1cEluZmluaXRlIiwidXBkYXRlRG90cyIsInNldFNsaWRlQ2xhc3NlcyIsImJ1aWxkUm93cyIsIm5ld1NsaWRlcyIsIm51bU9mU2xpZGVzIiwib3JpZ2luYWxTbGlkZXMiLCJzbGlkZXNQZXJTZWN0aW9uIiwiZW1wdHkiLCJjaGVja1Jlc3BvbnNpdmUiLCJmb3JjZVVwZGF0ZSIsImJyZWFrcG9pbnQiLCJ0YXJnZXRCcmVha3BvaW50IiwicmVzcG9uZFRvV2lkdGgiLCJ0cmlnZ2VyQnJlYWtwb2ludCIsInNsaWRlcldpZHRoIiwidW5zbGljayIsInJlZnJlc2giLCJkb250QW5pbWF0ZSIsImluZGV4T2Zmc2V0IiwidW5ldmVuT2Zmc2V0IiwiY2hlY2tOYXZpZ2FibGUiLCJuYXZpZ2FibGVzIiwicHJldk5hdmlnYWJsZSIsImdldE5hdmlnYWJsZUluZGV4ZXMiLCJjbGVhblVwRXZlbnRzIiwiaW50ZXJydXB0IiwidmlzaWJpbGl0eSIsImNsZWFuVXBTbGlkZUV2ZW50cyIsIm9yaWVudGF0aW9uQ2hhbmdlIiwiY2xlYW5VcFJvd3MiLCJmYWRlU2xpZGUiLCJzbGlkZUluZGV4IiwiZmFkZVNsaWRlT3V0IiwiZmlsdGVyU2xpZGVzIiwic2xpY2tGaWx0ZXIiLCJmb2N1c0hhbmRsZXIiLCIkc2YiLCJnZXRDdXJyZW50Iiwic2xpY2tDdXJyZW50U2xpZGUiLCJicmVha1BvaW50IiwicGFnZXJRdHkiLCJnZXRMZWZ0IiwidmVydGljYWxIZWlnaHQiLCJ2ZXJ0aWNhbE9mZnNldCIsInRhcmdldFNsaWRlIiwiZmxvb3IiLCJnZXRPcHRpb24iLCJzbGlja0dldE9wdGlvbiIsIm9wdGlvbiIsImluZGV4ZXMiLCJnZXRTbGljayIsImdldFNsaWRlQ291bnQiLCJzbGlkZXNUcmF2ZXJzZWQiLCJzd2lwZWRTbGlkZSIsImNlbnRlck9mZnNldCIsImdvVG8iLCJzbGlja0dvVG8iLCJjcmVhdGlvbiIsInNldFByb3BzIiwic3RhcnRMb2FkIiwibG9hZFNsaWRlciIsImluaXRpYWxpemVFdmVudHMiLCJ1cGRhdGVBcnJvd3MiLCJpbml0QURBIiwiaW5pdEFycm93RXZlbnRzIiwiaW5pdERvdEV2ZW50cyIsImluaXRTbGlkZUV2ZW50cyIsImFjdGlvbiIsImluaXRVSSIsImxvYWRSYW5nZSIsImNsb25lUmFuZ2UiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmQiLCJsb2FkSW1hZ2VzIiwiaW1hZ2VzU2NvcGUiLCJpbWFnZVNvdXJjZSIsImltYWdlVG9Mb2FkIiwicHJvZ3Jlc3NpdmVMYXp5TG9hZCIsInNsaWNrTmV4dCIsInNsaWNrUGF1c2UiLCJwbGF5Iiwic2xpY2tQbGF5IiwicG9zdFNsaWRlIiwic2xpY2tQcmV2IiwidHJ5Q291bnQiLCIkaW1nc1RvTG9hZCIsImluaXRpYWxpemluZyIsImxhc3RWaXNpYmxlSW5kZXgiLCJjdXJyZW50QnJlYWtwb2ludCIsInJlc3BvbnNpdmVTZXR0aW5ncyIsIndpbmRvd0RlbGF5IiwicmVtb3ZlU2xpZGUiLCJzbGlja1JlbW92ZSIsInJlbW92ZUJlZm9yZSIsInJlbW92ZUFsbCIsInNldENTUyIsInBvc2l0aW9uUHJvcHMiLCJzZXREaW1lbnNpb25zIiwic2V0RmFkZSIsInNldEhlaWdodCIsInNldE9wdGlvbiIsInNsaWNrU2V0T3B0aW9uIiwiYm9keVN0eWxlIiwiV2Via2l0VHJhbnNpdGlvbiIsIk1velRyYW5zaXRpb24iLCJtc1RyYW5zaXRpb24iLCJPVHJhbnNmb3JtIiwicGVyc3BlY3RpdmVQcm9wZXJ0eSIsIndlYmtpdFBlcnNwZWN0aXZlIiwiTW96VHJhbnNmb3JtIiwiTW96UGVyc3BlY3RpdmUiLCJ3ZWJraXRUcmFuc2Zvcm0iLCJtc1RyYW5zZm9ybSIsImFsbFNsaWRlcyIsInJlbWFpbmRlciIsImluZmluaXRlQ291bnQiLCJ0YXJnZXRFbGVtZW50IiwiYW5pbVNsaWRlIiwib2xkU2xpZGUiLCJzbGlkZUxlZnQiLCJuYXZUYXJnZXQiLCJzd2lwZURpcmVjdGlvbiIsInhEaXN0IiwieURpc3QiLCJzd2lwZUFuZ2xlIiwic3RhcnRYIiwiY3VyWCIsInN0YXJ0WSIsImN1clkiLCJzd2lwZUVuZCIsInN3aXBlTGVuZ3RoIiwiZWRnZUhpdCIsIm1pblN3aXBlIiwiZmluZ2VyQ291bnQiLCJzd2lwZVN0YXJ0Iiwic3dpcGVNb3ZlIiwiZWRnZVdhc0hpdCIsImN1ckxlZnQiLCJwb3NpdGlvbk9mZnNldCIsInVuZmlsdGVyU2xpZGVzIiwic2xpY2tVbmZpbHRlciIsImZyb21CcmVha3BvaW50IiwidGFiaW5kZXgiLCJyb2xlIiwicHVybCIsInRhZzJhdHRyIiwiZm9ybSIsImJhc2UiLCJpZnJhbWUiLCJsaW5rIiwiYWxpYXNlcyIsInBhcnNlciIsInN0cmljdCIsImxvb3NlIiwiaXNpbnQiLCJwYXJzZVVyaSIsInN0cmljdE1vZGUiLCJkZWNvZGVVUkkiLCJ1cmkiLCJwYXJzZVN0cmluZyIsImhvc3QiLCJwcm90b2NvbCIsInBvcnQiLCJnZXRBdHRyTmFtZSIsInRuIiwicHJvbW90ZSIsInBhcnQiLCJtZXJnZSIsInBhaXIiLCJlcWwiLCJicmFjZSIsImxhc3RCcmFjZUluS2V5IiwiYWNjdW11bGF0b3IiLCJjdXJyIiwidkFyZyIsImtleV9hcnJheSIsImZwYXJhbSIsInNlZ21lbnQiLCJmc2VnbWVudCIsIkoiLCJLIiwiRiIsIkQiLCJJIl0sIm1hcHBpbmdzIjoiOztBQUFBQSxPQUFPQyxTQUFQLEdBQW9CLFlBQVc7O0FBRTdCOztBQUVBOzs7Ozs7QUFNQTs7QUFDQSxNQUFJQyxhQUFhLEVBQWpCOztBQUVBO0FBQ0EsTUFBSUMsSUFBSjs7QUFFQTtBQUNBLE1BQUlDLFNBQVMsS0FBYjs7QUFFQTtBQUNBLE1BQUlDLGVBQWUsSUFBbkI7O0FBRUE7QUFDQSxNQUFJQyxrQkFBa0IsQ0FDcEIsUUFEb0IsRUFFcEIsVUFGb0IsRUFHcEIsTUFIb0IsRUFJcEIsT0FKb0Is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SUFBWCxFQUFpQmlSLEVBQWpCLENBQW9CLG1CQUFwQixFQUF3QzZGLENBQXhDLENBSDZMLEVBR2xKZ29CLEVBQUU3dEIsRUFBRixDQUFLLG1CQUFMLEVBQXlCZzhCLENBQXpCLENBSGtKLEVBR3RIanNDLFdBQVcyK0IsQ0FBWCxFQUFhLENBQWIsQ0FIK0c7QUFHL0Y7QUFBQyxLQUwrUCxDQUs5UFQsSUFBRSxDQUFGLENBQUksS0FBSTZ6QyxJQUFFLEtBQUszc0UsTUFBWCxFQUFrQjg0QixJQUFFNnpDLENBQXBCLEVBQXNCN3pDLEdBQXRCO0FBQTBCcVosVUFBRSxLQUFLclosQ0FBTCxDQUFGLEVBQVU0ekMsRUFBRS96QyxFQUFFd1osQ0FBRixDQUFGLENBQVY7QUFBMUIsS0FBNEMsT0FBTyxJQUFQO0FBQVksR0FMM0Y7QUFLNEYsQ0FMekosRUFLMkpudkMsSUFMM0osQ0FLZ0ssSUFMaEsiLCJmaWxlIjoiZm91bmRhdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIndpbmRvdy53aGF0SW5wdXQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyaWFibGVzXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICovXG5cbiAgLy8gYXJyYXkgb2YgYWN0aXZlbHkgcHJlc3NlZCBrZXlzXG4gIHZhciBhY3RpdmVLZXlzID0gW107XG5cbiAgLy8gY2FjaGUgZG9jdW1lbnQuYm9keVxuICB2YXIgYm9keTtcblxuICAvLyBib29sZWFuOiB0cnVlIGlmIHRvdWNoIGJ1ZmZlciB0aW1lciBpcyBydW5uaW5nXG4gIHZhciBidWZmZXIgPSBmYWxzZTtcblxuICAvLyB0aGUgbGFzdCB1c2VkIGlucHV0IHR5cGVcbiAgdmFyIGN1cnJlbnRJbnB1dCA9IG51bGw7XG5cbiAgLy8gYGlucHV0YCB0eXBlcyB0aGF0IGRvbid0IGFjY2VwdCB0ZXh0XG4gIHZhciBub25UeXBpbmdJbnB1dHMgPSBbXG4gICAgJ2J1dHRvbicsXG4gICAgJ2NoZWNrYm94JyxcbiAgICAnZmlsZScsXG4gICAgJ2ltYWdlJyxcbiAgICAncmFkaW8nLFxuICAgICdyZXNldCcsXG4gICAgJ3N1Ym1pdCdcbiAgXTtcblxuICAvLyBkZXRlY3QgdmVyc2lvbiBvZiBtb3VzZSB3aGVlbCBldmVudCB0byB1c2VcbiAgLy8gdmlhIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy93aGVlbFxuICB2YXIgbW91c2VXaGVlbCA9IGRldGVjdFdoZWVsKCk7XG5cbiAgLy8gbGlzdCBvZiBtb2RpZmllciBrZXlzIGNvbW1vbmx5IHVzZWQgd2l0aCB0aGUgbW91c2UgYW5kXG4gIC8vIGNhbiBiZSBzYWZlbHkgaWdub3JlZCB0byBwcmV2ZW50IGZhbHNlIGtleWJvYXJkIGRldGVjdGlvblxuICB2YXIgaWdub3JlTWFwID0gW1xuICAgIDE2LCAvLyBzaGlmdFxuICAgIDE3LCAvLyBjb250cm9sXG4gICAgMTgsIC8vIGFsdFxuICAgIDkxLCAvLyBXaW5kb3dzIGtleSAvIGxlZnQgQXBwbGUgY21kXG4gICAgOTMgIC8vIFdpbmRvd3MgbWVudSAvIHJpZ2h0IEFwcGxlIGNtZFxuICBdO1xuXG4gIC8vIG1hcHBpbmcgb2YgZXZlbnRzIHRvIGlucHV0IHR5cGVzXG4gIHZhciBpbnB1dE1hcCA9IHtcbiAgICAna2V5ZG93bic6ICdrZXlib2FyZCcsXG4gICAgJ2tleXVwJzogJ2tleWJvYXJkJyxcbiAgICAnbW91c2Vkb3duJzogJ21vdXNlJyxcbiAgICAnbW91c2Vtb3ZlJzogJ21vdXNlJyxcbiAgICAnTVNQb2ludGVyRG93bic6ICdwb2ludGVyJyxcbiAgICAnTVNQb2ludGVyTW92ZSc6ICdwb2ludGVyJyxcbiAgICAncG9pbnRlcmRvd24nOiAncG9pbnRlcicsXG4gICAgJ3BvaW50ZXJtb3ZlJzogJ3BvaW50ZXInLFxuICAgICd0b3VjaHN0YXJ0JzogJ3RvdWNoJ1xuICB9O1xuXG4gIC8vIGFkZCBjb3JyZWN0IG1vdXNlIHdoZWVsIGV2ZW50IG1hcHBpbmcgdG8gYGlucHV0TWFwYFxuICBpbnB1dE1hcFtkZXRlY3RXaGVlbCgpXSA9ICdtb3VzZSc7XG5cbiAgLy8gYXJyYXkgb2YgYWxsIHVzZWQgaW5wdXQgdHlwZXNcbiAgdmFyIGlucHV0VHlwZXMgPSBbXTtcblxuICAvLyBtYXBwaW5nIG9mIGtleSBjb2RlcyB0byBhIGNvbW1vbiBuYW1lXG4gIHZhciBrZXlNYXAgPSB7XG4gICAgOTogJ3RhYicsXG4gICAgMTM6ICdlbnRlcicsXG4gICAgMTY6ICdzaGlmdCcsXG4gICAgMjc6ICdlc2MnLFxuICAgIDMyOiAnc3BhY2UnLFxuICAgIDM3OiAnbGVmdCcsXG4gICAgMzg6ICd1cCcsXG4gICAgMzk6ICdyaWdodCcsXG4gICAgNDA6ICdkb3duJ1xuICB9O1xuXG4gIC8vIG1hcCBvZiBJRSAxMCBwb2ludGVyIGV2ZW50c1xuICB2YXIgcG9pbnRlck1hcCA9IHtcbiAgICAyOiAndG91Y2gnLFxuICAgIDM6ICd0b3VjaCcsIC8vIHRyZWF0IHBlbiBsaWtlIHRvdWNoXG4gICAgNDogJ21vdXNlJ1xuICB9O1xuXG4gIC8vIHRvdWNoIGJ1ZmZlciB0aW1lclxuICB2YXIgdGltZXI7XG5cblxuICAvKlxuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uc1xuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAqL1xuXG4gIC8vIGFsbG93cyBldmVudHMgdGhhdCBhcmUgYWxzbyB0cmlnZ2VyZWQgdG8gYmUgZmlsdGVyZWQgb3V0IGZvciBgdG91Y2hzdGFydGBcbiAgZnVuY3Rpb24gZXZlbnRCdWZmZXIoKSB7XG4gICAgY2xlYXJUaW1lcigpO1xuICAgIHNldElucHV0KGV2ZW50KTtcblxuICAgIGJ1ZmZlciA9IHRydWU7XG4gICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGJ1ZmZlciA9IGZhbHNlO1xuICAgIH0sIDY1MCk7XG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJlZEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCFidWZmZXIpIHNldElucHV0KGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuQnVmZmVyZWRFdmVudChldmVudCkge1xuICAgIGNsZWFyVGltZXIoKTtcbiAgICBzZXRJbnB1dChldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW5wdXQoZXZlbnQpIHtcbiAgICB2YXIgZXZlbnRLZXkgPSBrZXkoZXZlbnQpO1xuICAgIHZhciB2YWx1ZSA9IGlucHV0TWFwW2V2ZW50LnR5cGVdO1xuICAgIGlmICh2YWx1ZSA9PT0gJ3BvaW50ZXInKSB2YWx1ZSA9IHBvaW50ZXJUeXBlKGV2ZW50KTtcblxuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHRoZSB2YWx1ZSBtYXRjaGVzIHRoZSBpbnB1dCB0eXBlIGFscmVhZHkgc2V0XG4gICAgaWYgKGN1cnJlbnRJbnB1dCAhPT0gdmFsdWUpIHtcbiAgICAgIHZhciBldmVudFRhcmdldCA9IHRhcmdldChldmVudCk7XG4gICAgICB2YXIgZXZlbnRUYXJnZXROb2RlID0gZXZlbnRUYXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBldmVudFRhcmdldFR5cGUgPSAoZXZlbnRUYXJnZXROb2RlID09PSAnaW5wdXQnKSA/IGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndHlwZScpIDogbnVsbDtcblxuICAgICAgaWYgKFxuICAgICAgICAoLy8gb25seSBpZiB0aGUgdXNlciBmbGFnIHRvIGFsbG93IHR5cGluZyBpbiBmb3JtIGZpZWxkcyBpc24ndCBzZXRcbiAgICAgICAgIWJvZHkuaGFzQXR0cmlidXRlKCdkYXRhLXdoYXRpbnB1dC1mb3JtdHlwaW5nJykgJiZcblxuICAgICAgICAvLyBvbmx5IGlmIGN1cnJlbnRJbnB1dCBoYXMgYSB2YWx1ZVxuICAgICAgICBjdXJyZW50SW5wdXQgJiZcblxuICAgICAgICAvLyBvbmx5IGlmIHRoZSBpbnB1dCBpcyBga2V5Ym9hcmRgXG4gICAgICAgIHZhbHVlID09PSAna2V5Ym9hcmQnICYmXG5cbiAgICAgICAgLy8gbm90IGlmIHRoZSBrZXkgaXMgYFRBQmBcbiAgICAgICAga2V5TWFwW2V2ZW50S2V5XSAhPT0gJ3RhYicgJiZcblxuICAgICAgICAvLyBvbmx5IGlmIHRoZSB0YXJnZXQgaXMgYSBmb3JtIGlucHV0IHRoYXQgYWNjZXB0cyB0ZXh0XG4gICAgICAgIChcbiAgICAgICAgICAgZXZlbnRUYXJnZXROb2RlID09PSAndGV4dGFyZWEnIHx8XG4gICAgICAgICAgIGV2ZW50VGFyZ2V0Tm9kZSA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgICAgKGV2ZW50VGFyZ2V0Tm9kZSA9PT0gJ2lucHV0JyAmJiBub25UeXBpbmdJbnB1dHMuaW5kZXhPZihldmVudFRhcmdldFR5cGUpIDwgMClcbiAgICAgICAgKSkgfHwgKFxuICAgICAgICAgIC8vIGlnbm9yZSBtb2RpZmllciBrZXlzXG4gICAgICAgICAgaWdub3JlTWFwLmluZGV4T2YoZXZlbnRLZXkpID4gLTFcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIC8vIGlnbm9yZSBrZXlib2FyZCB0eXBpbmdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaElucHV0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICdrZXlib2FyZCcpIGxvZ0tleXMoZXZlbnRLZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3dpdGNoSW5wdXQoc3RyaW5nKSB7XG4gICAgY3VycmVudElucHV0ID0gc3RyaW5nO1xuICAgIGJvZHkuc2V0QXR0cmlidXRlKCdkYXRhLXdoYXRpbnB1dCcsIGN1cnJlbnRJbnB1dCk7XG5cbiAgICBpZiAoaW5wdXRUeXBlcy5pbmRleE9mKGN1cnJlbnRJbnB1dCkgPT09IC0xKSBpbnB1dFR5cGVzLnB1c2goY3VycmVudElucHV0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleShldmVudCkge1xuICAgIHJldHVybiAoZXZlbnQua2V5Q29kZSkgPyBldmVudC5rZXlDb2RlIDogZXZlbnQud2hpY2g7XG4gIH1cblxuICBmdW5jdGlvbiB0YXJnZXQoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludGVyVHlwZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQucG9pbnRlclR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcG9pbnRlck1hcFtldmVudC5wb2ludGVyVHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSA/ICd0b3VjaCcgOiBldmVudC5wb2ludGVyVHlwZTsgLy8gdHJlYXQgcGVuIGxpa2UgdG91Y2hcbiAgICB9XG4gIH1cblxuICAvLyBrZXlib2FyZCBsb2dnaW5nXG4gIGZ1bmN0aW9uIGxvZ0tleXMoZXZlbnRLZXkpIHtcbiAgICBpZiAoYWN0aXZlS2V5cy5pbmRleE9mKGtleU1hcFtldmVudEtleV0pID09PSAtMSAmJiBrZXlNYXBbZXZlbnRLZXldKSBhY3RpdmVLZXlzLnB1c2goa2V5TWFwW2V2ZW50S2V5XSk7XG4gIH1cblxuICBmdW5jdGlvbiB1bkxvZ0tleXMoZXZlbnQpIHtcbiAgICB2YXIgZXZlbnRLZXkgPSBrZXkoZXZlbnQpO1xuICAgIHZhciBhcnJheVBvcyA9IGFjdGl2ZUtleXMuaW5kZXhPZihrZXlNYXBbZXZlbnRLZXldKTtcblxuICAgIGlmIChhcnJheVBvcyAhPT0gLTEpIGFjdGl2ZUtleXMuc3BsaWNlKGFycmF5UG9zLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XG4gICAgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgICAvLyBwb2ludGVyIGV2ZW50cyAobW91c2UsIHBlbiwgdG91Y2gpXG4gICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBidWZmZXJlZEV2ZW50KTtcbiAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBidWZmZXJlZEV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xuICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJEb3duJywgYnVmZmVyZWRFdmVudCk7XG4gICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlck1vdmUnLCBidWZmZXJlZEV2ZW50KTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBtb3VzZSBldmVudHNcbiAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgYnVmZmVyZWRFdmVudCk7XG4gICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGJ1ZmZlcmVkRXZlbnQpO1xuXG4gICAgICAvLyB0b3VjaCBldmVudHNcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcbiAgICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZXZlbnRCdWZmZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1vdXNlIHdoZWVsXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKG1vdXNlV2hlZWwsIGJ1ZmZlcmVkRXZlbnQpO1xuXG4gICAgLy8ga2V5Ym9hcmQgZXZlbnRzXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdW5CdWZmZXJlZEV2ZW50KTtcbiAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdW5CdWZmZXJlZEV2ZW50KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVuTG9nS2V5cyk7XG4gIH1cblxuXG4gIC8qXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICAgdXRpbGl0aWVzXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICovXG5cbiAgLy8gZGV0ZWN0IHZlcnNpb24gb2YgbW91c2Ugd2hlZWwgZXZlbnQgdG8gdXNlXG4gIC8vIHZpYSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWxcbiAgZnVuY3Rpb24gZGV0ZWN0V2hlZWwoKSB7XG4gICAgcmV0dXJuIG1vdXNlV2hlZWwgPSAnb253aGVlbCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgP1xuICAgICAgJ3doZWVsJyA6IC8vIE1vZGVybiBicm93c2VycyBzdXBwb3J0IFwid2hlZWxcIlxuXG4gICAgICBkb2N1bWVudC5vbm1vdXNld2hlZWwgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICdtb3VzZXdoZWVsJyA6IC8vIFdlYmtpdCBhbmQgSUUgc3VwcG9ydCBhdCBsZWFzdCBcIm1vdXNld2hlZWxcIlxuICAgICAgICAnRE9NTW91c2VTY3JvbGwnOyAvLyBsZXQncyBhc3N1bWUgdGhhdCByZW1haW5pbmcgYnJvd3NlcnMgYXJlIG9sZGVyIEZpcmVmb3hcbiAgfVxuXG5cbiAgLypcbiAgICAtLS0tLS0tLS0tLS0tLS1cbiAgICBpbml0XG5cbiAgICBkb24ndCBzdGFydCBzY3JpcHQgdW5sZXNzIGJyb3dzZXIgY3V0cyB0aGUgbXVzdGFyZCxcbiAgICBhbHNvIHBhc3NlcyBpZiBwb2x5ZmlsbHMgYXJlIHVzZWRcbiAgICAtLS0tLS0tLS0tLS0tLS1cbiAgKi9cblxuICBpZiAoXG4gICAgJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbmRvdyAmJlxuICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mXG4gICkge1xuXG4gICAgLy8gaWYgdGhlIGRvbSBpcyBhbHJlYWR5IHJlYWR5IGFscmVhZHkgKHNjcmlwdCB3YXMgcGxhY2VkIGF0IGJvdHRvbSBvZiA8Ym9keT4pXG4gICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGJpbmRFdmVudHMoKTtcblxuICAgIC8vIG90aGVyd2lzZSB3YWl0IGZvciB0aGUgZG9tIHRvIGxvYWQgKHNjcmlwdCB3YXMgcGxhY2VkIGluIHRoZSA8aGVhZD4pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBiaW5kRXZlbnRzKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICAgYXBpXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICovXG5cbiAgcmV0dXJuIHtcblxuICAgIC8vIHJldHVybnMgc3RyaW5nOiB0aGUgY3VycmVudCBpbnB1dCB0eXBlXG4gICAgYXNrOiBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRJbnB1dDsgfSxcblxuICAgIC8vIHJldHVybnMgYXJyYXk6IGN1cnJlbnRseSBwcmVzc2VkIGtleXNcbiAgICBrZXlzOiBmdW5jdGlvbigpIHsgcmV0dXJuIGFjdGl2ZUtleXM7IH0sXG5cbiAgICAvLyByZXR1cm5zIGFycmF5OiBhbGwgdGhlIGRldGVjdGVkIGlucHV0IHR5cGVzXG4gICAgdHlwZXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5wdXRUeXBlczsgfSxcblxuICAgIC8vIGFjY2VwdHMgc3RyaW5nOiBtYW51YWxseSBzZXQgdGhlIGlucHV0IHR5cGVcbiAgICBzZXQ6IHN3aXRjaElucHV0XG4gIH07XG5cbn0oKSk7XG4iLCIhZnVuY3Rpb24oJCkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEZPVU5EQVRJT05fVkVSU0lPTiA9ICc2LjIuMic7XG5cbi8vIEdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxuLy8gVGhpcyBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93LCBvciB1c2VkIGFzIGEgbW9kdWxlIGZvciBBTUQvQnJvd3NlcmlmeVxudmFyIEZvdW5kYXRpb24gPSB7XG4gIHZlcnNpb246IEZPVU5EQVRJT05fVkVSU0lPTixcblxuICAvKipcbiAgICogU3RvcmVzIGluaXRpYWxpemVkIHBsdWdpbnMuXG4gICAqL1xuICBfcGx1Z2luczoge30sXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBnZW5lcmF0ZWQgdW5pcXVlIGlkcyBmb3IgcGx1Z2luIGluc3RhbmNlc1xuICAgKi9cbiAgX3V1aWRzOiBbXSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gZm9yIFJUTCBzdXBwb3J0XG4gICAqL1xuICBydGw6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICQoJ2h0bWwnKS5hdHRyKCdkaXInKSA9PT0gJ3J0bCc7XG4gIH0sXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgRm91bmRhdGlvbiBwbHVnaW4sIGFkZGluZyBpdCB0byB0aGUgYEZvdW5kYXRpb25gIG5hbWVzcGFjZSBhbmQgdGhlIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplIHdoZW4gcmVmbG93aW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBwbHVnaW4uXG4gICAqL1xuICBwbHVnaW46IGZ1bmN0aW9uKHBsdWdpbiwgbmFtZSkge1xuICAgIC8vIE9iamVjdCBrZXkgdG8gdXNlIHdoZW4gYWRkaW5nIHRvIGdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxuICAgIC8vIEV4YW1wbGVzOiBGb3VuZGF0aW9uLlJldmVhbCwgRm91bmRhdGlvbi5PZmZDYW52YXNcbiAgICB2YXIgY2xhc3NOYW1lID0gKG5hbWUgfHwgZnVuY3Rpb25OYW1lKHBsdWdpbikpO1xuICAgIC8vIE9iamVjdCBrZXkgdG8gdXNlIHdoZW4gc3RvcmluZyB0aGUgcGx1Z2luLCBhbHNvIHVzZWQgdG8gY3JlYXRlIHRoZSBpZGVudGlmeWluZyBkYXRhIGF0dHJpYnV0ZSBmb3IgdGhlIHBsdWdpblxuICAgIC8vIEV4YW1wbGVzOiBkYXRhLXJldmVhbCwgZGF0YS1vZmYtY2FudmFzXG4gICAgdmFyIGF0dHJOYW1lICA9IGh5cGhlbmF0ZShjbGFzc05hbWUpO1xuXG4gICAgLy8gQWRkIHRvIHRoZSBGb3VuZGF0aW9uIG9iamVjdCBhbmQgdGhlIHBsdWdpbnMgbGlzdCAoZm9yIHJlZmxvd2luZylcbiAgICB0aGlzLl9wbHVnaW5zW2F0dHJOYW1lXSA9IHRoaXNbY2xhc3NOYW1lXSA9IHBsdWdpbjtcbiAgfSxcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBQb3B1bGF0ZXMgdGhlIF91dWlkcyBhcnJheSB3aXRoIHBvaW50ZXJzIHRvIGVhY2ggaW5kaXZpZHVhbCBwbHVnaW4gaW5zdGFuY2UuXG4gICAqIEFkZHMgdGhlIGB6ZlBsdWdpbmAgZGF0YS1hdHRyaWJ1dGUgdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGVkIHBsdWdpbnMgdG8gYWxsb3cgdXNlIG9mICQoc2VsZWN0b3IpLmZvdW5kYXRpb24obWV0aG9kKSBjYWxscy5cbiAgICogQWxzbyBmaXJlcyB0aGUgaW5pdGlhbGl6YXRpb24gZXZlbnQgZm9yIGVhY2ggcGx1Z2luLCBjb25zb2xpZGF0aW5nIHJlcGV0aXRpdmUgY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4sIHBhc3NlZCBhcyBhIGNhbWVsQ2FzZWQgc3RyaW5nLlxuICAgKiBAZmlyZXMgUGx1Z2luI2luaXRcbiAgICovXG4gIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4sIG5hbWUpe1xuICAgIHZhciBwbHVnaW5OYW1lID0gbmFtZSA/IGh5cGhlbmF0ZShuYW1lKSA6IGZ1bmN0aW9uTmFtZShwbHVnaW4uY29uc3RydWN0b3IpLnRvTG93ZXJDYXNlKCk7XG4gICAgcGx1Z2luLnV1aWQgPSB0aGlzLkdldFlvRGlnaXRzKDYsIHBsdWdpbk5hbWUpO1xuXG4gICAgaWYoIXBsdWdpbi4kZWxlbWVudC5hdHRyKGBkYXRhLSR7cGx1Z2luTmFtZX1gKSl7IHBsdWdpbi4kZWxlbWVudC5hdHRyKGBkYXRhLSR7cGx1Z2luTmFtZX1gLCBwbHVnaW4udXVpZCk7IH1cbiAgICBpZighcGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykpeyBwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nLCBwbHVnaW4pOyB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBpbml0aWFsaXplZC5cbiAgICAgICAgICAgKiBAZXZlbnQgUGx1Z2luI2luaXRcbiAgICAgICAgICAgKi9cbiAgICBwbHVnaW4uJGVsZW1lbnQudHJpZ2dlcihgaW5pdC56Zi4ke3BsdWdpbk5hbWV9YCk7XG5cbiAgICB0aGlzLl91dWlkcy5wdXNoKHBsdWdpbi51dWlkKTtcblxuICAgIHJldHVybjtcbiAgfSxcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBSZW1vdmVzIHRoZSBwbHVnaW5zIHV1aWQgZnJvbSB0aGUgX3V1aWRzIGFycmF5LlxuICAgKiBSZW1vdmVzIHRoZSB6ZlBsdWdpbiBkYXRhIGF0dHJpYnV0ZSwgYXMgd2VsbCBhcyB0aGUgZGF0YS1wbHVnaW4tbmFtZSBhdHRyaWJ1dGUuXG4gICAqIEFsc28gZmlyZXMgdGhlIGRlc3Ryb3llZCBldmVudCBmb3IgdGhlIHBsdWdpbiwgY29uc29saWRhdGluZyByZXBldGl0aXZlIGNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBhbiBpbnN0YW5jZSBvZiBhIHBsdWdpbiwgdXN1YWxseSBgdGhpc2AgaW4gY29udGV4dC5cbiAgICogQGZpcmVzIFBsdWdpbiNkZXN0cm95ZWRcbiAgICovXG4gIHVucmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uKHBsdWdpbil7XG4gICAgdmFyIHBsdWdpbk5hbWUgPSBoeXBoZW5hdGUoZnVuY3Rpb25OYW1lKHBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpLmNvbnN0cnVjdG9yKSk7XG5cbiAgICB0aGlzLl91dWlkcy5zcGxpY2UodGhpcy5fdXVpZHMuaW5kZXhPZihwbHVnaW4udXVpZCksIDEpO1xuICAgIHBsdWdpbi4kZWxlbWVudC5yZW1vdmVBdHRyKGBkYXRhLSR7cGx1Z2luTmFtZX1gKS5yZW1vdmVEYXRhKCd6ZlBsdWdpbicpXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBiZWVuIGRlc3Ryb3llZC5cbiAgICAgICAgICAgKiBAZXZlbnQgUGx1Z2luI2Rlc3Ryb3llZFxuICAgICAgICAgICAqL1xuICAgICAgICAgIC50cmlnZ2VyKGBkZXN0cm95ZWQuemYuJHtwbHVnaW5OYW1lfWApO1xuICAgIGZvcih2YXIgcHJvcCBpbiBwbHVnaW4pe1xuICAgICAgcGx1Z2luW3Byb3BdID0gbnVsbDsvL2NsZWFuIHVwIHNjcmlwdCB0byBwcmVwIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgfVxuICAgIHJldHVybjtcbiAgfSxcblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIENhdXNlcyBvbmUgb3IgbW9yZSBhY3RpdmUgcGx1Z2lucyB0byByZS1pbml0aWFsaXplLCByZXNldHRpbmcgZXZlbnQgbGlzdGVuZXJzLCByZWNhbGN1bGF0aW5nIHBvc2l0aW9ucywgZXRjLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGx1Z2lucyAtIG9wdGlvbmFsIHN0cmluZyBvZiBhbiBpbmRpdmlkdWFsIHBsdWdpbiBrZXksIGF0dGFpbmVkIGJ5IGNhbGxpbmcgYCQoZWxlbWVudCkuZGF0YSgncGx1Z2luTmFtZScpYCwgb3Igc3RyaW5nIG9mIGEgcGx1Z2luIGNsYXNzIGkuZS4gYCdkcm9wZG93bidgXG4gICAqIEBkZWZhdWx0IElmIG5vIGFyZ3VtZW50IGlzIHBhc3NlZCwgcmVmbG93IGFsbCBjdXJyZW50bHkgYWN0aXZlIHBsdWdpbnMuXG4gICAqL1xuICAgcmVJbml0OiBmdW5jdGlvbihwbHVnaW5zKXtcbiAgICAgdmFyIGlzSlEgPSBwbHVnaW5zIGluc3RhbmNlb2YgJDtcbiAgICAgdHJ5e1xuICAgICAgIGlmKGlzSlEpe1xuICAgICAgICAgcGx1Z2lucy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICQodGhpcykuZGF0YSgnemZQbHVnaW4nKS5faW5pdCgpO1xuICAgICAgICAgfSk7XG4gICAgICAgfWVsc2V7XG4gICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBwbHVnaW5zLFxuICAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgZm5zID0ge1xuICAgICAgICAgICAnb2JqZWN0JzogZnVuY3Rpb24ocGxncyl7XG4gICAgICAgICAgICAgcGxncy5mb3JFYWNoKGZ1bmN0aW9uKHApe1xuICAgICAgICAgICAgICAgcCA9IGh5cGhlbmF0ZShwKTtcbiAgICAgICAgICAgICAgICQoJ1tkYXRhLScrIHAgKyddJykuZm91bmRhdGlvbignX2luaXQnKTtcbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgJ3N0cmluZyc6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgcGx1Z2lucyA9IGh5cGhlbmF0ZShwbHVnaW5zKTtcbiAgICAgICAgICAgICAkKCdbZGF0YS0nKyBwbHVnaW5zICsnXScpLmZvdW5kYXRpb24oJ19pbml0Jyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgICd1bmRlZmluZWQnOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgIHRoaXNbJ29iamVjdCddKE9iamVjdC5rZXlzKF90aGlzLl9wbHVnaW5zKSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH07XG4gICAgICAgICBmbnNbdHlwZV0ocGx1Z2lucyk7XG4gICAgICAgfVxuICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgIH1maW5hbGx5e1xuICAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgICB9XG4gICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGEgcmFuZG9tIGJhc2UtMzYgdWlkIHdpdGggbmFtZXNwYWNpbmdcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBudW1iZXIgb2YgcmFuZG9tIGJhc2UtMzYgZGlnaXRzIGRlc2lyZWQuIEluY3JlYXNlIGZvciBtb3JlIHJhbmRvbSBzdHJpbmdzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIC0gbmFtZSBvZiBwbHVnaW4gdG8gYmUgaW5jb3Jwb3JhdGVkIGluIHVpZCwgb3B0aW9uYWwuXG4gICAqIEBkZWZhdWx0IHtTdHJpbmd9ICcnIC0gaWYgbm8gcGx1Z2luIG5hbWUgaXMgcHJvdmlkZWQsIG5vdGhpbmcgaXMgYXBwZW5kZWQgdG8gdGhlIHVpZC5cbiAgICogQHJldHVybnMge1N0cmluZ30gLSB1bmlxdWUgaWRcbiAgICovXG4gIEdldFlvRGlnaXRzOiBmdW5jdGlvbihsZW5ndGgsIG5hbWVzcGFjZSl7XG4gICAgbGVuZ3RoID0gbGVuZ3RoIHx8IDY7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKE1hdGgucG93KDM2LCBsZW5ndGggKyAxKSAtIE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygzNiwgbGVuZ3RoKSkpLnRvU3RyaW5nKDM2KS5zbGljZSgxKSArIChuYW1lc3BhY2UgPyBgLSR7bmFtZXNwYWNlfWAgOiAnJyk7XG4gIH0sXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHBsdWdpbnMgb24gYW55IGVsZW1lbnRzIHdpdGhpbiBgZWxlbWAgKGFuZCBgZWxlbWAgaXRzZWxmKSB0aGF0IGFyZW4ndCBhbHJlYWR5IGluaXRpYWxpemVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbSAtIGpRdWVyeSBvYmplY3QgY29udGFpbmluZyB0aGUgZWxlbWVudCB0byBjaGVjayBpbnNpZGUuIEFsc28gY2hlY2tzIHRoZSBlbGVtZW50IGl0c2VsZiwgdW5sZXNzIGl0J3MgdGhlIGBkb2N1bWVudGAgb2JqZWN0LlxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcGx1Z2lucyAtIEEgbGlzdCBvZiBwbHVnaW5zIHRvIGluaXRpYWxpemUuIExlYXZlIHRoaXMgb3V0IHRvIGluaXRpYWxpemUgZXZlcnl0aGluZy5cbiAgICovXG4gIHJlZmxvdzogZnVuY3Rpb24oZWxlbSwgcGx1Z2lucykge1xuXG4gICAgLy8gSWYgcGx1Z2lucyBpcyB1bmRlZmluZWQsIGp1c3QgZ3JhYiBldmVyeXRoaW5nXG4gICAgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcGx1Z2lucyA9IE9iamVjdC5rZXlzKHRoaXMuX3BsdWdpbnMpO1xuICAgIH1cbiAgICAvLyBJZiBwbHVnaW5zIGlzIGEgc3RyaW5nLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggb25lIGl0ZW1cbiAgICBlbHNlIGlmICh0eXBlb2YgcGx1Z2lucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBsdWdpbnMgPSBbcGx1Z2luc107XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHBsdWdpblxuICAgICQuZWFjaChwbHVnaW5zLCBmdW5jdGlvbihpLCBuYW1lKSB7XG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGx1Z2luXG4gICAgICB2YXIgcGx1Z2luID0gX3RoaXMuX3BsdWdpbnNbbmFtZV07XG5cbiAgICAgIC8vIExvY2FsaXplIHRoZSBzZWFyY2ggdG8gYWxsIGVsZW1lbnRzIGluc2lkZSBlbGVtLCBhcyB3ZWxsIGFzIGVsZW0gaXRzZWxmLCB1bmxlc3MgZWxlbSA9PT0gZG9jdW1lbnRcbiAgICAgIHZhciAkZWxlbSA9ICQoZWxlbSkuZmluZCgnW2RhdGEtJytuYW1lKyddJykuYWRkQmFjaygnW2RhdGEtJytuYW1lKyddJyk7XG5cbiAgICAgIC8vIEZvciBlYWNoIHBsdWdpbiBmb3VuZCwgaW5pdGlhbGl6ZSBpdFxuICAgICAgJGVsZW0uZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICRlbCA9ICQodGhpcyksXG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIC8vIERvbid0IGRvdWJsZS1kaXAgb24gcGx1Z2luc1xuICAgICAgICBpZiAoJGVsLmRhdGEoJ3pmUGx1Z2luJykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byBpbml0aWFsaXplIFwiK25hbWUrXCIgb24gYW4gZWxlbWVudCB0aGF0IGFscmVhZHkgaGFzIGEgRm91bmRhdGlvbiBwbHVnaW4uXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCRlbC5hdHRyKCdkYXRhLW9wdGlvbnMnKSl7XG4gICAgICAgICAgdmFyIHRoaW5nID0gJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbihlLCBpKXtcbiAgICAgICAgICAgIHZhciBvcHQgPSBlLnNwbGl0KCc6JykubWFwKGZ1bmN0aW9uKGVsKXsgcmV0dXJuIGVsLnRyaW0oKTsgfSk7XG4gICAgICAgICAgICBpZihvcHRbMF0pIG9wdHNbb3B0WzBdXSA9IHBhcnNlVmFsdWUob3B0WzFdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cnl7XG4gICAgICAgICAgJGVsLmRhdGEoJ3pmUGx1Z2luJywgbmV3IHBsdWdpbigkKHRoaXMpLCBvcHRzKSk7XG4gICAgICAgIH1jYXRjaChlcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcik7XG4gICAgICAgIH1maW5hbGx5e1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIGdldEZuTmFtZTogZnVuY3Rpb25OYW1lLFxuICB0cmFuc2l0aW9uZW5kOiBmdW5jdGlvbigkZWxlbSl7XG4gICAgdmFyIHRyYW5zaXRpb25zID0ge1xuICAgICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICdNb3pUcmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgJ09UcmFuc2l0aW9uJzogJ290cmFuc2l0aW9uZW5kJ1xuICAgIH07XG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgZW5kO1xuXG4gICAgZm9yICh2YXIgdCBpbiB0cmFuc2l0aW9ucyl7XG4gICAgICBpZiAodHlwZW9mIGVsZW0uc3R5bGVbdF0gIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgZW5kID0gdHJhbnNpdGlvbnNbdF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGVuZCl7XG4gICAgICByZXR1cm4gZW5kO1xuICAgIH1lbHNle1xuICAgICAgZW5kID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAkZWxlbS50cmlnZ2VySGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIFskZWxlbV0pO1xuICAgICAgfSwgMSk7XG4gICAgICByZXR1cm4gJ3RyYW5zaXRpb25lbmQnO1xuICAgIH1cbiAgfVxufTtcblxuRm91bmRhdGlvbi51dGlsID0ge1xuICAvKipcbiAgICogRnVuY3Rpb24gZm9yIGFwcGx5aW5nIGEgZGVib3VuY2UgZWZmZWN0IHRvIGEgZnVuY3Rpb24gY2FsbC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYXQgZW5kIG9mIHRpbWVvdXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIFRpbWUgaW4gbXMgdG8gZGVsYXkgdGhlIGNhbGwgb2YgYGZ1bmNgLlxuICAgKiBAcmV0dXJucyBmdW5jdGlvblxuICAgKi9cbiAgdGhyb3R0bGU6IGZ1bmN0aW9uIChmdW5jLCBkZWxheSkge1xuICAgIHZhciB0aW1lciA9IG51bGw7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICBpZiAodGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbi8vIFRPRE86IGNvbnNpZGVyIG5vdCBtYWtpbmcgdGhpcyBhIGpRdWVyeSBmdW5jdGlvblxuLy8gVE9ETzogbmVlZCB3YXkgdG8gcmVmbG93IHZzLiByZS1pbml0aWFsaXplXG4vKipcbiAqIFRoZSBGb3VuZGF0aW9uIGpRdWVyeSBtZXRob2QuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gbWV0aG9kIC0gQW4gYWN0aW9uIHRvIHBlcmZvcm0gb24gdGhlIGN1cnJlbnQgalF1ZXJ5IG9iamVjdC5cbiAqL1xudmFyIGZvdW5kYXRpb24gPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgbWV0aG9kLFxuICAgICAgJG1ldGEgPSAkKCdtZXRhLmZvdW5kYXRpb24tbXEnKSxcbiAgICAgICRub0pTID0gJCgnLm5vLWpzJyk7XG5cbiAgaWYoISRtZXRhLmxlbmd0aCl7XG4gICAgJCgnPG1ldGEgY2xhc3M9XCJmb3VuZGF0aW9uLW1xXCI+JykuYXBwZW5kVG8oZG9jdW1lbnQuaGVhZCk7XG4gIH1cbiAgaWYoJG5vSlMubGVuZ3RoKXtcbiAgICAkbm9KUy5yZW1vdmVDbGFzcygnbm8tanMnKTtcbiAgfVxuXG4gIGlmKHR5cGUgPT09ICd1bmRlZmluZWQnKXsvL25lZWRzIHRvIGluaXRpYWxpemUgdGhlIEZvdW5kYXRpb24gb2JqZWN0LCBvciBhbiBpbmRpdmlkdWFsIHBsdWdpbi5cbiAgICBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuX2luaXQoKTtcbiAgICBGb3VuZGF0aW9uLnJlZmxvdyh0aGlzKTtcbiAgfWVsc2UgaWYodHlwZSA9PT0gJ3N0cmluZycpey8vYW4gaW5kaXZpZHVhbCBtZXRob2QgdG8gaW52b2tlIG9uIGEgcGx1Z2luIG9yIGdyb3VwIG9mIHBsdWdpbnNcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7Ly9jb2xsZWN0IGFsbCB0aGUgYXJndW1lbnRzLCBpZiBuZWNlc3NhcnlcbiAgICB2YXIgcGx1Z0NsYXNzID0gdGhpcy5kYXRhKCd6ZlBsdWdpbicpOy8vZGV0ZXJtaW5lIHRoZSBjbGFzcyBvZiBwbHVnaW5cblxuICAgIGlmKHBsdWdDbGFzcyAhPT0gdW5kZWZpbmVkICYmIHBsdWdDbGFzc1ttZXRob2RdICE9PSB1bmRlZmluZWQpey8vbWFrZSBzdXJlIGJvdGggdGhlIGNsYXNzIGFuZCBtZXRob2QgZXhpc3RcbiAgICAgIGlmKHRoaXMubGVuZ3RoID09PSAxKXsvL2lmIHRoZXJlJ3Mgb25seSBvbmUsIGNhbGwgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgcGx1Z0NsYXNzW21ldGhvZF0uYXBwbHkocGx1Z0NsYXNzLCBhcmdzKTtcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSwgZWwpey8vb3RoZXJ3aXNlIGxvb3AgdGhyb3VnaCB0aGUgalF1ZXJ5IGNvbGxlY3Rpb24gYW5kIGludm9rZSB0aGUgbWV0aG9kIG9uIGVhY2hcbiAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseSgkKGVsKS5kYXRhKCd6ZlBsdWdpbicpLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfWVsc2V7Ly9lcnJvciBmb3Igbm8gY2xhc3Mgb3Igbm8gbWV0aG9kXG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJXZSdyZSBzb3JyeSwgJ1wiICsgbWV0aG9kICsgXCInIGlzIG5vdCBhbiBhdmFpbGFibGUgbWV0aG9kIGZvciBcIiArIChwbHVnQ2xhc3MgPyBmdW5jdGlvbk5hbWUocGx1Z0NsYXNzKSA6ICd0aGlzIGVsZW1lbnQnKSArICcuJyk7XG4gICAgfVxuICB9ZWxzZXsvL2Vycm9yIGZvciBpbnZhbGlkIGFyZ3VtZW50IHR5cGVcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBXZSdyZSBzb3JyeSwgJHt0eXBlfSBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIuIFlvdSBtdXN0IHVzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG1ldGhvZCB5b3Ugd2lzaCB0byBpbnZva2UuYCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG53aW5kb3cuRm91bmRhdGlvbiA9IEZvdW5kYXRpb247XG4kLmZuLmZvdW5kYXRpb24gPSBmb3VuZGF0aW9uO1xuXG4vLyBQb2x5ZmlsbCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4oZnVuY3Rpb24oKSB7XG4gIGlmICghRGF0ZS5ub3cgfHwgIXdpbmRvdy5EYXRlLm5vdylcbiAgICB3aW5kb3cuRGF0ZS5ub3cgPSBEYXRlLm5vdyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG5cbiAgdmFyIHZlbmRvcnMgPSBbJ3dlYmtpdCcsICdtb3onXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKytpKSB7XG4gICAgICB2YXIgdnAgPSB2ZW5kb3JzW2ldO1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2cCsnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSAod2luZG93W3ZwKydDYW5jZWxBbmltYXRpb25GcmFtZSddXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3dbdnArJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddKTtcbiAgfVxuICBpZiAoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgIHx8ICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8ICF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIG5leHRUaW1lID0gTWF0aC5tYXgobGFzdFRpbWUgKyAxNiwgbm93KTtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGxhc3RUaW1lID0gbmV4dFRpbWUpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0VGltZSAtIG5vdyk7XG4gICAgfTtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjbGVhclRpbWVvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFBvbHlmaWxsIGZvciBwZXJmb3JtYW5jZS5ub3csIHJlcXVpcmVkIGJ5IHJBRlxuICAgKi9cbiAgaWYoIXdpbmRvdy5wZXJmb3JtYW5jZSB8fCAhd2luZG93LnBlcmZvcm1hbmNlLm5vdyl7XG4gICAgd2luZG93LnBlcmZvcm1hbmNlID0ge1xuICAgICAgc3RhcnQ6IERhdGUubm93KCksXG4gICAgICBub3c6IGZ1bmN0aW9uKCl7IHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zdGFydDsgfVxuICAgIH07XG4gIH1cbn0pKCk7XG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24ob1RoaXMpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNVxuICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYUFyZ3MgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgIGZUb0JpbmQgPSB0aGlzLFxuICAgICAgICBmTk9QICAgID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgZkJvdW5kICA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QXG4gICAgICAgICAgICAgICAgID8gdGhpc1xuICAgICAgICAgICAgICAgICA6IG9UaGlzLFxuICAgICAgICAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuXG4gICAgaWYgKHRoaXMucHJvdG90eXBlKSB7XG4gICAgICAvLyBuYXRpdmUgZnVuY3Rpb25zIGRvbid0IGhhdmUgYSBwcm90b3R5cGVcbiAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG4gICAgfVxuICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuXG4gICAgcmV0dXJuIGZCb3VuZDtcbiAgfTtcbn1cbi8vIFBvbHlmaWxsIHRvIGdldCB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIGluIElFOVxuZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZuKSB7XG4gIGlmIChGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZ1bmNOYW1lUmVnZXggPSAvZnVuY3Rpb25cXHMoW14oXXsxLH0pXFwoLztcbiAgICB2YXIgcmVzdWx0cyA9IChmdW5jTmFtZVJlZ2V4KS5leGVjKChmbikudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSkgPyByZXN1bHRzWzFdLnRyaW0oKSA6IFwiXCI7XG4gIH1cbiAgZWxzZSBpZiAoZm4ucHJvdG90eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZm4uY29uc3RydWN0b3IubmFtZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZm4ucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoc3RyKXtcbiAgaWYoL3RydWUvLnRlc3Qoc3RyKSkgcmV0dXJuIHRydWU7XG4gIGVsc2UgaWYoL2ZhbHNlLy50ZXN0KHN0cikpIHJldHVybiBmYWxzZTtcbiAgZWxzZSBpZighaXNOYU4oc3RyICogMSkpIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiBzdHI7XG59XG4vLyBDb252ZXJ0IFBhc2NhbENhc2UgdG8ga2ViYWItY2FzZVxuLy8gVGhhbmsgeW91OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84OTU1NTgwXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG5Gb3VuZGF0aW9uLkJveCA9IHtcbiAgSW1Ob3RUb3VjaGluZ1lvdTogSW1Ob3RUb3VjaGluZ1lvdSxcbiAgR2V0RGltZW5zaW9uczogR2V0RGltZW5zaW9ucyxcbiAgR2V0T2Zmc2V0czogR2V0T2Zmc2V0c1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQgdG8gYSBjb250YWluZXIgYW5kIGRldGVybWluZXMgY29sbGlzaW9uIGV2ZW50cyB3aXRoIGNvbnRhaW5lci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHRlc3QgZm9yIGNvbGxpc2lvbnMuXG4gKiBAcGFyYW0ge2pRdWVyeX0gcGFyZW50IC0galF1ZXJ5IG9iamVjdCB0byB1c2UgYXMgYm91bmRpbmcgY29udGFpbmVyLlxuICogQHBhcmFtIHtCb29sZWFufSBsck9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayBsZWZ0IGFuZCByaWdodCB2YWx1ZXMgb25seS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdGJPbmx5IC0gc2V0IHRvIHRydWUgdG8gY2hlY2sgdG9wIGFuZCBib3R0b20gdmFsdWVzIG9ubHkuXG4gKiBAZGVmYXVsdCBpZiBubyBwYXJlbnQgb2JqZWN0IHBhc3NlZCwgZGV0ZWN0cyBjb2xsaXNpb25zIHdpdGggYHdpbmRvd2AuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIGNvbGxpc2lvbiBmcmVlLCBmYWxzZSBpZiBhIGNvbGxpc2lvbiBpbiBhbnkgZGlyZWN0aW9uLlxuICovXG5mdW5jdGlvbiBJbU5vdFRvdWNoaW5nWW91KGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHkpIHtcbiAgdmFyIGVsZURpbXMgPSBHZXREaW1lbnNpb25zKGVsZW1lbnQpLFxuICAgICAgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0O1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB2YXIgcGFyRGltcyA9IEdldERpbWVuc2lvbnMocGFyZW50KTtcblxuICAgIGJvdHRvbSA9IChlbGVEaW1zLm9mZnNldC50b3AgKyBlbGVEaW1zLmhlaWdodCA8PSBwYXJEaW1zLmhlaWdodCArIHBhckRpbXMub2Zmc2V0LnRvcCk7XG4gICAgdG9wICAgID0gKGVsZURpbXMub2Zmc2V0LnRvcCA+PSBwYXJEaW1zLm9mZnNldC50b3ApO1xuICAgIGxlZnQgICA9IChlbGVEaW1zLm9mZnNldC5sZWZ0ID49IHBhckRpbXMub2Zmc2V0LmxlZnQpO1xuICAgIHJpZ2h0ICA9IChlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCA8PSBwYXJEaW1zLndpZHRoICsgcGFyRGltcy5vZmZzZXQubGVmdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgYm90dG9tID0gKGVsZURpbXMub2Zmc2V0LnRvcCArIGVsZURpbXMuaGVpZ2h0IDw9IGVsZURpbXMud2luZG93RGltcy5oZWlnaHQgKyBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCk7XG4gICAgdG9wICAgID0gKGVsZURpbXMub2Zmc2V0LnRvcCA+PSBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCk7XG4gICAgbGVmdCAgID0gKGVsZURpbXMub2Zmc2V0LmxlZnQgPj0gZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC5sZWZ0KTtcbiAgICByaWdodCAgPSAoZWxlRGltcy5vZmZzZXQubGVmdCArIGVsZURpbXMud2lkdGggPD0gZWxlRGltcy53aW5kb3dEaW1zLndpZHRoKTtcbiAgfVxuXG4gIHZhciBhbGxEaXJzID0gW2JvdHRvbSwgdG9wLCBsZWZ0LCByaWdodF07XG5cbiAgaWYgKGxyT25seSkge1xuICAgIHJldHVybiBsZWZ0ID09PSByaWdodCA9PT0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0Yk9ubHkpIHtcbiAgICByZXR1cm4gdG9wID09PSBib3R0b20gPT09IHRydWU7XG4gIH1cblxuICByZXR1cm4gYWxsRGlycy5pbmRleE9mKGZhbHNlKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFVzZXMgbmF0aXZlIG1ldGhvZHMgdG8gcmV0dXJuIGFuIG9iamVjdCBvZiBkaW1lbnNpb24gdmFsdWVzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2pRdWVyeSB8fCBIVE1MfSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCBvciBET00gZWxlbWVudCBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBkaW1lbnNpb25zLiBDYW4gYmUgYW55IGVsZW1lbnQgb3RoZXIgdGhhdCBkb2N1bWVudCBvciB3aW5kb3cuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIG5lc3RlZCBvYmplY3Qgb2YgaW50ZWdlciBwaXhlbCB2YWx1ZXNcbiAqIFRPRE8gLSBpZiBlbGVtZW50IGlzIHdpbmRvdywgcmV0dXJuIG9ubHkgdGhvc2UgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBHZXREaW1lbnNpb25zKGVsZW0sIHRlc3Qpe1xuICBlbGVtID0gZWxlbS5sZW5ndGggPyBlbGVtWzBdIDogZWxlbTtcblxuICBpZiAoZWxlbSA9PT0gd2luZG93IHx8IGVsZW0gPT09IGRvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSSdtIHNvcnJ5LCBEYXZlLiBJJ20gYWZyYWlkIEkgY2FuJ3QgZG8gdGhhdC5cIik7XG4gIH1cblxuICB2YXIgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBwYXJSZWN0ID0gZWxlbS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgd2luUmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB3aW5ZID0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgd2luWCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgb2Zmc2V0OiB7XG4gICAgICB0b3A6IHJlY3QudG9wICsgd2luWSxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpblhcbiAgICB9LFxuICAgIHBhcmVudERpbXM6IHtcbiAgICAgIHdpZHRoOiBwYXJSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJSZWN0LmhlaWdodCxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB0b3A6IHBhclJlY3QudG9wICsgd2luWSxcbiAgICAgICAgbGVmdDogcGFyUmVjdC5sZWZ0ICsgd2luWFxuICAgICAgfVxuICAgIH0sXG4gICAgd2luZG93RGltczoge1xuICAgICAgd2lkdGg6IHdpblJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHdpblJlY3QuaGVpZ2h0LFxuICAgICAgb2Zmc2V0OiB7XG4gICAgICAgIHRvcDogd2luWSxcbiAgICAgICAgbGVmdDogd2luWFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHRvcCBhbmQgbGVmdCBpbnRlZ2VyIHBpeGVsIHZhbHVlcyBmb3IgZHluYW1pY2FsbHkgcmVuZGVyZWQgZWxlbWVudHMsXG4gKiBzdWNoIGFzOiBUb29sdGlwLCBSZXZlYWwsIGFuZCBEcm9wZG93blxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgZm9yIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gKiBAcGFyYW0ge2pRdWVyeX0gYW5jaG9yIC0galF1ZXJ5IG9iamVjdCBmb3IgdGhlIGVsZW1lbnQncyBhbmNob3IgcG9pbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBhIHN0cmluZyByZWxhdGluZyB0byB0aGUgZGVzaXJlZCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCwgcmVsYXRpdmUgdG8gaXQncyBhbmNob3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB2T2Zmc2V0IC0gaW50ZWdlciBwaXhlbCB2YWx1ZSBvZiBkZXNpcmVkIHZlcnRpY2FsIHNlcGFyYXRpb24gYmV0d2VlbiBhbmNob3IgYW5kIGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gaE9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCBob3Jpem9udGFsIHNlcGFyYXRpb24gYmV0d2VlbiBhbmNob3IgYW5kIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3ZlcmZsb3cgLSBpZiBhIGNvbGxpc2lvbiBldmVudCBpcyBkZXRlY3RlZCwgc2V0cyB0byB0cnVlIHRvIGRlZmF1bHQgdGhlIGVsZW1lbnQgdG8gZnVsbCB3aWR0aCAtIGFueSBkZXNpcmVkIG9mZnNldC5cbiAqIFRPRE8gYWx0ZXIvcmV3cml0ZSB0byB3b3JrIHdpdGggYGVtYCB2YWx1ZXMgYXMgd2VsbC9pbnN0ZWFkIG9mIHBpeGVsc1xuICovXG5mdW5jdGlvbiBHZXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgcG9zaXRpb24sIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpIHtcbiAgdmFyICRlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcbiAgICAgICRhbmNob3JEaW1zID0gYW5jaG9yID8gR2V0RGltZW5zaW9ucyhhbmNob3IpIDogbnVsbDtcblxuICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IChGb3VuZGF0aW9uLnJ0bCgpID8gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAkZWxlRGltcy53aWR0aCArICRhbmNob3JEaW1zLndpZHRoIDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgLSAoJGVsZURpbXMuaGVpZ2h0ICsgdk9mZnNldClcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KSxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldCxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXIgdG9wJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICgkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICgkYW5jaG9yRGltcy53aWR0aCAvIDIpKSAtICgkZWxlRGltcy53aWR0aCAvIDIpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgLSAoJGVsZURpbXMuaGVpZ2h0ICsgdk9mZnNldClcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogaXNPdmVyZmxvdyA/IGhPZmZzZXQgOiAoKCRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgKCRhbmNob3JEaW1zLndpZHRoIC8gMikpIC0gKCRlbGVEaW1zLndpZHRoIC8gMikpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgKyB2T2Zmc2V0XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXIgbGVmdCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICgkZWxlRGltcy53aWR0aCArIGhPZmZzZXQpLFxuICAgICAgICB0b3A6ICgkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgKCRhbmNob3JEaW1zLmhlaWdodCAvIDIpKSAtICgkZWxlRGltcy5oZWlnaHQgLyAyKVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2VudGVyIHJpZ2h0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggKyBoT2Zmc2V0ICsgMSxcbiAgICAgICAgdG9wOiAoJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICgkYW5jaG9yRGltcy5oZWlnaHQgLyAyKSkgLSAoJGVsZURpbXMuaGVpZ2h0IC8gMilcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAoJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCArICgkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC8gMikpIC0gKCRlbGVEaW1zLndpZHRoIC8gMiksXG4gICAgICAgIHRvcDogKCRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCArICgkZWxlRGltcy53aW5kb3dEaW1zLmhlaWdodCAvIDIpKSAtICgkZWxlRGltcy5oZWlnaHQgLyAyKVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmV2ZWFsJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICgkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC0gJGVsZURpbXMud2lkdGgpIC8gMixcbiAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgKyB2T2Zmc2V0XG4gICAgICB9XG4gICAgY2FzZSAncmV2ZWFsIGZ1bGwnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCxcbiAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3BcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gKCRlbGVEaW1zLndpZHRoICsgaE9mZnNldCksXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0IGJvdHRvbSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldCAtICRlbGVEaW1zLndpZHRoLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogKEZvdW5kYXRpb24ucnRsKCkgPyAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICRlbGVEaW1zLndpZHRoICsgJGFuY2hvckRpbXMud2lkdGggOiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCksXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXRcbiAgICAgIH1cbiAgfVxufVxuXG59KGpRdWVyeSk7XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIFRoaXMgdXRpbCB3YXMgY3JlYXRlZCBieSBNYXJpdXMgT2xiZXJ0eiAqXG4gKiBQbGVhc2UgdGhhbmsgTWFyaXVzIG9uIEdpdEh1YiAvb3dsYmVydHogKlxuICogb3IgdGhlIHdlYiBodHRwOi8vd3d3Lm1hcml1c29sYmVydHouZGUvICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4ndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbmNvbnN0IGtleUNvZGVzID0ge1xuICA5OiAnVEFCJyxcbiAgMTM6ICdFTlRFUicsXG4gIDI3OiAnRVNDQVBFJyxcbiAgMzI6ICdTUEFDRScsXG4gIDM3OiAnQVJST1dfTEVGVCcsXG4gIDM4OiAnQVJST1dfVVAnLFxuICAzOTogJ0FSUk9XX1JJR0hUJyxcbiAgNDA6ICdBUlJPV19ET1dOJ1xufVxuXG52YXIgY29tbWFuZHMgPSB7fVxuXG52YXIgS2V5Ym9hcmQgPSB7XG4gIGtleXM6IGdldEtleUNvZGVzKGtleUNvZGVzKSxcblxuICAvKipcbiAgICogUGFyc2VzIHRoZSAoa2V5Ym9hcmQpIGV2ZW50IGFuZCByZXR1cm5zIGEgU3RyaW5nIHRoYXQgcmVwcmVzZW50cyBpdHMga2V5XG4gICAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIHRoZSBldmVudCBnZW5lcmF0ZWQgYnkgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICogQHJldHVybiBTdHJpbmcga2V5IC0gU3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUga2V5IHByZXNzZWRcbiAgICovXG4gIHBhcnNlS2V5KGV2ZW50KSB7XG4gICAgdmFyIGtleSA9IGtleUNvZGVzW2V2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVdIHx8IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQud2hpY2gpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSBrZXkgPSBgU0hJRlRfJHtrZXl9YDtcbiAgICBpZiAoZXZlbnQuY3RybEtleSkga2V5ID0gYENUUkxfJHtrZXl9YDtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KSBrZXkgPSBgQUxUXyR7a2V5fWA7XG4gICAgcmV0dXJuIGtleTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZ2l2ZW4gKGtleWJvYXJkKSBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIHRoZSBldmVudCBnZW5lcmF0ZWQgYnkgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAtIEZvdW5kYXRpb24gY29tcG9uZW50J3MgbmFtZSwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXG4gICAqIEBwYXJhbSB7T2JqZWN0c30gZnVuY3Rpb25zIC0gY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgdG8gYmUgZXhlY3V0ZWRcbiAgICovXG4gIGhhbmRsZUtleShldmVudCwgY29tcG9uZW50LCBmdW5jdGlvbnMpIHtcbiAgICB2YXIgY29tbWFuZExpc3QgPSBjb21tYW5kc1tjb21wb25lbnRdLFxuICAgICAga2V5Q29kZSA9IHRoaXMucGFyc2VLZXkoZXZlbnQpLFxuICAgICAgY21kcyxcbiAgICAgIGNvbW1hbmQsXG4gICAgICBmbjtcblxuICAgIGlmICghY29tbWFuZExpc3QpIHJldHVybiBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCBub3QgZGVmaW5lZCEnKTtcblxuICAgIGlmICh0eXBlb2YgY29tbWFuZExpc3QubHRyID09PSAndW5kZWZpbmVkJykgeyAvLyB0aGlzIGNvbXBvbmVudCBkb2VzIG5vdCBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbHRyIGFuZCBydGxcbiAgICAgICAgY21kcyA9IGNvbW1hbmRMaXN0OyAvLyB1c2UgcGxhaW4gbGlzdFxuICAgIH0gZWxzZSB7IC8vIG1lcmdlIGx0ciBhbmQgcnRsOiBpZiBkb2N1bWVudCBpcyBydGwsIHJ0bCBvdmVyd3JpdGVzIGx0ciBhbmQgdmljZSB2ZXJzYVxuICAgICAgICBpZiAoRm91bmRhdGlvbi5ydGwoKSkgY21kcyA9ICQuZXh0ZW5kKHt9LCBjb21tYW5kTGlzdC5sdHIsIGNvbW1hbmRMaXN0LnJ0bCk7XG5cbiAgICAgICAgZWxzZSBjbWRzID0gJC5leHRlbmQoe30sIGNvbW1hbmRMaXN0LnJ0bCwgY29tbWFuZExpc3QubHRyKTtcbiAgICB9XG4gICAgY29tbWFuZCA9IGNtZHNba2V5Q29kZV07XG5cbiAgICBmbiA9IGZ1bmN0aW9uc1tjb21tYW5kXTtcbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7IC8vIGV4ZWN1dGUgZnVuY3Rpb24gIGlmIGV4aXN0c1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gZm4uYXBwbHkoKTtcbiAgICAgIGlmIChmdW5jdGlvbnMuaGFuZGxlZCB8fCB0eXBlb2YgZnVuY3Rpb25zLmhhbmRsZWQgPT09ICdmdW5jdGlvbicpIHsgLy8gZXhlY3V0ZSBmdW5jdGlvbiB3aGVuIGV2ZW50IHdhcyBoYW5kbGVkXG4gICAgICAgICAgZnVuY3Rpb25zLmhhbmRsZWQocmV0dXJuVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZnVuY3Rpb25zLnVuaGFuZGxlZCB8fCB0eXBlb2YgZnVuY3Rpb25zLnVuaGFuZGxlZCA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBleGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIG5vdCBoYW5kbGVkXG4gICAgICAgICAgZnVuY3Rpb25zLnVuaGFuZGxlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoaW4gdGhlIGdpdmVuIGAkZWxlbWVudGBcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBzZWFyY2ggd2l0aGluXG4gICAqIEByZXR1cm4ge2pRdWVyeX0gJGZvY3VzYWJsZSAtIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIGAkZWxlbWVudGBcbiAgICovXG4gIGZpbmRGb2N1c2FibGUoJGVsZW1lbnQpIHtcbiAgICByZXR1cm4gJGVsZW1lbnQuZmluZCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgKlt0YWJpbmRleF0sICpbY29udGVudGVkaXRhYmxlXScpLmZpbHRlcihmdW5jdGlvbigpIHtcbiAgICAgIGlmICghJCh0aGlzKS5pcygnOnZpc2libGUnKSB8fCAkKHRoaXMpLmF0dHIoJ3RhYmluZGV4JykgPCAwKSB7IHJldHVybiBmYWxzZTsgfSAvL29ubHkgaGF2ZSB2aXNpYmxlIGVsZW1lbnRzIGFuZCB0aG9zZSB0aGF0IGhhdmUgYSB0YWJpbmRleCBncmVhdGVyIG9yIGVxdWFsIDBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgbmFtZSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgLSBGb3VuZGF0aW9uIGNvbXBvbmVudCwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXG4gICAqIEByZXR1cm4gU3RyaW5nIGNvbXBvbmVudE5hbWVcbiAgICovXG5cbiAgcmVnaXN0ZXIoY29tcG9uZW50TmFtZSwgY21kcykge1xuICAgIGNvbW1hbmRzW2NvbXBvbmVudE5hbWVdID0gY21kcztcbiAgfVxufVxuXG4vKlxuICogQ29uc3RhbnRzIGZvciBlYXNpZXIgY29tcGFyaW5nLlxuICogQ2FuIGJlIHVzZWQgbGlrZSBGb3VuZGF0aW9uLnBhcnNlS2V5KGV2ZW50KSA9PT0gRm91bmRhdGlvbi5rZXlzLlNQQUNFXG4gKi9cbmZ1bmN0aW9uIGdldEtleUNvZGVzKGtjcykge1xuICB2YXIgayA9IHt9O1xuICBmb3IgKHZhciBrYyBpbiBrY3MpIGtba2NzW2tjXV0gPSBrY3Nba2NdO1xuICByZXR1cm4gaztcbn1cblxuRm91bmRhdGlvbi5LZXlib2FyZCA9IEtleWJvYXJkO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8vIERlZmF1bHQgc2V0IG9mIG1lZGlhIHF1ZXJpZXNcbmNvbnN0IGRlZmF1bHRRdWVyaWVzID0ge1xuICAnZGVmYXVsdCcgOiAnb25seSBzY3JlZW4nLFxuICBsYW5kc2NhcGUgOiAnb25seSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXG4gIHBvcnRyYWl0IDogJ29ubHkgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KScsXG4gIHJldGluYSA6ICdvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMiksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyLzEpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxOTJkcGkpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweCknXG59O1xuXG52YXIgTWVkaWFRdWVyeSA9IHtcbiAgcXVlcmllczogW10sXG5cbiAgY3VycmVudDogJycsXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtZWRpYSBxdWVyeSBoZWxwZXIsIGJ5IGV4dHJhY3RpbmcgdGhlIGJyZWFrcG9pbnQgbGlzdCBmcm9tIHRoZSBDU1MgYW5kIGFjdGl2YXRpbmcgdGhlIGJyZWFrcG9pbnQgd2F0Y2hlci5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGV4dHJhY3RlZFN0eWxlcyA9ICQoJy5mb3VuZGF0aW9uLW1xJykuY3NzKCdmb250LWZhbWlseScpO1xuICAgIHZhciBuYW1lZFF1ZXJpZXM7XG5cbiAgICBuYW1lZFF1ZXJpZXMgPSBwYXJzZVN0eWxlVG9PYmplY3QoZXh0cmFjdGVkU3R5bGVzKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBuYW1lZFF1ZXJpZXMpIHtcbiAgICAgIGlmKG5hbWVkUXVlcmllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHNlbGYucXVlcmllcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdmFsdWU6IGBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogJHtuYW1lZFF1ZXJpZXNba2V5XX0pYFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLl9nZXRDdXJyZW50U2l6ZSgpO1xuXG4gICAgdGhpcy5fd2F0Y2hlcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHNjcmVlbiBpcyBhdCBsZWFzdCBhcyB3aWRlIGFzIGEgYnJlYWtwb2ludC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYnJlYWtwb2ludCBtYXRjaGVzLCBgZmFsc2VgIGlmIGl0J3Mgc21hbGxlci5cbiAgICovXG4gIGF0TGVhc3Qoc2l6ZSkge1xuICAgIHZhciBxdWVyeSA9IHRoaXMuZ2V0KHNpemUpO1xuXG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpLm1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtZWRpYSBxdWVyeSBvZiBhIGJyZWFrcG9pbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IC0gVGhlIG1lZGlhIHF1ZXJ5IG9mIHRoZSBicmVha3BvaW50LCBvciBgbnVsbGAgaWYgdGhlIGJyZWFrcG9pbnQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGdldChzaXplKSB7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLnF1ZXJpZXMpIHtcbiAgICAgIGlmKHRoaXMucXVlcmllcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJpZXNbaV07XG4gICAgICAgIGlmIChzaXplID09PSBxdWVyeS5uYW1lKSByZXR1cm4gcXVlcnkudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCBuYW1lIGJ5IHRlc3RpbmcgZXZlcnkgYnJlYWtwb2ludCBhbmQgcmV0dXJuaW5nIHRoZSBsYXN0IG9uZSB0byBtYXRjaCAodGhlIGJpZ2dlc3Qgb25lKS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGN1cnJlbnQgYnJlYWtwb2ludC5cbiAgICovXG4gIF9nZXRDdXJyZW50U2l6ZSgpIHtcbiAgICB2YXIgbWF0Y2hlZDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWVyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJpZXNbaV07XG5cbiAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShxdWVyeS52YWx1ZSkubWF0Y2hlcykge1xuICAgICAgICBtYXRjaGVkID0gcXVlcnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtYXRjaGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG1hdGNoZWQubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGJyZWFrcG9pbnQgd2F0Y2hlciwgd2hpY2ggZmlyZXMgYW4gZXZlbnQgb24gdGhlIHdpbmRvdyB3aGVuZXZlciB0aGUgYnJlYWtwb2ludCBjaGFuZ2VzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93YXRjaGVyKCkge1xuICAgICQod2luZG93KS5vbigncmVzaXplLnpmLm1lZGlhcXVlcnknLCAoKSA9PiB7XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuX2dldEN1cnJlbnRTaXplKCksIGN1cnJlbnRTaXplID0gdGhpcy5jdXJyZW50O1xuXG4gICAgICBpZiAobmV3U2l6ZSAhPT0gY3VycmVudFNpemUpIHtcbiAgICAgICAgLy8gQ2hhbmdlIHRoZSBjdXJyZW50IG1lZGlhIHF1ZXJ5XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5ld1NpemU7XG5cbiAgICAgICAgLy8gQnJvYWRjYXN0IHRoZSBtZWRpYSBxdWVyeSBjaGFuZ2Ugb24gdGhlIHdpbmRvd1xuICAgICAgICAkKHdpbmRvdykudHJpZ2dlcignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgW25ld1NpemUsIGN1cnJlbnRTaXplXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbkZvdW5kYXRpb24uTWVkaWFRdWVyeSA9IE1lZGlhUXVlcnk7XG5cbi8vIG1hdGNoTWVkaWEoKSBwb2x5ZmlsbCAtIFRlc3QgYSBDU1MgbWVkaWEgdHlwZS9xdWVyeSBpbiBKUy5cbi8vIEF1dGhvcnMgJiBjb3B5cmlnaHQgKGMpIDIwMTI6IFNjb3R0IEplaGwsIFBhdWwgSXJpc2gsIE5pY2hvbGFzIFpha2FzLCBEYXZpZCBLbmlnaHQuIER1YWwgTUlUL0JTRCBsaWNlbnNlXG53aW5kb3cubWF0Y2hNZWRpYSB8fCAod2luZG93Lm1hdGNoTWVkaWEgPSBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgbWF0Y2hNZWRpdW0gYXBpIHN1Y2ggYXMgSUUgOSBhbmQgd2Via2l0XG4gIHZhciBzdHlsZU1lZGlhID0gKHdpbmRvdy5zdHlsZU1lZGlhIHx8IHdpbmRvdy5tZWRpYSk7XG5cbiAgLy8gRm9yIHRob3NlIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtYXRjaE1lZGl1bVxuICBpZiAoIXN0eWxlTWVkaWEpIHtcbiAgICB2YXIgc3R5bGUgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksXG4gICAgc2NyaXB0ICAgICAgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF0sXG4gICAgaW5mbyAgICAgICAgPSBudWxsO1xuXG4gICAgc3R5bGUudHlwZSAgPSAndGV4dC9jc3MnO1xuICAgIHN0eWxlLmlkICAgID0gJ21hdGNobWVkaWFqcy10ZXN0JztcblxuICAgIHNjcmlwdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZSwgc2NyaXB0KTtcblxuICAgIC8vICdzdHlsZS5jdXJyZW50U3R5bGUnIGlzIHVzZWQgYnkgSUUgPD0gOCBhbmQgJ3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlJyBmb3IgYWxsIG90aGVyIGJyb3dzZXJzXG4gICAgaW5mbyA9ICgnZ2V0Q29tcHV0ZWRTdHlsZScgaW4gd2luZG93KSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSwgbnVsbCkgfHwgc3R5bGUuY3VycmVudFN0eWxlO1xuXG4gICAgc3R5bGVNZWRpYSA9IHtcbiAgICAgIG1hdGNoTWVkaXVtKG1lZGlhKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gYEBtZWRpYSAke21lZGlhfXsgI21hdGNobWVkaWFqcy10ZXN0IHsgd2lkdGg6IDFweDsgfSB9YDtcblxuICAgICAgICAvLyAnc3R5bGUuc3R5bGVTaGVldCcgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnc3R5bGUudGV4dENvbnRlbnQnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbiAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3QgaWYgbWVkaWEgcXVlcnkgaXMgdHJ1ZSBvciBmYWxzZVxuICAgICAgICByZXR1cm4gaW5mby53aWR0aCA9PT0gJzFweCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG1lZGlhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoZXM6IHN0eWxlTWVkaWEubWF0Y2hNZWRpdW0obWVkaWEgfHwgJ2FsbCcpLFxuICAgICAgbWVkaWE6IG1lZGlhIHx8ICdhbGwnXG4gICAgfTtcbiAgfVxufSgpKTtcblxuLy8gVGhhbmsgeW91OiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZ1xuZnVuY3Rpb24gcGFyc2VTdHlsZVRvT2JqZWN0KHN0cikge1xuICB2YXIgc3R5bGVPYmplY3QgPSB7fTtcblxuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gIH1cblxuICBzdHIgPSBzdHIudHJpbSgpLnNsaWNlKDEsIC0xKTsgLy8gYnJvd3NlcnMgcmUtcXVvdGUgc3RyaW5nIHN0eWxlIHZhbHVlc1xuXG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG5cbiAgc3R5bGVPYmplY3QgPSBzdHIuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24ocmV0LCBwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IHBhcnRzWzBdO1xuICAgIHZhciB2YWwgPSBwYXJ0c1sxXTtcbiAgICBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcblxuICAgIC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG4gICAgLy8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuICAgIHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG4gICAgaWYgKCFyZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0W2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xuICAgICAgcmV0W2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSwge30pO1xuXG4gIHJldHVybiBzdHlsZU9iamVjdDtcbn1cblxuRm91bmRhdGlvbi5NZWRpYVF1ZXJ5ID0gTWVkaWFRdWVyeTtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIE1vdGlvbiBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ubW90aW9uXG4gKi9cblxuY29uc3QgaW5pdENsYXNzZXMgICA9IFsnbXVpLWVudGVyJywgJ211aS1sZWF2ZSddO1xuY29uc3QgYWN0aXZlQ2xhc3NlcyA9IFsnbXVpLWVudGVyLWFjdGl2ZScsICdtdWktbGVhdmUtYWN0aXZlJ107XG5cbmNvbnN0IE1vdGlvbiA9IHtcbiAgYW5pbWF0ZUluOiBmdW5jdGlvbihlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XG4gICAgYW5pbWF0ZSh0cnVlLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKTtcbiAgfSxcblxuICBhbmltYXRlT3V0OiBmdW5jdGlvbihlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XG4gICAgYW5pbWF0ZShmYWxzZSwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gTW92ZShkdXJhdGlvbiwgZWxlbSwgZm4pe1xuICB2YXIgYW5pbSwgcHJvZywgc3RhcnQgPSBudWxsO1xuICAvLyBjb25zb2xlLmxvZygnY2FsbGVkJyk7XG5cbiAgZnVuY3Rpb24gbW92ZSh0cyl7XG4gICAgaWYoIXN0YXJ0KSBzdGFydCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAvLyBjb25zb2xlLmxvZyhzdGFydCwgdHMpO1xuICAgIHByb2cgPSB0cyAtIHN0YXJ0O1xuICAgIGZuLmFwcGx5KGVsZW0pO1xuXG4gICAgaWYocHJvZyA8IGR1cmF0aW9uKXsgYW5pbSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW92ZSwgZWxlbSk7IH1cbiAgICBlbHNle1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW0pO1xuICAgICAgZWxlbS50cmlnZ2VyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKS50cmlnZ2VySGFuZGxlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSk7XG4gICAgfVxuICB9XG4gIGFuaW0gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdmUpO1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIGFuIGVsZW1lbnQgaW4gb3Igb3V0IHVzaW5nIGEgQ1NTIHRyYW5zaXRpb24gY2xhc3MuXG4gKiBAZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW4gLSBEZWZpbmVzIGlmIHRoZSBhbmltYXRpb24gaXMgaW4gb3Igb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb3IgSFRNTCBvYmplY3QgdG8gYW5pbWF0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBhbmltYXRpb24gLSBDU1MgY2xhc3MgdG8gdXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBDYWxsYmFjayB0byBydW4gd2hlbiBhbmltYXRpb24gaXMgZmluaXNoZWQuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGUoaXNJbiwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICBlbGVtZW50ID0gJChlbGVtZW50KS5lcSgwKTtcblxuICBpZiAoIWVsZW1lbnQubGVuZ3RoKSByZXR1cm47XG5cbiAgdmFyIGluaXRDbGFzcyA9IGlzSW4gPyBpbml0Q2xhc3Nlc1swXSA6IGluaXRDbGFzc2VzWzFdO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0luID8gYWN0aXZlQ2xhc3Nlc1swXSA6IGFjdGl2ZUNsYXNzZXNbMV07XG5cbiAgLy8gU2V0IHVwIHRoZSBhbmltYXRpb25cbiAgcmVzZXQoKTtcblxuICBlbGVtZW50XG4gICAgLmFkZENsYXNzKGFuaW1hdGlvbilcbiAgICAuY3NzKCd0cmFuc2l0aW9uJywgJ25vbmUnKTtcblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGVsZW1lbnQuYWRkQ2xhc3MoaW5pdENsYXNzKTtcbiAgICBpZiAoaXNJbikgZWxlbWVudC5zaG93KCk7XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IHRoZSBhbmltYXRpb25cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBlbGVtZW50WzBdLm9mZnNldFdpZHRoO1xuICAgIGVsZW1lbnRcbiAgICAgIC5jc3MoJ3RyYW5zaXRpb24nLCAnJylcbiAgICAgIC5hZGRDbGFzcyhhY3RpdmVDbGFzcyk7XG4gIH0pO1xuXG4gIC8vIENsZWFuIHVwIHRoZSBhbmltYXRpb24gd2hlbiBpdCBmaW5pc2hlc1xuICBlbGVtZW50Lm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoZWxlbWVudCksIGZpbmlzaCk7XG5cbiAgLy8gSGlkZXMgdGhlIGVsZW1lbnQgKGZvciBvdXQgYW5pbWF0aW9ucyksIHJlc2V0cyB0aGUgZWxlbWVudCwgYW5kIHJ1bnMgYSBjYWxsYmFja1xuICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgaWYgKCFpc0luKSBlbGVtZW50LmhpZGUoKTtcbiAgICByZXNldCgpO1xuICAgIGlmIChjYikgY2IuYXBwbHkoZWxlbWVudCk7XG4gIH1cblxuICAvLyBSZXNldHMgdHJhbnNpdGlvbnMgYW5kIHJlbW92ZXMgbW90aW9uLXNwZWNpZmljIGNsYXNzZXNcbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZWxlbWVudFswXS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAwO1xuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoYCR7aW5pdENsYXNzfSAke2FjdGl2ZUNsYXNzfSAke2FuaW1hdGlvbn1gKTtcbiAgfVxufVxuXG5Gb3VuZGF0aW9uLk1vdmUgPSBNb3ZlO1xuRm91bmRhdGlvbi5Nb3Rpb24gPSBNb3Rpb247XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuY29uc3QgTmVzdCA9IHtcbiAgRmVhdGhlcihtZW51LCB0eXBlID0gJ3pmJykge1xuICAgIG1lbnUuYXR0cigncm9sZScsICdtZW51YmFyJyk7XG5cbiAgICB2YXIgaXRlbXMgPSBtZW51LmZpbmQoJ2xpJykuYXR0cih7J3JvbGUnOiAnbWVudWl0ZW0nfSksXG4gICAgICAgIHN1Yk1lbnVDbGFzcyA9IGBpcy0ke3R5cGV9LXN1Ym1lbnVgLFxuICAgICAgICBzdWJJdGVtQ2xhc3MgPSBgJHtzdWJNZW51Q2xhc3N9LWl0ZW1gLFxuICAgICAgICBoYXNTdWJDbGFzcyA9IGBpcy0ke3R5cGV9LXN1Ym1lbnUtcGFyZW50YDtcblxuICAgIG1lbnUuZmluZCgnYTpmaXJzdCcpLmF0dHIoJ3RhYmluZGV4JywgMCk7XG5cbiAgICBpdGVtcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyICRpdGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAkc3ViID0gJGl0ZW0uY2hpbGRyZW4oJ3VsJyk7XG5cbiAgICAgIGlmICgkc3ViLmxlbmd0aCkge1xuICAgICAgICAkaXRlbVxuICAgICAgICAgIC5hZGRDbGFzcyhoYXNTdWJDbGFzcylcbiAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlLFxuICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiAkaXRlbS5jaGlsZHJlbignYTpmaXJzdCcpLnRleHQoKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICRzdWJcbiAgICAgICAgICAuYWRkQ2xhc3MoYHN1Ym1lbnUgJHtzdWJNZW51Q2xhc3N9YClcbiAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAnZGF0YS1zdWJtZW51JzogJycsXG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgICAgICAgJ3JvbGUnOiAnbWVudSdcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRpdGVtLnBhcmVudCgnW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcbiAgICAgICAgJGl0ZW0uYWRkQ2xhc3MoYGlzLXN1Ym1lbnUtaXRlbSAke3N1Ykl0ZW1DbGFzc31gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfSxcblxuICBCdXJuKG1lbnUsIHR5cGUpIHtcbiAgICB2YXIgaXRlbXMgPSBtZW51LmZpbmQoJ2xpJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKSxcbiAgICAgICAgc3ViTWVudUNsYXNzID0gYGlzLSR7dHlwZX0tc3VibWVudWAsXG4gICAgICAgIHN1Ykl0ZW1DbGFzcyA9IGAke3N1Yk1lbnVDbGFzc30taXRlbWAsXG4gICAgICAgIGhhc1N1YkNsYXNzID0gYGlzLSR7dHlwZX0tc3VibWVudS1wYXJlbnRgO1xuXG4gICAgbWVudVxuICAgICAgLmZpbmQoJyonKVxuICAgICAgLnJlbW92ZUNsYXNzKGAke3N1Yk1lbnVDbGFzc30gJHtzdWJJdGVtQ2xhc3N9ICR7aGFzU3ViQ2xhc3N9IGlzLXN1Ym1lbnUtaXRlbSBzdWJtZW51IGlzLWFjdGl2ZWApXG4gICAgICAucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51JykuY3NzKCdkaXNwbGF5JywgJycpO1xuXG4gICAgLy8gY29uc29sZS5sb2coICAgICAgbWVudS5maW5kKCcuJyArIHN1Yk1lbnVDbGFzcyArICcsIC4nICsgc3ViSXRlbUNsYXNzICsgJywgLmhhcy1zdWJtZW51LCAuaXMtc3VibWVudS1pdGVtLCAuc3VibWVudSwgW2RhdGEtc3VibWVudV0nKVxuICAgIC8vICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc3ViTWVudUNsYXNzICsgJyAnICsgc3ViSXRlbUNsYXNzICsgJyBoYXMtc3VibWVudSBpcy1zdWJtZW51LWl0ZW0gc3VibWVudScpXG4gICAgLy8gICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXN1Ym1lbnUnKSk7XG4gICAgLy8gaXRlbXMuZWFjaChmdW5jdGlvbigpe1xuICAgIC8vICAgdmFyICRpdGVtID0gJCh0aGlzKSxcbiAgICAvLyAgICAgICAkc3ViID0gJGl0ZW0uY2hpbGRyZW4oJ3VsJyk7XG4gICAgLy8gICBpZigkaXRlbS5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKXtcbiAgICAvLyAgICAgJGl0ZW0ucmVtb3ZlQ2xhc3MoJ2lzLXN1Ym1lbnUtaXRlbSAnICsgc3ViSXRlbUNsYXNzKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIGlmKCRzdWIubGVuZ3RoKXtcbiAgICAvLyAgICAgJGl0ZW0ucmVtb3ZlQ2xhc3MoJ2hhcy1zdWJtZW51Jyk7XG4gICAgLy8gICAgICRzdWIucmVtb3ZlQ2xhc3MoJ3N1Ym1lbnUgJyArIHN1Yk1lbnVDbGFzcykucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51Jyk7XG4gICAgLy8gICB9XG4gICAgLy8gfSk7XG4gIH1cbn1cblxuRm91bmRhdGlvbi5OZXN0ID0gTmVzdDtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG5mdW5jdGlvbiBUaW1lcihlbGVtLCBvcHRpb25zLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uLC8vb3B0aW9ucyBpcyBhbiBvYmplY3QgZm9yIGVhc2lseSBhZGRpbmcgZmVhdHVyZXMgbGF0ZXIuXG4gICAgICBuYW1lU3BhY2UgPSBPYmplY3Qua2V5cyhlbGVtLmRhdGEoKSlbMF0gfHwgJ3RpbWVyJyxcbiAgICAgIHJlbWFpbiA9IC0xLFxuICAgICAgc3RhcnQsXG4gICAgICB0aW1lcjtcblxuICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgdGhpcy5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtYWluID0gLTE7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aGlzLnN0YXJ0KCk7XG4gIH1cblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuICAgIC8vIGlmKCFlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgcmVtYWluID0gcmVtYWluIDw9IDAgPyBkdXJhdGlvbiA6IHJlbWFpbjtcbiAgICBlbGVtLmRhdGEoJ3BhdXNlZCcsIGZhbHNlKTtcbiAgICBzdGFydCA9IERhdGUubm93KCk7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBpZihvcHRpb25zLmluZmluaXRlKXtcbiAgICAgICAgX3RoaXMucmVzdGFydCgpOy8vcmVydW4gdGhlIHRpbWVyLlxuICAgICAgfVxuICAgICAgY2IoKTtcbiAgICB9LCByZW1haW4pO1xuICAgIGVsZW0udHJpZ2dlcihgdGltZXJzdGFydC56Zi4ke25hbWVTcGFjZX1gKTtcbiAgfVxuXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICAvL2lmKGVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICBlbGVtLmRhdGEoJ3BhdXNlZCcsIHRydWUpO1xuICAgIHZhciBlbmQgPSBEYXRlLm5vdygpO1xuICAgIHJlbWFpbiA9IHJlbWFpbiAtIChlbmQgLSBzdGFydCk7XG4gICAgZWxlbS50cmlnZ2VyKGB0aW1lcnBhdXNlZC56Zi4ke25hbWVTcGFjZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkLlxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlcyAtIEltYWdlKHMpIHRvIGNoZWNrIGlmIGxvYWRlZC5cbiAqIEBwYXJhbSB7RnVuY30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gaW1hZ2UgaXMgZnVsbHkgbG9hZGVkLlxuICovXG5mdW5jdGlvbiBvbkltYWdlc0xvYWRlZChpbWFnZXMsIGNhbGxiYWNrKXtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgdW5sb2FkZWQgPSBpbWFnZXMubGVuZ3RoO1xuXG4gIGlmICh1bmxvYWRlZCA9PT0gMCkge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBpbWFnZXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb21wbGV0ZSkge1xuICAgICAgc2luZ2xlSW1hZ2VMb2FkZWQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMubmF0dXJhbFdpZHRoICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm5hdHVyYWxXaWR0aCA+IDApIHtcbiAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJCh0aGlzKS5vbmUoJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2luZ2xlSW1hZ2VMb2FkZWQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gc2luZ2xlSW1hZ2VMb2FkZWQoKSB7XG4gICAgdW5sb2FkZWQtLTtcbiAgICBpZiAodW5sb2FkZWQgPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG59XG5cbkZvdW5kYXRpb24uVGltZXIgPSBUaW1lcjtcbkZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQgPSBvbkltYWdlc0xvYWRlZDtcblxufShqUXVlcnkpO1xuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8qKldvcmsgaW5zcGlyZWQgYnkgbXVsdGlwbGUganF1ZXJ5IHN3aXBlIHBsdWdpbnMqKlxuLy8qKkRvbmUgYnkgWW9oYWkgQXJhcmF0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuKGZ1bmN0aW9uKCQpIHtcblxuICAkLnNwb3RTd2lwZSA9IHtcbiAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgIGVuYWJsZWQ6ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgbW92ZVRocmVzaG9sZDogNzUsXG4gICAgdGltZVRocmVzaG9sZDogMjAwXG4gIH07XG5cbiAgdmFyICAgc3RhcnRQb3NYLFxuICAgICAgICBzdGFydFBvc1ksXG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgZWxhcHNlZFRpbWUsXG4gICAgICAgIGlzTW92aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25Ub3VjaEVuZCgpIHtcbiAgICAvLyAgYWxlcnQodGhpcyk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICAgIGlzTW92aW5nID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgaWYgKCQuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgIGlmKGlzTW92aW5nKSB7XG4gICAgICB2YXIgeCA9IGUudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgIHZhciB5ID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgdmFyIGR4ID0gc3RhcnRQb3NYIC0geDtcbiAgICAgIHZhciBkeSA9IHN0YXJ0UG9zWSAtIHk7XG4gICAgICB2YXIgZGlyO1xuICAgICAgZWxhcHNlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTtcbiAgICAgIGlmKE1hdGguYWJzKGR4KSA+PSAkLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkICYmIGVsYXBzZWRUaW1lIDw9ICQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQpIHtcbiAgICAgICAgZGlyID0gZHggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH1cbiAgICAgIC8vIGVsc2UgaWYoTWF0aC5hYnMoZHkpID49ICQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0gJC5zcG90U3dpcGUudGltZVRocmVzaG9sZCkge1xuICAgICAgLy8gICBkaXIgPSBkeSA+IDAgPyAnZG93bicgOiAndXAnO1xuICAgICAgLy8gfVxuICAgICAgaWYoZGlyKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25Ub3VjaEVuZC5jYWxsKHRoaXMpO1xuICAgICAgICAkKHRoaXMpLnRyaWdnZXIoJ3N3aXBlJywgZGlyKS50cmlnZ2VyKGBzd2lwZSR7ZGlyfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgc3RhcnRQb3NYID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgc3RhcnRQb3NZID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyICYmIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVhcmRvd24oKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgfVxuXG4gICQuZXZlbnQuc3BlY2lhbC5zd2lwZSA9IHsgc2V0dXA6IGluaXQgfTtcblxuICAkLmVhY2goWydsZWZ0JywgJ3VwJywgJ2Rvd24nLCAncmlnaHQnXSwgZnVuY3Rpb24gKCkge1xuICAgICQuZXZlbnQuc3BlY2lhbFtgc3dpcGUke3RoaXN9YF0gPSB7IHNldHVwOiBmdW5jdGlvbigpe1xuICAgICAgJCh0aGlzKS5vbignc3dpcGUnLCAkLm5vb3ApO1xuICAgIH0gfTtcbiAgfSk7XG59KShqUXVlcnkpO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1ldGhvZCBmb3IgYWRkaW5nIHBzdWVkbyBkcmFnIGV2ZW50cyB0byBlbGVtZW50cyAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuIWZ1bmN0aW9uKCQpe1xuICAkLmZuLmFkZFRvdWNoID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSxlbCl7XG4gICAgICAkKGVsKS5iaW5kKCd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsZnVuY3Rpb24oKXtcbiAgICAgICAgLy93ZSBwYXNzIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QgYmVjYXVzZSB0aGUgalF1ZXJ5IGV2ZW50XG4gICAgICAgIC8vb2JqZWN0IGlzIG5vcm1hbGl6ZWQgdG8gdzNjIHNwZWNzIGFuZCBkb2VzIG5vdCBwcm92aWRlIHRoZSBUb3VjaExpc3RcbiAgICAgICAgaGFuZGxlVG91Y2goZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgaGFuZGxlVG91Y2ggPSBmdW5jdGlvbihldmVudCl7XG4gICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICAgIGZpcnN0ID0gdG91Y2hlc1swXSxcbiAgICAgICAgICBldmVudFR5cGVzID0ge1xuICAgICAgICAgICAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gICAgICAgICAgICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgdG91Y2hlbmQ6ICdtb3VzZXVwJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHlwZSA9IGV2ZW50VHlwZXNbZXZlbnQudHlwZV0sXG4gICAgICAgICAgc2ltdWxhdGVkRXZlbnRcbiAgICAgICAgO1xuXG4gICAgICBpZignTW91c2VFdmVudCcgaW4gd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IG5ldyB3aW5kb3cuTW91c2VFdmVudCh0eXBlLCB7XG4gICAgICAgICAgJ2J1YmJsZXMnOiB0cnVlLFxuICAgICAgICAgICdjYW5jZWxhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnc2NyZWVuWCc6IGZpcnN0LnNjcmVlblgsXG4gICAgICAgICAgJ3NjcmVlblknOiBmaXJzdC5zY3JlZW5ZLFxuICAgICAgICAgICdjbGllbnRYJzogZmlyc3QuY2xpZW50WCxcbiAgICAgICAgICAnY2xpZW50WSc6IGZpcnN0LmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgICAgIHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSwgZmlyc3Quc2NyZWVuWCwgZmlyc3Quc2NyZWVuWSwgZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAvKmxlZnQqLywgbnVsbCk7XG4gICAgICB9XG4gICAgICBmaXJzdC50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG4gICAgfTtcbiAgfTtcbn0oalF1ZXJ5KTtcblxuXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vKipGcm9tIHRoZSBqUXVlcnkgTW9iaWxlIExpYnJhcnkqKlxuLy8qKm5lZWQgdG8gcmVjcmVhdGUgZnVuY3Rpb25hbGl0eSoqXG4vLyoqYW5kIHRyeSB0byBpbXByb3ZlIGlmIHBvc3NpYmxlKipcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vKiBSZW1vdmluZyB0aGUgalF1ZXJ5IGZ1bmN0aW9uICoqKipcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4oZnVuY3Rpb24oICQsIHdpbmRvdywgdW5kZWZpbmVkICkge1xuXG5cdHZhciAkZG9jdW1lbnQgPSAkKCBkb2N1bWVudCApLFxuXHRcdC8vIHN1cHBvcnRUb3VjaCA9ICQubW9iaWxlLnN1cHBvcnQudG91Y2gsXG5cdFx0dG91Y2hTdGFydEV2ZW50ID0gJ3RvdWNoc3RhcnQnLy9zdXBwb3J0VG91Y2ggPyBcInRvdWNoc3RhcnRcIiA6IFwibW91c2Vkb3duXCIsXG5cdFx0dG91Y2hTdG9wRXZlbnQgPSAndG91Y2hlbmQnLy9zdXBwb3J0VG91Y2ggPyBcInRvdWNoZW5kXCIgOiBcIm1vdXNldXBcIixcblx0XHR0b3VjaE1vdmVFdmVudCA9ICd0b3VjaG1vdmUnLy9zdXBwb3J0VG91Y2ggPyBcInRvdWNobW92ZVwiIDogXCJtb3VzZW1vdmVcIjtcblxuXHQvLyBzZXR1cCBuZXcgZXZlbnQgc2hvcnRjdXRzXG5cdCQuZWFjaCggKCBcInRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIFwiICtcblx0XHRcInN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0XCIgKS5zcGxpdCggXCIgXCIgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0XHQkLmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRyZXR1cm4gZm4gPyB0aGlzLmJpbmQoIG5hbWUsIGZuICkgOiB0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXG5cdFx0Ly8galF1ZXJ5IDwgMS44XG5cdFx0aWYgKCAkLmF0dHJGbiApIHtcblx0XHRcdCQuYXR0ckZuWyBuYW1lIF0gPSB0cnVlO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gdHJpZ2dlckN1c3RvbUV2ZW50KCBvYmosIGV2ZW50VHlwZSwgZXZlbnQsIGJ1YmJsZSApIHtcblx0XHR2YXIgb3JpZ2luYWxUeXBlID0gZXZlbnQudHlwZTtcblx0XHRldmVudC50eXBlID0gZXZlbnRUeXBlO1xuXHRcdGlmICggYnViYmxlICkge1xuXHRcdFx0JC5ldmVudC50cmlnZ2VyKCBldmVudCwgdW5kZWZpbmVkLCBvYmogKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JC5ldmVudC5kaXNwYXRjaC5jYWxsKCBvYmosIGV2ZW50ICk7XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSBvcmlnaW5hbFR5cGU7XG5cdH1cblxuXHQvLyBhbHNvIGhhbmRsZXMgdGFwaG9sZFxuXG5cdC8vIEFsc28gaGFuZGxlcyBzd2lwZWxlZnQsIHN3aXBlcmlnaHRcblx0JC5ldmVudC5zcGVjaWFsLnN3aXBlID0ge1xuXG5cdFx0Ly8gTW9yZSB0aGFuIHRoaXMgaG9yaXpvbnRhbCBkaXNwbGFjZW1lbnQsIGFuZCB3ZSB3aWxsIHN1cHByZXNzIHNjcm9sbGluZy5cblx0XHRzY3JvbGxTdXByZXNzaW9uVGhyZXNob2xkOiAzMCxcblxuXHRcdC8vIE1vcmUgdGltZSB0aGFuIHRoaXMsIGFuZCBpdCBpc24ndCBhIHN3aXBlLlxuXHRcdGR1cmF0aW9uVGhyZXNob2xkOiAxMDAwLFxuXG5cdFx0Ly8gU3dpcGUgaG9yaXpvbnRhbCBkaXNwbGFjZW1lbnQgbXVzdCBiZSBtb3JlIHRoYW4gdGhpcy5cblx0XHRob3Jpem9udGFsRGlzdGFuY2VUaHJlc2hvbGQ6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID49IDIgPyAxNSA6IDMwLFxuXG5cdFx0Ly8gU3dpcGUgdmVydGljYWwgZGlzcGxhY2VtZW50IG11c3QgYmUgbGVzcyB0aGFuIHRoaXMuXG5cdFx0dmVydGljYWxEaXN0YW5jZVRocmVzaG9sZDogd2luZG93LmRldmljZVBpeGVsUmF0aW8gPj0gMiA/IDE1IDogMzAsXG5cblx0XHRnZXRMb2NhdGlvbjogZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdHZhciB3aW5QYWdlWCA9IHdpbmRvdy5wYWdlWE9mZnNldCxcblx0XHRcdFx0d2luUGFnZVkgPSB3aW5kb3cucGFnZVlPZmZzZXQsXG5cdFx0XHRcdHggPSBldmVudC5jbGllbnRYLFxuXHRcdFx0XHR5ID0gZXZlbnQuY2xpZW50WTtcblxuXHRcdFx0aWYgKCBldmVudC5wYWdlWSA9PT0gMCAmJiBNYXRoLmZsb29yKCB5ICkgPiBNYXRoLmZsb29yKCBldmVudC5wYWdlWSApIHx8XG5cdFx0XHRcdGV2ZW50LnBhZ2VYID09PSAwICYmIE1hdGguZmxvb3IoIHggKSA+IE1hdGguZmxvb3IoIGV2ZW50LnBhZ2VYICkgKSB7XG5cblx0XHRcdFx0Ly8gaU9TNCBjbGllbnRYL2NsaWVudFkgaGF2ZSB0aGUgdmFsdWUgdGhhdCBzaG91bGQgaGF2ZSBiZWVuXG5cdFx0XHRcdC8vIGluIHBhZ2VYL3BhZ2VZLiBXaGlsZSBwYWdlWC9wYWdlLyBoYXZlIHRoZSB2YWx1ZSAwXG5cdFx0XHRcdHggPSB4IC0gd2luUGFnZVg7XG5cdFx0XHRcdHkgPSB5IC0gd2luUGFnZVk7XG5cdFx0XHR9IGVsc2UgaWYgKCB5IDwgKCBldmVudC5wYWdlWSAtIHdpblBhZ2VZKSB8fCB4IDwgKCBldmVudC5wYWdlWCAtIHdpblBhZ2VYICkgKSB7XG5cblx0XHRcdFx0Ly8gU29tZSBBbmRyb2lkIGJyb3dzZXJzIGhhdmUgdG90YWxseSBib2d1cyB2YWx1ZXMgZm9yIGNsaWVudFgvWVxuXHRcdFx0XHQvLyB3aGVuIHNjcm9sbGluZy96b29taW5nIGEgcGFnZS4gRGV0ZWN0YWJsZSBzaW5jZSBjbGllbnRYL2NsaWVudFlcblx0XHRcdFx0Ly8gc2hvdWxkIG5ldmVyIGJlIHNtYWxsZXIgdGhhbiBwYWdlWC9wYWdlWSBtaW51cyBwYWdlIHNjcm9sbFxuXHRcdFx0XHR4ID0gZXZlbnQucGFnZVggLSB3aW5QYWdlWDtcblx0XHRcdFx0eSA9IGV2ZW50LnBhZ2VZIC0gd2luUGFnZVk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHlcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdHN0YXJ0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgZGF0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyA/XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWyAwIF0gOiBldmVudCxcblx0XHRcdFx0bG9jYXRpb24gPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZ2V0TG9jYXRpb24oIGRhdGEgKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0aW1lOiAoIG5ldyBEYXRlKCkgKS5nZXRUaW1lKCksXG5cdFx0XHRcdFx0XHRjb29yZHM6IFsgbG9jYXRpb24ueCwgbG9jYXRpb24ueSBdLFxuXHRcdFx0XHRcdFx0b3JpZ2luOiAkKCBldmVudC50YXJnZXQgKVxuXHRcdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdHN0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBkYXRhID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzID9cblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbIDAgXSA6IGV2ZW50LFxuXHRcdFx0XHRsb2NhdGlvbiA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5nZXRMb2NhdGlvbiggZGF0YSApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHRpbWU6ICggbmV3IERhdGUoKSApLmdldFRpbWUoKSxcblx0XHRcdFx0XHRcdGNvb3JkczogWyBsb2NhdGlvbi54LCBsb2NhdGlvbi55IF1cblx0XHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRoYW5kbGVTd2lwZTogZnVuY3Rpb24oIHN0YXJ0LCBzdG9wLCB0aGlzT2JqZWN0LCBvcmlnVGFyZ2V0ICkge1xuXHRcdFx0aWYgKCBzdG9wLnRpbWUgLSBzdGFydC50aW1lIDwgJC5ldmVudC5zcGVjaWFsLnN3aXBlLmR1cmF0aW9uVGhyZXNob2xkICYmXG5cdFx0XHRcdE1hdGguYWJzKCBzdGFydC5jb29yZHNbIDAgXSAtIHN0b3AuY29vcmRzWyAwIF0gKSA+ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ob3Jpem9udGFsRGlzdGFuY2VUaHJlc2hvbGQgJiZcblx0XHRcdFx0TWF0aC5hYnMoIHN0YXJ0LmNvb3Jkc1sgMSBdIC0gc3RvcC5jb29yZHNbIDEgXSApIDwgJC5ldmVudC5zcGVjaWFsLnN3aXBlLnZlcnRpY2FsRGlzdGFuY2VUaHJlc2hvbGQgKSB7XG5cdFx0XHRcdHZhciBkaXJlY3Rpb24gPSBzdGFydC5jb29yZHNbMF0gPiBzdG9wLmNvb3Jkc1sgMCBdID8gXCJzd2lwZWxlZnRcIiA6IFwic3dpcGVyaWdodFwiO1xuXG5cdFx0XHRcdHRyaWdnZXJDdXN0b21FdmVudCggdGhpc09iamVjdCwgXCJzd2lwZVwiLCAkLkV2ZW50KCBcInN3aXBlXCIsIHsgdGFyZ2V0OiBvcmlnVGFyZ2V0LCBzd2lwZXN0YXJ0OiBzdGFydCwgc3dpcGVzdG9wOiBzdG9wIH0pLCB0cnVlICk7XG5cdFx0XHRcdHRyaWdnZXJDdXN0b21FdmVudCggdGhpc09iamVjdCwgZGlyZWN0aW9uLCQuRXZlbnQoIGRpcmVjdGlvbiwgeyB0YXJnZXQ6IG9yaWdUYXJnZXQsIHN3aXBlc3RhcnQ6IHN0YXJ0LCBzd2lwZXN0b3A6IHN0b3AgfSApLCB0cnVlICk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fSxcblxuXHRcdC8vIFRoaXMgc2VydmVzIGFzIGEgZmxhZyB0byBlbnN1cmUgdGhhdCBhdCBtb3N0IG9uZSBzd2lwZSBldmVudCBldmVudCBpc1xuXHRcdC8vIGluIHdvcmsgYXQgYW55IGdpdmVuIHRpbWVcblx0XHRldmVudEluUHJvZ3Jlc3M6IGZhbHNlLFxuXG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGV2ZW50cyxcblx0XHRcdFx0dGhpc09iamVjdCA9IHRoaXMsXG5cdFx0XHRcdCR0aGlzID0gJCggdGhpc09iamVjdCApLFxuXHRcdFx0XHRjb250ZXh0ID0ge307XG5cblx0XHRcdC8vIFJldHJpZXZlIHRoZSBldmVudHMgZGF0YSBmb3IgdGhpcyBlbGVtZW50IGFuZCBhZGQgdGhlIHN3aXBlIGNvbnRleHRcblx0XHRcdGV2ZW50cyA9ICQuZGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIgKTtcblx0XHRcdGlmICggIWV2ZW50cyApIHtcblx0XHRcdFx0ZXZlbnRzID0geyBsZW5ndGg6IDAgfTtcblx0XHRcdFx0JC5kYXRhKCB0aGlzLCBcIm1vYmlsZS1ldmVudHNcIiwgZXZlbnRzICk7XG5cdFx0XHR9XG5cdFx0XHRldmVudHMubGVuZ3RoKys7XG5cdFx0XHRldmVudHMuc3dpcGUgPSBjb250ZXh0O1xuXG5cdFx0XHRjb250ZXh0LnN0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIEJhaWwgaWYgd2UncmUgYWxyZWFkeSB3b3JraW5nIG9uIGEgc3dpcGUgZXZlbnRcblx0XHRcdFx0aWYgKCAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzID0gdHJ1ZTtcblxuXHRcdFx0XHR2YXIgc3RvcCxcblx0XHRcdFx0XHRzdGFydCA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5zdGFydCggZXZlbnQgKSxcblx0XHRcdFx0XHRvcmlnVGFyZ2V0ID0gZXZlbnQudGFyZ2V0LFxuXHRcdFx0XHRcdGVtaXR0ZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRjb250ZXh0Lm1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhcnQgfHwgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RvcCA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5zdG9wKCBldmVudCApO1xuXHRcdFx0XHRcdGlmICggIWVtaXR0ZWQgKSB7XG5cdFx0XHRcdFx0XHRlbWl0dGVkID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmhhbmRsZVN3aXBlKCBzdGFydCwgc3RvcCwgdGhpc09iamVjdCwgb3JpZ1RhcmdldCApO1xuXHRcdFx0XHRcdFx0aWYgKCBlbWl0dGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBjb250ZXh0IHRvIG1ha2Ugd2F5IGZvciB0aGUgbmV4dCBzd2lwZSBldmVudFxuXHRcdFx0XHRcdFx0XHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHByZXZlbnQgc2Nyb2xsaW5nXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggc3RhcnQuY29vcmRzWyAwIF0gLSBzdG9wLmNvb3Jkc1sgMCBdICkgPiAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc2Nyb2xsU3VwcmVzc2lvblRocmVzaG9sZCApIHtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNvbnRleHQuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZW1pdHRlZCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBjb250ZXh0IHRvIG1ha2Ugd2F5IGZvciB0aGUgbmV4dCBzd2lwZSBldmVudFxuXHRcdFx0XHRcdFx0JC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0JGRvY3VtZW50Lm9mZiggdG91Y2hNb3ZlRXZlbnQsIGNvbnRleHQubW92ZSApO1xuXHRcdFx0XHRcdFx0Y29udGV4dC5tb3ZlID0gbnVsbDtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQkZG9jdW1lbnQub24oIHRvdWNoTW92ZUV2ZW50LCBjb250ZXh0Lm1vdmUgKVxuXHRcdFx0XHRcdC5vbmUoIHRvdWNoU3RvcEV2ZW50LCBjb250ZXh0LnN0b3AgKTtcblx0XHRcdH07XG5cdFx0XHQkdGhpcy5vbiggdG91Y2hTdGFydEV2ZW50LCBjb250ZXh0LnN0YXJ0ICk7XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBldmVudHMsIGNvbnRleHQ7XG5cblx0XHRcdGV2ZW50cyA9ICQuZGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIgKTtcblx0XHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0XHRjb250ZXh0ID0gZXZlbnRzLnN3aXBlO1xuXHRcdFx0XHRkZWxldGUgZXZlbnRzLnN3aXBlO1xuXHRcdFx0XHRldmVudHMubGVuZ3RoLS07XG5cdFx0XHRcdGlmICggZXZlbnRzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0XHQkLnJlbW92ZURhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjb250ZXh0ICkge1xuXHRcdFx0XHRpZiAoIGNvbnRleHQuc3RhcnQgKSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLm9mZiggdG91Y2hTdGFydEV2ZW50LCBjb250ZXh0LnN0YXJ0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjb250ZXh0Lm1vdmUgKSB7XG5cdFx0XHRcdFx0JGRvY3VtZW50Lm9mZiggdG91Y2hNb3ZlRXZlbnQsIGNvbnRleHQubW92ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY29udGV4dC5zdG9wICkge1xuXHRcdFx0XHRcdCRkb2N1bWVudC5vZmYoIHRvdWNoU3RvcEV2ZW50LCBjb250ZXh0LnN0b3AgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0JC5lYWNoKHtcblx0XHRzd2lwZWxlZnQ6IFwic3dpcGUubGVmdFwiLFxuXHRcdHN3aXBlcmlnaHQ6IFwic3dpcGUucmlnaHRcIlxuXHR9LCBmdW5jdGlvbiggZXZlbnQsIHNvdXJjZUV2ZW50ICkge1xuXG5cdFx0JC5ldmVudC5zcGVjaWFsWyBldmVudCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkuYmluZCggc291cmNlRXZlbnQsICQubm9vcCApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLnVuYmluZCggc291cmNlRXZlbnQgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn0pKCBqUXVlcnksIHRoaXMgKTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbmNvbnN0IE11dGF0aW9uT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNcycsICcnXTtcbiAgZm9yICh2YXIgaT0wOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYCR7cHJlZml4ZXNbaV19TXV0YXRpb25PYnNlcnZlcmAgaW4gd2luZG93KSB7XG4gICAgICByZXR1cm4gd2luZG93W2Ake3ByZWZpeGVzW2ldfU11dGF0aW9uT2JzZXJ2ZXJgXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSgpKTtcblxuY29uc3QgdHJpZ2dlcnMgPSAoZWwsIHR5cGUpID0+IHtcbiAgZWwuZGF0YSh0eXBlKS5zcGxpdCgnICcpLmZvckVhY2goaWQgPT4ge1xuICAgICQoYCMke2lkfWApWyB0eXBlID09PSAnY2xvc2UnID8gJ3RyaWdnZXInIDogJ3RyaWdnZXJIYW5kbGVyJ10oYCR7dHlwZX0uemYudHJpZ2dlcmAsIFtlbF0pO1xuICB9KTtcbn07XG4vLyBFbGVtZW50cyB3aXRoIFtkYXRhLW9wZW5dIHdpbGwgcmV2ZWFsIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuJChkb2N1bWVudCkub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtb3Blbl0nLCBmdW5jdGlvbigpIHtcbiAgdHJpZ2dlcnMoJCh0aGlzKSwgJ29wZW4nKTtcbn0pO1xuXG4vLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NlXSB3aWxsIGNsb3NlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuLy8gSWYgdXNlZCB3aXRob3V0IGEgdmFsdWUgb24gW2RhdGEtY2xvc2VdLCB0aGUgZXZlbnQgd2lsbCBidWJibGUsIGFsbG93aW5nIGl0IHRvIGNsb3NlIGEgcGFyZW50IGNvbXBvbmVudC5cbiQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NlXScsIGZ1bmN0aW9uKCkge1xuICBsZXQgaWQgPSAkKHRoaXMpLmRhdGEoJ2Nsb3NlJyk7XG4gIGlmIChpZCkge1xuICAgIHRyaWdnZXJzKCQodGhpcyksICdjbG9zZScpO1xuICB9XG4gIGVsc2Uge1xuICAgICQodGhpcykudHJpZ2dlcignY2xvc2UuemYudHJpZ2dlcicpO1xuICB9XG59KTtcblxuLy8gRWxlbWVudHMgd2l0aCBbZGF0YS10b2dnbGVdIHdpbGwgdG9nZ2xlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuJChkb2N1bWVudCkub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtdG9nZ2xlXScsIGZ1bmN0aW9uKCkge1xuICB0cmlnZ2VycygkKHRoaXMpLCAndG9nZ2xlJyk7XG59KTtcblxuLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1jbG9zYWJsZV0gd2lsbCByZXNwb25kIHRvIGNsb3NlLnpmLnRyaWdnZXIgZXZlbnRzLlxuJChkb2N1bWVudCkub24oJ2Nsb3NlLnpmLnRyaWdnZXInLCAnW2RhdGEtY2xvc2FibGVdJywgZnVuY3Rpb24oZSl7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGxldCBhbmltYXRpb24gPSAkKHRoaXMpLmRhdGEoJ2Nsb3NhYmxlJyk7XG5cbiAgaWYoYW5pbWF0aW9uICE9PSAnJyl7XG4gICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCgkKHRoaXMpLCBhbmltYXRpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbG9zZWQuemYnKTtcbiAgICB9KTtcbiAgfWVsc2V7XG4gICAgJCh0aGlzKS5mYWRlT3V0KCkudHJpZ2dlcignY2xvc2VkLnpmJyk7XG4gIH1cbn0pO1xuXG4kKGRvY3VtZW50KS5vbignZm9jdXMuemYudHJpZ2dlciBibHVyLnpmLnRyaWdnZXInLCAnW2RhdGEtdG9nZ2xlLWZvY3VzXScsIGZ1bmN0aW9uKCkge1xuICBsZXQgaWQgPSAkKHRoaXMpLmRhdGEoJ3RvZ2dsZS1mb2N1cycpO1xuICAkKGAjJHtpZH1gKS50cmlnZ2VySGFuZGxlcigndG9nZ2xlLnpmLnRyaWdnZXInLCBbJCh0aGlzKV0pO1xufSk7XG5cbi8qKlxuKiBGaXJlcyBvbmNlIGFmdGVyIGFsbCBvdGhlciBzY3JpcHRzIGhhdmUgbG9hZGVkXG4qIEBmdW5jdGlvblxuKiBAcHJpdmF0ZVxuKi9cbiQod2luZG93KS5sb2FkKCgpID0+IHtcbiAgY2hlY2tMaXN0ZW5lcnMoKTtcbn0pO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVycygpIHtcbiAgZXZlbnRzTGlzdGVuZXIoKTtcbiAgcmVzaXplTGlzdGVuZXIoKTtcbiAgc2Nyb2xsTGlzdGVuZXIoKTtcbiAgY2xvc2VtZUxpc3RlbmVyKCk7XG59XG5cbi8vKioqKioqKiogb25seSBmaXJlcyB0aGlzIGZ1bmN0aW9uIG9uY2Ugb24gbG9hZCwgaWYgdGhlcmUncyBzb21ldGhpbmcgdG8gd2F0Y2ggKioqKioqKipcbmZ1bmN0aW9uIGNsb3NlbWVMaXN0ZW5lcihwbHVnaW5OYW1lKSB7XG4gIHZhciB5ZXRpQm94ZXMgPSAkKCdbZGF0YS15ZXRpLWJveF0nKSxcbiAgICAgIHBsdWdOYW1lcyA9IFsnZHJvcGRvd24nLCAndG9vbHRpcCcsICdyZXZlYWwnXTtcblxuICBpZihwbHVnaW5OYW1lKXtcbiAgICBpZih0eXBlb2YgcGx1Z2luTmFtZSA9PT0gJ3N0cmluZycpe1xuICAgICAgcGx1Z05hbWVzLnB1c2gocGx1Z2luTmFtZSk7XG4gICAgfWVsc2UgaWYodHlwZW9mIHBsdWdpbk5hbWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwbHVnaW5OYW1lWzBdID09PSAnc3RyaW5nJyl7XG4gICAgICBwbHVnTmFtZXMuY29uY2F0KHBsdWdpbk5hbWUpO1xuICAgIH1lbHNle1xuICAgICAgY29uc29sZS5lcnJvcignUGx1Z2luIG5hbWVzIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgfVxuICBpZih5ZXRpQm94ZXMubGVuZ3RoKXtcbiAgICBsZXQgbGlzdGVuZXJzID0gcGx1Z05hbWVzLm1hcCgobmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGBjbG9zZW1lLnpmLiR7bmFtZX1gO1xuICAgIH0pLmpvaW4oJyAnKTtcblxuICAgICQod2luZG93KS5vZmYobGlzdGVuZXJzKS5vbihsaXN0ZW5lcnMsIGZ1bmN0aW9uKGUsIHBsdWdpbklkKXtcbiAgICAgIGxldCBwbHVnaW4gPSBlLm5hbWVzcGFjZS5zcGxpdCgnLicpWzBdO1xuICAgICAgbGV0IHBsdWdpbnMgPSAkKGBbZGF0YS0ke3BsdWdpbn1dYCkubm90KGBbZGF0YS15ZXRpLWJveD1cIiR7cGx1Z2luSWR9XCJdYCk7XG5cbiAgICAgIHBsdWdpbnMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICBsZXQgX3RoaXMgPSAkKHRoaXMpO1xuXG4gICAgICAgIF90aGlzLnRyaWdnZXJIYW5kbGVyKCdjbG9zZS56Zi50cmlnZ2VyJywgW190aGlzXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNpemVMaXN0ZW5lcihkZWJvdW5jZSl7XG4gIGxldCB0aW1lcixcbiAgICAgICRub2RlcyA9ICQoJ1tkYXRhLXJlc2l6ZV0nKTtcbiAgaWYoJG5vZGVzLmxlbmd0aCl7XG4gICAgJCh3aW5kb3cpLm9mZigncmVzaXplLnpmLnRyaWdnZXInKVxuICAgIC5vbigncmVzaXplLnpmLnRyaWdnZXInLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGltZXIpIHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfVxuXG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgICAgICBpZighTXV0YXRpb25PYnNlcnZlcil7Ly9mYWxsYmFjayBmb3IgSUUgOVxuICAgICAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKCdyZXNpemVtZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy90cmlnZ2VyIGFsbCBsaXN0ZW5pbmcgZWxlbWVudHMgYW5kIHNpZ25hbCBhIHJlc2l6ZSBldmVudFxuICAgICAgICAkbm9kZXMuYXR0cignZGF0YS1ldmVudHMnLCBcInJlc2l6ZVwiKTtcbiAgICAgIH0sIGRlYm91bmNlIHx8IDEwKTsvL2RlZmF1bHQgdGltZSB0byBlbWl0IHJlc2l6ZSBldmVudFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbExpc3RlbmVyKGRlYm91bmNlKXtcbiAgbGV0IHRpbWVyLFxuICAgICAgJG5vZGVzID0gJCgnW2RhdGEtc2Nyb2xsXScpO1xuICBpZigkbm9kZXMubGVuZ3RoKXtcbiAgICAkKHdpbmRvdykub2ZmKCdzY3JvbGwuemYudHJpZ2dlcicpXG4gICAgLm9uKCdzY3JvbGwuemYudHJpZ2dlcicsIGZ1bmN0aW9uKGUpe1xuICAgICAgaWYodGltZXIpeyBjbGVhclRpbWVvdXQodGltZXIpOyB9XG5cbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXG4gICAgICAgIGlmKCFNdXRhdGlvbk9ic2VydmVyKXsvL2ZhbGxiYWNrIGZvciBJRSA5XG4gICAgICAgICAgJG5vZGVzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL3RyaWdnZXIgYWxsIGxpc3RlbmluZyBlbGVtZW50cyBhbmQgc2lnbmFsIGEgc2Nyb2xsIGV2ZW50XG4gICAgICAgICRub2Rlcy5hdHRyKCdkYXRhLWV2ZW50cycsIFwic2Nyb2xsXCIpO1xuICAgICAgfSwgZGVib3VuY2UgfHwgMTApOy8vZGVmYXVsdCB0aW1lIHRvIGVtaXQgc2Nyb2xsIGV2ZW50XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRzTGlzdGVuZXIoKSB7XG4gIGlmKCFNdXRhdGlvbk9ic2VydmVyKXsgcmV0dXJuIGZhbHNlOyB9XG4gIGxldCBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXJlc2l6ZV0sIFtkYXRhLXNjcm9sbF0sIFtkYXRhLW11dGF0ZV0nKTtcblxuICAvL2VsZW1lbnQgY2FsbGJhY2tcbiAgdmFyIGxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24gPSBmdW5jdGlvbihtdXRhdGlvblJlY29yZHNMaXN0KSB7XG4gICAgdmFyICR0YXJnZXQgPSAkKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0udGFyZ2V0KTtcbiAgICAvL3RyaWdnZXIgdGhlIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBlbGVtZW50IGRlcGVuZGluZyBvbiB0eXBlXG4gICAgc3dpdGNoICgkdGFyZ2V0LmF0dHIoXCJkYXRhLWV2ZW50c1wiKSkge1xuXG4gICAgICBjYXNlIFwicmVzaXplXCIgOlxuICAgICAgJHRhcmdldC50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0XSk7XG4gICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInNjcm9sbFwiIDpcbiAgICAgICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInLCBbJHRhcmdldCwgd2luZG93LnBhZ2VZT2Zmc2V0XSk7XG4gICAgICBicmVhaztcblxuICAgICAgLy8gY2FzZSBcIm11dGF0ZVwiIDpcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXRhdGUnLCAkdGFyZ2V0KTtcbiAgICAgIC8vICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ211dGF0ZS56Zi50cmlnZ2VyJyk7XG4gICAgICAvL1xuICAgICAgLy8gLy9tYWtlIHN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3AgZnJvbSBzbG9wcHkgY29kZWluZ1xuICAgICAgLy8gaWYgKCR0YXJnZXQuaW5kZXgoJ1tkYXRhLW11dGF0ZV0nKSA9PSAkKFwiW2RhdGEtbXV0YXRlXVwiKS5sZW5ndGgtMSkge1xuICAgICAgLy8gICBkb21NdXRhdGlvbk9ic2VydmVyKCk7XG4gICAgICAvLyB9XG4gICAgICAvLyBicmVhaztcblxuICAgICAgZGVmYXVsdCA6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvL25vdGhpbmdcbiAgICB9XG4gIH1cblxuICBpZihub2Rlcy5sZW5ndGgpe1xuICAgIC8vZm9yIGVhY2ggZWxlbWVudCB0aGF0IG5lZWRzIHRvIGxpc3RlbiBmb3IgcmVzaXppbmcsIHNjcm9sbGluZywgKG9yIGNvbWluZyBzb29uIG11dGF0aW9uKSBhZGQgYSBzaW5nbGUgb2JzZXJ2ZXJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBub2Rlcy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICBsZXQgZWxlbWVudE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbik7XG4gICAgICBlbGVtZW50T2JzZXJ2ZXIub2JzZXJ2ZShub2Rlc1tpXSwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IGZhbHNlLCBjaGFyYWN0ZXJEYXRhOiBmYWxzZSwgc3VidHJlZTpmYWxzZSwgYXR0cmlidXRlRmlsdGVyOltcImRhdGEtZXZlbnRzXCJdfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBbUEhdXG4vLyBGb3VuZGF0aW9uLkNoZWNrV2F0Y2hlcnMgPSBjaGVja1dhdGNoZXJzO1xuRm91bmRhdGlvbi5JSGVhcllvdSA9IGNoZWNrTGlzdGVuZXJzO1xuLy8gRm91bmRhdGlvbi5JU2VlWW91ID0gc2Nyb2xsTGlzdGVuZXI7XG4vLyBGb3VuZGF0aW9uLklGZWVsWW91ID0gY2xvc2VtZUxpc3RlbmVyO1xuXG59KGpRdWVyeSk7XG5cbi8vIGZ1bmN0aW9uIGRvbU11dGF0aW9uT2JzZXJ2ZXIoZGVib3VuY2UpIHtcbi8vICAgLy8gISEhIFRoaXMgaXMgY29taW5nIHNvb24gYW5kIG5lZWRzIG1vcmUgd29yazsgbm90IGFjdGl2ZSAgISEhIC8vXG4vLyAgIHZhciB0aW1lcixcbi8vICAgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tdXRhdGVdJyk7XG4vLyAgIC8vXG4vLyAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbi8vICAgICAvLyB2YXIgTXV0YXRpb25PYnNlcnZlciA9IChmdW5jdGlvbiAoKSB7XG4vLyAgICAgLy8gICB2YXIgcHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNcycsICcnXTtcbi8vICAgICAvLyAgIGZvciAodmFyIGk9MDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgLy8gICAgIGlmIChwcmVmaXhlc1tpXSArICdNdXRhdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cpIHtcbi8vICAgICAvLyAgICAgICByZXR1cm4gd2luZG93W3ByZWZpeGVzW2ldICsgJ011dGF0aW9uT2JzZXJ2ZXInXTtcbi8vICAgICAvLyAgICAgfVxuLy8gICAgIC8vICAgfVxuLy8gICAgIC8vICAgcmV0dXJuIGZhbHNlO1xuLy8gICAgIC8vIH0oKSk7XG4vL1xuLy9cbi8vICAgICAvL2ZvciB0aGUgYm9keSwgd2UgbmVlZCB0byBsaXN0ZW4gZm9yIGFsbCBjaGFuZ2VzIGVmZmVjdGluZyB0aGUgc3R5bGUgYW5kIGNsYXNzIGF0dHJpYnV0ZXNcbi8vICAgICB2YXIgYm9keU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoYm9keU11dGF0aW9uKTtcbi8vICAgICBib2R5T2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogZmFsc2UsIHN1YnRyZWU6dHJ1ZSwgYXR0cmlidXRlRmlsdGVyOltcInN0eWxlXCIsIFwiY2xhc3NcIl19KTtcbi8vXG4vL1xuLy8gICAgIC8vYm9keSBjYWxsYmFja1xuLy8gICAgIGZ1bmN0aW9uIGJvZHlNdXRhdGlvbihtdXRhdGUpIHtcbi8vICAgICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBtdXRhdGlvbiBldmVudFxuLy8gICAgICAgaWYgKHRpbWVyKSB7IGNsZWFyVGltZW91dCh0aW1lcik7IH1cbi8vXG4vLyAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgIGJvZHlPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4vLyAgICAgICAgICQoJ1tkYXRhLW11dGF0ZV0nKS5hdHRyKCdkYXRhLWV2ZW50cycsXCJtdXRhdGVcIik7XG4vLyAgICAgICB9LCBkZWJvdW5jZSB8fCAxNTApO1xuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIEFiaWRlIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5hYmlkZVxuICovXG5cbmNsYXNzIEFiaWRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQWJpZGUuXG4gICAqIEBjbGFzc1xuICAgKiBAZmlyZXMgQWJpZGUjaW5pdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgID0gJC5leHRlbmQoe30sIEFiaWRlLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdBYmlkZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBBYmlkZSBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgQWJpZGUgZnVuY3Rpb25pbmcgb24gbG9hZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHRoaXMuJGlucHV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnKTtcblxuICAgIHRoaXMuX2V2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgQWJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuYWJpZGUnKVxuICAgICAgLm9uKCdyZXNldC56Zi5hYmlkZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5yZXNldEZvcm0oKTtcbiAgICAgIH0pXG4gICAgICAub24oJ3N1Ym1pdC56Zi5hYmlkZScsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVGb3JtKCk7XG4gICAgICB9KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGVPbiA9PT0gJ2ZpZWxkQ2hhbmdlJykge1xuICAgICAgdGhpcy4kaW5wdXRzXG4gICAgICAgIC5vZmYoJ2NoYW5nZS56Zi5hYmlkZScpXG4gICAgICAgIC5vbignY2hhbmdlLnpmLmFiaWRlJywgKGUpID0+IHtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlSW5wdXQoJChlLnRhcmdldCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpdmVWYWxpZGF0ZSkge1xuICAgICAgdGhpcy4kaW5wdXRzXG4gICAgICAgIC5vZmYoJ2lucHV0LnpmLmFiaWRlJylcbiAgICAgICAgLm9uKCdpbnB1dC56Zi5hYmlkZScsIChlKSA9PiB7XG4gICAgICAgICAgdGhpcy52YWxpZGF0ZUlucHV0KCQoZS50YXJnZXQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIEFiaWRlIHVwb24gRE9NIGNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZmxvdygpIHtcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGEgZm9ybSBlbGVtZW50IGhhcyB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIGFuZCBpZiBpdCdzIGNoZWNrZWQgb3Igbm90XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcbiAgICovXG4gIHJlcXVpcmVkQ2hlY2soJGVsKSB7XG4gICAgaWYgKCEkZWwuYXR0cigncmVxdWlyZWQnKSkgcmV0dXJuIHRydWU7XG5cbiAgICB2YXIgaXNHb29kID0gdHJ1ZTtcblxuICAgIHN3aXRjaCAoJGVsWzBdLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgaXNHb29kID0gJGVsWzBdLmNoZWNrZWQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XG4gICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxuICAgICAgICB2YXIgb3B0ID0gJGVsLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpO1xuICAgICAgICBpZiAoIW9wdC5sZW5ndGggfHwgIW9wdC52YWwoKSkgaXNHb29kID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZighJGVsLnZhbCgpIHx8ICEkZWwudmFsKCkubGVuZ3RoKSBpc0dvb2QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNHb29kO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhc2VkIG9uICRlbCwgZ2V0IHRoZSBmaXJzdCBlbGVtZW50IHdpdGggc2VsZWN0b3IgaW4gdGhpcyBvcmRlcjpcbiAgICogMS4gVGhlIGVsZW1lbnQncyBkaXJlY3Qgc2libGluZygncykuXG4gICAqIDMuIFRoZSBlbGVtZW50J3MgcGFyZW50J3MgY2hpbGRyZW4uXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIGZvciBtdWx0aXBsZSBmb3JtIGVycm9ycyBwZXIgaW5wdXQsIHRob3VnaCBpZiBub25lIGFyZSBmb3VuZCwgbm8gZm9ybSBlcnJvcnMgd2lsbCBiZSBzaG93bi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGFzIHJlZmVyZW5jZSB0byBmaW5kIHRoZSBmb3JtIGVycm9yIHNlbGVjdG9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBqUXVlcnkgb2JqZWN0IHdpdGggdGhlIHNlbGVjdG9yLlxuICAgKi9cbiAgZmluZEZvcm1FcnJvcigkZWwpIHtcbiAgICB2YXIgJGVycm9yID0gJGVsLnNpYmxpbmdzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3Rvcik7XG5cbiAgICBpZiAoISRlcnJvci5sZW5ndGgpIHtcbiAgICAgICRlcnJvciA9ICRlbC5wYXJlbnQoKS5maW5kKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuICRlcnJvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhpcyBvcmRlcjpcbiAgICogMi4gVGhlIDxsYWJlbD4gd2l0aCB0aGUgYXR0cmlidXRlIGBbZm9yPVwic29tZUlucHV0SWRcIl1gXG4gICAqIDMuIFRoZSBgLmNsb3Nlc3QoKWAgPGxhYmVsPlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcbiAgICovXG4gIGZpbmRMYWJlbCgkZWwpIHtcbiAgICB2YXIgaWQgPSAkZWxbMF0uaWQ7XG4gICAgdmFyICRsYWJlbCA9IHRoaXMuJGVsZW1lbnQuZmluZChgbGFiZWxbZm9yPVwiJHtpZH1cIl1gKTtcblxuICAgIGlmICghJGxhYmVsLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICRlbC5jbG9zZXN0KCdsYWJlbCcpO1xuICAgIH1cblxuICAgIHJldHVybiAkbGFiZWw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZXQgb2YgbGFiZWxzIGFzc29jaWF0ZWQgd2l0aCBhIHNldCBvZiByYWRpbyBlbHMgaW4gdGhpcyBvcmRlclxuICAgKiAyLiBUaGUgPGxhYmVsPiB3aXRoIHRoZSBhdHRyaWJ1dGUgYFtmb3I9XCJzb21lSW5wdXRJZFwiXWBcbiAgICogMy4gVGhlIGAuY2xvc2VzdCgpYCA8bGFiZWw+XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxuICAgKi9cbiAgZmluZFJhZGlvTGFiZWxzKCRlbHMpIHtcbiAgICB2YXIgbGFiZWxzID0gJGVscy5tYXAoKGksIGVsKSA9PiB7XG4gICAgICB2YXIgaWQgPSBlbC5pZDtcbiAgICAgIHZhciAkbGFiZWwgPSB0aGlzLiRlbGVtZW50LmZpbmQoYGxhYmVsW2Zvcj1cIiR7aWR9XCJdYCk7XG5cbiAgICAgIGlmICghJGxhYmVsLmxlbmd0aCkge1xuICAgICAgICAkbGFiZWwgPSAkKGVsKS5jbG9zZXN0KCdsYWJlbCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICRsYWJlbFswXTtcbiAgICB9KTtcblxuICAgIHJldHVybiAkKGxhYmVscyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgQ1NTIGVycm9yIGNsYXNzIGFzIHNwZWNpZmllZCBieSB0aGUgQWJpZGUgc2V0dGluZ3MgdG8gdGhlIGxhYmVsLCBpbnB1dCwgYW5kIHRoZSBmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgY2xhc3MgdG9cbiAgICovXG4gIGFkZEVycm9yQ2xhc3NlcygkZWwpIHtcbiAgICB2YXIgJGxhYmVsID0gdGhpcy5maW5kTGFiZWwoJGVsKTtcbiAgICB2YXIgJGZvcm1FcnJvciA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWwpO1xuXG4gICAgaWYgKCRsYWJlbC5sZW5ndGgpIHtcbiAgICAgICRsYWJlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoJGZvcm1FcnJvci5sZW5ndGgpIHtcbiAgICAgICRmb3JtRXJyb3IuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcbiAgICB9XG5cbiAgICAkZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykuYXR0cignZGF0YS1pbnZhbGlkJywgJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBDU1MgZXJyb3IgY2xhc3NlcyBldGMgZnJvbSBhbiBlbnRpcmUgcmFkaW8gYnV0dG9uIGdyb3VwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgLSBBIHN0cmluZyB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZSBvZiBhIHJhZGlvIGJ1dHRvbiBncm91cFxuICAgKlxuICAgKi9cblxuICByZW1vdmVSYWRpb0Vycm9yQ2xhc3Nlcyhncm91cE5hbWUpIHtcbiAgICB2YXIgJGVscyA9IHRoaXMuJGVsZW1lbnQuZmluZChgOnJhZGlvW25hbWU9XCIke2dyb3VwTmFtZX1cIl1gKTtcbiAgICB2YXIgJGxhYmVscyA9IHRoaXMuZmluZFJhZGlvTGFiZWxzKCRlbHMpO1xuICAgIHZhciAkZm9ybUVycm9ycyA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWxzKTtcblxuICAgIGlmICgkbGFiZWxzLmxlbmd0aCkge1xuICAgICAgJGxhYmVscy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoJGZvcm1FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAkZm9ybUVycm9ycy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xuICAgIH1cblxuICAgICRlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIENTUyBlcnJvciBjbGFzcyBhcyBzcGVjaWZpZWQgYnkgdGhlIEFiaWRlIHNldHRpbmdzIGZyb20gdGhlIGxhYmVsLCBpbnB1dCwgYW5kIHRoZSBmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxuICAgKi9cbiAgcmVtb3ZlRXJyb3JDbGFzc2VzKCRlbCkge1xuICAgIC8vIHJhZGlvcyBuZWVkIHRvIGNsZWFyIGFsbCBvZiB0aGUgZWxzXG4gICAgaWYoJGVsWzBdLnR5cGUgPT0gJ3JhZGlvJykge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlUmFkaW9FcnJvckNsYXNzZXMoJGVsLmF0dHIoJ25hbWUnKSk7XG4gICAgfVxuXG4gICAgdmFyICRsYWJlbCA9IHRoaXMuZmluZExhYmVsKCRlbCk7XG4gICAgdmFyICRmb3JtRXJyb3IgPSB0aGlzLmZpbmRGb3JtRXJyb3IoJGVsKTtcblxuICAgIGlmICgkbGFiZWwubGVuZ3RoKSB7XG4gICAgICAkbGFiZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKCRmb3JtRXJyb3IubGVuZ3RoKSB7XG4gICAgICAkZm9ybUVycm9yLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyk7XG4gICAgfVxuXG4gICAgJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLnJlbW92ZUF0dHIoJ2RhdGEtaW52YWxpZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvZXMgdGhyb3VnaCBhIGZvcm0gdG8gZmluZCBpbnB1dHMgYW5kIHByb2NlZWRzIHRvIHZhbGlkYXRlIHRoZW0gaW4gd2F5cyBzcGVjaWZpYyB0byB0aGVpciB0eXBlXG4gICAqIEBmaXJlcyBBYmlkZSNpbnZhbGlkXG4gICAqIEBmaXJlcyBBYmlkZSN2YWxpZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdmFsaWRhdGUsIHNob3VsZCBiZSBhbiBIVE1MIGlucHV0XG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBnb29kVG9HbyAtIElmIHRoZSBpbnB1dCBpcyB2YWxpZCBvciBub3QuXG4gICAqL1xuICB2YWxpZGF0ZUlucHV0KCRlbCkge1xuICAgIHZhciBjbGVhclJlcXVpcmUgPSB0aGlzLnJlcXVpcmVkQ2hlY2soJGVsKSxcbiAgICAgICAgdmFsaWRhdGVkID0gZmFsc2UsXG4gICAgICAgIGN1c3RvbVZhbGlkYXRvciA9IHRydWUsXG4gICAgICAgIHZhbGlkYXRvciA9ICRlbC5hdHRyKCdkYXRhLXZhbGlkYXRvcicpLFxuICAgICAgICBlcXVhbFRvID0gdHJ1ZTtcblxuICAgIC8vIGRvbid0IHZhbGlkYXRlIGlnbm9yZWQgaW5wdXRzIG9yIGhpZGRlbiBpbnB1dHNcbiAgICBpZiAoJGVsLmlzKCdbZGF0YS1hYmlkZS1pZ25vcmVdJykgfHwgJGVsLmlzKCdbdHlwZT1cImhpZGRlblwiXScpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKCRlbFswXS50eXBlKSB7XG4gICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgIHZhbGlkYXRlZCA9IHRoaXMudmFsaWRhdGVSYWRpbygkZWwuYXR0cignbmFtZScpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgdmFsaWRhdGVkID0gY2xlYXJSZXF1aXJlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGNhc2UgJ3NlbGVjdC1vbmUnOlxuICAgICAgY2FzZSAnc2VsZWN0LW11bHRpcGxlJzpcbiAgICAgICAgdmFsaWRhdGVkID0gY2xlYXJSZXF1aXJlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFsaWRhdGVkID0gdGhpcy52YWxpZGF0ZVRleHQoJGVsKTtcbiAgICB9XG5cbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICBjdXN0b21WYWxpZGF0b3IgPSB0aGlzLm1hdGNoVmFsaWRhdGlvbigkZWwsIHZhbGlkYXRvciwgJGVsLmF0dHIoJ3JlcXVpcmVkJykpO1xuICAgIH1cblxuICAgIGlmICgkZWwuYXR0cignZGF0YS1lcXVhbHRvJykpIHtcbiAgICAgIGVxdWFsVG8gPSB0aGlzLm9wdGlvbnMudmFsaWRhdG9ycy5lcXVhbFRvKCRlbCk7XG4gICAgfVxuXG5cbiAgICB2YXIgZ29vZFRvR28gPSBbY2xlYXJSZXF1aXJlLCB2YWxpZGF0ZWQsIGN1c3RvbVZhbGlkYXRvciwgZXF1YWxUb10uaW5kZXhPZihmYWxzZSkgPT09IC0xO1xuICAgIHZhciBtZXNzYWdlID0gKGdvb2RUb0dvID8gJ3ZhbGlkJyA6ICdpbnZhbGlkJykgKyAnLnpmLmFiaWRlJztcblxuICAgIHRoaXNbZ29vZFRvR28gPyAncmVtb3ZlRXJyb3JDbGFzc2VzJyA6ICdhZGRFcnJvckNsYXNzZXMnXSgkZWwpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgaW5wdXQgaXMgZG9uZSBjaGVja2luZyBmb3IgdmFsaWRhdGlvbi4gRXZlbnQgdHJpZ2dlciBpcyBlaXRoZXIgYHZhbGlkLnpmLmFiaWRlYCBvciBgaW52YWxpZC56Zi5hYmlkZWBcbiAgICAgKiBUcmlnZ2VyIGluY2x1ZGVzIHRoZSBET00gZWxlbWVudCBvZiB0aGUgaW5wdXQuXG4gICAgICogQGV2ZW50IEFiaWRlI3ZhbGlkXG4gICAgICogQGV2ZW50IEFiaWRlI2ludmFsaWRcbiAgICAgKi9cbiAgICAkZWwudHJpZ2dlcihtZXNzYWdlLCBbJGVsXSk7XG5cbiAgICByZXR1cm4gZ29vZFRvR287XG4gIH1cblxuICAvKipcbiAgICogR29lcyB0aHJvdWdoIGEgZm9ybSBhbmQgaWYgdGhlcmUgYXJlIGFueSBpbnZhbGlkIGlucHV0cywgaXQgd2lsbCBkaXNwbGF5IHRoZSBmb3JtIGVycm9yIGVsZW1lbnRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IG5vRXJyb3IgLSB0cnVlIGlmIG5vIGVycm9ycyB3ZXJlIGRldGVjdGVkLi4uXG4gICAqIEBmaXJlcyBBYmlkZSNmb3JtdmFsaWRcbiAgICogQGZpcmVzIEFiaWRlI2Zvcm1pbnZhbGlkXG4gICAqL1xuICB2YWxpZGF0ZUZvcm0oKSB7XG4gICAgdmFyIGFjYyA9IFtdO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLiRpbnB1dHMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGFjYy5wdXNoKF90aGlzLnZhbGlkYXRlSW5wdXQoJCh0aGlzKSkpO1xuICAgIH0pO1xuXG4gICAgdmFyIG5vRXJyb3IgPSBhY2MuaW5kZXhPZihmYWxzZSkgPT09IC0xO1xuXG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKS5jc3MoJ2Rpc3BsYXknLCAobm9FcnJvciA/ICdub25lJyA6ICdibG9jaycpKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGZvcm0gaXMgZmluaXNoZWQgdmFsaWRhdGluZy4gRXZlbnQgdHJpZ2dlciBpcyBlaXRoZXIgYGZvcm12YWxpZC56Zi5hYmlkZWAgb3IgYGZvcm1pbnZhbGlkLnpmLmFiaWRlYC5cbiAgICAgKiBUcmlnZ2VyIGluY2x1ZGVzIHRoZSBlbGVtZW50IG9mIHRoZSBmb3JtLlxuICAgICAqIEBldmVudCBBYmlkZSNmb3JtdmFsaWRcbiAgICAgKiBAZXZlbnQgQWJpZGUjZm9ybWludmFsaWRcbiAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoKG5vRXJyb3IgPyAnZm9ybXZhbGlkJyA6ICdmb3JtaW52YWxpZCcpICsgJy56Zi5hYmlkZScsIFt0aGlzLiRlbGVtZW50XSk7XG5cbiAgICByZXR1cm4gbm9FcnJvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3IgYSBub3QgYSB0ZXh0IGlucHV0IGlzIHZhbGlkIGJhc2VkIG9uIHRoZSBwYXR0ZXJuIHNwZWNpZmllZCBpbiB0aGUgYXR0cmlidXRlLiBJZiBubyBtYXRjaGluZyBwYXR0ZXJuIGlzIGZvdW5kLCByZXR1cm5zIHRydWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHZhbGlkYXRlLCBzaG91bGQgYmUgYSB0ZXh0IGlucHV0IEhUTUwgZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiAtIHN0cmluZyB2YWx1ZSBvZiBvbmUgb2YgdGhlIFJlZ0V4IHBhdHRlcm5zIGluIEFiaWRlLm9wdGlvbnMucGF0dGVybnNcbiAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgdmFsdWUgbWF0Y2hlcyB0aGUgcGF0dGVybiBzcGVjaWZpZWRcbiAgICovXG4gIHZhbGlkYXRlVGV4dCgkZWwsIHBhdHRlcm4pIHtcbiAgICAvLyBBIHBhdHRlcm4gY2FuIGJlIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGJlIGluZmVyZWQgZnJvbSB0aGUgaW5wdXQncyBcInBhdHRlcm5cIiBhdHRyaWJ1dGUsIG9yIGl0J3MgXCJ0eXBlXCIgYXR0cmlidXRlXG4gICAgcGF0dGVybiA9IChwYXR0ZXJuIHx8ICRlbC5hdHRyKCdwYXR0ZXJuJykgfHwgJGVsLmF0dHIoJ3R5cGUnKSk7XG4gICAgdmFyIGlucHV0VGV4dCA9ICRlbC52YWwoKTtcbiAgICB2YXIgdmFsaWQgPSBmYWxzZTtcblxuICAgIGlmIChpbnB1dFRleHQubGVuZ3RoKSB7XG4gICAgICAvLyBJZiB0aGUgcGF0dGVybiBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQgaXMgaW4gQWJpZGUncyBsaXN0IG9mIHBhdHRlcm5zLCB0aGVuIHRlc3QgdGhhdCByZWdleHBcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGF0dGVybnMuaGFzT3duUHJvcGVydHkocGF0dGVybikpIHtcbiAgICAgICAgdmFsaWQgPSB0aGlzLm9wdGlvbnMucGF0dGVybnNbcGF0dGVybl0udGVzdChpbnB1dFRleHQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIHBhdHRlcm4gbmFtZSBpc24ndCBhbHNvIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiB0aGUgZmllbGQsIHRoZW4gdGVzdCBpdCBhcyBhIHJlZ2V4cFxuICAgICAgZWxzZSBpZiAocGF0dGVybiAhPT0gJGVsLmF0dHIoJ3R5cGUnKSkge1xuICAgICAgICB2YWxpZCA9IG5ldyBSZWdFeHAocGF0dGVybikudGVzdChpbnB1dFRleHQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQW4gZW1wdHkgZmllbGQgaXMgdmFsaWQgaWYgaXQncyBub3QgcmVxdWlyZWRcbiAgICBlbHNlIGlmICghJGVsLnByb3AoJ3JlcXVpcmVkJykpIHtcbiAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWQ7XG4gICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBvciBhIG5vdCBhIHJhZGlvIGlucHV0IGlzIHZhbGlkIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IGl0IGlzIHJlcXVpcmVkIGFuZCBzZWxlY3RlZC4gQWx0aG91Z2ggdGhlIGZ1bmN0aW9uIHRhcmdldHMgYSBzaW5nbGUgYDxpbnB1dD5gLCBpdCB2YWxpZGF0ZXMgYnkgY2hlY2tpbmcgdGhlIGByZXF1aXJlZGAgYW5kIGBjaGVja2VkYCBwcm9wZXJ0aWVzIG9mIGFsbCByYWRpbyBidXR0b25zIGluIGl0cyBncm91cC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSAtIEEgc3RyaW5nIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lIG9mIGEgcmFkaW8gYnV0dG9uIGdyb3VwXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXQgbGVhc3Qgb25lIHJhZGlvIGlucHV0IGhhcyBiZWVuIHNlbGVjdGVkIChpZiBpdCdzIHJlcXVpcmVkKVxuICAgKi9cbiAgdmFsaWRhdGVSYWRpbyhncm91cE5hbWUpIHtcbiAgICAvLyBJZiBhdCBsZWFzdCBvbmUgcmFkaW8gaW4gdGhlIGdyb3VwIGhhcyB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUsIHRoZSBncm91cCBpcyBjb25zaWRlcmVkIHJlcXVpcmVkXG4gICAgLy8gUGVyIFczQyBzcGVjLCBhbGwgcmFkaW8gYnV0dG9ucyBpbiBhIGdyb3VwIHNob3VsZCBoYXZlIGByZXF1aXJlZGAsIGJ1dCB3ZSdyZSBiZWluZyBuaWNlXG4gICAgdmFyICRncm91cCA9IHRoaXMuJGVsZW1lbnQuZmluZChgOnJhZGlvW25hbWU9XCIke2dyb3VwTmFtZX1cIl1gKTtcbiAgICB2YXIgdmFsaWQgPSBmYWxzZSwgcmVxdWlyZWQgPSBmYWxzZTtcblxuICAgIC8vIEZvciB0aGUgZ3JvdXAgdG8gYmUgcmVxdWlyZWQsIGF0IGxlYXN0IG9uZSByYWRpbyBuZWVkcyB0byBiZSByZXF1aXJlZFxuICAgICRncm91cC5lYWNoKChpLCBlKSA9PiB7XG4gICAgICBpZiAoJChlKS5hdHRyKCdyZXF1aXJlZCcpKSB7XG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZighcmVxdWlyZWQpIHZhbGlkPXRydWU7XG5cbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAvLyBGb3IgdGhlIGdyb3VwIHRvIGJlIHZhbGlkLCBhdCBsZWFzdCBvbmUgcmFkaW8gbmVlZHMgdG8gYmUgY2hlY2tlZFxuICAgICAgJGdyb3VwLmVhY2goKGksIGUpID0+IHtcbiAgICAgICAgaWYgKCQoZSkucHJvcCgnY2hlY2tlZCcpKSB7XG4gICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYSBzZWxlY3RlZCBpbnB1dCBwYXNzZXMgYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi4gTXVsdGlwbGUgdmFsaWRhdGlvbnMgY2FuIGJlIHVzZWQsIGlmIHBhc3NlZCB0byB0aGUgZWxlbWVudCB3aXRoIGBkYXRhLXZhbGlkYXRvcj1cImZvbyBiYXIgYmF6XCJgIGluIGEgc3BhY2Ugc2VwYXJhdGVkIGxpc3RlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBpbnB1dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsaWRhdG9ycyAtIGEgc3RyaW5nIG9mIGZ1bmN0aW9uIG5hbWVzIG1hdGNoaW5nIGZ1bmN0aW9ucyBpbiB0aGUgQWJpZGUub3B0aW9ucy52YWxpZGF0b3JzIG9iamVjdC5cbiAgICogQHBhcmFtIHtCb29sZWFufSByZXF1aXJlZCAtIHNlbGYgZXhwbGFuYXRvcnk/XG4gICAqIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgdmFsaWRhdGlvbnMgcGFzc2VkLlxuICAgKi9cbiAgbWF0Y2hWYWxpZGF0aW9uKCRlbCwgdmFsaWRhdG9ycywgcmVxdWlyZWQpIHtcbiAgICByZXF1aXJlZCA9IHJlcXVpcmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgdmFyIGNsZWFyID0gdmFsaWRhdG9ycy5zcGxpdCgnICcpLm1hcCgodikgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWxpZGF0b3JzW3ZdKCRlbCwgcmVxdWlyZWQsICRlbC5wYXJlbnQoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsZWFyLmluZGV4T2YoZmFsc2UpID09PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgZm9ybSBpbnB1dHMgYW5kIHN0eWxlc1xuICAgKiBAZmlyZXMgQWJpZGUjZm9ybXJlc2V0XG4gICAqL1xuICByZXNldEZvcm0oKSB7XG4gICAgdmFyICRmb3JtID0gdGhpcy4kZWxlbWVudCxcbiAgICAgICAgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgICQoYC4ke29wdHMubGFiZWxFcnJvckNsYXNzfWAsICRmb3JtKS5ub3QoJ3NtYWxsJykucmVtb3ZlQ2xhc3Mob3B0cy5sYWJlbEVycm9yQ2xhc3MpO1xuICAgICQoYC4ke29wdHMuaW5wdXRFcnJvckNsYXNzfWAsICRmb3JtKS5ub3QoJ3NtYWxsJykucmVtb3ZlQ2xhc3Mob3B0cy5pbnB1dEVycm9yQ2xhc3MpO1xuICAgICQoYCR7b3B0cy5mb3JtRXJyb3JTZWxlY3Rvcn0uJHtvcHRzLmZvcm1FcnJvckNsYXNzfWApLnJlbW92ZUNsYXNzKG9wdHMuZm9ybUVycm9yQ2xhc3MpO1xuICAgICRmb3JtLmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgJCgnOmlucHV0JywgJGZvcm0pLm5vdCgnOmJ1dHRvbiwgOnN1Ym1pdCwgOnJlc2V0LCA6aGlkZGVuLCA6cmFkaW8sIDpjaGVja2JveCwgW2RhdGEtYWJpZGUtaWdub3JlXScpLnZhbCgnJykucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7XG4gICAgJCgnOmlucHV0OnJhZGlvJywgJGZvcm0pLm5vdCgnW2RhdGEtYWJpZGUtaWdub3JlXScpLnByb3AoJ2NoZWNrZWQnLGZhbHNlKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTtcbiAgICAkKCc6aW5wdXQ6Y2hlY2tib3gnLCAkZm9ybSkubm90KCdbZGF0YS1hYmlkZS1pZ25vcmVdJykucHJvcCgnY2hlY2tlZCcsZmFsc2UpLnJlbW92ZUF0dHIoJ2RhdGEtaW52YWxpZCcpO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGZvcm0gaGFzIGJlZW4gcmVzZXQuXG4gICAgICogQGV2ZW50IEFiaWRlI2Zvcm1yZXNldFxuICAgICAqL1xuICAgICRmb3JtLnRyaWdnZXIoJ2Zvcm1yZXNldC56Zi5hYmlkZScsIFskZm9ybV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIEFiaWRlLlxuICAgKiBSZW1vdmVzIGVycm9yIHN0eWxlcyBhbmQgY2xhc3NlcyBmcm9tIGVsZW1lbnRzLCB3aXRob3V0IHJlc2V0dGluZyB0aGVpciB2YWx1ZXMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLm9mZignLmFiaWRlJylcbiAgICAgIC5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKVxuICAgICAgICAuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcblxuICAgIHRoaXMuJGlucHV0c1xuICAgICAgLm9mZignLmFiaWRlJylcbiAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5yZW1vdmVFcnJvckNsYXNzZXMoJCh0aGlzKSk7XG4gICAgICB9KTtcblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICovXG5BYmlkZS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGV2ZW50IHRvIHZhbGlkYXRlIGlucHV0cy4gQ2hlY2tib3hlcyBhbmQgcmFkaW9zIHZhbGlkYXRlIGltbWVkaWF0ZWx5LlxuICAgKiBSZW1vdmUgb3IgY2hhbmdlIHRoaXMgdmFsdWUgZm9yIG1hbnVhbCB2YWxpZGF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdmaWVsZENoYW5nZSdcbiAgICovXG4gIHZhbGlkYXRlT246ICdmaWVsZENoYW5nZScsXG5cbiAgLyoqXG4gICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gaW5wdXQgbGFiZWxzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdpcy1pbnZhbGlkLWxhYmVsJ1xuICAgKi9cbiAgbGFiZWxFcnJvckNsYXNzOiAnaXMtaW52YWxpZC1sYWJlbCcsXG5cbiAgLyoqXG4gICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gaW5wdXRzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdpcy1pbnZhbGlkLWlucHV0J1xuICAgKi9cbiAgaW5wdXRFcnJvckNsYXNzOiAnaXMtaW52YWxpZC1pbnB1dCcsXG5cbiAgLyoqXG4gICAqIENsYXNzIHNlbGVjdG9yIHRvIHVzZSB0byB0YXJnZXQgRm9ybSBFcnJvcnMgZm9yIHNob3cvaGlkZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnLmZvcm0tZXJyb3InXG4gICAqL1xuICBmb3JtRXJyb3JTZWxlY3RvcjogJy5mb3JtLWVycm9yJyxcblxuICAvKipcbiAgICogQ2xhc3MgYWRkZWQgdG8gRm9ybSBFcnJvcnMgb24gZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ2lzLXZpc2libGUnXG4gICAqL1xuICBmb3JtRXJyb3JDbGFzczogJ2lzLXZpc2libGUnLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSB0byB2YWxpZGF0ZSB0ZXh0IGlucHV0cyBvbiBhbnkgdmFsdWUgY2hhbmdlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBsaXZlVmFsaWRhdGU6IGZhbHNlLFxuXG4gIHBhdHRlcm5zOiB7XG4gICAgYWxwaGEgOiAvXlthLXpBLVpdKyQvLFxuICAgIGFscGhhX251bWVyaWMgOiAvXlthLXpBLVowLTldKyQvLFxuICAgIGludGVnZXIgOiAvXlstK10/XFxkKyQvLFxuICAgIG51bWJlciA6IC9eWy0rXT9cXGQqKD86W1xcLlxcLF1cXGQrKT8kLyxcblxuICAgIC8vIGFtZXgsIHZpc2EsIGRpbmVyc1xuICAgIGNhcmQgOiAvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxkezN9KVxcZHsxMX0pJC8sXG4gICAgY3Z2IDogL14oWzAtOV0pezMsNH0kLyxcblxuICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3N0YXRlcy1vZi10aGUtdHlwZS1hdHRyaWJ1dGUuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzc1xuICAgIGVtYWlsIDogL15bYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrJC8sXG5cbiAgICB1cmwgOiAvXihodHRwcz98ZnRwfGZpbGV8c3NoKTpcXC9cXC8oKCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OikqQCk/KCgoXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pKXwoKChbYS16QS1aXXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2EtekEtWl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4/KSg6XFxkKik/KShcXC8oKChbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKyhcXC8oKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkqKSopPyk/KFxcPygoKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8W1xcdUUwMDAtXFx1RjhGRl18XFwvfFxcPykqKT8oXFwjKCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxcXC98XFw/KSopPyQvLFxuICAgIC8vIGFiYy5kZVxuICAgIGRvbWFpbiA6IC9eKFthLXpBLVowLTldKFthLXpBLVowLTlcXC1dezAsNjF9W2EtekEtWjAtOV0pP1xcLikrW2EtekEtWl17Miw4fSQvLFxuXG4gICAgZGF0ZXRpbWUgOiAvXihbMC0yXVswLTldezN9KVxcLShbMC0xXVswLTldKVxcLShbMC0zXVswLTldKVQoWzAtNV1bMC05XSlcXDooWzAtNV1bMC05XSlcXDooWzAtNV1bMC05XSkoWnwoW1xcLVxcK10oWzAtMV1bMC05XSlcXDowMCkpJC8sXG4gICAgLy8gWVlZWS1NTS1ERFxuICAgIGRhdGUgOiAvKD86MTl8MjApWzAtOV17Mn0tKD86KD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfDFbMC05XXwyWzAtOV0pfCg/Oig/ITAyKSg/OjBbMS05XXwxWzAtMl0pLSg/OjMwKSl8KD86KD86MFsxMzU3OF18MVswMl0pLTMxKSkkLyxcbiAgICAvLyBISDpNTTpTU1xuICAgIHRpbWUgOiAvXigwWzAtOV18MVswLTldfDJbMC0zXSkoOlswLTVdWzAtOV0pezJ9JC8sXG4gICAgZGF0ZUlTTyA6IC9eXFxkezR9W1xcL1xcLV1cXGR7MSwyfVtcXC9cXC1dXFxkezEsMn0kLyxcbiAgICAvLyBNTS9ERC9ZWVlZXG4gICAgbW9udGhfZGF5X3llYXIgOiAvXigwWzEtOV18MVswMTJdKVstIFxcLy5dKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFwvLl1cXGR7NH0kLyxcbiAgICAvLyBERC9NTS9ZWVlZXG4gICAgZGF5X21vbnRoX3llYXIgOiAvXigwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcLy5dKDBbMS05XXwxWzAxMl0pWy0gXFwvLl1cXGR7NH0kLyxcblxuICAgIC8vICNGRkYgb3IgI0ZGRkZGRlxuICAgIGNvbG9yIDogL14jPyhbYS1mQS1GMC05XXs2fXxbYS1mQS1GMC05XXszfSkkL1xuICB9LFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCB2YWxpZGF0aW9uIGZ1bmN0aW9ucyB0byBiZSB1c2VkLiBgZXF1YWxUb2AgYmVpbmcgdGhlIG9ubHkgZGVmYXVsdCBpbmNsdWRlZCBmdW5jdGlvbi5cbiAgICogRnVuY3Rpb25zIHNob3VsZCByZXR1cm4gb25seSBhIGJvb2xlYW4gaWYgdGhlIGlucHV0IGlzIHZhbGlkIG9yIG5vdC4gRnVuY3Rpb25zIGFyZSBnaXZlbiB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czpcbiAgICogZWwgOiBUaGUgalF1ZXJ5IGVsZW1lbnQgdG8gdmFsaWRhdGUuXG4gICAqIHJlcXVpcmVkIDogQm9vbGVhbiB2YWx1ZSBvZiB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIGJlIHByZXNlbnQgb3Igbm90LlxuICAgKiBwYXJlbnQgOiBUaGUgZGlyZWN0IHBhcmVudCBvZiB0aGUgaW5wdXQuXG4gICAqIEBvcHRpb25cbiAgICovXG4gIHZhbGlkYXRvcnM6IHtcbiAgICBlcXVhbFRvOiBmdW5jdGlvbiAoZWwsIHJlcXVpcmVkLCBwYXJlbnQpIHtcbiAgICAgIHJldHVybiAkKGAjJHtlbC5hdHRyKCdkYXRhLWVxdWFsdG8nKX1gKS52YWwoKSA9PT0gZWwudmFsKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihBYmlkZSwgJ0FiaWRlJyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBBY2NvcmRpb24gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmFjY29yZGlvblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqL1xuXG5jbGFzcyBBY2NvcmRpb24ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24uXG4gICAqIEBjbGFzc1xuICAgKiBAZmlyZXMgQWNjb3JkaW9uI2luaXRcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYSBwbGFpbiBvYmplY3Qgd2l0aCBzZXR0aW5ncyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBY2NvcmRpb24uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ0FjY29yZGlvbicpO1xuICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ0FjY29yZGlvbicsIHtcbiAgICAgICdFTlRFUic6ICd0b2dnbGUnLFxuICAgICAgJ1NQQUNFJzogJ3RvZ2dsZScsXG4gICAgICAnQVJST1dfRE9XTic6ICduZXh0JyxcbiAgICAgICdBUlJPV19VUCc6ICdwcmV2aW91cydcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgYWNjb3JkaW9uIGJ5IGFuaW1hdGluZyB0aGUgcHJlc2V0IGFjdGl2ZSBwYW5lKHMpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCdyb2xlJywgJ3RhYmxpc3QnKTtcbiAgICB0aGlzLiR0YWJzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbignbGksIFtkYXRhLWFjY29yZGlvbi1pdGVtXScpO1xuXG4gICAgdGhpcy4kdGFicy5lYWNoKGZ1bmN0aW9uKGlkeCwgZWwpIHtcbiAgICAgIHZhciAkZWwgPSAkKGVsKSxcbiAgICAgICAgICAkY29udGVudCA9ICRlbC5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyksXG4gICAgICAgICAgaWQgPSAkY29udGVudFswXS5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdhY2NvcmRpb24nKSxcbiAgICAgICAgICBsaW5rSWQgPSBlbC5pZCB8fCBgJHtpZH0tbGFiZWxgO1xuXG4gICAgICAkZWwuZmluZCgnYTpmaXJzdCcpLmF0dHIoe1xuICAgICAgICAnYXJpYS1jb250cm9scyc6IGlkLFxuICAgICAgICAncm9sZSc6ICd0YWInLFxuICAgICAgICAnaWQnOiBsaW5rSWQsXG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICAkY29udGVudC5hdHRyKHsncm9sZSc6ICd0YWJwYW5lbCcsICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWQsICdhcmlhLWhpZGRlbic6IHRydWUsICdpZCc6IGlkfSk7XG4gICAgfSk7XG4gICAgdmFyICRpbml0QWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuICAgIGlmKCRpbml0QWN0aXZlLmxlbmd0aCl7XG4gICAgICB0aGlzLmRvd24oJGluaXRBY3RpdmUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIGFjY29yZGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ldmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuJHRhYnMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkZWxlbSA9ICQodGhpcyk7XG4gICAgICB2YXIgJHRhYkNvbnRlbnQgPSAkZWxlbS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XG4gICAgICBpZiAoJHRhYkNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICRlbGVtLmNoaWxkcmVuKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb24ga2V5ZG93bi56Zi5hY2NvcmRpb24nKVxuICAgICAgICAgICAgICAgLm9uKCdjbGljay56Zi5hY2NvcmRpb24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vICQodGhpcykuY2hpbGRyZW4oJ2EnKS5vbignY2xpY2suemYuYWNjb3JkaW9uJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoJGVsZW0uaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSB7XG4gICAgICAgICAgICBpZihfdGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkIHx8ICRlbGVtLnNpYmxpbmdzKCkuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKXtcbiAgICAgICAgICAgICAgX3RoaXMudXAoJHRhYkNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmRvd24oJHRhYkNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkub24oJ2tleWRvd24uemYuYWNjb3JkaW9uJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ0FjY29yZGlvbicsIHtcbiAgICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkdGFiQ29udGVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciAkYSA9ICRlbGVtLm5leHQoKS5maW5kKCdhJykuZm9jdXMoKTtcbiAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kKSB7XG4gICAgICAgICAgICAgICAgJGEudHJpZ2dlcignY2xpY2suemYuYWNjb3JkaW9uJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyICRhID0gJGVsZW0ucHJldigpLmZpbmQoJ2EnKS5mb2N1cygpO1xuICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQpIHtcbiAgICAgICAgICAgICAgICAkYS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgc2VsZWN0ZWQgY29udGVudCBwYW5lJ3Mgb3Blbi9jbG9zZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBqUXVlcnkgb2JqZWN0IG9mIHRoZSBwYW5lIHRvIHRvZ2dsZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICB0b2dnbGUoJHRhcmdldCkge1xuICAgIGlmKCR0YXJnZXQucGFyZW50KCkuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSB7XG4gICAgICBpZih0aGlzLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWQgfHwgJHRhcmdldC5wYXJlbnQoKS5zaWJsaW5ncygpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSl7XG4gICAgICAgIHRoaXMudXAoJHRhcmdldCk7XG4gICAgICB9IGVsc2UgeyByZXR1cm47IH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb3duKCR0YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgYWNjb3JkaW9uIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBBY2NvcmRpb24gcGFuZSB0byBvcGVuLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpcnN0VGltZSAtIGZsYWcgdG8gZGV0ZXJtaW5lIGlmIHJlZmxvdyBzaG91bGQgaGFwcGVuLlxuICAgKiBAZmlyZXMgQWNjb3JkaW9uI2Rvd25cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkb3duKCR0YXJnZXQsIGZpcnN0VGltZSkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kICYmICFmaXJzdFRpbWUpIHtcbiAgICAgIHZhciAkY3VycmVudEFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy5pcy1hY3RpdmUnKS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XG4gICAgICBpZigkY3VycmVudEFjdGl2ZS5sZW5ndGgpe1xuICAgICAgICB0aGlzLnVwKCRjdXJyZW50QWN0aXZlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkdGFyZ2V0XG4gICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSlcbiAgICAgIC5wYXJlbnQoJ1tkYXRhLXRhYi1jb250ZW50XScpXG4gICAgICAuYWRkQmFjaygpXG4gICAgICAucGFyZW50KCkuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXG4gICAgJHRhcmdldC5zbGlkZURvd24odGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsICgpID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgdGFiIGlzIGRvbmUgb3BlbmluZy5cbiAgICAgICAqIEBldmVudCBBY2NvcmRpb24jZG93blxuICAgICAgICovXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Rvd24uemYuYWNjb3JkaW9uJywgWyR0YXJnZXRdKTtcbiAgICB9KTtcblxuICAgICQoYCMkeyR0YXJnZXQuYXR0cignYXJpYS1sYWJlbGxlZGJ5Jyl9YCkuYXR0cih7XG4gICAgICAnYXJpYS1leHBhbmRlZCc6IHRydWUsXG4gICAgICAnYXJpYS1zZWxlY3RlZCc6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBBY2NvcmRpb24gdGFiIHRvIGNsb3NlLlxuICAgKiBAZmlyZXMgQWNjb3JkaW9uI3VwXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgdXAoJHRhcmdldCkge1xuICAgIHZhciAkYXVudHMgPSAkdGFyZ2V0LnBhcmVudCgpLnNpYmxpbmdzKCksXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICB2YXIgY2FuQ2xvc2UgPSB0aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQgPyAkYXVudHMuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpIDogJHRhcmdldC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtYWN0aXZlJyk7XG5cbiAgICBpZighdGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkICYmICFjYW5DbG9zZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgJHRhcmdldCwgZnVuY3Rpb24oKXtcbiAgICAgICR0YXJnZXQuc2xpZGVVcChfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHRhYiBpcyBkb25lIGNvbGxhcHNpbmcgdXAuXG4gICAgICAgICAqIEBldmVudCBBY2NvcmRpb24jdXBcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3VwLnpmLmFjY29yZGlvbicsIFskdGFyZ2V0XSk7XG4gICAgICB9KTtcbiAgICAvLyB9KTtcblxuICAgICR0YXJnZXQuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXG4gICAgJChgIyR7JHRhcmdldC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKX1gKS5hdHRyKHtcbiAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcbiAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBmYWxzZVxuICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uLlxuICAgKiBAZmlyZXMgQWNjb3JkaW9uI2Rlc3Ryb3llZFxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS10YWItY29udGVudF0nKS5zdG9wKHRydWUpLnNsaWRlVXAoMCkuY3NzKCdkaXNwbGF5JywgJycpO1xuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignLnpmLmFjY29yZGlvbicpO1xuXG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG59XG5cbkFjY29yZGlvbi5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYW4gYWNjb3JkaW9uIHBhbmUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMjUwXG4gICAqL1xuICBzbGlkZVNwZWVkOiAyNTAsXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgYWNjb3JkaW9uIHRvIGhhdmUgbXVsdGlwbGUgb3BlbiBwYW5lcy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgbXVsdGlFeHBhbmQ6IGZhbHNlLFxuICAvKipcbiAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBjbG9zZSBhbGwgcGFuZXMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGFsbG93QWxsQ2xvc2VkOiBmYWxzZVxufTtcblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKEFjY29yZGlvbiwgJ0FjY29yZGlvbicpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogQWNjb3JkaW9uTWVudSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWNjb3JkaW9uTWVudVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxuICovXG5cbmNsYXNzIEFjY29yZGlvbk1lbnUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24gbWVudS5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2luaXRcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24gbWVudS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBY2NvcmRpb25NZW51LmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICBGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnYWNjb3JkaW9uJyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdBY2NvcmRpb25NZW51Jyk7XG4gICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignQWNjb3JkaW9uTWVudScsIHtcbiAgICAgICdFTlRFUic6ICd0b2dnbGUnLFxuICAgICAgJ1NQQUNFJzogJ3RvZ2dsZScsXG4gICAgICAnQVJST1dfUklHSFQnOiAnb3BlbicsXG4gICAgICAnQVJST1dfVVAnOiAndXAnLFxuICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXG4gICAgICAnQVJST1dfTEVGVCc6ICdjbG9zZScsXG4gICAgICAnRVNDQVBFJzogJ2Nsb3NlQWxsJyxcbiAgICAgICdUQUInOiAnZG93bicsXG4gICAgICAnU0hJRlRfVEFCJzogJ3VwJ1xuICAgIH0pO1xuICB9XG5cblxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgYWNjb3JkaW9uIG1lbnUgYnkgaGlkaW5nIGFsbCBuZXN0ZWQgbWVudXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykubm90KCcuaXMtYWN0aXZlJykuc2xpZGVVcCgwKTsvLy5maW5kKCdhJykuY3NzKCdwYWRkaW5nLWxlZnQnLCAnMXJlbScpO1xuICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAncm9sZSc6ICd0YWJsaXN0JyxcbiAgICAgICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IHRoaXMub3B0aW9ucy5tdWx0aU9wZW5cbiAgICB9KTtcblxuICAgIHRoaXMuJG1lbnVMaW5rcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudCcpO1xuICAgIHRoaXMuJG1lbnVMaW5rcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgbGlua0lkID0gdGhpcy5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdhY2MtbWVudS1saW5rJyksXG4gICAgICAgICAgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICRzdWIgPSAkZWxlbS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKSxcbiAgICAgICAgICBzdWJJZCA9ICRzdWJbMF0uaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnYWNjLW1lbnUnKSxcbiAgICAgICAgICBpc0FjdGl2ZSA9ICRzdWIuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgJGVsZW0uYXR0cih7XG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogc3ViSWQsXG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogaXNBY3RpdmUsXG4gICAgICAgICdyb2xlJzogJ3RhYicsXG4gICAgICAgICdpZCc6IGxpbmtJZFxuICAgICAgfSk7XG4gICAgICAkc3ViLmF0dHIoe1xuICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkLFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiAhaXNBY3RpdmUsXG4gICAgICAgICdyb2xlJzogJ3RhYnBhbmVsJyxcbiAgICAgICAgJ2lkJzogc3ViSWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBpbml0UGFuZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKTtcbiAgICBpZihpbml0UGFuZXMubGVuZ3RoKXtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpbml0UGFuZXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICBfdGhpcy5kb3duKCQodGhpcykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgbWVudS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ldmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyICRzdWJtZW51ID0gJCh0aGlzKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcblxuICAgICAgaWYgKCRzdWJtZW51Lmxlbmd0aCkge1xuICAgICAgICAkKHRoaXMpLmNoaWxkcmVuKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25NZW51Jykub24oJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMudG9nZ2xlKCRzdWJtZW51KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkub24oJ2tleWRvd24uemYuYWNjb3JkaW9ubWVudScsIGZ1bmN0aW9uKGUpe1xuICAgICAgdmFyICRlbGVtZW50ID0gJCh0aGlzKSxcbiAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXG4gICAgICAgICAgJHByZXZFbGVtZW50LFxuICAgICAgICAgICRuZXh0RWxlbWVudCxcbiAgICAgICAgICAkdGFyZ2V0ID0gJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7XG5cbiAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaWYgKCQodGhpcykuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWF4KDAsIGktMSkpLmZpbmQoJ2EnKS5maXJzdCgpO1xuICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1pbihpKzEsICRlbGVtZW50cy5sZW5ndGgtMSkpLmZpbmQoJ2EnKS5maXJzdCgpO1xuXG4gICAgICAgICAgaWYgKCQodGhpcykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHsgLy8gaGFzIG9wZW4gc3ViIG1lbnVcbiAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50LmZpbmQoJ2xpOmZpcnN0LWNoaWxkJykuZmluZCgnYScpLmZpcnN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCc6Zmlyc3QtY2hpbGQnKSkgeyAvLyBpcyBmaXJzdCBlbGVtZW50IG9mIHN1YiBtZW51XG4gICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuZmluZCgnYScpLmZpcnN0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICgkcHJldkVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHsgLy8gaWYgcHJldmlvdXMgZWxlbWVudCBoYXMgb3BlbiBzdWIgbWVudVxuICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJHByZXZFbGVtZW50LmZpbmQoJ2xpOmxhc3QtY2hpbGQnKS5maW5kKCdhJykuZmlyc3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCQodGhpcykuaXMoJzpsYXN0LWNoaWxkJykpIHsgLy8gaXMgbGFzdCBlbGVtZW50IG9mIHN1YiBtZW51XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkubmV4dCgnbGknKS5maW5kKCdhJykuZmlyc3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ0FjY29yZGlvbk1lbnUnLCB7XG4gICAgICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICgkdGFyZ2V0LmlzKCc6aGlkZGVuJykpIHtcbiAgICAgICAgICAgIF90aGlzLmRvd24oJHRhcmdldCk7XG4gICAgICAgICAgICAkdGFyZ2V0LmZpbmQoJ2xpJykuZmlyc3QoKS5maW5kKCdhJykuZmlyc3QoKS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICgkdGFyZ2V0Lmxlbmd0aCAmJiAhJHRhcmdldC5pcygnOmhpZGRlbicpKSB7IC8vIGNsb3NlIGFjdGl2ZSBzdWIgb2YgdGhpcyBpdGVtXG4gICAgICAgICAgICBfdGhpcy51cCgkdGFyZ2V0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHsgLy8gY2xvc2UgY3VycmVudGx5IG9wZW4gc3ViXG4gICAgICAgICAgICBfdGhpcy51cCgkZWxlbWVudC5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykpO1xuICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHByZXZFbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgLTEpLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRuZXh0RWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKS5mb2N1cygpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICgkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbG9zZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMuaGlkZUFsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbihwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTsvLy5hdHRyKCd0YWJpbmRleCcsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBhbGwgcGFuZXMgb2YgdGhlIG1lbnUuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgaGlkZUFsbCgpIHtcbiAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykuc2xpZGVVcCh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgb3Blbi9jbG9zZSBzdGF0ZSBvZiBhIHN1Ym1lbnUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIHRoZSBzdWJtZW51IHRvIHRvZ2dsZVxuICAgKi9cbiAgdG9nZ2xlKCR0YXJnZXQpe1xuICAgIGlmKCEkdGFyZ2V0LmlzKCc6YW5pbWF0ZWQnKSkge1xuICAgICAgaWYgKCEkdGFyZ2V0LmlzKCc6aGlkZGVuJykpIHtcbiAgICAgICAgdGhpcy51cCgkdGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmRvd24oJHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBzdWItbWVudSBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBTdWItbWVudSB0byBvcGVuLlxuICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSNkb3duXG4gICAqL1xuICBkb3duKCR0YXJnZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYoIXRoaXMub3B0aW9ucy5tdWx0aU9wZW4pIHtcbiAgICAgIHRoaXMudXAodGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykubm90KCR0YXJnZXQucGFyZW50c1VudGlsKHRoaXMuJGVsZW1lbnQpLmFkZCgkdGFyZ2V0KSkpO1xuICAgIH1cblxuICAgICR0YXJnZXQuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoeydhcmlhLWhpZGRlbic6IGZhbHNlfSlcbiAgICAgIC5wYXJlbnQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKS5hdHRyKHsnYXJpYS1leHBhbmRlZCc6IHRydWV9KTtcblxuICAgICAgLy9Gb3VuZGF0aW9uLk1vdmUodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsICR0YXJnZXQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkdGFyZ2V0LnNsaWRlRG93bihfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGRvbmUgb3BlbmluZy5cbiAgICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSNkb3duXG4gICAgICAgICAgICovXG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignZG93bi56Zi5hY2NvcmRpb25NZW51JywgWyR0YXJnZXRdKTtcbiAgICAgICAgfSk7XG4gICAgICAvL30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuIEFsbCBzdWItbWVudXMgaW5zaWRlIHRoZSB0YXJnZXQgd2lsbCBiZSBjbG9zZWQgYXMgd2VsbC5cbiAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBTdWItbWVudSB0byBjbG9zZS5cbiAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjdXBcbiAgICovXG4gIHVwKCR0YXJnZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCAkdGFyZ2V0LCBmdW5jdGlvbigpe1xuICAgICAgJHRhcmdldC5zbGlkZVVwKF90aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBkb25lIGNvbGxhcHNpbmcgdXAuXG4gICAgICAgICAqIEBldmVudCBBY2NvcmRpb25NZW51I3VwXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cC56Zi5hY2NvcmRpb25NZW51JywgWyR0YXJnZXRdKTtcbiAgICAgIH0pO1xuICAgIC8vfSk7XG5cbiAgICB2YXIgJG1lbnVzID0gJHRhcmdldC5maW5kKCdbZGF0YS1zdWJtZW51XScpLnNsaWRlVXAoMCkuYWRkQmFjaygpLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG5cbiAgICAkbWVudXMucGFyZW50KCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50JykuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhY2NvcmRpb24gbWVudS5cbiAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjZGVzdHJveWVkXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKS5zbGlkZURvd24oMCkuY3NzKCdkaXNwbGF5JywgJycpO1xuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uTWVudScpO1xuXG4gICAgRm91bmRhdGlvbi5OZXN0LkJ1cm4odGhpcy4kZWxlbWVudCwgJ2FjY29yZGlvbicpO1xuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5BY2NvcmRpb25NZW51LmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogQW1vdW50IG9mIHRpbWUgdG8gYW5pbWF0ZSB0aGUgb3BlbmluZyBvZiBhIHN1Ym1lbnUgaW4gbXMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMjUwXG4gICAqL1xuICBzbGlkZVNwZWVkOiAyNTAsXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgbWVudSB0byBoYXZlIG11bHRpcGxlIG9wZW4gcGFuZXMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgbXVsdGlPcGVuOiB0cnVlXG59O1xuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oQWNjb3JkaW9uTWVudSwgJ0FjY29yZGlvbk1lbnUnKTtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIERyaWxsZG93biBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJpbGxkb3duXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5uZXN0XG4gKi9cblxuY2xhc3MgRHJpbGxkb3duIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcmlsbGRvd24gbWVudS5cbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRHJpbGxkb3duLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICBGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdEcmlsbGRvd24nKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdEcmlsbGRvd24nLCB7XG4gICAgICAnRU5URVInOiAnb3BlbicsXG4gICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXG4gICAgICAnQVJST1dfVVAnOiAndXAnLFxuICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXG4gICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cycsXG4gICAgICAnRVNDQVBFJzogJ2Nsb3NlJyxcbiAgICAgICdUQUInOiAnZG93bicsXG4gICAgICAnU0hJRlRfVEFCJzogJ3VwJ1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBkcmlsbGRvd24gYnkgY3JlYXRpbmcgalF1ZXJ5IGNvbGxlY3Rpb25zIG9mIGVsZW1lbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB0aGlzLiRzdWJtZW51QW5jaG9ycyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGkuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50JykuY2hpbGRyZW4oJ2EnKTtcbiAgICB0aGlzLiRzdWJtZW51cyA9IHRoaXMuJHN1Ym1lbnVBbmNob3JzLnBhcmVudCgnbGknKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcbiAgICB0aGlzLiRtZW51SXRlbXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpJykubm90KCcuanMtZHJpbGxkb3duLWJhY2snKS5hdHRyKCdyb2xlJywgJ21lbnVpdGVtJykuZmluZCgnYScpO1xuXG4gICAgdGhpcy5fcHJlcGFyZU1lbnUoKTtcblxuICAgIHRoaXMuX2tleWJvYXJkRXZlbnRzKCk7XG4gIH1cblxuICAvKipcbiAgICogcHJlcGFyZXMgZHJpbGxkb3duIG1lbnUgYnkgc2V0dGluZyBhdHRyaWJ1dGVzIHRvIGxpbmtzIGFuZCBlbGVtZW50c1xuICAgKiBzZXRzIGEgbWluIGhlaWdodCB0byBwcmV2ZW50IGNvbnRlbnQganVtcGluZ1xuICAgKiB3cmFwcyB0aGUgZWxlbWVudCBpZiBub3QgYWxyZWFkeSB3cmFwcGVkXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgX3ByZXBhcmVNZW51KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gaWYoIXRoaXMub3B0aW9ucy5ob2xkT3Blbil7XG4gICAgLy8gICB0aGlzLl9tZW51TGlua0V2ZW50cygpO1xuICAgIC8vIH1cbiAgICB0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgJGxpbmsgPSAkKHRoaXMpO1xuICAgICAgdmFyICRzdWIgPSAkbGluay5wYXJlbnQoKTtcbiAgICAgIGlmKF90aGlzLm9wdGlvbnMucGFyZW50TGluayl7XG4gICAgICAgICRsaW5rLmNsb25lKCkucHJlcGVuZFRvKCRzdWIuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykpLndyYXAoJzxsaSBjbGFzcz1cImlzLXN1Ym1lbnUtcGFyZW50LWl0ZW0gaXMtc3VibWVudS1pdGVtIGlzLWRyaWxsZG93bi1zdWJtZW51LWl0ZW1cIiByb2xlPVwibWVudS1pdGVtXCI+PC9saT4nKTtcbiAgICAgIH1cbiAgICAgICRsaW5rLmRhdGEoJ3NhdmVkSHJlZicsICRsaW5rLmF0dHIoJ2hyZWYnKSkucmVtb3ZlQXR0cignaHJlZicpO1xuICAgICAgJGxpbmsuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJylcbiAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgICAgICAgJ3RhYmluZGV4JzogMCxcbiAgICAgICAgICAgICdyb2xlJzogJ21lbnUnXG4gICAgICAgICAgfSk7XG4gICAgICBfdGhpcy5fZXZlbnRzKCRsaW5rKTtcbiAgICB9KTtcbiAgICB0aGlzLiRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgJG1lbnUgPSAkKHRoaXMpLFxuICAgICAgICAgICRiYWNrID0gJG1lbnUuZmluZCgnLmpzLWRyaWxsZG93bi1iYWNrJyk7XG4gICAgICBpZighJGJhY2subGVuZ3RoKXtcbiAgICAgICAgJG1lbnUucHJlcGVuZChfdGhpcy5vcHRpb25zLmJhY2tCdXR0b24pO1xuICAgICAgfVxuICAgICAgX3RoaXMuX2JhY2soJG1lbnUpO1xuICAgIH0pO1xuICAgIGlmKCF0aGlzLiRlbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKCdpcy1kcmlsbGRvd24nKSl7XG4gICAgICB0aGlzLiR3cmFwcGVyID0gJCh0aGlzLm9wdGlvbnMud3JhcHBlcikuYWRkQ2xhc3MoJ2lzLWRyaWxsZG93bicpO1xuICAgICAgdGhpcy4kd3JhcHBlciA9IHRoaXMuJGVsZW1lbnQud3JhcCh0aGlzLiR3cmFwcGVyKS5wYXJlbnQoKS5jc3ModGhpcy5fZ2V0TWF4RGltcygpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBldmVudCBoYW5kbGVycyB0byBlbGVtZW50cyBpbiB0aGUgbWVudS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IG1lbnUgaXRlbSB0byBhZGQgaGFuZGxlcnMgdG8uXG4gICAqL1xuICBfZXZlbnRzKCRlbGVtKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICRlbGVtLm9mZignY2xpY2suemYuZHJpbGxkb3duJylcbiAgICAub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uKGUpe1xuICAgICAgaWYoJChlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsICdsaScpLmhhc0NsYXNzKCdpcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQnKSl7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldC5maXJzdEVsZW1lbnRDaGlsZCl7XG4gICAgICAvLyAgIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIH1cbiAgICAgIF90aGlzLl9zaG93KCRlbGVtLnBhcmVudCgnbGknKSk7XG5cbiAgICAgIGlmKF90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKXtcbiAgICAgICAgdmFyICRib2R5ID0gJCgnYm9keScpO1xuICAgICAgICAkYm9keS5vZmYoJy56Zi5kcmlsbGRvd24nKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCAkLmNvbnRhaW5zKF90aGlzLiRlbGVtZW50WzBdLCBlLnRhcmdldCkpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIF90aGlzLl9oaWRlQWxsKCk7XG4gICAgICAgICAgJGJvZHkub2ZmKCcuemYuZHJpbGxkb3duJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMga2V5ZG93biBldmVudCBsaXN0ZW5lciB0byBgbGlgJ3MgaW4gdGhlIG1lbnUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfa2V5Ym9hcmRFdmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuJG1lbnVJdGVtcy5hZGQodGhpcy4kZWxlbWVudC5maW5kKCcuanMtZHJpbGxkb3duLWJhY2sgPiBhJykpLm9uKCdrZXlkb3duLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uKGUpe1xuXG4gICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpLFxuICAgICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJykuY2hpbGRyZW4oJ2EnKSxcbiAgICAgICAgICAkcHJldkVsZW1lbnQsXG4gICAgICAgICAgJG5leHRFbGVtZW50O1xuXG4gICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpLTEpKTtcbiAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSsxLCAkZWxlbWVudHMubGVuZ3RoLTEpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnRHJpbGxkb3duJywge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoJGVsZW1lbnQuaXMoX3RoaXMuJHN1Ym1lbnVBbmNob3JzKSkge1xuICAgICAgICAgICAgX3RoaXMuX3Nob3coJGVsZW1lbnQucGFyZW50KCdsaScpKTtcbiAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLmZpbmQoJ3VsIGxpIGEnKS5maWx0ZXIoX3RoaXMuJG1lbnVJdGVtcykuZmlyc3QoKS5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpKTtcbiAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW1lbnQpLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ2EnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRwcmV2RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkbmV4dEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLl9iYWNrKCk7XG4gICAgICAgICAgLy9fdGhpcy4kbWVudUl0ZW1zLmZpcnN0KCkuZm9jdXMoKTsgLy8gZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxuICAgICAgICB9LFxuICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoISRlbGVtZW50LmlzKF90aGlzLiRtZW51SXRlbXMpKSB7IC8vIG5vdCBtZW51IGl0ZW0gbWVhbnMgYmFjayBidXR0b25cbiAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykpO1xuICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKS5jaGlsZHJlbignYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCRlbGVtZW50LmlzKF90aGlzLiRzdWJtZW51QW5jaG9ycykpIHtcbiAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50LnBhcmVudCgnbGknKSk7XG4gICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbWVudCksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5maW5kKCd1bCBsaSBhJykuZmlsdGVyKF90aGlzLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24ocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7IC8vIGVuZCBrZXlib2FyZEFjY2Vzc1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBhbGwgb3BlbiBlbGVtZW50cywgYW5kIHJldHVybnMgdG8gcm9vdCBtZW51LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIERyaWxsZG93biNjbG9zZWRcbiAgICovXG4gIF9oaWRlQWxsKCkge1xuICAgIHZhciAkZWxlbSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWFjdGl2ZScpLmFkZENsYXNzKCdpcy1jbG9zaW5nJyk7XG4gICAgJGVsZW0ub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbSksIGZ1bmN0aW9uKGUpe1xuICAgICAgJGVsZW0ucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nJyk7XG4gICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGZ1bGx5IGNsb3NlZC5cbiAgICAgICAgICogQGV2ZW50IERyaWxsZG93biNjbG9zZWRcbiAgICAgICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYuZHJpbGxkb3duJyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lciBmb3IgZWFjaCBgYmFja2AgYnV0dG9uLCBhbmQgY2xvc2VzIG9wZW4gbWVudXMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAZmlyZXMgRHJpbGxkb3duI2JhY2tcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGN1cnJlbnQgc3ViLW1lbnUgdG8gYWRkIGBiYWNrYCBldmVudC5cbiAgICovXG4gIF9iYWNrKCRlbGVtKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAkZWxlbS5vZmYoJ2NsaWNrLnpmLmRyaWxsZG93bicpO1xuICAgICRlbGVtLmNoaWxkcmVuKCcuanMtZHJpbGxkb3duLWJhY2snKVxuICAgICAgLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbihlKXtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ21vdXNldXAgb24gYmFjaycpO1xuICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVyIHRvIG1lbnUgaXRlbXMgdy9vIHN1Ym1lbnVzIHRvIGNsb3NlIG9wZW4gbWVudXMgb24gY2xpY2suXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21lbnVMaW5rRXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy4kbWVudUl0ZW1zLm5vdCgnLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpXG4gICAgICAgIC5vZmYoJ2NsaWNrLnpmLmRyaWxsZG93bicpXG4gICAgICAgIC5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgLy8gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBfdGhpcy5faGlkZUFsbCgpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgYSBzdWJtZW51LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIERyaWxsZG93biNvcGVuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gb3BlbiwgaS5lLiB0aGUgYGxpYCB0YWcuXG4gICAqL1xuICBfc2hvdygkZWxlbSkge1xuICAgICRlbGVtLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBzdWJtZW51IGhhcyBvcGVuZWQuXG4gICAgICogQGV2ZW50IERyaWxsZG93biNvcGVuXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvcGVuLnpmLmRyaWxsZG93bicsIFskZWxlbV0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlcyBhIHN1Ym1lbnVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBEcmlsbGRvd24jaGlkZVxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBzdWItbWVudSB0byBoaWRlLCBpLmUuIHRoZSBgdWxgIHRhZy5cbiAgICovXG4gIF9oaWRlKCRlbGVtKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAkZWxlbS5hZGRDbGFzcygnaXMtY2xvc2luZycpXG4gICAgICAgICAub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbSksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZycpO1xuICAgICAgICAgICAkZWxlbS5ibHVyKCk7XG4gICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBzdWJtZW51IGhhcyBjbG9zZWQuXG4gICAgICogQGV2ZW50IERyaWxsZG93biNoaWRlXG4gICAgICovXG4gICAgJGVsZW0udHJpZ2dlcignaGlkZS56Zi5kcmlsbGRvd24nLCBbJGVsZW1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBuZXN0ZWQgbWVudXMgdG8gY2FsY3VsYXRlIHRoZSBtaW4taGVpZ2h0LCBhbmQgbWF4LXdpZHRoIGZvciB0aGUgbWVudS5cbiAgICogUHJldmVudHMgY29udGVudCBqdW1waW5nLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRNYXhEaW1zKCkge1xuICAgIHZhciBtYXggPSAwLCByZXN1bHQgPSB7fTtcbiAgICB0aGlzLiRzdWJtZW51cy5hZGQodGhpcy4kZWxlbWVudCkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyIG51bU9mRWxlbXMgPSAkKHRoaXMpLmNoaWxkcmVuKCdsaScpLmxlbmd0aDtcbiAgICAgIG1heCA9IG51bU9mRWxlbXMgPiBtYXggPyBudW1PZkVsZW1zIDogbWF4O1xuICAgIH0pO1xuXG4gICAgcmVzdWx0WydtaW4taGVpZ2h0J10gPSBgJHttYXggKiB0aGlzLiRtZW51SXRlbXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0fXB4YDtcbiAgICByZXN1bHRbJ21heC13aWR0aCddID0gYCR7dGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aH1weGA7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBEcmlsbGRvd24gTWVudVxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5faGlkZUFsbCgpO1xuICAgIEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsICdkcmlsbGRvd24nKTtcbiAgICB0aGlzLiRlbGVtZW50LnVud3JhcCgpXG4gICAgICAgICAgICAgICAgIC5maW5kKCcuanMtZHJpbGxkb3duLWJhY2ssIC5pcy1zdWJtZW51LXBhcmVudC1pdGVtJykucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgLmVuZCgpLmZpbmQoJy5pcy1hY3RpdmUsIC5pcy1jbG9zaW5nLCAuaXMtZHJpbGxkb3duLXN1Ym1lbnUnKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcgaXMtZHJpbGxkb3duLXN1Ym1lbnUnKVxuICAgICAgICAgICAgICAgICAuZW5kKCkuZmluZCgnW2RhdGEtc3VibWVudV0nKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiB0YWJpbmRleCByb2xlJyk7XG4gICAgdGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykub2ZmKCcuemYuZHJpbGxkb3duJyk7XG4gICAgfSk7XG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCdhJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyICRsaW5rID0gJCh0aGlzKTtcbiAgICAgIGlmKCRsaW5rLmRhdGEoJ3NhdmVkSHJlZicpKXtcbiAgICAgICAgJGxpbmsuYXR0cignaHJlZicsICRsaW5rLmRhdGEoJ3NhdmVkSHJlZicpKS5yZW1vdmVEYXRhKCdzYXZlZEhyZWYnKTtcbiAgICAgIH1lbHNleyByZXR1cm47IH1cbiAgICB9KTtcbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH07XG59XG5cbkRyaWxsZG93bi5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIE1hcmt1cCB1c2VkIGZvciBKUyBnZW5lcmF0ZWQgYmFjayBidXR0b24uIFByZXBlbmRlZCB0byBzdWJtZW51IGxpc3RzIGFuZCBkZWxldGVkIG9uIGBkZXN0cm95YCBtZXRob2QsICdqcy1kcmlsbGRvd24tYmFjaycgY2xhc3MgcmVxdWlyZWQuIFJlbW92ZSB0aGUgYmFja3NsYXNoIChgXFxgKSBpZiBjb3B5IGFuZCBwYXN0aW5nLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICc8XFxsaT48XFxhPkJhY2s8XFwvYT48XFwvbGk+J1xuICAgKi9cbiAgYmFja0J1dHRvbjogJzxsaSBjbGFzcz1cImpzLWRyaWxsZG93bi1iYWNrXCI+PGEgdGFiaW5kZXg9XCIwXCI+QmFjazwvYT48L2xpPicsXG4gIC8qKlxuICAgKiBNYXJrdXAgdXNlZCB0byB3cmFwIGRyaWxsZG93biBtZW51LiBVc2UgYSBjbGFzcyBuYW1lIGZvciBpbmRlcGVuZGVudCBzdHlsaW5nOyB0aGUgSlMgYXBwbGllZCBjbGFzczogYGlzLWRyaWxsZG93bmAgaXMgcmVxdWlyZWQuIFJlbW92ZSB0aGUgYmFja3NsYXNoIChgXFxgKSBpZiBjb3B5IGFuZCBwYXN0aW5nLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICc8XFxkaXYgY2xhc3M9XCJpcy1kcmlsbGRvd25cIj48XFwvZGl2PidcbiAgICovXG4gIHdyYXBwZXI6ICc8ZGl2PjwvZGl2PicsXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBwYXJlbnQgbGluayB0byB0aGUgc3VibWVudS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgcGFyZW50TGluazogZmFsc2UsXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgbWVudSB0byByZXR1cm4gdG8gcm9vdCBsaXN0IG9uIGJvZHkgY2xpY2suXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGNsb3NlT25DbGljazogZmFsc2VcbiAgLy8gaG9sZE9wZW46IGZhbHNlXG59O1xuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oRHJpbGxkb3duLCAnRHJpbGxkb3duJyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBEcm9wZG93biBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJvcGRvd25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKi9cblxuY2xhc3MgRHJvcGRvd24ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIGRyb3Bkb3duLlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhIGRyb3Bkb3duLlxuICAgKiAgICAgICAgT2JqZWN0IHNob3VsZCBiZSBvZiB0aGUgZHJvcGRvd24gcGFuZWwsIHJhdGhlciB0aGFuIGl0cyBhbmNob3IuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRHJvcGRvd24uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdEcm9wZG93bicpO1xuICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ0Ryb3Bkb3duJywge1xuICAgICAgJ0VOVEVSJzogJ29wZW4nLFxuICAgICAgJ1NQQUNFJzogJ29wZW4nLFxuICAgICAgJ0VTQ0FQRSc6ICdjbG9zZScsXG4gICAgICAnVEFCJzogJ3RhYl9mb3J3YXJkJyxcbiAgICAgICdTSElGVF9UQUInOiAndGFiX2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4gYnkgc2V0dGluZy9jaGVja2luZyBvcHRpb25zIGFuZCBhdHRyaWJ1dGVzLCBhZGRpbmcgaGVscGVyIHZhcmlhYmxlcywgYW5kIHNhdmluZyB0aGUgYW5jaG9yLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciAkaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XG5cbiAgICB0aGlzLiRhbmNob3IgPSAkKGBbZGF0YS10b2dnbGU9XCIkeyRpZH1cIl1gKSB8fCAkKGBbZGF0YS1vcGVuPVwiJHskaWR9XCJdYCk7XG4gICAgdGhpcy4kYW5jaG9yLmF0dHIoe1xuICAgICAgJ2FyaWEtY29udHJvbHMnOiAkaWQsXG4gICAgICAnZGF0YS1pcy1mb2N1cyc6IGZhbHNlLFxuICAgICAgJ2RhdGEteWV0aS1ib3gnOiAkaWQsXG4gICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlXG5cbiAgICB9KTtcblxuICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzID0gdGhpcy5nZXRQb3NpdGlvbkNsYXNzKCk7XG4gICAgdGhpcy5jb3VudGVyID0gNDtcbiAgICB0aGlzLnVzZWRQb3NpdGlvbnMgPSBbXTtcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnLFxuICAgICAgJ2RhdGEteWV0aS1ib3gnOiAkaWQsXG4gICAgICAnZGF0YS1yZXNpemUnOiAkaWQsXG4gICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogdGhpcy4kYW5jaG9yWzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ2RkLWFuY2hvcicpXG4gICAgfSk7XG4gICAgdGhpcy5fZXZlbnRzKCk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBjdXJyZW50IG9yaWVudGF0aW9uIG9mIGRyb3Bkb3duIHBhbmUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwb3NpdGlvbiAtIHN0cmluZyB2YWx1ZSBvZiBhIHBvc2l0aW9uIGNsYXNzLlxuICAgKi9cbiAgZ2V0UG9zaXRpb25DbGFzcygpIHtcbiAgICB2YXIgdmVydGljYWxQb3NpdGlvbiA9IHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tKS9nKTtcbiAgICAgICAgdmVydGljYWxQb3NpdGlvbiA9IHZlcnRpY2FsUG9zaXRpb24gPyB2ZXJ0aWNhbFBvc2l0aW9uWzBdIDogJyc7XG4gICAgdmFyIGhvcml6b250YWxQb3NpdGlvbiA9IC9mbG9hdC0oXFxTKylcXHMvLmV4ZWModGhpcy4kYW5jaG9yWzBdLmNsYXNzTmFtZSk7XG4gICAgICAgIGhvcml6b250YWxQb3NpdGlvbiA9IGhvcml6b250YWxQb3NpdGlvbiA/IGhvcml6b250YWxQb3NpdGlvblsxXSA6ICcnO1xuICAgIHZhciBwb3NpdGlvbiA9IGhvcml6b250YWxQb3NpdGlvbiA/IGhvcml6b250YWxQb3NpdGlvbiArICcgJyArIHZlcnRpY2FsUG9zaXRpb24gOiB2ZXJ0aWNhbFBvc2l0aW9uO1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGp1c3RzIHRoZSBkcm9wZG93biBwYW5lcyBvcmllbnRhdGlvbiBieSBhZGRpbmcvcmVtb3ZpbmcgcG9zaXRpb25pbmcgY2xhc3Nlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbiAtIHBvc2l0aW9uIGNsYXNzIHRvIHJlbW92ZS5cbiAgICovXG4gIF9yZXBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgdGhpcy51c2VkUG9zaXRpb25zLnB1c2gocG9zaXRpb24gPyBwb3NpdGlvbiA6ICdib3R0b20nKTtcbiAgICAvL2RlZmF1bHQsIHRyeSBzd2l0Y2hpbmcgdG8gb3Bwb3NpdGUgc2lkZVxuICAgIGlmKCFwb3NpdGlvbiAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygndG9wJyk7XG4gICAgfWVsc2UgaWYocG9zaXRpb24gPT09ICd0b3AnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJykgPCAwKSl7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcbiAgICB9ZWxzZSBpZihwb3NpdGlvbiA9PT0gJ2xlZnQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA8IDApKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pXG4gICAgICAgICAgLmFkZENsYXNzKCdyaWdodCcpO1xuICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAncmlnaHQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbilcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xlZnQnKTtcbiAgICB9XG5cbiAgICAvL2lmIGRlZmF1bHQgY2hhbmdlIGRpZG4ndCB3b3JrLCB0cnkgYm90dG9tIG9yIGxlZnQgZmlyc3RcbiAgICBlbHNlIGlmKCFwb3NpdGlvbiAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpID4gLTEpICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnbGVmdCcpO1xuICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAndG9wJyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpID4gLTEpICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbilcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xlZnQnKTtcbiAgICB9ZWxzZSBpZihwb3NpdGlvbiA9PT0gJ2xlZnQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA+IC0xKSAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgfWVsc2UgaWYocG9zaXRpb24gPT09ICdyaWdodCcgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPiAtMSkgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA8IDApKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgIH1cbiAgICAvL2lmIG5vdGhpbmcgY2xlYXJlZCwgc2V0IHRvIGJvdHRvbVxuICAgIGVsc2V7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc0NoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuY291bnRlci0tO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgZHJvcGRvd24gcGFuZSwgY2hlY2tzIGZvciBjb2xsaXNpb25zLlxuICAgKiBSZWN1cnNpdmVseSBjYWxscyBpdHNlbGYgaWYgYSBjb2xsaXNpb24gaXMgZGV0ZWN0ZWQsIHdpdGggYSBuZXcgcG9zaXRpb24gY2xhc3MuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFBvc2l0aW9uKCkge1xuICAgIGlmKHRoaXMuJGFuY2hvci5hdHRyKCdhcmlhLWV4cGFuZGVkJykgPT09ICdmYWxzZScpeyByZXR1cm4gZmFsc2U7IH1cbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uQ2xhc3MoKSxcbiAgICAgICAgJGVsZURpbXMgPSBGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGVsZW1lbnQpLFxuICAgICAgICAkYW5jaG9yRGltcyA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kYW5jaG9yKSxcbiAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICBkaXJlY3Rpb24gPSAocG9zaXRpb24gPT09ICdsZWZ0JyA/ICdsZWZ0JyA6ICgocG9zaXRpb24gPT09ICdyaWdodCcpID8gJ2xlZnQnIDogJ3RvcCcpKSxcbiAgICAgICAgcGFyYW0gPSAoZGlyZWN0aW9uID09PSAndG9wJykgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsXG4gICAgICAgIG9mZnNldCA9IChwYXJhbSA9PT0gJ2hlaWdodCcpID8gdGhpcy5vcHRpb25zLnZPZmZzZXQgOiB0aGlzLm9wdGlvbnMuaE9mZnNldDtcblxuXG5cbiAgICBpZigoJGVsZURpbXMud2lkdGggPj0gJGVsZURpbXMud2luZG93RGltcy53aWR0aCkgfHwgKCF0aGlzLmNvdW50ZXIgJiYgIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy4kZWxlbWVudCkpKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCwgdGhpcy4kYW5jaG9yLCAnY2VudGVyIGJvdHRvbScsIHRoaXMub3B0aW9ucy52T2Zmc2V0LCB0aGlzLm9wdGlvbnMuaE9mZnNldCwgdHJ1ZSkpLmNzcyh7XG4gICAgICAgICd3aWR0aCc6ICRlbGVEaW1zLndpbmRvd0RpbXMud2lkdGggLSAodGhpcy5vcHRpb25zLmhPZmZzZXQgKiAyKSxcbiAgICAgICAgJ2hlaWdodCc6ICdhdXRvJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNsYXNzQ2hhbmdlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLiRlbGVtZW50LCB0aGlzLiRhbmNob3IsIHBvc2l0aW9uLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQpKTtcblxuICAgIHdoaWxlKCFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMuJGVsZW1lbnQsIGZhbHNlLCB0cnVlKSAmJiB0aGlzLmNvdW50ZXIpe1xuICAgICAgdGhpcy5fcmVwb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgZWxlbWVudCB1dGlsaXppbmcgdGhlIHRyaWdnZXJzIHV0aWxpdHkgbGlicmFyeS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAnb3Blbi56Zi50cmlnZ2VyJzogdGhpcy5vcGVuLmJpbmQodGhpcyksXG4gICAgICAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuY2xvc2UuYmluZCh0aGlzKSxcbiAgICAgICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXG4gICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMuX3NldFBvc2l0aW9uLmJpbmQodGhpcylcbiAgICB9KTtcblxuICAgIGlmKHRoaXMub3B0aW9ucy5ob3Zlcil7XG4gICAgICB0aGlzLiRhbmNob3Iub2ZmKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd24nKVxuICAgICAgICAgIC5vbignbW91c2VlbnRlci56Zi5kcm9wZG93bicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBfdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd24nLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgX3RoaXMuJGFuY2hvci5kYXRhKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgICAgfSk7XG4gICAgICBpZih0aGlzLm9wdGlvbnMuaG92ZXJQYW5lKXtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ21vdXNlZW50ZXIuemYuZHJvcGRvd24gbW91c2VsZWF2ZS56Zi5kcm9wZG93bicpXG4gICAgICAgICAgICAub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd24nLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4kYW5jaG9yLmFkZCh0aGlzLiRlbGVtZW50KS5vbigna2V5ZG93bi56Zi5kcm9wZG93bicsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgdmFyICR0YXJnZXQgPSAkKHRoaXMpLFxuICAgICAgICB2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMgPSBGb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUoX3RoaXMuJGVsZW1lbnQpO1xuXG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnRHJvcGRvd24nLCB7XG4gICAgICAgIHRhYl9mb3J3YXJkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuZmluZCgnOmZvY3VzJykuaXModmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzLmVxKC0xKSkpIHsgLy8gbGVmdCBtb2RhbCBkb3dud2FyZHMsIHNldHRpbmcgZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMudHJhcEZvY3VzKSB7IC8vIGlmIGZvY3VzIHNoYWxsIGJlIHRyYXBwZWRcbiAgICAgICAgICAgICAgdmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzLmVxKDApLmZvY3VzKCk7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGlmIGZvY3VzIGlzIG5vdCB0cmFwcGVkLCBjbG9zZSBkcm9wZG93biBvbiBmb2N1cyBvdXRcbiAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRhYl9iYWNrd2FyZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKF90aGlzLiRlbGVtZW50LmZpbmQoJzpmb2N1cycpLmlzKHZpc2libGVGb2N1c2FibGVFbGVtZW50cy5lcSgwKSkgfHwgX3RoaXMuJGVsZW1lbnQuaXMoJzpmb2N1cycpKSB7IC8vIGxlZnQgbW9kYWwgdXB3YXJkcywgc2V0dGluZyBmb2N1cyB0byBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnRyYXBGb2N1cykgeyAvLyBpZiBmb2N1cyBzaGFsbCBiZSB0cmFwcGVkXG4gICAgICAgICAgICAgIHZpc2libGVGb2N1c2FibGVFbGVtZW50cy5lcSgtMSkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gaWYgZm9jdXMgaXMgbm90IHRyYXBwZWQsIGNsb3NlIGRyb3Bkb3duIG9uIGZvY3VzIG91dFxuICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCR0YXJnZXQuaXMoX3RoaXMuJGFuY2hvcikpIHtcbiAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcbiAgICAgICAgICAgIF90aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgLTEpLmZvY3VzKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICBfdGhpcy4kYW5jaG9yLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgYm9keSB0byBjbG9zZSBhbnkgZHJvcGRvd25zIG9uIGEgY2xpY2suXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZEJvZHlIYW5kbGVyKCkge1xuICAgICB2YXIgJGJvZHkgPSAkKGRvY3VtZW50LmJvZHkpLm5vdCh0aGlzLiRlbGVtZW50KSxcbiAgICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgJGJvZHkub2ZmKCdjbGljay56Zi5kcm9wZG93bicpXG4gICAgICAgICAgLm9uKCdjbGljay56Zi5kcm9wZG93bicsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgaWYoX3RoaXMuJGFuY2hvci5pcyhlLnRhcmdldCkgfHwgX3RoaXMuJGFuY2hvci5maW5kKGUudGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoX3RoaXMuJGVsZW1lbnQuZmluZChlLnRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAkYm9keS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3duJyk7XG4gICAgICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGRyb3Bkb3duIHBhbmUsIGFuZCBmaXJlcyBhIGJ1YmJsaW5nIGV2ZW50IHRvIGNsb3NlIG90aGVyIGRyb3Bkb3ducy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBEcm9wZG93biNjbG9zZW1lXG4gICAqIEBmaXJlcyBEcm9wZG93biNzaG93XG4gICAqL1xuICBvcGVuKCkge1xuICAgIC8vIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLyoqXG4gICAgICogRmlyZXMgdG8gY2xvc2Ugb3RoZXIgb3BlbiBkcm9wZG93bnNcbiAgICAgKiBAZXZlbnQgRHJvcGRvd24jY2xvc2VtZVxuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VtZS56Zi5kcm9wZG93bicsIHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XG4gICAgdGhpcy4kYW5jaG9yLmFkZENsYXNzKCdob3ZlcicpXG4gICAgICAgIC5hdHRyKHsnYXJpYS1leHBhbmRlZCc6IHRydWV9KTtcbiAgICAvLyB0aGlzLiRlbGVtZW50Lyouc2hvdygpKi87XG4gICAgdGhpcy5fc2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdpcy1vcGVuJylcbiAgICAgICAgLmF0dHIoeydhcmlhLWhpZGRlbic6IGZhbHNlfSk7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKXtcbiAgICAgIHZhciAkZm9jdXNhYmxlID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgaWYoJGZvY3VzYWJsZS5sZW5ndGgpe1xuICAgICAgICAkZm9jdXNhYmxlLmVxKDApLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayl7IHRoaXMuX2FkZEJvZHlIYW5kbGVyKCk7IH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIG9uY2UgdGhlIGRyb3Bkb3duIGlzIHZpc2libGUuXG4gICAgICogQGV2ZW50IERyb3Bkb3duI3Nob3dcbiAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYuZHJvcGRvd24nLCBbdGhpcy4kZWxlbWVudF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgb3BlbiBkcm9wZG93biBwYW5lLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIERyb3Bkb3duI2hpZGVcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGlmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJylcbiAgICAgICAgLmF0dHIoeydhcmlhLWhpZGRlbic6IHRydWV9KTtcblxuICAgIHRoaXMuJGFuY2hvci5yZW1vdmVDbGFzcygnaG92ZXInKVxuICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcblxuICAgIGlmKHRoaXMuY2xhc3NDaGFuZ2VkKXtcbiAgICAgIHZhciBjdXJQb3NpdGlvbkNsYXNzID0gdGhpcy5nZXRQb3NpdGlvbkNsYXNzKCk7XG4gICAgICBpZihjdXJQb3NpdGlvbkNsYXNzKXtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhjdXJQb3NpdGlvbkNsYXNzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MpXG4gICAgICAgICAgLyouaGlkZSgpKi8uY3NzKHtoZWlnaHQ6ICcnLCB3aWR0aDogJyd9KTtcbiAgICAgIHRoaXMuY2xhc3NDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvdW50ZXIgPSA0O1xuICAgICAgdGhpcy51c2VkUG9zaXRpb25zLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi5kcm9wZG93bicsIFt0aGlzLiRlbGVtZW50XSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgZHJvcGRvd24gcGFuZSdzIHZpc2liaWxpdHkuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIGlmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSl7XG4gICAgICBpZih0aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInKSkgcmV0dXJuO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1lbHNle1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBkcm9wZG93bi5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlcicpLmhpZGUoKTtcbiAgICB0aGlzLiRhbmNob3Iub2ZmKCcuemYuZHJvcGRvd24nKTtcblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5Ecm9wZG93bi5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IG9wZW5pbmcgYSBzdWJtZW51IG9uIGhvdmVyIGV2ZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDI1MFxuICAgKi9cbiAgaG92ZXJEZWxheTogMjUwLFxuICAvKipcbiAgICogQWxsb3cgc3VibWVudXMgdG8gb3BlbiBvbiBob3ZlciBldmVudHNcbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgaG92ZXI6IGZhbHNlLFxuICAvKipcbiAgICogRG9uJ3QgY2xvc2UgZHJvcGRvd24gd2hlbiBob3ZlcmluZyBvdmVyIGRyb3Bkb3duIHBhbmVcbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBob3ZlclBhbmU6IGZhbHNlLFxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyBiZXR3ZWVuIHRoZSBkcm9wZG93biBwYW5lIGFuZCB0aGUgdHJpZ2dlcmluZyBlbGVtZW50IG9uIG9wZW4uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMVxuICAgKi9cbiAgdk9mZnNldDogMSxcbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgYmV0d2VlbiB0aGUgZHJvcGRvd24gcGFuZSBhbmQgdGhlIHRyaWdnZXJpbmcgZWxlbWVudCBvbiBvcGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDFcbiAgICovXG4gIGhPZmZzZXQ6IDEsXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIGFkanVzdCBvcGVuIHBvc2l0aW9uLiBKUyB3aWxsIHRlc3QgYW5kIGZpbGwgdGhpcyBpbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAndG9wJ1xuICAgKi9cbiAgcG9zaXRpb25DbGFzczogJycsXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgcGx1Z2luIHRvIHRyYXAgZm9jdXMgdG8gdGhlIGRyb3Bkb3duIHBhbmUgaWYgb3BlbmVkIHdpdGgga2V5Ym9hcmQgY29tbWFuZHMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIHRyYXBGb2N1czogZmFsc2UsXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgcGx1Z2luIHRvIHNldCBmb2N1cyB0byB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBwYW5lLCByZWdhcmRsZXNzIG9mIG1ldGhvZCBvZiBvcGVuaW5nLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGF1dG9Gb2N1czogZmFsc2UsXG4gIC8qKlxuICAgKiBBbGxvd3MgYSBjbGljayBvbiB0aGUgYm9keSB0byBjbG9zZSB0aGUgZHJvcGRvd24uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGNsb3NlT25DbGljazogZmFsc2Vcbn1cblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKERyb3Bkb3duLCAnRHJvcGRvd24nKTtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIERyb3Bkb3duTWVudSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJvcGRvd24tbWVudVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5ib3hcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxuICovXG5cbmNsYXNzIERyb3Bkb3duTWVudSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIERyb3Bkb3duTWVudS5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBEcm9wZG93bk1lbnUjaW5pdFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGEgZHJvcGRvd24gbWVudS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBEcm9wZG93bk1lbnUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIEZvdW5kYXRpb24uTmVzdC5GZWF0aGVyKHRoaXMuJGVsZW1lbnQsICdkcm9wZG93bicpO1xuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ0Ryb3Bkb3duTWVudScpO1xuICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ0Ryb3Bkb3duTWVudScsIHtcbiAgICAgICdFTlRFUic6ICdvcGVuJyxcbiAgICAgICdTUEFDRSc6ICdvcGVuJyxcbiAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcbiAgICAgICdBUlJPV19VUCc6ICd1cCcsXG4gICAgICAnQVJST1dfRE9XTic6ICdkb3duJyxcbiAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJyxcbiAgICAgICdFU0NBUEUnOiAnY2xvc2UnXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiwgYW5kIGNhbGxzIF9wcmVwYXJlTWVudVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciBzdWJzID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpO1xuICAgIHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpLmFkZENsYXNzKCdmaXJzdC1zdWInKTtcblxuICAgIHRoaXMuJG1lbnVJdGVtcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW3JvbGU9XCJtZW51aXRlbVwiXScpO1xuICAgIHRoaXMuJHRhYnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCdbcm9sZT1cIm1lbnVpdGVtXCJdJyk7XG4gICAgdGhpcy4kdGFicy5maW5kKCd1bC5pcy1kcm9wZG93bi1zdWJtZW51JykuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsQ2xhc3MpO1xuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLnJpZ2h0Q2xhc3MpIHx8IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdyaWdodCcgfHwgRm91bmRhdGlvbi5ydGwoKSB8fCB0aGlzLiRlbGVtZW50LnBhcmVudHMoJy50b3AtYmFyLXJpZ2h0JykuaXMoJyonKSkge1xuICAgICAgdGhpcy5vcHRpb25zLmFsaWdubWVudCA9ICdyaWdodCc7XG4gICAgICBzdWJzLmFkZENsYXNzKCdvcGVucy1sZWZ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLXJpZ2h0Jyk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2V2ZW50cygpO1xuICB9O1xuICAvKipcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gZWxlbWVudHMgd2l0aGluIHRoZSBtZW51XG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgX2V2ZW50cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBoYXNUb3VjaCA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCAodHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09ICd1bmRlZmluZWQnKSxcbiAgICAgICAgcGFyQ2xhc3MgPSAnaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnO1xuXG4gICAgLy8gdXNlZCBmb3Igb25DbGljayBhbmQgaW4gdGhlIGtleWJvYXJkIGhhbmRsZXJzXG4gICAgdmFyIGhhbmRsZUNsaWNrRm4gPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgJGVsZW0gPSAkKGUudGFyZ2V0KS5wYXJlbnRzVW50aWwoJ3VsJywgYC4ke3BhckNsYXNzfWApLFxuICAgICAgICAgIGhhc1N1YiA9ICRlbGVtLmhhc0NsYXNzKHBhckNsYXNzKSxcbiAgICAgICAgICBoYXNDbGlja2VkID0gJGVsZW0uYXR0cignZGF0YS1pcy1jbGljaycpID09PSAndHJ1ZScsXG4gICAgICAgICAgJHN1YiA9ICRlbGVtLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpO1xuXG4gICAgICBpZiAoaGFzU3ViKSB7XG4gICAgICAgIGlmIChoYXNDbGlja2VkKSB7XG4gICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayB8fCAoIV90aGlzLm9wdGlvbnMuY2xpY2tPcGVuICYmICFoYXNUb3VjaCkgfHwgKF90aGlzLm9wdGlvbnMuZm9yY2VGb2xsb3cgJiYgaGFzVG91Y2gpKSB7IHJldHVybjsgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgX3RoaXMuX3Nob3coJGVsZW0uY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51JykpO1xuICAgICAgICAgICRlbGVtLmFkZCgkZWxlbS5wYXJlbnRzVW50aWwoX3RoaXMuJGVsZW1lbnQsIGAuJHtwYXJDbGFzc31gKSkuYXR0cignZGF0YS1pcy1jbGljaycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyByZXR1cm47IH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja09wZW4gfHwgaGFzVG91Y2gpIHtcbiAgICAgIHRoaXMuJG1lbnVJdGVtcy5vbignY2xpY2suemYuZHJvcGRvd25tZW51IHRvdWNoc3RhcnQuemYuZHJvcGRvd25tZW51JywgaGFuZGxlQ2xpY2tGbik7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyKSB7XG4gICAgICB0aGlzLiRtZW51SXRlbXMub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO1xuXG4gICAgICAgIGlmIChoYXNTdWIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuZGVsYXkpO1xuICAgICAgICAgIF90aGlzLmRlbGF5ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpKTtcbiAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyksXG4gICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyk7XG4gICAgICAgIGlmIChoYXNTdWIgJiYgX3RoaXMub3B0aW9ucy5hdXRvY2xvc2UpIHtcbiAgICAgICAgICBpZiAoJGVsZW0uYXR0cignZGF0YS1pcy1jbGljaycpID09PSAndHJ1ZScgJiYgX3RoaXMub3B0aW9ucy5jbGlja09wZW4pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuZGVsYXkpO1xuICAgICAgICAgIF90aGlzLmRlbGF5ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtKTtcbiAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmNsb3NpbmdUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuJG1lbnVJdGVtcy5vbigna2V5ZG93bi56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgJGVsZW1lbnQgPSAkKGUudGFyZ2V0KS5wYXJlbnRzVW50aWwoJ3VsJywgJ1tyb2xlPVwibWVudWl0ZW1cIl0nKSxcbiAgICAgICAgICBpc1RhYiA9IF90aGlzLiR0YWJzLmluZGV4KCRlbGVtZW50KSA+IC0xLFxuICAgICAgICAgICRlbGVtZW50cyA9IGlzVGFiID8gX3RoaXMuJHRhYnMgOiAkZWxlbWVudC5zaWJsaW5ncygnbGknKS5hZGQoJGVsZW1lbnQpLFxuICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAkbmV4dEVsZW1lbnQ7XG5cbiAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaWYgKCQodGhpcykuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKGktMSk7XG4gICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKGkrMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIG5leHRTaWJsaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghJGVsZW1lbnQuaXMoJzpsYXN0LWNoaWxkJykpIHtcbiAgICAgICAgICAkbmV4dEVsZW1lbnQuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgcHJldlNpYmxpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJHByZXZFbGVtZW50LmNoaWxkcmVuKCdhOmZpcnN0JykuZm9jdXMoKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSwgb3BlblN1YiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgJHN1YiA9ICRlbGVtZW50LmNoaWxkcmVuKCd1bC5pcy1kcm9wZG93bi1zdWJtZW51Jyk7XG4gICAgICAgIGlmICgkc3ViLmxlbmd0aCkge1xuICAgICAgICAgIF90aGlzLl9zaG93KCRzdWIpO1xuICAgICAgICAgICRlbGVtZW50LmZpbmQoJ2xpID4gYTpmaXJzdCcpLmZvY3VzKCk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgeyByZXR1cm47IH1cbiAgICAgIH0sIGNsb3NlU3ViID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vaWYgKCRlbGVtZW50LmlzKCc6Zmlyc3QtY2hpbGQnKSkge1xuICAgICAgICB2YXIgY2xvc2UgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpO1xuICAgICAgICBjbG9zZS5jaGlsZHJlbignYTpmaXJzdCcpLmZvY3VzKCk7XG4gICAgICAgIF90aGlzLl9oaWRlKGNsb3NlKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvL31cbiAgICAgIH07XG4gICAgICB2YXIgZnVuY3Rpb25zID0ge1xuICAgICAgICBvcGVuOiBvcGVuU3ViLFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMuX2hpZGUoX3RoaXMuJGVsZW1lbnQpO1xuICAgICAgICAgIF90aGlzLiRtZW51SXRlbXMuZmluZCgnYTpmaXJzdCcpLmZvY3VzKCk7IC8vIGZvY3VzIHRvIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChpc1RhYikge1xuICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoX3RoaXMub3B0aW9ucy52ZXJ0aWNhbENsYXNzKSkgeyAvLyB2ZXJ0aWNhbCBtZW51XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnbGVmdCcpIHsgLy8gbGVmdCBhbGlnbmVkXG4gICAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcbiAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgbmV4dDogb3BlblN1YixcbiAgICAgICAgICAgICAgcHJldmlvdXM6IGNsb3NlU3ViXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyByaWdodCBhbGlnbmVkXG4gICAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcbiAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgbmV4dDogY2xvc2VTdWIsXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBvcGVuU3ViXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGhvcml6b250YWwgbWVudVxuICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgbmV4dDogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgICBwcmV2aW91czogcHJldlNpYmxpbmcsXG4gICAgICAgICAgICBkb3duOiBvcGVuU3ViLFxuICAgICAgICAgICAgdXA6IGNsb3NlU3ViXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8vIG5vdCB0YWJzIC0+IG9uZSBzdWJcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnbGVmdCcpIHsgLy8gbGVmdCBhbGlnbmVkXG4gICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICBuZXh0OiBvcGVuU3ViLFxuICAgICAgICAgICAgcHJldmlvdXM6IGNsb3NlU3ViLFxuICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgICB1cDogcHJldlNpYmxpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHsgLy8gcmlnaHQgYWxpZ25lZFxuICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgbmV4dDogY2xvc2VTdWIsXG4gICAgICAgICAgICBwcmV2aW91czogb3BlblN1YixcbiAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdEcm9wZG93bk1lbnUnLCBmdW5jdGlvbnMpO1xuXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBoYW5kbGVyIHRvIHRoZSBib2R5IHRvIGNsb3NlIGFueSBkcm9wZG93bnMgb24gYSBjbGljay5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkQm9keUhhbmRsZXIoKSB7XG4gICAgdmFyICRib2R5ID0gJChkb2N1bWVudC5ib2R5KSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICRib2R5Lm9mZignbW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51JylcbiAgICAgICAgIC5vbignbW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICB2YXIgJGxpbmsgPSBfdGhpcy4kZWxlbWVudC5maW5kKGUudGFyZ2V0KTtcbiAgICAgICAgICAgaWYgKCRsaW5rLmxlbmd0aCkgeyByZXR1cm47IH1cblxuICAgICAgICAgICBfdGhpcy5faGlkZSgpO1xuICAgICAgICAgICAkYm9keS5vZmYoJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScpO1xuICAgICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgYSBkcm9wZG93biBwYW5lLCBhbmQgY2hlY2tzIGZvciBjb2xsaXNpb25zIGZpcnN0LlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJHN1YiAtIHVsIGVsZW1lbnQgdGhhdCBpcyBhIHN1Ym1lbnUgdG8gc2hvd1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIERyb3Bkb3duTWVudSNzaG93XG4gICAqL1xuICBfc2hvdygkc3ViKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuJHRhYnMuaW5kZXgodGhpcy4kdGFicy5maWx0ZXIoZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgIHJldHVybiAkKGVsKS5maW5kKCRzdWIpLmxlbmd0aCA+IDA7XG4gICAgfSkpO1xuICAgIHZhciAkc2licyA9ICRzdWIucGFyZW50KCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLnNpYmxpbmdzKCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpO1xuICAgIHRoaXMuX2hpZGUoJHNpYnMsIGlkeCk7XG4gICAgJHN1Yi5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuYWRkQ2xhc3MoJ2pzLWRyb3Bkb3duLWFjdGl2ZScpLmF0dHIoeydhcmlhLWhpZGRlbic6IGZhbHNlfSlcbiAgICAgICAgLnBhcmVudCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5hZGRDbGFzcygnaXMtYWN0aXZlJylcbiAgICAgICAgLmF0dHIoeydhcmlhLWV4cGFuZGVkJzogdHJ1ZX0pO1xuICAgIHZhciBjbGVhciA9IEZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UoJHN1YiwgbnVsbCwgdHJ1ZSk7XG4gICAgaWYgKCFjbGVhcikge1xuICAgICAgdmFyIG9sZENsYXNzID0gdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnID8gJy1yaWdodCcgOiAnLWxlZnQnLFxuICAgICAgICAgICRwYXJlbnRMaSA9ICRzdWIucGFyZW50KCcuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTtcbiAgICAgICRwYXJlbnRMaS5yZW1vdmVDbGFzcyhgb3BlbnMke29sZENsYXNzfWApLmFkZENsYXNzKGBvcGVucy0ke3RoaXMub3B0aW9ucy5hbGlnbm1lbnR9YCk7XG4gICAgICBjbGVhciA9IEZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UoJHN1YiwgbnVsbCwgdHJ1ZSk7XG4gICAgICBpZiAoIWNsZWFyKSB7XG4gICAgICAgICRwYXJlbnRMaS5yZW1vdmVDbGFzcyhgb3BlbnMtJHt0aGlzLm9wdGlvbnMuYWxpZ25tZW50fWApLmFkZENsYXNzKCdvcGVucy1pbm5lcicpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgJHN1Yi5jc3MoJ3Zpc2liaWxpdHknLCAnJyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHsgdGhpcy5fYWRkQm9keUhhbmRsZXIoKTsgfVxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIG5ldyBkcm9wZG93biBwYW5lIGlzIHZpc2libGUuXG4gICAgICogQGV2ZW50IERyb3Bkb3duTWVudSNzaG93XG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzaG93LnpmLmRyb3Bkb3dubWVudScsIFskc3ViXSk7XG4gIH1cblxuICAvKipcbiAgICogSGlkZXMgYSBzaW5nbGUsIGN1cnJlbnRseSBvcGVuIGRyb3Bkb3duIHBhbmUsIGlmIHBhc3NlZCBhIHBhcmFtZXRlciwgb3RoZXJ3aXNlLCBoaWRlcyBldmVyeXRoaW5nLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gZWxlbWVudCB3aXRoIGEgc3VibWVudSB0byBoaWRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSBpbmRleCBvZiB0aGUgJHRhYnMgY29sbGVjdGlvbiB0byBoaWRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGlkZSgkZWxlbSwgaWR4KSB7XG4gICAgdmFyICR0b0Nsb3NlO1xuICAgIGlmICgkZWxlbSAmJiAkZWxlbS5sZW5ndGgpIHtcbiAgICAgICR0b0Nsb3NlID0gJGVsZW07XG4gICAgfSBlbHNlIGlmIChpZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgJHRvQ2xvc2UgPSB0aGlzLiR0YWJzLm5vdChmdW5jdGlvbihpLCBlbCkge1xuICAgICAgICByZXR1cm4gaSA9PT0gaWR4O1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJHRvQ2xvc2UgPSB0aGlzLiRlbGVtZW50O1xuICAgIH1cbiAgICB2YXIgc29tZXRoaW5nVG9DbG9zZSA9ICR0b0Nsb3NlLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSB8fCAkdG9DbG9zZS5maW5kKCcuaXMtYWN0aXZlJykubGVuZ3RoID4gMDtcblxuICAgIGlmIChzb21ldGhpbmdUb0Nsb3NlKSB7XG4gICAgICAkdG9DbG9zZS5maW5kKCdsaS5pcy1hY3RpdmUnKS5hZGQoJHRvQ2xvc2UpLmF0dHIoe1xuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlLFxuICAgICAgICAnZGF0YS1pcy1jbGljayc6IGZhbHNlXG4gICAgICB9KS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyk7XG5cbiAgICAgICR0b0Nsb3NlLmZpbmQoJ3VsLmpzLWRyb3Bkb3duLWFjdGl2ZScpLmF0dHIoe1xuICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlXG4gICAgICB9KS5yZW1vdmVDbGFzcygnanMtZHJvcGRvd24tYWN0aXZlJyk7XG5cbiAgICAgIGlmICh0aGlzLmNoYW5nZWQgfHwgJHRvQ2xvc2UuZmluZCgnb3BlbnMtaW5uZXInKS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG9sZENsYXNzID0gdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgJHRvQ2xvc2UuZmluZCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5hZGQoJHRvQ2xvc2UpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKGBvcGVucy1pbm5lciBvcGVucy0ke3RoaXMub3B0aW9ucy5hbGlnbm1lbnR9YClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoYG9wZW5zLSR7b2xkQ2xhc3N9YCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBvcGVuIG1lbnVzIGFyZSBjbG9zZWQuXG4gICAgICAgKiBAZXZlbnQgRHJvcGRvd25NZW51I2hpZGVcbiAgICAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdoaWRlLnpmLmRyb3Bkb3dubWVudScsIFskdG9DbG9zZV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kbWVudUl0ZW1zLm9mZignLnpmLmRyb3Bkb3dubWVudScpLnJlbW92ZUF0dHIoJ2RhdGEtaXMtY2xpY2snKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2lzLXJpZ2h0LWFycm93IGlzLWxlZnQtYXJyb3cgaXMtZG93bi1hcnJvdyBvcGVucy1yaWdodCBvcGVucy1sZWZ0IG9wZW5zLWlubmVyJyk7XG4gICAgJChkb2N1bWVudC5ib2R5KS5vZmYoJy56Zi5kcm9wZG93bm1lbnUnKTtcbiAgICBGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cbiAqL1xuRHJvcGRvd25NZW51LmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogRGlzYWxsb3dzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgc3VibWVudXNcbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZUhvdmVyOiBmYWxzZSxcbiAgLyoqXG4gICAqIEFsbG93IGEgc3VibWVudSB0byBhdXRvbWF0aWNhbGx5IGNsb3NlIG9uIGEgbW91c2VsZWF2ZSBldmVudCwgaWYgbm90IGNsaWNrZWQgb3Blbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBhdXRvY2xvc2U6IHRydWUsXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSA1MFxuICAgKi9cbiAgaG92ZXJEZWxheTogNTAsXG4gIC8qKlxuICAgKiBBbGxvdyBhIHN1Ym1lbnUgdG8gb3Blbi9yZW1haW4gb3BlbiBvbiBwYXJlbnQgY2xpY2sgZXZlbnQuIEFsbG93cyBjdXJzb3IgdG8gbW92ZSBhd2F5IGZyb20gbWVudS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBjbGlja09wZW46IGZhbHNlLFxuICAvKipcbiAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgY2xvc2luZyBhIHN1Ym1lbnUgb24gYSBtb3VzZWxlYXZlIGV2ZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDUwMFxuICAgKi9cblxuICBjbG9zaW5nVGltZTogMjAwLFxuICAvKipcbiAgICogUG9zaXRpb24gb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gd2hhdCBkaXJlY3Rpb24gdGhlIHN1Ym1lbnVzIHNob3VsZCBvcGVuLiBIYW5kbGVkIGJ5IEpTLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdsZWZ0J1xuICAgKi9cbiAgYWxpZ25tZW50OiAnbGVmdCcsXG4gIC8qKlxuICAgKiBBbGxvdyBjbGlja3Mgb24gdGhlIGJvZHkgdG8gY2xvc2UgYW55IG9wZW4gc3VibWVudXMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgY2xvc2VPbkNsaWNrOiB0cnVlLFxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byB2ZXJ0aWNhbCBvcmllbnRlZCBtZW51cywgRm91bmRhdGlvbiBkZWZhdWx0IGlzIGB2ZXJ0aWNhbGAuIFVwZGF0ZSB0aGlzIGlmIHVzaW5nIHlvdXIgb3duIGNsYXNzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICd2ZXJ0aWNhbCdcbiAgICovXG4gIHZlcnRpY2FsQ2xhc3M6ICd2ZXJ0aWNhbCcsXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHJpZ2h0LXNpZGUgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgYWxpZ24tcmlnaHRgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnYWxpZ24tcmlnaHQnXG4gICAqL1xuICByaWdodENsYXNzOiAnYWxpZ24tcmlnaHQnLFxuICAvKipcbiAgICogQm9vbGVhbiB0byBmb3JjZSBvdmVyaWRlIHRoZSBjbGlja2luZyBvZiBsaW5rcyB0byBwZXJmb3JtIGRlZmF1bHQgYWN0aW9uLCBvbiBzZWNvbmQgdG91Y2ggZXZlbnQgZm9yIG1vYmlsZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgZm9yY2VGb2xsb3c6IHRydWVcbn07XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihEcm9wZG93bk1lbnUsICdEcm9wZG93bk1lbnUnKTtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIEVxdWFsaXplciBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZXF1YWxpemVyXG4gKi9cblxuY2xhc3MgRXF1YWxpemVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgRXF1YWxpemVyLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIEVxdWFsaXplciNpbml0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpe1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyAgPSAkLmV4dGVuZCh7fSwgRXF1YWxpemVyLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdFcXVhbGl6ZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgRXF1YWxpemVyIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBlcXVhbGl6ZXIgZnVuY3Rpb25pbmcgb24gbG9hZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciBlcUlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLWVxdWFsaXplcicpIHx8ICcnO1xuICAgIHZhciAkd2F0Y2hlZCA9IHRoaXMuJGVsZW1lbnQuZmluZChgW2RhdGEtZXF1YWxpemVyLXdhdGNoPVwiJHtlcUlkfVwiXWApO1xuXG4gICAgdGhpcy4kd2F0Y2hlZCA9ICR3YXRjaGVkLmxlbmd0aCA/ICR3YXRjaGVkIDogdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1lcXVhbGl6ZXItd2F0Y2hdJyk7XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLXJlc2l6ZScsIChlcUlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ2VxJykpKTtcblxuICAgIHRoaXMuaGFzTmVzdGVkID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1lcXVhbGl6ZXJdJykubGVuZ3RoID4gMDtcbiAgICB0aGlzLmlzTmVzdGVkID0gdGhpcy4kZWxlbWVudC5wYXJlbnRzVW50aWwoZG9jdW1lbnQuYm9keSwgJ1tkYXRhLWVxdWFsaXplcl0nKS5sZW5ndGggPiAwO1xuICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xuICAgIHRoaXMuX2JpbmRIYW5kbGVyID0ge1xuICAgICAgb25SZXNpemVNZUJvdW5kOiB0aGlzLl9vblJlc2l6ZU1lLmJpbmQodGhpcyksXG4gICAgICBvblBvc3RFcXVhbGl6ZWRCb3VuZDogdGhpcy5fb25Qb3N0RXF1YWxpemVkLmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgdmFyIGltZ3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2ltZycpO1xuICAgIHZhciB0b29TbWFsbDtcbiAgICBpZih0aGlzLm9wdGlvbnMuZXF1YWxpemVPbil7XG4gICAgICB0b29TbWFsbCA9IHRoaXMuX2NoZWNrTVEoKTtcbiAgICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fY2hlY2tNUS5iaW5kKHRoaXMpKTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgICBpZigodG9vU21hbGwgIT09IHVuZGVmaW5lZCAmJiB0b29TbWFsbCA9PT0gZmFsc2UpIHx8IHRvb1NtYWxsID09PSB1bmRlZmluZWQpe1xuICAgICAgaWYoaW1ncy5sZW5ndGgpe1xuICAgICAgICBGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKGltZ3MsIHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpKTtcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLl9yZWZsb3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgaWYgdGhlIGJyZWFrcG9pbnQgaXMgdG9vIHNtYWxsLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BhdXNlRXZlbnRzKCkge1xuICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xuICAgIHRoaXMuJGVsZW1lbnQub2ZmKHtcbiAgICAgICcuemYuZXF1YWxpemVyJzogdGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQsXG4gICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGZ1bmN0aW9uIHRvIGhhbmRsZSAkZWxlbWVudHMgcmVzaXplbWUuemYudHJpZ2dlciwgd2l0aCBib3VuZCB0aGlzIG9uIF9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblJlc2l6ZU1lKGUpIHtcbiAgICB0aGlzLl9yZWZsb3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmdW5jdGlvbiB0byBoYW5kbGUgJGVsZW1lbnRzIHBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyLCB3aXRoIGJvdW5kIHRoaXMgb24gX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Qb3N0RXF1YWxpemVkKGUpIHtcbiAgICBpZihlLnRhcmdldCAhPT0gdGhpcy4kZWxlbWVudFswXSl7IHRoaXMuX3JlZmxvdygpOyB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBFcXVhbGl6ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fcGF1c2VFdmVudHMoKTtcbiAgICBpZih0aGlzLmhhc05lc3RlZCl7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplcicsIHRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kKTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQpO1xuICAgIH1cbiAgICB0aGlzLmlzT24gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgY3VycmVudCBicmVha3BvaW50IHRvIHRoZSBtaW5pbXVtIHJlcXVpcmVkIHNpemUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tNUSgpIHtcbiAgICB2YXIgdG9vU21hbGwgPSAhRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmVxdWFsaXplT24pO1xuICAgIGlmKHRvb1NtYWxsKXtcbiAgICAgIGlmKHRoaXMuaXNPbil7XG4gICAgICAgIHRoaXMuX3BhdXNlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgaWYoIXRoaXMuaXNPbil7XG4gICAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9vU21hbGw7XG4gIH1cblxuICAvKipcbiAgICogQSBub29wIHZlcnNpb24gZm9yIHRoZSBwbHVnaW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9raWxsc3dpdGNoKCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBFcXVhbGl6ZXIgdXBvbiBET00gY2hhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVmbG93KCkge1xuICAgIGlmKCF0aGlzLm9wdGlvbnMuZXF1YWxpemVPblN0YWNrKXtcbiAgICAgIGlmKHRoaXMuX2lzU3RhY2tlZCgpKXtcbiAgICAgICAgdGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsICdhdXRvJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lcXVhbGl6ZUJ5Um93KSB7XG4gICAgICB0aGlzLmdldEhlaWdodHNCeVJvdyh0aGlzLmFwcGx5SGVpZ2h0QnlSb3cuYmluZCh0aGlzKSk7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLmdldEhlaWdodHModGhpcy5hcHBseUhlaWdodC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFudWFsbHkgZGV0ZXJtaW5lcyBpZiB0aGUgZmlyc3QgMiBlbGVtZW50cyBhcmUgKk5PVCogc3RhY2tlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc1N0YWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJHdhdGNoZWRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICE9PSB0aGlzLiR3YXRjaGVkWzFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgb3V0ZXIgaGVpZ2h0cyBvZiBjaGlsZHJlbiBjb250YWluZWQgd2l0aGluIGFuIEVxdWFsaXplciBwYXJlbnQgYW5kIHJldHVybnMgdGhlbSBpbiBhbiBhcnJheVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIEEgbm9uLW9wdGlvbmFsIGNhbGxiYWNrIHRvIHJldHVybiB0aGUgaGVpZ2h0cyBhcnJheSB0by5cbiAgICogQHJldHVybnMge0FycmF5fSBoZWlnaHRzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lclxuICAgKi9cbiAgZ2V0SGVpZ2h0cyhjYikge1xuICAgIHZhciBoZWlnaHRzID0gW107XG4gICAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICB0aGlzLiR3YXRjaGVkW2ldLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgIGhlaWdodHMucHVzaCh0aGlzLiR3YXRjaGVkW2ldLm9mZnNldEhlaWdodCk7XG4gICAgfVxuICAgIGNiKGhlaWdodHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBvdXRlciBoZWlnaHRzIG9mIGNoaWxkcmVuIGNvbnRhaW5lZCB3aXRoaW4gYW4gRXF1YWxpemVyIHBhcmVudCBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gQSBub24tb3B0aW9uYWwgY2FsbGJhY2sgdG8gcmV0dXJuIHRoZSBoZWlnaHRzIGFycmF5IHRvLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGdyb3VwcyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXIgZ3JvdXBlZCBieSByb3cgd2l0aCBlbGVtZW50LGhlaWdodCBhbmQgbWF4IGFzIGxhc3QgY2hpbGRcbiAgICovXG4gIGdldEhlaWdodHNCeVJvdyhjYikge1xuICAgIHZhciBsYXN0RWxUb3BPZmZzZXQgPSAodGhpcy4kd2F0Y2hlZC5sZW5ndGggPyB0aGlzLiR3YXRjaGVkLmZpcnN0KCkub2Zmc2V0KCkudG9wIDogMCksXG4gICAgICAgIGdyb3VwcyA9IFtdLFxuICAgICAgICBncm91cCA9IDA7XG4gICAgLy9ncm91cCBieSBSb3dcbiAgICBncm91cHNbZ3JvdXBdID0gW107XG4gICAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICB0aGlzLiR3YXRjaGVkW2ldLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgIC8vbWF5YmUgY291bGQgdXNlIHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0VG9wXG4gICAgICB2YXIgZWxPZmZzZXRUb3AgPSAkKHRoaXMuJHdhdGNoZWRbaV0pLm9mZnNldCgpLnRvcDtcbiAgICAgIGlmIChlbE9mZnNldFRvcCE9bGFzdEVsVG9wT2Zmc2V0KSB7XG4gICAgICAgIGdyb3VwKys7XG4gICAgICAgIGdyb3Vwc1tncm91cF0gPSBbXTtcbiAgICAgICAgbGFzdEVsVG9wT2Zmc2V0PWVsT2Zmc2V0VG9wO1xuICAgICAgfVxuICAgICAgZ3JvdXBzW2dyb3VwXS5wdXNoKFt0aGlzLiR3YXRjaGVkW2ldLHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0SGVpZ2h0XSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDAsIGxuID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGxuOyBqKyspIHtcbiAgICAgIHZhciBoZWlnaHRzID0gJChncm91cHNbal0pLm1hcChmdW5jdGlvbigpeyByZXR1cm4gdGhpc1sxXTsgfSkuZ2V0KCk7XG4gICAgICB2YXIgbWF4ICAgICAgICAgPSBNYXRoLm1heC5hcHBseShudWxsLCBoZWlnaHRzKTtcbiAgICAgIGdyb3Vwc1tqXS5wdXNoKG1heCk7XG4gICAgfVxuICAgIGNiKGdyb3Vwcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgQ1NTIGhlaWdodCBwcm9wZXJ0eSBvZiBlYWNoIGNoaWxkIGluIGFuIEVxdWFsaXplciBwYXJlbnQgdG8gbWF0Y2ggdGhlIHRhbGxlc3RcbiAgICogQHBhcmFtIHthcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcbiAgICogQGZpcmVzIEVxdWFsaXplciNwcmVlcXVhbGl6ZWRcbiAgICogQGZpcmVzIEVxdWFsaXplciNwb3N0ZXF1YWxpemVkXG4gICAqL1xuICBhcHBseUhlaWdodChoZWlnaHRzKSB7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGhlaWdodHMpO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBhcmUgYXBwbGllZFxuICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XG5cbiAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgbWF4KTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGhlaWdodHMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcbiAgICAgKi9cbiAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIENTUyBoZWlnaHQgcHJvcGVydHkgb2YgZWFjaCBjaGlsZCBpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IHRvIG1hdGNoIHRoZSB0YWxsZXN0IGJ5IHJvd1xuICAgKiBAcGFyYW0ge2FycmF5fSBncm91cHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyIGdyb3VwZWQgYnkgcm93IHdpdGggZWxlbWVudCxoZWlnaHQgYW5kIG1heCBhcyBsYXN0IGNoaWxkXG4gICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkUm93XG4gICAqIEBmaXJlcyBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFJvd1xuICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcbiAgICovXG4gIGFwcGx5SGVpZ2h0QnlSb3coZ3JvdXBzKSB7XG4gICAgLyoqXG4gICAgICogRmlyZXMgYmVmb3JlIHRoZSBoZWlnaHRzIGFyZSBhcHBsaWVkXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgIHZhciBncm91cHNJTGVuZ3RoID0gZ3JvdXBzW2ldLmxlbmd0aCxcbiAgICAgICAgICBtYXggPSBncm91cHNbaV1bZ3JvdXBzSUxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGdyb3Vwc0lMZW5ndGg8PTIpIHtcbiAgICAgICAgJChncm91cHNbaV1bMF1bMF0pLmNzcyh7J2hlaWdodCc6J2F1dG8nfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgICogRmlyZXMgYmVmb3JlIHRoZSBoZWlnaHRzIHBlciByb3cgYXJlIGFwcGxpZWRcbiAgICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3ByZWVxdWFsaXplZFJvd1xuICAgICAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWRyb3cuemYuZXF1YWxpemVyJyk7XG4gICAgICBmb3IgKHZhciBqID0gMCwgbGVuSiA9IChncm91cHNJTGVuZ3RoLTEpOyBqIDwgbGVuSiA7IGorKykge1xuICAgICAgICAkKGdyb3Vwc1tpXVtqXVswXSkuY3NzKHsnaGVpZ2h0JzptYXh9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhlaWdodHMgcGVyIHJvdyBoYXZlIGJlZW4gYXBwbGllZFxuICAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFJvd1xuICAgICAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwb3N0ZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgICovXG4gICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9wYXVzZUV2ZW50cygpO1xuICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xuXG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gKi9cbkVxdWFsaXplci5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEVuYWJsZSBoZWlnaHQgZXF1YWxpemF0aW9uIHdoZW4gc3RhY2tlZCBvbiBzbWFsbGVyIHNjcmVlbnMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgZXF1YWxpemVPblN0YWNrOiB0cnVlLFxuICAvKipcbiAgICogRW5hYmxlIGhlaWdodCBlcXVhbGl6YXRpb24gcm93IGJ5IHJvdy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgZXF1YWxpemVCeVJvdzogZmFsc2UsXG4gIC8qKlxuICAgKiBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBtaW5pbXVtIGJyZWFrcG9pbnQgc2l6ZSB0aGUgcGx1Z2luIHNob3VsZCBlcXVhbGl6ZSBoZWlnaHRzIG9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdtZWRpdW0nXG4gICAqL1xuICBlcXVhbGl6ZU9uOiAnJ1xufTtcblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKEVxdWFsaXplciwgJ0VxdWFsaXplcicpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogSW50ZXJjaGFuZ2UgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmludGVyY2hhbmdlXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlclxuICovXG5cbmNsYXNzIEludGVyY2hhbmdlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgSW50ZXJjaGFuZ2UuXG4gICAqIEBjbGFzc1xuICAgKiBAZmlyZXMgSW50ZXJjaGFuZ2UjaW5pdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIEludGVyY2hhbmdlLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICB0aGlzLnJ1bGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50UGF0aCA9ICcnO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnSW50ZXJjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgSW50ZXJjaGFuZ2UgcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IGludGVyY2hhbmdlIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fYWRkQnJlYWtwb2ludHMoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZVJ1bGVzKCk7XG4gICAgdGhpcy5fcmVmbG93KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBJbnRlcmNoYW5nZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgICQod2luZG93KS5vbigncmVzaXplLnpmLmludGVyY2hhbmdlJywgRm91bmRhdGlvbi51dGlsLnRocm90dGxlKHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpLCA1MCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIEludGVyY2hhbmdlIHVwb24gRE9NIGNoYW5nZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZWZsb3coKSB7XG4gICAgdmFyIG1hdGNoO1xuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSwgYnV0IG9ubHkgc2F2ZSB0aGUgbGFzdCBtYXRjaFxuICAgIGZvciAodmFyIGkgaW4gdGhpcy5ydWxlcykge1xuICAgICAgaWYodGhpcy5ydWxlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXNbaV07XG5cbiAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKHJ1bGUucXVlcnkpLm1hdGNoZXMpIHtcbiAgICAgICAgICBtYXRjaCA9IHJ1bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRoaXMucmVwbGFjZShtYXRjaC5wYXRoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgRm91bmRhdGlvbiBicmVha3BvaW50cyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVMgb2JqZWN0LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hZGRCcmVha3BvaW50cygpIHtcbiAgICBmb3IgKHZhciBpIGluIEZvdW5kYXRpb24uTWVkaWFRdWVyeS5xdWVyaWVzKSB7XG4gICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXNbaV07XG4gICAgICAgIEludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFU1txdWVyeS5uYW1lXSA9IHF1ZXJ5LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIEludGVyY2hhbmdlIGVsZW1lbnQgZm9yIHRoZSBwcm92aWRlZCBtZWRpYSBxdWVyeSArIGNvbnRlbnQgcGFpcmluZ3NcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0aGF0IGlzIGFuIEludGVyY2hhbmdlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gc2NlbmFyaW9zIC0gQXJyYXkgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgJ21xJyBhbmQgJ3BhdGgnIGtleXMgd2l0aCBjb3JyZXNwb25kaW5nIGtleXNcbiAgICovXG4gIF9nZW5lcmF0ZVJ1bGVzKGVsZW1lbnQpIHtcbiAgICB2YXIgcnVsZXNMaXN0ID0gW107XG4gICAgdmFyIHJ1bGVzO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydWxlcykge1xuICAgICAgcnVsZXMgPSB0aGlzLm9wdGlvbnMucnVsZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcnVsZXMgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ2ludGVyY2hhbmdlJykubWF0Y2goL1xcWy4qP1xcXS9nKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIHJ1bGVzKSB7XG4gICAgICBpZihydWxlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldLnNsaWNlKDEsIC0xKS5zcGxpdCgnLCAnKTtcbiAgICAgICAgdmFyIHBhdGggPSBydWxlLnNsaWNlKDAsIC0xKS5qb2luKCcnKTtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gcnVsZVtydWxlLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldKSB7XG4gICAgICAgICAgcXVlcnkgPSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldO1xuICAgICAgICB9XG5cbiAgICAgICAgcnVsZXNMaXN0LnB1c2goe1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucnVsZXMgPSBydWxlc0xpc3Q7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBgc3JjYCBwcm9wZXJ0eSBvZiBhbiBpbWFnZSwgb3IgY2hhbmdlIHRoZSBIVE1MIG9mIGEgY29udGFpbmVyLCB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFBhdGggdG8gdGhlIGltYWdlIG9yIEhUTUwgcGFydGlhbC5cbiAgICogQGZpcmVzIEludGVyY2hhbmdlI3JlcGxhY2VkXG4gICAqL1xuICByZXBsYWNlKHBhdGgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aCA9PT0gcGF0aCkgcmV0dXJuO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgdHJpZ2dlciA9ICdyZXBsYWNlZC56Zi5pbnRlcmNoYW5nZSc7XG5cbiAgICAvLyBSZXBsYWNpbmcgaW1hZ2VzXG4gICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0ubm9kZU5hbWUgPT09ICdJTUcnKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3NyYycsIHBhdGgpLmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLmN1cnJlbnRQYXRoID0gcGF0aDtcbiAgICAgIH0pXG4gICAgICAudHJpZ2dlcih0cmlnZ2VyKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjaW5nIGJhY2tncm91bmQgaW1hZ2VzXG4gICAgZWxzZSBpZiAocGF0aC5tYXRjaCgvXFwuKGdpZnxqcGd8anBlZ3xwbmd8c3ZnfHRpZmYpKFs/I10uKik/L2kpKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmNzcyh7ICdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnK3BhdGgrJyknIH0pXG4gICAgICAgICAgLnRyaWdnZXIodHJpZ2dlcik7XG4gICAgfVxuICAgIC8vIFJlcGxhY2luZyBIVE1MXG4gICAgZWxzZSB7XG4gICAgICAkLmdldChwYXRoLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBfdGhpcy4kZWxlbWVudC5odG1sKHJlc3BvbnNlKVxuICAgICAgICAgICAgIC50cmlnZ2VyKHRyaWdnZXIpO1xuICAgICAgICAkKHJlc3BvbnNlKS5mb3VuZGF0aW9uKCk7XG4gICAgICAgIF90aGlzLmN1cnJlbnRQYXRoID0gcGF0aDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gY29udGVudCBpbiBhbiBJbnRlcmNoYW5nZSBlbGVtZW50IGlzIGRvbmUgYmVpbmcgbG9hZGVkLlxuICAgICAqIEBldmVudCBJbnRlcmNoYW5nZSNyZXBsYWNlZFxuICAgICAqL1xuICAgIC8vIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncmVwbGFjZWQuemYuaW50ZXJjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBpbnRlcmNoYW5nZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIC8vVE9ETyB0aGlzLlxuICB9XG59XG5cbi8qKlxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gKi9cbkludGVyY2hhbmdlLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogUnVsZXMgdG8gYmUgYXBwbGllZCB0byBJbnRlcmNoYW5nZSBlbGVtZW50cy4gU2V0IHdpdGggdGhlIGBkYXRhLWludGVyY2hhbmdlYCBhcnJheSBub3RhdGlvbi5cbiAgICogQG9wdGlvblxuICAgKi9cbiAgcnVsZXM6IG51bGxcbn07XG5cbkludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFUyA9IHtcbiAgJ2xhbmRzY2FwZSc6ICdzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXG4gICdwb3J0cmFpdCc6ICdzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpJyxcbiAgJ3JldGluYSc6ICdvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyLzEpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxOTJkcGkpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweCknXG59O1xuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oSW50ZXJjaGFuZ2UsICdJbnRlcmNoYW5nZScpO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogTWFnZWxsYW4gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm1hZ2VsbGFuXG4gKi9cblxuY2xhc3MgTWFnZWxsYW4ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNYWdlbGxhbi5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBNYWdlbGxhbiNpbml0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgID0gJC5leHRlbmQoe30sIE1hZ2VsbGFuLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdNYWdlbGxhbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBNYWdlbGxhbiBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ21hZ2VsbGFuJyk7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLiR0YXJnZXRzID0gJCgnW2RhdGEtbWFnZWxsYW4tdGFyZ2V0XScpO1xuICAgIHRoaXMuJGxpbmtzID0gdGhpcy4kZWxlbWVudC5maW5kKCdhJyk7XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICdkYXRhLXJlc2l6ZSc6IGlkLFxuICAgICAgJ2RhdGEtc2Nyb2xsJzogaWQsXG4gICAgICAnaWQnOiBpZFxuICAgIH0pO1xuICAgIHRoaXMuJGFjdGl2ZSA9ICQoKTtcbiAgICB0aGlzLnNjcm9sbFBvcyA9IHBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwgMTApO1xuXG4gICAgdGhpcy5fZXZlbnRzKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhbiBhcnJheSBvZiBwaXhlbCB2YWx1ZXMgdGhhdCBhcmUgdGhlIGRlbWFyY2F0aW9uIGxpbmVzIGJldHdlZW4gbG9jYXRpb25zIG9uIHRoZSBwYWdlLlxuICAgKiBDYW4gYmUgaW52b2tlZCBpZiBuZXcgZWxlbWVudHMgYXJlIGFkZGVkIG9yIHRoZSBzaXplIG9mIGEgbG9jYXRpb24gY2hhbmdlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBjYWxjUG9pbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuICAgICAgICBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICB0aGlzLndpbkhlaWdodCA9IE1hdGgucm91bmQoTWF0aC5tYXgod2luZG93LmlubmVySGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCkpO1xuICAgIHRoaXMuZG9jSGVpZ2h0ID0gTWF0aC5yb3VuZChNYXRoLm1heChib2R5LnNjcm9sbEhlaWdodCwgYm9keS5vZmZzZXRIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5vZmZzZXRIZWlnaHQpKTtcblxuICAgIHRoaXMuJHRhcmdldHMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyICR0YXIgPSAkKHRoaXMpLFxuICAgICAgICAgIHB0ID0gTWF0aC5yb3VuZCgkdGFyLm9mZnNldCgpLnRvcCAtIF90aGlzLm9wdGlvbnMudGhyZXNob2xkKTtcbiAgICAgICR0YXIudGFyZ2V0UG9pbnQgPSBwdDtcbiAgICAgIF90aGlzLnBvaW50cy5wdXNoKHB0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIE1hZ2VsbGFuLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V2ZW50cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAkYm9keSA9ICQoJ2h0bWwsIGJvZHknKSxcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICBkdXJhdGlvbjogX3RoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6ICAgX3RoaXMub3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgfTtcbiAgICAkKHdpbmRvdykub25lKCdsb2FkJywgZnVuY3Rpb24oKXtcbiAgICAgIGlmKF90aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpe1xuICAgICAgICBpZihsb2NhdGlvbi5oYXNoKXtcbiAgICAgICAgICBfdGhpcy5zY3JvbGxUb0xvYyhsb2NhdGlvbi5oYXNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3RoaXMuY2FsY1BvaW50cygpO1xuICAgICAgX3RoaXMuX3VwZGF0ZUFjdGl2ZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMucmVmbG93LmJpbmQodGhpcyksXG4gICAgICAnc2Nyb2xsbWUuemYudHJpZ2dlcic6IHRoaXMuX3VwZGF0ZUFjdGl2ZS5iaW5kKHRoaXMpXG4gICAgfSkub24oJ2NsaWNrLnpmLm1hZ2VsbGFuJywgJ2FbaHJlZl49XCIjXCJdJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBhcnJpdmFsICAgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICBfdGhpcy5zY3JvbGxUb0xvYyhhcnJpdmFsKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBzY3JvbGwgdG8gYSBnaXZlbiBsb2NhdGlvbiBvbiB0aGUgcGFnZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGxvYyAtIGEgcHJvcGVybHkgZm9ybWF0dGVkIGpRdWVyeSBpZCBzZWxlY3Rvci4gRXhhbXBsZTogJyNmb28nXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgc2Nyb2xsVG9Mb2MobG9jKSB7XG4gICAgdmFyIHNjcm9sbFBvcyA9IE1hdGgucm91bmQoJChsb2MpLm9mZnNldCgpLnRvcCAtIHRoaXMub3B0aW9ucy50aHJlc2hvbGQgLyAyIC0gdGhpcy5vcHRpb25zLmJhck9mZnNldCk7XG5cbiAgICAkKCdodG1sLCBib2R5Jykuc3RvcCh0cnVlKS5hbmltYXRlKHsgc2Nyb2xsVG9wOiBzY3JvbGxQb3MgfSwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBNYWdlbGxhbiB1cG9uIERPTSBjaGFuZ2VcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICByZWZsb3coKSB7XG4gICAgdGhpcy5jYWxjUG9pbnRzKCk7XG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdmlzaWJpbGl0eSBvZiBhbiBhY3RpdmUgbG9jYXRpb24gbGluaywgYW5kIHVwZGF0ZXMgdGhlIHVybCBoYXNoIGZvciB0aGUgcGFnZSwgaWYgZGVlcExpbmtpbmcgZW5hYmxlZC5cbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBNYWdlbGxhbiN1cGRhdGVcbiAgICovXG4gIF91cGRhdGVBY3RpdmUoLypldnQsIGVsZW0sIHNjcm9sbFBvcyovKSB7XG4gICAgdmFyIHdpblBvcyA9IC8qc2Nyb2xsUG9zIHx8Ki8gcGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0LCAxMCksXG4gICAgICAgIGN1cklkeDtcblxuICAgIGlmKHdpblBvcyArIHRoaXMud2luSGVpZ2h0ID09PSB0aGlzLmRvY0hlaWdodCl7IGN1cklkeCA9IHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7IH1cbiAgICBlbHNlIGlmKHdpblBvcyA8IHRoaXMucG9pbnRzWzBdKXsgY3VySWR4ID0gMDsgfVxuICAgIGVsc2V7XG4gICAgICB2YXIgaXNEb3duID0gdGhpcy5zY3JvbGxQb3MgPCB3aW5Qb3MsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGN1clZpc2libGUgPSB0aGlzLnBvaW50cy5maWx0ZXIoZnVuY3Rpb24ocCwgaSl7XG4gICAgICAgICAgICByZXR1cm4gaXNEb3duID8gcCAtIF90aGlzLm9wdGlvbnMuYmFyT2Zmc2V0IDw9IHdpblBvcyA6IHAgLSBfdGhpcy5vcHRpb25zLmJhck9mZnNldCAtIF90aGlzLm9wdGlvbnMudGhyZXNob2xkIDw9IHdpblBvcztcbiAgICAgICAgICB9KTtcbiAgICAgIGN1cklkeCA9IGN1clZpc2libGUubGVuZ3RoID8gY3VyVmlzaWJsZS5sZW5ndGggLSAxIDogMDtcbiAgICB9XG5cbiAgICB0aGlzLiRhY3RpdmUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcbiAgICB0aGlzLiRhY3RpdmUgPSB0aGlzLiRsaW5rcy5lcShjdXJJZHgpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpe1xuICAgICAgdmFyIGhhc2ggPSB0aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICBpZih3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpe1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgaGFzaCk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2Nyb2xsUG9zID0gd2luUG9zO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gbWFnZWxsYW4gaXMgZmluaXNoZWQgdXBkYXRpbmcgdG8gdGhlIG5ldyBhY3RpdmUgZWxlbWVudC5cbiAgICAgKiBAZXZlbnQgTWFnZWxsYW4jdXBkYXRlXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cGRhdGUuemYubWFnZWxsYW4nLCBbdGhpcy4kYWN0aXZlXSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgTWFnZWxsYW4gYW5kIHJlc2V0cyB0aGUgdXJsIG9mIHRoZSB3aW5kb3cuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXIgLnpmLm1hZ2VsbGFuJylcbiAgICAgICAgLmZpbmQoYC4ke3RoaXMub3B0aW9ucy5hY3RpdmVDbGFzc31gKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXG4gICAgaWYodGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKXtcbiAgICAgIHZhciBoYXNoID0gdGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2gucmVwbGFjZShoYXNoLCAnJyk7XG4gICAgfVxuXG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gKi9cbk1hZ2VsbGFuLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogQW1vdW50IG9mIHRpbWUsIGluIG1zLCB0aGUgYW5pbWF0ZWQgc2Nyb2xsaW5nIHNob3VsZCB0YWtlIGJldHdlZW4gbG9jYXRpb25zLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDUwMFxuICAgKi9cbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLyoqXG4gICAqIEFuaW1hdGlvbiBzdHlsZSB0byB1c2Ugd2hlbiBzY3JvbGxpbmcgYmV0d2VlbiBsb2NhdGlvbnMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ2Vhc2UtaW4tb3V0J1xuICAgKi9cbiAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJyxcbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgdG8gdXNlIGFzIGEgbWFya2VyIGZvciBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDUwXG4gICAqL1xuICB0aHJlc2hvbGQ6IDUwLFxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYWN0aXZlIGxvY2F0aW9ucyBsaW5rIG9uIHRoZSBtYWdlbGxhbiBjb250YWluZXIuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ2FjdGl2ZSdcbiAgICovXG4gIGFjdGl2ZUNsYXNzOiAnYWN0aXZlJyxcbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgc2NyaXB0IHRvIG1hbmlwdWxhdGUgdGhlIHVybCBvZiB0aGUgY3VycmVudCBwYWdlLCBhbmQgaWYgc3VwcG9ydGVkLCBhbHRlciB0aGUgaGlzdG9yeS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBkZWVwTGlua2luZzogZmFsc2UsXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIG9mZnNldCB0aGUgc2Nyb2xsIG9mIHRoZSBwYWdlIG9uIGl0ZW0gY2xpY2sgaWYgdXNpbmcgYSBzdGlja3kgbmF2IGJhci5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAyNVxuICAgKi9cbiAgYmFyT2Zmc2V0OiAwXG59XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihNYWdlbGxhbiwgJ01hZ2VsbGFuJyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBPZmZDYW52YXMgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm9mZmNhbnZhc1xuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICovXG5cbmNsYXNzIE9mZkNhbnZhcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIG9mZi1jYW52YXMgd3JhcHBlci5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBPZmZDYW52YXMjaW5pdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gaW5pdGlhbGl6ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBPZmZDYW52YXMuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICB0aGlzLiRsYXN0VHJpZ2dlciA9ICQoKTtcbiAgICB0aGlzLiR0cmlnZ2VycyA9ICQoKTtcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgICB0aGlzLl9ldmVudHMoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ09mZkNhbnZhcycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBvZmYtY2FudmFzIHdyYXBwZXIgYnkgYWRkaW5nIHRoZSBleGl0IG92ZXJsYXkgKGlmIG5lZWRlZCkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xuXG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAvLyBGaW5kIHRyaWdnZXJzIHRoYXQgYWZmZWN0IHRoaXMgZWxlbWVudCBhbmQgYWRkIGFyaWEtZXhwYW5kZWQgdG8gdGhlbVxuICAgIHRoaXMuJHRyaWdnZXJzID0gJChkb2N1bWVudClcbiAgICAgIC5maW5kKCdbZGF0YS1vcGVuPVwiJytpZCsnXCJdLCBbZGF0YS1jbG9zZT1cIicraWQrJ1wiXSwgW2RhdGEtdG9nZ2xlPVwiJytpZCsnXCJdJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJylcbiAgICAgIC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgaWQpO1xuXG4gICAgLy8gQWRkIGEgY2xvc2UgdHJpZ2dlciBvdmVyIHRoZSBib2R5IGlmIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICBpZiAoJCgnLmpzLW9mZi1jYW52YXMtZXhpdCcpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiRleGl0ZXIgPSAkKCcuanMtb2ZmLWNhbnZhcy1leGl0Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhpdGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGV4aXRlci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2pzLW9mZi1jYW52YXMtZXhpdCcpO1xuICAgICAgICAkKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykuYXBwZW5kKGV4aXRlcik7XG5cbiAgICAgICAgdGhpcy4kZXhpdGVyID0gJChleGl0ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5pc1JldmVhbGVkID0gdGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQgfHwgbmV3IFJlZ0V4cCh0aGlzLm9wdGlvbnMucmV2ZWFsQ2xhc3MsICdnJykudGVzdCh0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5yZXZlYWxPbiA9IHRoaXMub3B0aW9ucy5yZXZlYWxPbiB8fCB0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHJldmVhbC1mb3ItbWVkaXVtfHJldmVhbC1mb3ItbGFyZ2UpL2cpWzBdLnNwbGl0KCctJylbMl07XG4gICAgICB0aGlzLl9zZXRNUUNoZWNrZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSA9IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoJCgnW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXScpWzBdKS50cmFuc2l0aW9uRHVyYXRpb24pICogMTAwMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBldmVudCBoYW5kbGVycyB0byB0aGUgb2ZmLWNhbnZhcyB3cmFwcGVyIGFuZCB0aGUgZXhpdCBvdmVybGF5LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ldmVudHMoKSB7XG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXMnKS5vbih7XG4gICAgICAnb3Blbi56Zi50cmlnZ2VyJzogdGhpcy5vcGVuLmJpbmQodGhpcyksXG4gICAgICAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuY2xvc2UuYmluZCh0aGlzKSxcbiAgICAgICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXG4gICAgICAna2V5ZG93bi56Zi5vZmZjYW52YXMnOiB0aGlzLl9oYW5kbGVLZXlib2FyZC5iaW5kKHRoaXMpXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiB0aGlzLiRleGl0ZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLiRleGl0ZXIub24oeydjbGljay56Zi5vZmZjYW52YXMnOiB0aGlzLmNsb3NlLmJpbmQodGhpcyl9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBldmVudCBsaXN0ZW5lciBmb3IgZWxlbWVudHMgdGhhdCB3aWxsIHJldmVhbCBhdCBjZXJ0YWluIGJyZWFrcG9pbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE1RQ2hlY2tlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdChfdGhpcy5vcHRpb25zLnJldmVhbE9uKSkge1xuICAgICAgICBfdGhpcy5yZXZlYWwodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5yZXZlYWwoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pLm9uZSgnbG9hZC56Zi5vZmZjYW52YXMnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdChfdGhpcy5vcHRpb25zLnJldmVhbE9uKSkge1xuICAgICAgICBfdGhpcy5yZXZlYWwodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgcmV2ZWFsaW5nL2hpZGluZyB0aGUgb2ZmLWNhbnZhcyBhdCBicmVha3BvaW50cywgbm90IHRoZSBzYW1lIGFzIG9wZW4uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSZXZlYWxlZCAtIHRydWUgaWYgZWxlbWVudCBzaG91bGQgYmUgcmV2ZWFsZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgcmV2ZWFsKGlzUmV2ZWFsZWQpIHtcbiAgICB2YXIgJGNsb3NlciA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtY2xvc2VdJyk7XG4gICAgaWYgKGlzUmV2ZWFsZWQpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHRoaXMuaXNSZXZlYWxlZCA9IHRydWU7XG4gICAgICAvLyBpZiAoIXRoaXMub3B0aW9ucy5mb3JjZVRvcCkge1xuICAgICAgLy8gICB2YXIgc2Nyb2xsUG9zID0gcGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAgIC8vICAgdGhpcy4kZWxlbWVudFswXS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsJyArIHNjcm9sbFBvcyArICdweCknO1xuICAgICAgLy8gfVxuICAgICAgLy8gaWYgKHRoaXMub3B0aW9ucy5pc1N0aWNreSkgeyB0aGlzLl9zdGljaygpOyB9XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignb3Blbi56Zi50cmlnZ2VyIHRvZ2dsZS56Zi50cmlnZ2VyJyk7XG4gICAgICBpZiAoJGNsb3Nlci5sZW5ndGgpIHsgJGNsb3Nlci5oaWRlKCk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc1JldmVhbGVkID0gZmFsc2U7XG4gICAgICAvLyBpZiAodGhpcy5vcHRpb25zLmlzU3RpY2t5IHx8ICF0aGlzLm9wdGlvbnMuZm9yY2VUb3ApIHtcbiAgICAgIC8vICAgdGhpcy4kZWxlbWVudFswXS5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAgIC8vICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLnpmLm9mZmNhbnZhcycpO1xuICAgICAgLy8gfVxuICAgICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcbiAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKVxuICAgICAgfSk7XG4gICAgICBpZiAoJGNsb3Nlci5sZW5ndGgpIHtcbiAgICAgICAgJGNsb3Nlci5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBvZmYtY2FudmFzIG1lbnUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBvYmplY3QgcGFzc2VkIGZyb20gbGlzdGVuZXIuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSB0cmlnZ2VyIC0gZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgb2ZmLWNhbnZhcyB0byBvcGVuLlxuICAgKiBAZmlyZXMgT2ZmQ2FudmFzI29wZW5lZFxuICAgKi9cbiAgb3BlbihldmVudCwgdHJpZ2dlcikge1xuICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykgfHwgdGhpcy5pc1JldmVhbGVkKSB7IHJldHVybjsgfVxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICRib2R5ID0gJChkb2N1bWVudC5ib2R5KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VUb3ApIHtcbiAgICAgICQoJ2JvZHknKS5zY3JvbGxUb3AoMCk7XG4gICAgfVxuICAgIC8vIHdpbmRvdy5wYWdlWU9mZnNldCA9IDA7XG5cbiAgICAvLyBpZiAoIXRoaXMub3B0aW9ucy5mb3JjZVRvcCkge1xuICAgIC8vICAgdmFyIHNjcm9sbFBvcyA9IHBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgLy8gICB0aGlzLiRlbGVtZW50WzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwnICsgc2Nyb2xsUG9zICsgJ3B4KSc7XG4gICAgLy8gICBpZiAodGhpcy4kZXhpdGVyLmxlbmd0aCkge1xuICAgIC8vICAgICB0aGlzLiRleGl0ZXJbMF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBzY3JvbGxQb3MgKyAncHgpJztcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW5zLlxuICAgICAqIEBldmVudCBPZmZDYW52YXMjb3BlbmVkXG4gICAgICovXG4gICAgRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSwgdGhpcy4kZWxlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAkKCdbZGF0YS1vZmYtY2FudmFzLXdyYXBwZXJdJykuYWRkQ2xhc3MoJ2lzLW9mZi1jYW52YXMtb3BlbiBpcy1vcGVuLScrIF90aGlzLm9wdGlvbnMucG9zaXRpb24pO1xuXG4gICAgICBfdGhpcy4kZWxlbWVudFxuICAgICAgICAuYWRkQ2xhc3MoJ2lzLW9wZW4nKVxuXG4gICAgICAvLyBpZiAoX3RoaXMub3B0aW9ucy5pc1N0aWNreSkge1xuICAgICAgLy8gICBfdGhpcy5fc3RpY2soKTtcbiAgICAgIC8vIH1cbiAgICB9KTtcblxuICAgIHRoaXMuJHRyaWdnZXJzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKVxuICAgICAgICAudHJpZ2dlcignb3BlbmVkLnpmLm9mZmNhbnZhcycpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcbiAgICAgIHRoaXMuJGV4aXRlci5hZGRDbGFzcygnaXMtdmlzaWJsZScpO1xuICAgIH1cblxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICB0aGlzLiRsYXN0VHJpZ2dlciA9IHRyaWdnZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvRm9jdXMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCh0aGlzLiRlbGVtZW50KSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLiRlbGVtZW50LmZpbmQoJ2EsIGJ1dHRvbicpLmVxKDApLmZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRyYXBGb2N1cykge1xuICAgICAgJCgnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICB0aGlzLl90cmFwRm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhcHMgZm9jdXMgd2l0aGluIHRoZSBvZmZjYW52YXMgb24gb3Blbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cmFwRm9jdXMoKSB7XG4gICAgdmFyIGZvY3VzYWJsZSA9IEZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KSxcbiAgICAgICAgZmlyc3QgPSBmb2N1c2FibGUuZXEoMCksXG4gICAgICAgIGxhc3QgPSBmb2N1c2FibGUuZXEoLTEpO1xuXG4gICAgZm9jdXNhYmxlLm9mZignLnpmLm9mZmNhbnZhcycpLm9uKCdrZXlkb3duLnpmLm9mZmNhbnZhcycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLndoaWNoID09PSA5IHx8IGUua2V5Y29kZSA9PT0gOSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGxhc3RbMF0gJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZmlyc3QuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGZpcnN0WzBdICYmIGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgbGFzdC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHRoZSBvZmZjYW52YXMgdG8gYXBwZWFyIHN0aWNreSB1dGlsaXppbmcgdHJhbnNsYXRlIHByb3BlcnRpZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvLyBPZmZDYW52YXMucHJvdG90eXBlLl9zdGljayA9IGZ1bmN0aW9uKCkge1xuICAvLyAgIHZhciBlbFN0eWxlID0gdGhpcy4kZWxlbWVudFswXS5zdHlsZTtcbiAgLy9cbiAgLy8gICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xuICAvLyAgICAgdmFyIGV4aXRTdHlsZSA9IHRoaXMuJGV4aXRlclswXS5zdHlsZTtcbiAgLy8gICB9XG4gIC8vXG4gIC8vICAgJCh3aW5kb3cpLm9uKCdzY3JvbGwuemYub2ZmY2FudmFzJywgZnVuY3Rpb24oZSkge1xuICAvLyAgICAgY29uc29sZS5sb2coZSk7XG4gIC8vICAgICB2YXIgcGFnZVkgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gIC8vICAgICBlbFN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwnICsgcGFnZVkgKyAncHgpJztcbiAgLy8gICAgIGlmIChleGl0U3R5bGUgIT09IHVuZGVmaW5lZCkgeyBleGl0U3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBwYWdlWSArICdweCknOyB9XG4gIC8vICAgfSk7XG4gIC8vICAgLy8gdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzdHVjay56Zi5vZmZjYW52YXMnKTtcbiAgLy8gfTtcbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgb2ZmLWNhbnZhcyBtZW51LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYiB0byBmaXJlIGFmdGVyIGNsb3N1cmUuXG4gICAqIEBmaXJlcyBPZmZDYW52YXMjY2xvc2VkXG4gICAqL1xuICBjbG9zZShjYikge1xuICAgIGlmICghdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpIHx8IHRoaXMuaXNSZXZlYWxlZCkgeyByZXR1cm47IH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyAgRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSwgdGhpcy4kZWxlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgJCgnW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXScpLnJlbW92ZUNsYXNzKGBpcy1vZmYtY2FudmFzLW9wZW4gaXMtb3Blbi0ke190aGlzLm9wdGlvbnMucG9zaXRpb259YCk7XG4gICAgX3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKTtcbiAgICAgIC8vIEZvdW5kYXRpb24uX3JlZmxvdygpO1xuICAgIC8vIH0pO1xuICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cbiAgICAgICAqIEBldmVudCBPZmZDYW52YXMjY2xvc2VkXG4gICAgICAgKi9cbiAgICAgICAgLnRyaWdnZXIoJ2Nsb3NlZC56Zi5vZmZjYW52YXMnKTtcbiAgICAvLyBpZiAoX3RoaXMub3B0aW9ucy5pc1N0aWNreSB8fCAhX3RoaXMub3B0aW9ucy5mb3JjZVRvcCkge1xuICAgIC8vICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgX3RoaXMuJGVsZW1lbnRbMF0uc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgLy8gICAgICQod2luZG93KS5vZmYoJ3Njcm9sbC56Zi5vZmZjYW52YXMnKTtcbiAgICAvLyAgIH0sIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSk7XG4gICAgLy8gfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICB0aGlzLiRleGl0ZXIucmVtb3ZlQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLiR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMpIHtcbiAgICAgICQoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBvZmYtY2FudmFzIG1lbnUgb3BlbiBvciBjbG9zZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBvYmplY3QgcGFzc2VkIGZyb20gbGlzdGVuZXIuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSB0cmlnZ2VyIC0gZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgb2ZmLWNhbnZhcyB0byBvcGVuLlxuICAgKi9cbiAgdG9nZ2xlKGV2ZW50LCB0cmlnZ2VyKSB7XG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xuICAgICAgdGhpcy5jbG9zZShldmVudCwgdHJpZ2dlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5vcGVuKGV2ZW50LCB0cmlnZ2VyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBrZXlib2FyZCBpbnB1dCB3aGVuIGRldGVjdGVkLiBXaGVuIHRoZSBlc2NhcGUga2V5IGlzIHByZXNzZWQsIHRoZSBvZmYtY2FudmFzIG1lbnUgY2xvc2VzLCBhbmQgZm9jdXMgaXMgcmVzdG9yZWQgdG8gdGhlIGVsZW1lbnQgdGhhdCBvcGVuZWQgdGhlIG1lbnUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZUtleWJvYXJkKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LndoaWNoICE9PSAyNykgcmV0dXJuO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy4kbGFzdFRyaWdnZXIuZm9jdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgb2ZmY2FudmFzIHBsdWdpbi5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXIgLnpmLm9mZmNhbnZhcycpO1xuICAgIHRoaXMuJGV4aXRlci5vZmYoJy56Zi5vZmZjYW52YXMnKTtcblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5PZmZDYW52YXMuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgdXNlciB0byBjbGljayBvdXRzaWRlIG9mIHRoZSBtZW51IHRvIGNsb3NlIGl0LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGNsb3NlT25DbGljazogdHJ1ZSxcblxuICAvKipcbiAgICogQW1vdW50IG9mIHRpbWUgaW4gbXMgdGhlIG9wZW4gYW5kIGNsb3NlIHRyYW5zaXRpb24gcmVxdWlyZXMuIElmIG5vbmUgc2VsZWN0ZWQsIHB1bGxzIGZyb20gYm9keSBzdHlsZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSA1MDBcbiAgICovXG4gIHRyYW5zaXRpb25UaW1lOiAwLFxuXG4gIC8qKlxuICAgKiBEaXJlY3Rpb24gdGhlIG9mZmNhbnZhcyBvcGVucyBmcm9tLiBEZXRlcm1pbmVzIGNsYXNzIGFwcGxpZWQgdG8gYm9keS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBsZWZ0XG4gICAqL1xuICBwb3NpdGlvbjogJ2xlZnQnLFxuXG4gIC8qKlxuICAgKiBGb3JjZSB0aGUgcGFnZSB0byBzY3JvbGwgdG8gdG9wIG9uIG9wZW4uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgZm9yY2VUb3A6IHRydWUsXG5cbiAgLyoqXG4gICAqIEFsbG93IHRoZSBvZmZjYW52YXMgdG8gcmVtYWluIG9wZW4gZm9yIGNlcnRhaW4gYnJlYWtwb2ludHMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGlzUmV2ZWFsZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBCcmVha3BvaW50IGF0IHdoaWNoIHRvIHJldmVhbC4gSlMgd2lsbCB1c2UgYSBSZWdFeHAgdG8gdGFyZ2V0IHN0YW5kYXJkIGNsYXNzZXMsIGlmIGNoYW5naW5nIGNsYXNzbmFtZXMsIHBhc3MgeW91ciBjbGFzcyB3aXRoIHRoZSBgcmV2ZWFsQ2xhc3NgIG9wdGlvbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSByZXZlYWwtZm9yLWxhcmdlXG4gICAqL1xuICByZXZlYWxPbjogbnVsbCxcblxuICAvKipcbiAgICogRm9yY2UgZm9jdXMgdG8gdGhlIG9mZmNhbnZhcyBvbiBvcGVuLiBJZiB0cnVlLCB3aWxsIGZvY3VzIHRoZSBvcGVuaW5nIHRyaWdnZXIgb24gY2xvc2UuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgYXV0b0ZvY3VzOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBDbGFzcyB1c2VkIHRvIGZvcmNlIGFuIG9mZmNhbnZhcyB0byByZW1haW4gb3Blbi4gRm91bmRhdGlvbiBkZWZhdWx0cyBmb3IgdGhpcyBhcmUgYHJldmVhbC1mb3ItbGFyZ2VgICYgYHJldmVhbC1mb3ItbWVkaXVtYC5cbiAgICogQG9wdGlvblxuICAgKiBUT0RPIGltcHJvdmUgdGhlIHJlZ2V4IHRlc3RpbmcgZm9yIHRoaXMuXG4gICAqIEBleGFtcGxlIHJldmVhbC1mb3ItbGFyZ2VcbiAgICovXG4gIHJldmVhbENsYXNzOiAncmV2ZWFsLWZvci0nLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBvcHRpb25hbCBmb2N1cyB0cmFwcGluZyB3aGVuIG9wZW5pbmcgYW4gb2ZmY2FudmFzLiBTZXRzIHRhYmluZGV4IG9mIFtkYXRhLW9mZi1jYW52YXMtY29udGVudF0gdG8gLTEgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgdHJhcEZvY3VzOiBmYWxzZVxufVxuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oT2ZmQ2FudmFzLCAnT2ZmQ2FudmFzJyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBPcmJpdCBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ub3JiaXRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRpbWVyQW5kSW1hZ2VMb2FkZXJcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudG91Y2hcbiAqL1xuXG5jbGFzcyBPcmJpdCB7XG4gIC8qKlxuICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gb3JiaXQgY2Fyb3VzZWwuXG4gICogQGNsYXNzXG4gICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBPcmJpdCBDYXJvdXNlbC5cbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpe1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBPcmJpdC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnT3JiaXQnKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdPcmJpdCcsIHtcbiAgICAgICdsdHInOiB7XG4gICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnXG4gICAgICB9LFxuICAgICAgJ3J0bCc6IHtcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAnbmV4dCcsXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICdwcmV2aW91cydcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4gYnkgY3JlYXRpbmcgalF1ZXJ5IGNvbGxlY3Rpb25zLCBzZXR0aW5nIGF0dHJpYnV0ZXMsIGFuZCBzdGFydGluZyB0aGUgYW5pbWF0aW9uLlxuICAqIEBmdW5jdGlvblxuICAqIEBwcml2YXRlXG4gICovXG4gIF9pbml0KCkge1xuICAgIHRoaXMuJHdyYXBwZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoYC4ke3RoaXMub3B0aW9ucy5jb250YWluZXJDbGFzc31gKTtcbiAgICB0aGlzLiRzbGlkZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoYC4ke3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzfWApO1xuICAgIHZhciAkaW1hZ2VzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKSxcbiAgICBpbml0QWN0aXZlID0gdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpO1xuXG4gICAgaWYgKCFpbml0QWN0aXZlLmxlbmd0aCkge1xuICAgICAgdGhpcy4kc2xpZGVzLmVxKDApLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VNVUkpIHtcbiAgICAgIHRoaXMuJHNsaWRlcy5hZGRDbGFzcygnbm8tbW90aW9udWknKTtcbiAgICB9XG5cbiAgICBpZiAoJGltYWdlcy5sZW5ndGgpIHtcbiAgICAgIEZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQoJGltYWdlcywgdGhpcy5fcHJlcGFyZUZvck9yYml0LmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcmVwYXJlRm9yT3JiaXQoKTsvL2hlaGVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcbiAgICAgIHRoaXMuX2xvYWRCdWxsZXRzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmIHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLmdlb1N5bmMoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmFjY2Vzc2libGUpIHsgLy8gYWxsb3cgd3JhcHBlciB0byBiZSBmb2N1c2FibGUgdG8gZW5hYmxlIGFycm93IG5hdmlnYXRpb25cbiAgICAgIHRoaXMuJHdyYXBwZXIuYXR0cigndGFiaW5kZXgnLCAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBDcmVhdGVzIGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgYnVsbGV0cywgaWYgdGhleSBhcmUgYmVpbmcgdXNlZC5cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBfbG9hZEJ1bGxldHMoKSB7XG4gICAgdGhpcy4kYnVsbGV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZChgLiR7dGhpcy5vcHRpb25zLmJveE9mQnVsbGV0c31gKS5maW5kKCdidXR0b24nKTtcbiAgfVxuXG4gIC8qKlxuICAqIFNldHMgYSBgdGltZXJgIG9iamVjdCBvbiB0aGUgb3JiaXQsIGFuZCBzdGFydHMgdGhlIGNvdW50ZXIgZm9yIHRoZSBuZXh0IHNsaWRlLlxuICAqIEBmdW5jdGlvblxuICAqL1xuICBnZW9TeW5jKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy50aW1lciA9IG5ldyBGb3VuZGF0aW9uLlRpbWVyKFxuICAgICAgdGhpcy4kZWxlbWVudCxcbiAgICAgIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy50aW1lckRlbGF5LFxuICAgICAgICBpbmZpbml0ZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB0aGlzLnRpbWVyLnN0YXJ0KCk7XG4gIH1cblxuICAvKipcbiAgKiBTZXRzIHdyYXBwZXIgYW5kIHNsaWRlIGhlaWdodHMgZm9yIHRoZSBvcmJpdC5cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBfcHJlcGFyZUZvck9yYml0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fc2V0V3JhcHBlckhlaWdodChmdW5jdGlvbihtYXgpe1xuICAgICAgX3RoaXMuX3NldFNsaWRlSGVpZ2h0KG1heCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBDYWx1bGF0ZXMgdGhlIGhlaWdodCBvZiBlYWNoIHNsaWRlIGluIHRoZSBjb2xsZWN0aW9uLCBhbmQgdXNlcyB0aGUgdGFsbGVzdCBvbmUgZm9yIHRoZSB3cmFwcGVyIGhlaWdodC5cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gYSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIHdoZW4gY29tcGxldGUuXG4gICovXG4gIF9zZXRXcmFwcGVySGVpZ2h0KGNiKSB7Ly9yZXdyaXRlIHRoaXMgdG8gYGZvcmAgbG9vcFxuICAgIHZhciBtYXggPSAwLCB0ZW1wLCBjb3VudGVyID0gMDtcblxuICAgIHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdGVtcCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgJCh0aGlzKS5hdHRyKCdkYXRhLXNsaWRlJywgY291bnRlcik7XG5cbiAgICAgIGlmIChjb3VudGVyKSB7Ly9pZiBub3QgdGhlIGZpcnN0IHNsaWRlLCBzZXQgY3NzIHBvc2l0aW9uIGFuZCBkaXNwbGF5IHByb3BlcnR5XG4gICAgICAgICQodGhpcykuY3NzKHsncG9zaXRpb24nOiAncmVsYXRpdmUnLCAnZGlzcGxheSc6ICdub25lJ30pO1xuICAgICAgfVxuICAgICAgbWF4ID0gdGVtcCA+IG1heCA/IHRlbXAgOiBtYXg7XG4gICAgICBjb3VudGVyKys7XG4gICAgfSk7XG5cbiAgICBpZiAoY291bnRlciA9PT0gdGhpcy4kc2xpZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy4kd3JhcHBlci5jc3MoeydoZWlnaHQnOiBtYXh9KTsgLy9vbmx5IGNoYW5nZSB0aGUgd3JhcHBlciBoZWlnaHQgcHJvcGVydHkgb25jZS5cbiAgICAgIGNiKG1heCk7IC8vZmlyZSBjYWxsYmFjayB3aXRoIG1heCBoZWlnaHQgZGltZW5zaW9uLlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIFNldHMgdGhlIG1heC1oZWlnaHQgb2YgZWFjaCBzbGlkZS5cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBfc2V0U2xpZGVIZWlnaHQoaGVpZ2h0KSB7XG4gICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAkKHRoaXMpLmNzcygnbWF4LWhlaWdodCcsIGhlaWdodCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byBiYXNpY2FsbHkgZXZlcnl0aGluZyB3aXRoaW4gdGhlIGVsZW1lbnQuXG4gICogQGZ1bmN0aW9uXG4gICogQHByaXZhdGVcbiAgKi9cbiAgX2V2ZW50cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyoqTm93IHVzaW5nIGN1c3RvbSBldmVudCAtIHRoYW5rcyB0bzoqKlxuICAgIC8vKiogICAgICBZb2hhaSBBcmFyYXQgb2YgVG9yb250byAgICAgICoqXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBpZiAodGhpcy4kc2xpZGVzLmxlbmd0aCA+IDEpIHtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zd2lwZSkge1xuICAgICAgICB0aGlzLiRzbGlkZXMub2ZmKCdzd2lwZWxlZnQuemYub3JiaXQgc3dpcGVyaWdodC56Zi5vcmJpdCcpXG4gICAgICAgIC5vbignc3dpcGVsZWZ0LnpmLm9yYml0JywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKHRydWUpO1xuICAgICAgICB9KS5vbignc3dpcGVyaWdodC56Zi5vcmJpdCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUGxheSkge1xuICAgICAgICB0aGlzLiRzbGlkZXMub24oJ2NsaWNrLnpmLm9yYml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJywgX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgICAgIF90aGlzLnRpbWVyW190aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpID8gJ3BhdXNlJyA6ICdzdGFydCddKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGF1c2VPbkhvdmVyKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2VlbnRlci56Zi5vcmJpdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3RoaXMudGltZXIucGF1c2UoKTtcbiAgICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5vcmJpdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nKSkge1xuICAgICAgICAgICAgICBfdGhpcy50aW1lci5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubmF2QnV0dG9ucykge1xuICAgICAgICB2YXIgJGNvbnRyb2xzID0gdGhpcy4kZWxlbWVudC5maW5kKGAuJHt0aGlzLm9wdGlvbnMubmV4dENsYXNzfSwgLiR7dGhpcy5vcHRpb25zLnByZXZDbGFzc31gKTtcbiAgICAgICAgJGNvbnRyb2xzLmF0dHIoJ3RhYmluZGV4JywgMClcbiAgICAgICAgLy9hbHNvIG5lZWQgdG8gaGFuZGxlIGVudGVyL3JldHVybiBhbmQgc3BhY2ViYXIga2V5IHByZXNzZXNcbiAgICAgICAgLm9uKCdjbGljay56Zi5vcmJpdCB0b3VjaGVuZC56Zi5vcmJpdCcsIGZ1bmN0aW9uKGUpe1xuXHQgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSgkKHRoaXMpLmhhc0NsYXNzKF90aGlzLm9wdGlvbnMubmV4dENsYXNzKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcbiAgICAgICAgdGhpcy4kYnVsbGV0cy5vbignY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoL2lzLWFjdGl2ZS9nLnRlc3QodGhpcy5jbGFzc05hbWUpKSB7IHJldHVybiBmYWxzZTsgfS8vaWYgdGhpcyBpcyBhY3RpdmUsIGtpY2sgb3V0IG9mIGZ1bmN0aW9uLlxuICAgICAgICAgIHZhciBpZHggPSAkKHRoaXMpLmRhdGEoJ3NsaWRlJyksXG4gICAgICAgICAgbHRyID0gaWR4ID4gX3RoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKS5kYXRhKCdzbGlkZScpLFxuICAgICAgICAgICRzbGlkZSA9IF90aGlzLiRzbGlkZXMuZXEoaWR4KTtcblxuICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKGx0ciwgJHNsaWRlLCBpZHgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kd3JhcHBlci5hZGQodGhpcy4kYnVsbGV0cykub24oJ2tleWRvd24uemYub3JiaXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcbiAgICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ09yYml0Jywge1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbigpIHsgLy8gaWYgYnVsbGV0IGlzIGZvY3VzZWQsIG1ha2Ugc3VyZSBmb2N1cyBtb3Zlc1xuICAgICAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKF90aGlzLiRidWxsZXRzKSkge1xuICAgICAgICAgICAgICBfdGhpcy4kYnVsbGV0cy5maWx0ZXIoJy5pcy1hY3RpdmUnKS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHNsaWRlIHRvIGEgbmV3IG9uZS5cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzTFRSIC0gZmxhZyBpZiB0aGUgc2xpZGUgc2hvdWxkIG1vdmUgbGVmdCB0byByaWdodC5cbiAgKiBAcGFyYW0ge2pRdWVyeX0gY2hvc2VuU2xpZGUgLSB0aGUgalF1ZXJ5IGVsZW1lbnQgb2YgdGhlIHNsaWRlIHRvIHNob3cgbmV4dCwgaWYgb25lIGlzIHNlbGVjdGVkLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIG5ldyBzbGlkZSBpbiBpdHMgY29sbGVjdGlvbiwgaWYgb25lIGNob3Nlbi5cbiAgKiBAZmlyZXMgT3JiaXQjc2xpZGVjaGFuZ2VcbiAgKi9cbiAgY2hhbmdlU2xpZGUoaXNMVFIsIGNob3NlblNsaWRlLCBpZHgpIHtcbiAgICB2YXIgJGN1clNsaWRlID0gdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLmVxKDApO1xuXG4gICAgaWYgKC9tdWkvZy50ZXN0KCRjdXJTbGlkZVswXS5jbGFzc05hbWUpKSB7IHJldHVybiBmYWxzZTsgfSAvL2lmIHRoZSBzbGlkZSBpcyBjdXJyZW50bHkgYW5pbWF0aW5nLCBraWNrIG91dCBvZiB0aGUgZnVuY3Rpb25cblxuICAgIHZhciAkZmlyc3RTbGlkZSA9IHRoaXMuJHNsaWRlcy5maXJzdCgpLFxuICAgICRsYXN0U2xpZGUgPSB0aGlzLiRzbGlkZXMubGFzdCgpLFxuICAgIGRpckluID0gaXNMVFIgPyAnUmlnaHQnIDogJ0xlZnQnLFxuICAgIGRpck91dCA9IGlzTFRSID8gJ0xlZnQnIDogJ1JpZ2h0JyxcbiAgICBfdGhpcyA9IHRoaXMsXG4gICAgJG5ld1NsaWRlO1xuXG4gICAgaWYgKCFjaG9zZW5TbGlkZSkgeyAvL21vc3Qgb2YgdGhlIHRpbWUsIHRoaXMgd2lsbCBiZSBhdXRvIHBsYXllZCBvciBjbGlja2VkIGZyb20gdGhlIG5hdkJ1dHRvbnMuXG4gICAgICAkbmV3U2xpZGUgPSBpc0xUUiA/IC8vaWYgd3JhcHBpbmcgZW5hYmxlZCwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGEgYG5leHRgIG9yIGBwcmV2YCBzaWJsaW5nLCBpZiBub3QsIHNlbGVjdCB0aGUgZmlyc3Qgb3IgbGFzdCBzbGlkZSB0byBmaWxsIGluLiBpZiB3cmFwcGluZyBub3QgZW5hYmxlZCwgYXR0ZW1wdCB0byBzZWxlY3QgYG5leHRgIG9yIGBwcmV2YCwgaWYgdGhlcmUncyBub3RoaW5nIHRoZXJlLCB0aGUgZnVuY3Rpb24gd2lsbCBraWNrIG91dCBvbiBuZXh0IHN0ZXAuIENSQVpZIE5FU1RFRCBURVJOQVJJRVMhISEhIVxuICAgICAgKHRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXAgPyAkY3VyU2xpZGUubmV4dChgLiR7dGhpcy5vcHRpb25zLnNsaWRlQ2xhc3N9YCkubGVuZ3RoID8gJGN1clNsaWRlLm5leHQoYC4ke3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzfWApIDogJGZpcnN0U2xpZGUgOiAkY3VyU2xpZGUubmV4dChgLiR7dGhpcy5vcHRpb25zLnNsaWRlQ2xhc3N9YCkpLy9waWNrIG5leHQgc2xpZGUgaWYgbW92aW5nIGxlZnQgdG8gcmlnaHRcbiAgICAgIDpcbiAgICAgICh0aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwID8gJGN1clNsaWRlLnByZXYoYC4ke3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzfWApLmxlbmd0aCA/ICRjdXJTbGlkZS5wcmV2KGAuJHt0aGlzLm9wdGlvbnMuc2xpZGVDbGFzc31gKSA6ICRsYXN0U2xpZGUgOiAkY3VyU2xpZGUucHJldihgLiR7dGhpcy5vcHRpb25zLnNsaWRlQ2xhc3N9YCkpOy8vcGljayBwcmV2IHNsaWRlIGlmIG1vdmluZyByaWdodCB0byBsZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgICRuZXdTbGlkZSA9IGNob3NlblNsaWRlO1xuICAgIH1cblxuICAgIGlmICgkbmV3U2xpZGUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcbiAgICAgICAgaWR4ID0gaWR4IHx8IHRoaXMuJHNsaWRlcy5pbmRleCgkbmV3U2xpZGUpOyAvL2dyYWIgaW5kZXggdG8gdXBkYXRlIGJ1bGxldHNcbiAgICAgICAgdGhpcy5fdXBkYXRlQnVsbGV0cyhpZHgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVzZU1VSSkge1xuICAgICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4oXG4gICAgICAgICAgJG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5jc3Moeydwb3NpdGlvbic6ICdhYnNvbHV0ZScsICd0b3AnOiAwfSksXG4gICAgICAgICAgdGhpcy5vcHRpb25zW2BhbmltSW5Gcm9tJHtkaXJJbn1gXSxcbiAgICAgICAgICBmdW5jdGlvbigpe1xuICAgICAgICAgICAgJG5ld1NsaWRlLmNzcyh7J3Bvc2l0aW9uJzogJ3JlbGF0aXZlJywgJ2Rpc3BsYXknOiAnYmxvY2snfSlcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQoXG4gICAgICAgICAgJGN1clNsaWRlLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKSxcbiAgICAgICAgICB0aGlzLm9wdGlvbnNbYGFuaW1PdXRUbyR7ZGlyT3V0fWBdLFxuICAgICAgICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkY3VyU2xpZGUucmVtb3ZlQXR0cignYXJpYS1saXZlJyk7XG4gICAgICAgICAgICBpZihfdGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmICFfdGhpcy50aW1lci5pc1BhdXNlZCl7XG4gICAgICAgICAgICAgIF90aGlzLnRpbWVyLnJlc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vZG8gc3R1ZmY/XG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkY3VyU2xpZGUucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1pbicpLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpLmhpZGUoKTtcbiAgICAgICAgJG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUgaXMtaW4nKS5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJykuc2hvdygpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmICF0aGlzLnRpbWVyLmlzUGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy50aW1lci5yZXN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAvKipcbiAgICAqIFRyaWdnZXJzIHdoZW4gdGhlIHNsaWRlIGhhcyBmaW5pc2hlZCBhbmltYXRpbmcgaW4uXG4gICAgKiBAZXZlbnQgT3JiaXQjc2xpZGVjaGFuZ2VcbiAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzbGlkZWNoYW5nZS56Zi5vcmJpdCcsIFskbmV3U2xpZGVdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBVcGRhdGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGJ1bGxldHMsIGlmIGRpc3BsYXllZC5cbiAgKiBAZnVuY3Rpb25cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgc2xpZGUuXG4gICovXG4gIF91cGRhdGVCdWxsZXRzKGlkeCkge1xuICAgIHZhciAkb2xkQnVsbGV0ID0gdGhpcy4kZWxlbWVudC5maW5kKGAuJHt0aGlzLm9wdGlvbnMuYm94T2ZCdWxsZXRzfWApXG4gICAgLmZpbmQoJy5pcy1hY3RpdmUnKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJykuYmx1cigpLFxuICAgIHNwYW4gPSAkb2xkQnVsbGV0LmZpbmQoJ3NwYW46bGFzdCcpLmRldGFjaCgpLFxuICAgICRuZXdCdWxsZXQgPSB0aGlzLiRidWxsZXRzLmVxKGlkeCkuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmFwcGVuZChzcGFuKTtcbiAgfVxuXG4gIC8qKlxuICAqIERlc3Ryb3lzIHRoZSBjYXJvdXNlbCBhbmQgaGlkZXMgdGhlIGVsZW1lbnQuXG4gICogQGZ1bmN0aW9uXG4gICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5vcmJpdCcpLmZpbmQoJyonKS5vZmYoJy56Zi5vcmJpdCcpLmVuZCgpLmhpZGUoKTtcbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cbn1cblxuT3JiaXQuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAqIFRlbGxzIHRoZSBKUyB0byBsb29rIGZvciBhbmQgbG9hZEJ1bGxldHMuXG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlIHRydWVcbiAgKi9cbiAgYnVsbGV0czogdHJ1ZSxcbiAgLyoqXG4gICogVGVsbHMgdGhlIEpTIHRvIGFwcGx5IGV2ZW50IGxpc3RlbmVycyB0byBuYXYgYnV0dG9uc1xuICAqIEBvcHRpb25cbiAgKiBAZXhhbXBsZSB0cnVlXG4gICovXG4gIG5hdkJ1dHRvbnM6IHRydWUsXG4gIC8qKlxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgJ3NsaWRlLWluLXJpZ2h0J1xuICAqL1xuICBhbmltSW5Gcm9tUmlnaHQ6ICdzbGlkZS1pbi1yaWdodCcsXG4gIC8qKlxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgJ3NsaWRlLW91dC1yaWdodCdcbiAgKi9cbiAgYW5pbU91dFRvUmlnaHQ6ICdzbGlkZS1vdXQtcmlnaHQnLFxuICAvKipcbiAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlICdzbGlkZS1pbi1sZWZ0J1xuICAqXG4gICovXG4gIGFuaW1JbkZyb21MZWZ0OiAnc2xpZGUtaW4tbGVmdCcsXG4gIC8qKlxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgJ3NsaWRlLW91dC1sZWZ0J1xuICAqL1xuICBhbmltT3V0VG9MZWZ0OiAnc2xpZGUtb3V0LWxlZnQnLFxuICAvKipcbiAgKiBBbGxvd3MgT3JiaXQgdG8gYXV0b21hdGljYWxseSBhbmltYXRlIG9uIHBhZ2UgbG9hZC5cbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgdHJ1ZVxuICAqL1xuICBhdXRvUGxheTogdHJ1ZSxcbiAgLyoqXG4gICogQW1vdW50IG9mIHRpbWUsIGluIG1zLCBiZXR3ZWVuIHNsaWRlIHRyYW5zaXRpb25zXG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlIDUwMDBcbiAgKi9cbiAgdGltZXJEZWxheTogNTAwMCxcbiAgLyoqXG4gICogQWxsb3dzIE9yYml0IHRvIGluZmluaXRlbHkgbG9vcCB0aHJvdWdoIHRoZSBzbGlkZXNcbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgdHJ1ZVxuICAqL1xuICBpbmZpbml0ZVdyYXA6IHRydWUsXG4gIC8qKlxuICAqIEFsbG93cyB0aGUgT3JiaXQgc2xpZGVzIHRvIGJpbmQgdG8gc3dpcGUgZXZlbnRzIGZvciBtb2JpbGUsIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgdXRpbCBsaWJyYXJ5XG4gICogQG9wdGlvblxuICAqIEBleGFtcGxlIHRydWVcbiAgKi9cbiAgc3dpcGU6IHRydWUsXG4gIC8qKlxuICAqIEFsbG93cyB0aGUgdGltaW5nIGZ1bmN0aW9uIHRvIHBhdXNlIGFuaW1hdGlvbiBvbiBob3Zlci5cbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgdHJ1ZVxuICAqL1xuICBwYXVzZU9uSG92ZXI6IHRydWUsXG4gIC8qKlxuICAqIEFsbG93cyBPcmJpdCB0byBiaW5kIGtleWJvYXJkIGV2ZW50cyB0byB0aGUgc2xpZGVyLCB0byBhbmltYXRlIGZyYW1lcyB3aXRoIGFycm93IGtleXNcbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgdHJ1ZVxuICAqL1xuICBhY2Nlc3NpYmxlOiB0cnVlLFxuICAvKipcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBjb250YWluZXIgb2YgT3JiaXRcbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgJ29yYml0LWNvbnRhaW5lcidcbiAgKi9cbiAgY29udGFpbmVyQ2xhc3M6ICdvcmJpdC1jb250YWluZXInLFxuICAvKipcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIGluZGl2aWR1YWwgc2xpZGVzLlxuICAqIEBvcHRpb25cbiAgKiBAZXhhbXBsZSAnb3JiaXQtc2xpZGUnXG4gICovXG4gIHNsaWRlQ2xhc3M6ICdvcmJpdC1zbGlkZScsXG4gIC8qKlxuICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGJ1bGxldCBjb250YWluZXIuIFlvdSdyZSB3ZWxjb21lLlxuICAqIEBvcHRpb25cbiAgKiBAZXhhbXBsZSAnb3JiaXQtYnVsbGV0cydcbiAgKi9cbiAgYm94T2ZCdWxsZXRzOiAnb3JiaXQtYnVsbGV0cycsXG4gIC8qKlxuICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGBuZXh0YCBuYXZpZ2F0aW9uIGJ1dHRvbi5cbiAgKiBAb3B0aW9uXG4gICogQGV4YW1wbGUgJ29yYml0LW5leHQnXG4gICovXG4gIG5leHRDbGFzczogJ29yYml0LW5leHQnLFxuICAvKipcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBgcHJldmlvdXNgIG5hdmlnYXRpb24gYnV0dG9uLlxuICAqIEBvcHRpb25cbiAgKiBAZXhhbXBsZSAnb3JiaXQtcHJldmlvdXMnXG4gICovXG4gIHByZXZDbGFzczogJ29yYml0LXByZXZpb3VzJyxcbiAgLyoqXG4gICogQm9vbGVhbiB0byBmbGFnIHRoZSBqcyB0byB1c2UgbW90aW9uIHVpIGNsYXNzZXMgb3Igbm90LiBEZWZhdWx0IHRvIHRydWUgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5LlxuICAqIEBvcHRpb25cbiAgKiBAZXhhbXBsZSB0cnVlXG4gICovXG4gIHVzZU1VSTogdHJ1ZVxufTtcblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKE9yYml0LCAnT3JiaXQnKTtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIFJlc3BvbnNpdmVNZW51IG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXNwb25zaXZlTWVudVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmFjY29yZGlvbk1lbnVcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuZHJpbGxkb3duXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmRyb3Bkb3duLW1lbnVcbiAqL1xuXG5jbGFzcyBSZXNwb25zaXZlTWVudSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgcmVzcG9uc2l2ZSBtZW51LlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIFJlc3BvbnNpdmVNZW51I2luaXRcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhIGRyb3Bkb3duIG1lbnUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICB0aGlzLnJ1bGVzID0gdGhpcy4kZWxlbWVudC5kYXRhKCdyZXNwb25zaXZlLW1lbnUnKTtcbiAgICB0aGlzLmN1cnJlbnRNcSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbnVsbDtcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgICB0aGlzLl9ldmVudHMoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1Jlc3BvbnNpdmVNZW51Jyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIE1lbnUgYnkgcGFyc2luZyB0aGUgY2xhc3NlcyBmcm9tIHRoZSAnZGF0YS1SZXNwb25zaXZlTWVudScgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIC8vIFRoZSBmaXJzdCB0aW1lIGFuIEludGVyY2hhbmdlIHBsdWdpbiBpcyBpbml0aWFsaXplZCwgdGhpcy5ydWxlcyBpcyBjb252ZXJ0ZWQgZnJvbSBhIHN0cmluZyBvZiBcImNsYXNzZXNcIiB0byBhbiBvYmplY3Qgb2YgcnVsZXNcbiAgICBpZiAodHlwZW9mIHRoaXMucnVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgcnVsZXNUcmVlID0ge307XG5cbiAgICAgIC8vIFBhcnNlIHJ1bGVzIGZyb20gXCJjbGFzc2VzXCIgcHVsbGVkIGZyb20gZGF0YSBhdHRyaWJ1dGVcbiAgICAgIGxldCBydWxlcyA9IHRoaXMucnVsZXMuc3BsaXQoJyAnKTtcblxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IHJ1bGUgZm91bmRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJ1bGUgPSBydWxlc1tpXS5zcGxpdCgnLScpO1xuICAgICAgICBsZXQgcnVsZVNpemUgPSBydWxlLmxlbmd0aCA+IDEgPyBydWxlWzBdIDogJ3NtYWxsJztcbiAgICAgICAgbGV0IHJ1bGVQbHVnaW4gPSBydWxlLmxlbmd0aCA+IDEgPyBydWxlWzFdIDogcnVsZVswXTtcblxuICAgICAgICBpZiAoTWVudVBsdWdpbnNbcnVsZVBsdWdpbl0gIT09IG51bGwpIHtcbiAgICAgICAgICBydWxlc1RyZWVbcnVsZVNpemVdID0gTWVudVBsdWdpbnNbcnVsZVBsdWdpbl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzVHJlZTtcbiAgICB9XG5cbiAgICBpZiAoISQuaXNFbXB0eU9iamVjdCh0aGlzLnJ1bGVzKSkge1xuICAgICAgdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciB0aGUgTWVudS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XG4gICAgfSk7XG4gICAgLy8gJCh3aW5kb3cpLm9uKCdyZXNpemUuemYuUmVzcG9uc2l2ZU1lbnUnLCBmdW5jdGlvbigpIHtcbiAgICAvLyAgIF90aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xuICAgIC8vIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgY3VycmVudCBzY3JlZW4gd2lkdGggYWdhaW5zdCBhdmFpbGFibGUgbWVkaWEgcXVlcmllcy4gSWYgdGhlIG1lZGlhIHF1ZXJ5IGhhcyBjaGFuZ2VkLCBhbmQgdGhlIHBsdWdpbiBuZWVkZWQgaGFzIGNoYW5nZWQsIHRoZSBwbHVnaW5zIHdpbGwgc3dhcCBvdXQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrTWVkaWFRdWVyaWVzKCkge1xuICAgIHZhciBtYXRjaGVkTXEsIF90aGlzID0gdGhpcztcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBydWxlIGFuZCBmaW5kIHRoZSBsYXN0IG1hdGNoaW5nIHJ1bGVcbiAgICAkLmVhY2godGhpcy5ydWxlcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3Qoa2V5KSkge1xuICAgICAgICBtYXRjaGVkTXEgPSBrZXk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBObyBtYXRjaD8gTm8gZGljZVxuICAgIGlmICghbWF0Y2hlZE1xKSByZXR1cm47XG5cbiAgICAvLyBQbHVnaW4gYWxyZWFkeSBpbml0aWFsaXplZD8gV2UgZ29vZFxuICAgIGlmICh0aGlzLmN1cnJlbnRQbHVnaW4gaW5zdGFuY2VvZiB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKSByZXR1cm47XG5cbiAgICAvLyBSZW1vdmUgZXhpc3RpbmcgcGx1Z2luLXNwZWNpZmljIENTUyBjbGFzc2VzXG4gICAgJC5lYWNoKE1lbnVQbHVnaW5zLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBfdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh2YWx1ZS5jc3NDbGFzcyk7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgdGhlIENTUyBjbGFzcyBmb3IgdGhlIG5ldyBwbHVnaW5cbiAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5jc3NDbGFzcyk7XG5cbiAgICAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIG5ldyBwbHVnaW5cbiAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xuICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG5ldyB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKHRoaXMuJGVsZW1lbnQsIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgcGx1Z2luIG9uIHRoaXMgZWxlbWVudCwgYXMgd2VsbCBhcyB0aGUgd2luZG93IHJlc2l6ZSBoYW5kbGVyIHRoYXQgc3dpdGNoZXMgdGhlIHBsdWdpbnMgb3V0LlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcbiAgICAkKHdpbmRvdykub2ZmKCcuemYuUmVzcG9uc2l2ZU1lbnUnKTtcbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cbn1cblxuUmVzcG9uc2l2ZU1lbnUuZGVmYXVsdHMgPSB7fTtcblxuLy8gVGhlIHBsdWdpbiBtYXRjaGVzIHRoZSBwbHVnaW4gY2xhc3NlcyB3aXRoIHRoZXNlIHBsdWdpbiBpbnN0YW5jZXMuXG52YXIgTWVudVBsdWdpbnMgPSB7XG4gIGRyb3Bkb3duOiB7XG4gICAgY3NzQ2xhc3M6ICdkcm9wZG93bicsXG4gICAgcGx1Z2luOiBGb3VuZGF0aW9uLl9wbHVnaW5zWydkcm9wZG93bi1tZW51J10gfHwgbnVsbFxuICB9LFxuIGRyaWxsZG93bjoge1xuICAgIGNzc0NsYXNzOiAnZHJpbGxkb3duJyxcbiAgICBwbHVnaW46IEZvdW5kYXRpb24uX3BsdWdpbnNbJ2RyaWxsZG93biddIHx8IG51bGxcbiAgfSxcbiAgYWNjb3JkaW9uOiB7XG4gICAgY3NzQ2xhc3M6ICdhY2NvcmRpb24tbWVudScsXG4gICAgcGx1Z2luOiBGb3VuZGF0aW9uLl9wbHVnaW5zWydhY2NvcmRpb24tbWVudSddIHx8IG51bGxcbiAgfVxufTtcblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKFJlc3BvbnNpdmVNZW51LCAnUmVzcG9uc2l2ZU1lbnUnKTtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIFJlc3BvbnNpdmVUb2dnbGUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGVcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICovXG5cbmNsYXNzIFJlc3BvbnNpdmVUb2dnbGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUYWIgQmFyLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIFJlc3BvbnNpdmVUb2dnbGUjaW5pdFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYXR0YWNoIHRhYiBiYXIgZnVuY3Rpb25hbGl0eSB0by5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBSZXNwb25zaXZlVG9nZ2xlLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gICAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdSZXNwb25zaXZlVG9nZ2xlJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHRhYiBiYXIgYnkgZmluZGluZyB0aGUgdGFyZ2V0IGVsZW1lbnQsIHRvZ2dsaW5nIGVsZW1lbnQsIGFuZCBydW5uaW5nIHVwZGF0ZSgpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciB0YXJnZXRJRCA9IHRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS10b2dnbGUnKTtcbiAgICBpZiAoIXRhcmdldElEKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdZb3VyIHRhYiBiYXIgbmVlZHMgYW4gSUQgb2YgYSBNZW51IGFzIHRoZSB2YWx1ZSBvZiBkYXRhLXRhYi1iYXIuJyk7XG4gICAgfVxuXG4gICAgdGhpcy4kdGFyZ2V0TWVudSA9ICQoYCMke3RhcmdldElEfWApO1xuICAgIHRoaXMuJHRvZ2dsZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXRvZ2dsZV0nKTtcblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgdGFiIGJhciB0byB3b3JrLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ldmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX3VwZGF0ZU1xSGFuZGxlciA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIFxuICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fdXBkYXRlTXFIYW5kbGVyKTtcblxuICAgIHRoaXMuJHRvZ2dsZXIub24oJ2NsaWNrLnpmLnJlc3BvbnNpdmVUb2dnbGUnLCB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBjdXJyZW50IG1lZGlhIHF1ZXJ5IHRvIGRldGVybWluZSBpZiB0aGUgdGFiIGJhciBzaG91bGQgYmUgdmlzaWJsZSBvciBoaWRkZW4uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZSgpIHtcbiAgICAvLyBNb2JpbGVcbiAgICBpZiAoIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKSkge1xuICAgICAgdGhpcy4kZWxlbWVudC5zaG93KCk7XG4gICAgICB0aGlzLiR0YXJnZXRNZW51LmhpZGUoKTtcbiAgICB9XG5cbiAgICAvLyBEZXNrdG9wXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKTtcbiAgICAgIHRoaXMuJHRhcmdldE1lbnUuc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyLiBUaGUgdG9nZ2xlIG9ubHkgaGFwcGVucyBpZiB0aGUgc2NyZWVuIGlzIHNtYWxsIGVub3VnaCB0byBhbGxvdyBpdC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcbiAgICovXG4gIHRvZ2dsZU1lbnUoKSB7ICAgXG4gICAgaWYgKCFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcbiAgICAgIHRoaXMuJHRhcmdldE1lbnUudG9nZ2xlKDApO1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGVsZW1lbnQgYXR0YWNoZWQgdG8gdGhlIHRhYiBiYXIgdG9nZ2xlcy5cbiAgICAgICAqIEBldmVudCBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcbiAgICAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcbiAgICB9XG4gIH07XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcbiAgICB0aGlzLiR0b2dnbGVyLm9mZignLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcbiAgICBcbiAgICAkKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl91cGRhdGVNcUhhbmRsZXIpO1xuICAgIFxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5SZXNwb25zaXZlVG9nZ2xlLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogVGhlIGJyZWFrcG9pbnQgYWZ0ZXIgd2hpY2ggdGhlIG1lbnUgaXMgYWx3YXlzIHNob3duLCBhbmQgdGhlIHRhYiBiYXIgaXMgaGlkZGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdtZWRpdW0nXG4gICAqL1xuICBoaWRlRm9yOiAnbWVkaXVtJ1xufTtcblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKFJlc3BvbnNpdmVUb2dnbGUsICdSZXNwb25zaXZlVG9nZ2xlJyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBSZXZlYWwgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJldmVhbFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5ib3hcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb24gaWYgdXNpbmcgYW5pbWF0aW9uc1xuICovXG5cbmNsYXNzIFJldmVhbCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJldmVhbC5cbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byB1c2UgZm9yIHRoZSBtb2RhbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25hbCBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBSZXZlYWwuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdSZXZlYWwnKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdSZXZlYWwnLCB7XG4gICAgICAnRU5URVInOiAnb3BlbicsXG4gICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAnRVNDQVBFJzogJ2Nsb3NlJyxcbiAgICAgICdUQUInOiAndGFiX2ZvcndhcmQnLFxuICAgICAgJ1NISUZUX1RBQic6ICd0YWJfYmFja3dhcmQnXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZGFsIGJ5IGFkZGluZyB0aGUgb3ZlcmxheSBhbmQgY2xvc2UgYnV0dG9ucywgKGlmIHNlbGVjdGVkKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHRoaXMuaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY2FjaGVkID0ge21xOiBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudH07XG4gICAgdGhpcy5pc01vYmlsZSA9IG1vYmlsZVNuaWZmKCk7XG5cbiAgICB0aGlzLiRhbmNob3IgPSAkKGBbZGF0YS1vcGVuPVwiJHt0aGlzLmlkfVwiXWApLmxlbmd0aCA/ICQoYFtkYXRhLW9wZW49XCIke3RoaXMuaWR9XCJdYCkgOiAkKGBbZGF0YS10b2dnbGU9XCIke3RoaXMuaWR9XCJdYCk7XG4gICAgdGhpcy4kYW5jaG9yLmF0dHIoe1xuICAgICAgJ2FyaWEtY29udHJvbHMnOiB0aGlzLmlkLFxuICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxuICAgICAgJ3RhYmluZGV4JzogMFxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2Z1bGwnKSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4gPSB0cnVlO1xuICAgICAgdGhpcy5vcHRpb25zLm92ZXJsYXkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5ICYmICF0aGlzLiRvdmVybGF5KSB7XG4gICAgICB0aGlzLiRvdmVybGF5ID0gdGhpcy5fbWFrZU92ZXJsYXkodGhpcy5pZCk7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgJ3JvbGUnOiAnZGlhbG9nJyxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgJ2RhdGEteWV0aS1ib3gnOiB0aGlzLmlkLFxuICAgICAgICAnZGF0YS1yZXNpemUnOiB0aGlzLmlkXG4gICAgfSk7XG5cbiAgICBpZih0aGlzLiRvdmVybGF5KSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKHRoaXMuJG92ZXJsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKCQoJ2JvZHknKSk7XG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCd3aXRob3V0LW92ZXJsYXknKTtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluayAmJiB3aW5kb3cubG9jYXRpb24uaGFzaCA9PT0gKCBgIyR7dGhpcy5pZH1gKSkge1xuICAgICAgJCh3aW5kb3cpLm9uZSgnbG9hZC56Zi5yZXZlYWwnLCB0aGlzLm9wZW4uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb3ZlcmxheSBkaXYgdG8gZGlzcGxheSBiZWhpbmQgdGhlIG1vZGFsLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VPdmVybGF5KGlkKSB7XG4gICAgdmFyICRvdmVybGF5ID0gJCgnPGRpdj48L2Rpdj4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3JldmVhbC1vdmVybGF5JylcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKCdib2R5Jyk7XG4gICAgcmV0dXJuICRvdmVybGF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgcG9zaXRpb24gb2YgbW9kYWxcbiAgICogVE9ETzogIEZpZ3VyZSBvdXQgaWYgd2UgYWN0dWFsbHkgbmVlZCB0byBjYWNoZSB0aGVzZSB2YWx1ZXMgb3IgaWYgaXQgZG9lc24ndCBtYXR0ZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLiRlbGVtZW50Lm91dGVyV2lkdGgoKTtcbiAgICB2YXIgb3V0ZXJXaWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLiRlbGVtZW50Lm91dGVySGVpZ2h0KCk7XG4gICAgdmFyIG91dGVySGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuICAgIHZhciBsZWZ0LCB0b3A7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oT2Zmc2V0ID09PSAnYXV0bycpIHtcbiAgICAgIGxlZnQgPSBwYXJzZUludCgob3V0ZXJXaWR0aCAtIHdpZHRoKSAvIDIsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy5oT2Zmc2V0LCAxMCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudk9mZnNldCA9PT0gJ2F1dG8nKSB7XG4gICAgICBpZiAoaGVpZ2h0ID4gb3V0ZXJIZWlnaHQpIHtcbiAgICAgICAgdG9wID0gcGFyc2VJbnQoTWF0aC5taW4oMTAwLCBvdXRlckhlaWdodCAvIDEwKSwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9wID0gcGFyc2VJbnQoKG91dGVySGVpZ2h0IC0gaGVpZ2h0KSAvIDQsIDEwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLnZPZmZzZXQsIDEwKTtcbiAgICB9XG4gICAgdGhpcy4kZWxlbWVudC5jc3Moe3RvcDogdG9wICsgJ3B4J30pO1xuICAgIC8vIG9ubHkgd29ycnkgYWJvdXQgbGVmdCBpZiB3ZSBkb24ndCBoYXZlIGFuIG92ZXJsYXkgb3Igd2UgaGF2ZWEgIGhvcml6b250YWwgb2Zmc2V0LFxuICAgIC8vIG90aGVyd2lzZSB3ZSdyZSBwZXJmZWN0bHkgaW4gdGhlIG1pZGRsZVxuICAgIGlmKCF0aGlzLiRvdmVybGF5IHx8ICh0aGlzLm9wdGlvbnMuaE9mZnNldCAhPT0gJ2F1dG8nKSkge1xuICAgICAgdGhpcy4kZWxlbWVudC5jc3Moe2xlZnQ6IGxlZnQgKyAncHgnfSk7XG4gICAgICB0aGlzLiRlbGVtZW50LmNzcyh7bWFyZ2luOiAnMHB4J30pO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBtb2RhbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ldmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuJGVsZW1lbnQub24oe1xuICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiAoZXZlbnQsICRlbGVtZW50KSA9PiB7XG4gICAgICAgIGlmICgoZXZlbnQudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSkgfHxcbiAgICAgICAgICAgICgkKGV2ZW50LnRhcmdldCkucGFyZW50cygnW2RhdGEtY2xvc2FibGVdJylbMF0gPT09ICRlbGVtZW50KSkgeyAvLyBvbmx5IGNsb3NlIHJldmVhbCB3aGVuIGl0J3MgZXhwbGljaXRseSBjYWxsZWRcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZS5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXG4gICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLiRhbmNob3IubGVuZ3RoKSB7XG4gICAgICB0aGlzLiRhbmNob3Iub24oJ2tleWRvd24uemYucmV2ZWFsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS53aGljaCA9PT0gMTMgfHwgZS53aGljaCA9PT0gMzIpIHtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBfdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICYmIHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICB0aGlzLiRvdmVybGF5Lm9mZignLnpmLnJldmVhbCcpLm9uKCdjbGljay56Zi5yZXZlYWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwgJC5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSwgZS50YXJnZXQpKSB7IHJldHVybjsgfVxuICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcbiAgICAgICQod2luZG93KS5vbihgcG9wc3RhdGUuemYucmV2ZWFsOiR7dGhpcy5pZH1gLCB0aGlzLl9oYW5kbGVTdGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBtb2RhbCBtZXRob2RzIG9uIGJhY2svZm9yd2FyZCBidXR0b24gY2xpY2tzIG9yIGFueSBvdGhlciBldmVudCB0aGF0IHRyaWdnZXJzIHBvcHN0YXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZVN0YXRlKGUpIHtcbiAgICBpZih3aW5kb3cubG9jYXRpb24uaGFzaCA9PT0gKCAnIycgKyB0aGlzLmlkKSAmJiAhdGhpcy5pc0FjdGl2ZSl7IHRoaXMub3BlbigpOyB9XG4gICAgZWxzZXsgdGhpcy5jbG9zZSgpOyB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbW9kYWwgY29udHJvbGxlZCBieSBgdGhpcy4kYW5jaG9yYCwgYW5kIGNsb3NlcyBhbGwgb3RoZXJzIGJ5IGRlZmF1bHQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAZmlyZXMgUmV2ZWFsI2Nsb3NlbWVcbiAgICogQGZpcmVzIFJldmVhbCNvcGVuXG4gICAqL1xuICBvcGVuKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcbiAgICAgIHZhciBoYXNoID0gYCMke3RoaXMuaWR9YDtcblxuICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgaGFzaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IGhhc2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG5cbiAgICAvLyBNYWtlIGVsZW1lbnRzIGludmlzaWJsZSwgYnV0IHJlbW92ZSBkaXNwbGF5OiBub25lIHNvIHdlIGNhbiBnZXQgc2l6ZSBhbmQgcG9zaXRpb25pbmdcbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5jc3MoeyAndmlzaWJpbGl0eSc6ICdoaWRkZW4nIH0pXG4gICAgICAgIC5zaG93KClcbiAgICAgICAgLnNjcm9sbFRvcCgwKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgIHRoaXMuJG92ZXJsYXkuY3NzKHsndmlzaWJpbGl0eSc6ICdoaWRkZW4nfSkuc2hvdygpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAuaGlkZSgpXG4gICAgICAuY3NzKHsgJ3Zpc2liaWxpdHknOiAnJyB9KTtcblxuICAgIGlmKHRoaXMuJG92ZXJsYXkpIHtcbiAgICAgIHRoaXMuJG92ZXJsYXkuY3NzKHsndmlzaWJpbGl0eSc6ICcnfSkuaGlkZSgpO1xuICAgICAgaWYodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFzdCcpKSB7XG4gICAgICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ2Zhc3QnKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnc2xvdycpKSB7XG4gICAgICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ3Nsb3cnKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpcGxlT3BlbmVkKSB7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgbW9kYWwgb3BlbnMuXG4gICAgICAgKiBDbG9zZXMgYW55IG90aGVyIG1vZGFscyB0aGF0IGFyZSBjdXJyZW50bHkgb3BlblxuICAgICAgICogQGV2ZW50IFJldmVhbCNjbG9zZW1lXG4gICAgICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VtZS56Zi5yZXZlYWwnLCB0aGlzLmlkKTtcbiAgICB9XG4gICAgLy8gTW90aW9uIFVJIG1ldGhvZCBvZiByZXZlYWxcbiAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbkluKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gYWZ0ZXJBbmltYXRpb25Gb2N1cygpe1xuICAgICAgICBfdGhpcy4kZWxlbWVudFxuICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlLFxuICAgICAgICAgICAgJ3RhYmluZGV4JzogLTFcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5mb2N1cygpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdmb2N1cycpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbih0aGlzLiRvdmVybGF5LCAnZmFkZS1pbicpO1xuICAgICAgfVxuICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsIHRoaXMub3B0aW9ucy5hbmltYXRpb25JbiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUVsZW1lbnRzID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgICBhZnRlckFuaW1hdGlvbkZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8galF1ZXJ5IG1ldGhvZCBvZiByZXZlYWxcbiAgICBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICB0aGlzLiRvdmVybGF5LnNob3coMCk7XG4gICAgICB9XG4gICAgICB0aGlzLiRlbGVtZW50LnNob3codGhpcy5vcHRpb25zLnNob3dEZWxheSk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGFjY2Vzc2liaWxpdHlcbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAuYXR0cih7XG4gICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlLFxuICAgICAgICAndGFiaW5kZXgnOiAtMVxuICAgICAgfSlcbiAgICAgIC5mb2N1cygpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgbW9kYWwgaGFzIHN1Y2Nlc3NmdWxseSBvcGVuZWQuXG4gICAgICogQGV2ZW50IFJldmVhbCNvcGVuXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvcGVuLnpmLnJldmVhbCcpO1xuXG4gICAgaWYgKHRoaXMuaXNNb2JpbGUpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxTY3JvbGxQb3MgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAkKCdodG1sLCBib2R5JykuYWRkQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJCgnYm9keScpLmFkZENsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZXh0cmFIYW5kbGVycygpO1xuICAgIH0sIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZXh0cmEgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBib2R5IGFuZCB3aW5kb3cgaWYgbmVjZXNzYXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V4dHJhSGFuZGxlcnMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmZvY3VzYWJsZUVsZW1lbnRzID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICYmICF0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbikge1xuICAgICAgJCgnYm9keScpLm9uKCdjbGljay56Zi5yZXZlYWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwgJC5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSwgZS50YXJnZXQpKSB7IHJldHVybjsgfVxuICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uRXNjKSB7XG4gICAgICAkKHdpbmRvdykub24oJ2tleWRvd24uemYucmV2ZWFsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnUmV2ZWFsJywge1xuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgX3RoaXMuJGFuY2hvci5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBsb2NrIGZvY3VzIHdpdGhpbiBtb2RhbCB3aGlsZSB0YWJiaW5nXG4gICAgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi56Zi5yZXZlYWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgJHRhcmdldCA9ICQodGhpcyk7XG4gICAgICAvLyBoYW5kbGUga2V5Ym9hcmQgZXZlbnQgd2l0aCBrZXlib2FyZCB1dGlsXG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnUmV2ZWFsJywge1xuICAgICAgICB0YWJfZm9yd2FyZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKF90aGlzLiRlbGVtZW50LmZpbmQoJzpmb2N1cycpLmlzKF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzLmVxKC0xKSkpIHsgLy8gbGVmdCBtb2RhbCBkb3dud2FyZHMsIHNldHRpbmcgZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMuZXEoMCkuZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID09PSAwKSB7IC8vIG5vIGZvY3VzYWJsZSBlbGVtZW50cyBpbnNpZGUgdGhlIG1vZGFsIGF0IGFsbCwgcHJldmVudCB0YWJiaW5nIGluIGdlbmVyYWxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGFiX2JhY2t3YXJkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuZmluZCgnOmZvY3VzJykuaXMoX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMuZXEoMCkpIHx8IF90aGlzLiRlbGVtZW50LmlzKCc6Zm9jdXMnKSkgeyAvLyBsZWZ0IG1vZGFsIHVwd2FyZHMsIHNldHRpbmcgZm9jdXMgdG8gbGFzdCBlbGVtZW50XG4gICAgICAgICAgICBfdGhpcy5mb2N1c2FibGVFbGVtZW50cy5lcSgtMSkuZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID09PSAwKSB7IC8vIG5vIGZvY3VzYWJsZSBlbGVtZW50cyBpbnNpZGUgdGhlIG1vZGFsIGF0IGFsbCwgcHJldmVudCB0YWJiaW5nIGluIGdlbmVyYWxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKF90aGlzLiRlbGVtZW50LmZpbmQoJzpmb2N1cycpLmlzKF90aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWNsb3NlXScpKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgLy8gc2V0IGZvY3VzIGJhY2sgdG8gYW5jaG9yIGlmIGNsb3NlIGJ1dHRvbiBoYXMgYmVlbiBhY3RpdmF0ZWRcbiAgICAgICAgICAgICAgX3RoaXMuJGFuY2hvci5mb2N1cygpO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmICgkdGFyZ2V0LmlzKF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzKSkgeyAvLyBkb250J3QgdHJpZ2dlciBpZiBhY3VhbCBlbGVtZW50IGhhcyBmb2N1cyAoaS5lLiBpbnB1dHMsIGxpbmtzLCAuLi4pXG4gICAgICAgICAgICBfdGhpcy5vcGVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xuICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG1vZGFsLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIFJldmVhbCNjbG9zZWRcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGlmICghdGhpcy5pc0FjdGl2ZSB8fCAhdGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gTW90aW9uIFVJIG1ldGhvZCBvZiBoaWRpbmdcbiAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kb3ZlcmxheSwgJ2ZhZGUtb3V0JywgZmluaXNoVXApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZpbmlzaFVwKCk7XG4gICAgICB9XG5cbiAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kZWxlbWVudCwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCk7XG4gICAgfVxuICAgIC8vIGpRdWVyeSBtZXRob2Qgb2YgaGlkaW5nXG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5oaWRlKDAsIGZpbmlzaFVwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmaW5pc2hVcCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50LmhpZGUodGhpcy5vcHRpb25zLmhpZGVEZWxheSk7XG4gICAgfVxuXG4gICAgLy8gQ29uZGl0aW9uYWxzIHRvIHJlbW92ZSBleHRyYSBldmVudCBsaXN0ZW5lcnMgYWRkZWQgb24gb3BlblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xuICAgICAgJCh3aW5kb3cpLm9mZigna2V5ZG93bi56Zi5yZXZlYWwnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5vdmVybGF5ICYmIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcbiAgICAgICQoJ2JvZHknKS5vZmYoJ2NsaWNrLnpmLnJldmVhbCcpO1xuICAgIH1cblxuICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLnpmLnJldmVhbCcpO1xuXG4gICAgZnVuY3Rpb24gZmluaXNoVXAoKSB7XG4gICAgICBpZiAoX3RoaXMuaXNNb2JpbGUpIHtcbiAgICAgICAgJCgnaHRtbCwgYm9keScpLnJlbW92ZUNsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xuICAgICAgICBpZihfdGhpcy5vcmlnaW5hbFNjcm9sbFBvcykge1xuICAgICAgICAgICQoJ2JvZHknKS5zY3JvbGxUb3AoX3RoaXMub3JpZ2luYWxTY3JvbGxQb3MpO1xuICAgICAgICAgIF90aGlzLm9yaWdpbmFsU2Nyb2xsUG9zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcblxuICAgICAgLyoqXG4gICAgICAqIEZpcmVzIHdoZW4gdGhlIG1vZGFsIGlzIGRvbmUgY2xvc2luZy5cbiAgICAgICogQGV2ZW50IFJldmVhbCNjbG9zZWRcbiAgICAgICovXG4gICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYucmV2ZWFsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBSZXNldHMgdGhlIG1vZGFsIGNvbnRlbnRcbiAgICAqIFRoaXMgcHJldmVudHMgYSBydW5uaW5nIHZpZGVvIHRvIGtlZXAgZ29pbmcgaW4gdGhlIGJhY2tncm91bmRcbiAgICAqL1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzZXRPbkNsb3NlKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lmh0bWwodGhpcy4kZWxlbWVudC5odG1sKCkpO1xuICAgIH1cblxuICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgaWYgKF90aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcbiAgICAgICBpZiAod2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKSB7XG4gICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoXCJcIiwgZG9jdW1lbnQudGl0bGUsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgICAgfVxuICAgICB9XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgb3Blbi9jbG9zZWQgc3RhdGUgb2YgYSBtb2RhbC5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhIG1vZGFsLlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZFRvKCQoJ2JvZHknKSk7IC8vIG1vdmUgJGVsZW1lbnQgb3V0c2lkZSBvZiAkb3ZlcmxheSB0byBwcmV2ZW50IGVycm9yIHVucmVnaXN0ZXJQbHVnaW4oKVxuICAgICAgdGhpcy4kb3ZlcmxheS5oaWRlKCkub2ZmKCkucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpLm9mZigpO1xuICAgIHRoaXMuJGFuY2hvci5vZmYoJy56ZicpO1xuICAgICQod2luZG93KS5vZmYoYC56Zi5yZXZlYWw6JHt0aGlzLmlkfWApO1xuXG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9O1xufVxuXG5SZXZlYWwuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBNb3Rpb24tVUkgY2xhc3MgdG8gdXNlIGZvciBhbmltYXRlZCBlbGVtZW50cy4gSWYgbm9uZSB1c2VkLCBkZWZhdWx0cyB0byBzaW1wbGUgc2hvdy9oaWRlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdzbGlkZS1pbi1sZWZ0J1xuICAgKi9cbiAgYW5pbWF0aW9uSW46ICcnLFxuICAvKipcbiAgICogTW90aW9uLVVJIGNsYXNzIHRvIHVzZSBmb3IgYW5pbWF0ZWQgZWxlbWVudHMuIElmIG5vbmUgdXNlZCwgZGVmYXVsdHMgdG8gc2ltcGxlIHNob3cvaGlkZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnc2xpZGUtb3V0LXJpZ2h0J1xuICAgKi9cbiAgYW5pbWF0aW9uT3V0OiAnJyxcbiAgLyoqXG4gICAqIFRpbWUsIGluIG1zLCB0byBkZWxheSB0aGUgb3BlbmluZyBvZiBhIG1vZGFsIGFmdGVyIGEgY2xpY2sgaWYgbm8gYW5pbWF0aW9uIHVzZWQuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMTBcbiAgICovXG4gIHNob3dEZWxheTogMCxcbiAgLyoqXG4gICAqIFRpbWUsIGluIG1zLCB0byBkZWxheSB0aGUgY2xvc2luZyBvZiBhIG1vZGFsIGFmdGVyIGEgY2xpY2sgaWYgbm8gYW5pbWF0aW9uIHVzZWQuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMTBcbiAgICovXG4gIGhpZGVEZWxheTogMCxcbiAgLyoqXG4gICAqIEFsbG93cyBhIGNsaWNrIG9uIHRoZSBib2R5L292ZXJsYXkgdG8gY2xvc2UgdGhlIG1vZGFsLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGNsb3NlT25DbGljazogdHJ1ZSxcbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gY2xvc2UgaWYgdGhlIHVzZXIgcHJlc3NlcyB0aGUgYEVTQ0FQRWAga2V5LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGNsb3NlT25Fc2M6IHRydWUsXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBhbGxvd3MgbXVsdGlwbGUgbW9kYWxzIHRvIGJlIGRpc3BsYXllZCBhdCBvbmNlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBtdWx0aXBsZU9wZW5lZDogZmFsc2UsXG4gIC8qKlxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggZG93biBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcmVlbi5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBhdXRvXG4gICAqL1xuICB2T2Zmc2V0OiAnYXV0bycsXG4gIC8qKlxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggaW4gZnJvbSB0aGUgc2lkZSBvZiB0aGUgc2NyZWVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGF1dG9cbiAgICovXG4gIGhPZmZzZXQ6ICdhdXRvJyxcbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gYmUgZnVsbHNjcmVlbiwgY29tcGxldGVseSBibG9ja2luZyBvdXQgdGhlIHJlc3Qgb2YgdGhlIHZpZXcuIEpTIGNoZWNrcyBmb3IgdGhpcyBhcyB3ZWxsLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBmdWxsU2NyZWVuOiBmYWxzZSxcbiAgLyoqXG4gICAqIFBlcmNlbnRhZ2Ugb2Ygc2NyZWVuIGhlaWdodCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggdXAgZnJvbSB0aGUgYm90dG9tIG9mIHRoZSB2aWV3LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDEwXG4gICAqL1xuICBidG1PZmZzZXRQY3Q6IDEwLFxuICAvKipcbiAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBnZW5lcmF0ZSBhbiBvdmVybGF5IGRpdiwgd2hpY2ggd2lsbCBjb3ZlciB0aGUgdmlldyB3aGVuIG1vZGFsIG9wZW5zLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIG92ZXJsYXk6IHRydWUsXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIHJlbW92ZSBhbmQgcmVpbmplY3QgbWFya3VwIG9uIGNsb3NlLiBTaG91bGQgYmUgdHJ1ZSBpZiB1c2luZyB2aWRlbyBlbGVtZW50cyB3L28gdXNpbmcgcHJvdmlkZXIncyBhcGksIG90aGVyd2lzZSwgdmlkZW9zIHdpbGwgY29udGludWUgdG8gcGxheSBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgcmVzZXRPbkNsb3NlOiBmYWxzZSxcbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gYWx0ZXIgdGhlIHVybCBvbiBvcGVuL2Nsb3NlLCBhbmQgYWxsb3dzIHRoZSB1c2Ugb2YgdGhlIGBiYWNrYCBidXR0b24gdG8gY2xvc2UgbW9kYWxzLiBBTFNPLCBhbGxvd3MgYSBtb2RhbCB0byBhdXRvLW1hbmlhY2FsbHkgb3BlbiBvbiBwYWdlIGxvYWQgSUYgdGhlIGhhc2ggPT09IHRoZSBtb2RhbCdzIHVzZXItc2V0IGlkLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBkZWVwTGluazogZmFsc2Vcbn07XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihSZXZlYWwsICdSZXZlYWwnKTtcblxuZnVuY3Rpb24gaVBob25lU25pZmYoKSB7XG4gIHJldHVybiAvaVAoYWR8aG9uZXxvZCkuKk9TLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxuZnVuY3Rpb24gYW5kcm9pZFNuaWZmKCkge1xuICByZXR1cm4gL0FuZHJvaWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG5mdW5jdGlvbiBtb2JpbGVTbmlmZigpIHtcbiAgcmV0dXJuIGlQaG9uZVNuaWZmKCkgfHwgYW5kcm9pZFNuaWZmKCk7XG59XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBTbGlkZXIgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnNsaWRlclxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudG91Y2hcbiAqL1xuXG5jbGFzcyBTbGlkZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIGRyaWxsZG93biBtZW51LlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24gbWVudS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBTbGlkZXIuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1NsaWRlcicpO1xuICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ1NsaWRlcicsIHtcbiAgICAgICdsdHInOiB7XG4gICAgICAgICdBUlJPV19SSUdIVCc6ICdpbmNyZWFzZScsXG4gICAgICAgICdBUlJPV19VUCc6ICdpbmNyZWFzZScsXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2RlY3JlYXNlJyxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAnZGVjcmVhc2UnLFxuICAgICAgICAnU0hJRlRfQVJST1dfUklHSFQnOiAnaW5jcmVhc2VfZmFzdCcsXG4gICAgICAgICdTSElGVF9BUlJPV19VUCc6ICdpbmNyZWFzZV9mYXN0JyxcbiAgICAgICAgJ1NISUZUX0FSUk9XX0RPV04nOiAnZGVjcmVhc2VfZmFzdCcsXG4gICAgICAgICdTSElGVF9BUlJPV19MRUZUJzogJ2RlY3JlYXNlX2Zhc3QnXG4gICAgICB9LFxuICAgICAgJ3J0bCc6IHtcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAnaW5jcmVhc2UnLFxuICAgICAgICAnQVJST1dfUklHSFQnOiAnZGVjcmVhc2UnLFxuICAgICAgICAnU0hJRlRfQVJST1dfTEVGVCc6ICdpbmNyZWFzZV9mYXN0JyxcbiAgICAgICAgJ1NISUZUX0FSUk9XX1JJR0hUJzogJ2RlY3JlYXNlX2Zhc3QnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlsaXplcyB0aGUgcGx1Z2luIGJ5IHJlYWRpbmcvc2V0dGluZyBhdHRyaWJ1dGVzLCBjcmVhdGluZyBjb2xsZWN0aW9ucyBhbmQgc2V0dGluZyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgaGFuZGxlKHMpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHRoaXMuaW5wdXRzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuICAgIHRoaXMuaGFuZGxlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc2xpZGVyLWhhbmRsZV0nKTtcblxuICAgIHRoaXMuJGhhbmRsZSA9IHRoaXMuaGFuZGxlcy5lcSgwKTtcbiAgICB0aGlzLiRpbnB1dCA9IHRoaXMuaW5wdXRzLmxlbmd0aCA/IHRoaXMuaW5wdXRzLmVxKDApIDogJChgIyR7dGhpcy4kaGFuZGxlLmF0dHIoJ2FyaWEtY29udHJvbHMnKX1gKTtcbiAgICB0aGlzLiRmaWxsID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zbGlkZXItZmlsbF0nKS5jc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnLCAwKTtcblxuICAgIHZhciBpc0RibCA9IGZhbHNlLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSkge1xuICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5pbnB1dHMgPSAkKCkuYWRkKHRoaXMuJGlucHV0KTtcbiAgICAgIHRoaXMub3B0aW9ucy5iaW5kaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fc2V0SW5pdEF0dHIoMCk7XG4gICAgdGhpcy5fZXZlbnRzKHRoaXMuJGhhbmRsZSk7XG5cbiAgICBpZiAodGhpcy5oYW5kbGVzWzFdKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQgPSB0cnVlO1xuICAgICAgdGhpcy4kaGFuZGxlMiA9IHRoaXMuaGFuZGxlcy5lcSgxKTtcbiAgICAgIHRoaXMuJGlucHV0MiA9IHRoaXMuaW5wdXRzLmxlbmd0aCA+IDEgPyB0aGlzLmlucHV0cy5lcSgxKSA6ICQoYCMke3RoaXMuJGhhbmRsZTIuYXR0cignYXJpYS1jb250cm9scycpfWApO1xuXG4gICAgICBpZiAoIXRoaXMuaW5wdXRzWzFdKSB7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gdGhpcy5pbnB1dHMuYWRkKHRoaXMuJGlucHV0Mik7XG4gICAgICB9XG4gICAgICBpc0RibCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsIHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQsIHRydWUsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIF90aGlzLl9zZXRIYW5kbGVQb3MoX3RoaXMuJGhhbmRsZTIsIF90aGlzLm9wdGlvbnMuaW5pdGlhbEVuZCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIHRoaXMuJGhhbmRsZS50cmlnZ2VySGFuZGxlcignY2xpY2suemYuc2xpZGVyJyk7XG4gICAgICB0aGlzLl9zZXRJbml0QXR0cigxKTtcbiAgICAgIHRoaXMuX2V2ZW50cyh0aGlzLiRoYW5kbGUyKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRGJsKSB7XG4gICAgICB0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLCB0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0LCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHNlbGVjdGVkIGhhbmRsZSBhbmQgZmlsbCBiYXIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhuZGwgLSB0aGUgc2VsZWN0ZWQgaGFuZGxlIHRvIG1vdmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhdGlvbiAtIGZsb2F0aW5nIHBvaW50IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIG9mIHRoZSBzbGlkZXIgYmFyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbi5cbiAgICogQGZpcmVzIFNsaWRlciNtb3ZlZFxuICAgKiBAZmlyZXMgU2xpZGVyI2NoYW5nZWRcbiAgICovXG4gIF9zZXRIYW5kbGVQb3MoJGhuZGwsIGxvY2F0aW9uLCBub0ludmVydCwgY2IpIHtcbiAgICAvLyBkb24ndCBtb3ZlIGlmIHRoZSBzbGlkZXIgaGFzIGJlZW4gZGlzYWJsZWQgc2luY2UgaXRzIGluaXRpYWxpemF0aW9uXG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vbWlnaHQgbmVlZCB0byBhbHRlciB0aGF0IHNsaWdodGx5IGZvciBiYXJzIHRoYXQgd2lsbCBoYXZlIG9kZCBudW1iZXIgc2VsZWN0aW9ucy5cbiAgICBsb2NhdGlvbiA9IHBhcnNlRmxvYXQobG9jYXRpb24pOy8vb24gaW5wdXQgY2hhbmdlIGV2ZW50cywgY29udmVydCBzdHJpbmcgdG8gbnVtYmVyLi4uZ3J1bWJsZS5cblxuICAgIC8vIHByZXZlbnQgc2xpZGVyIGZyb20gcnVubmluZyBvdXQgb2YgYm91bmRzLCBpZiB2YWx1ZSBleGNlZWRzIHRoZSBsaW1pdHMgc2V0IHRocm91Z2ggb3B0aW9ucywgb3ZlcnJpZGUgdGhlIHZhbHVlIHRvIG1pbi9tYXhcbiAgICBpZiAobG9jYXRpb24gPCB0aGlzLm9wdGlvbnMuc3RhcnQpIHsgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuc3RhcnQ7IH1cbiAgICBlbHNlIGlmIChsb2NhdGlvbiA+IHRoaXMub3B0aW9ucy5lbmQpIHsgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuZW5kOyB9XG5cbiAgICB2YXIgaXNEYmwgPSB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ7XG5cbiAgICBpZiAoaXNEYmwpIHsgLy90aGlzIGJsb2NrIGlzIHRvIHByZXZlbnQgMiBoYW5kbGVzIGZyb20gY3Jvc3NpbmcgZWFjaG90aGVyLiBDb3VsZC9zaG91bGQgYmUgaW1wcm92ZWQuXG4gICAgICBpZiAodGhpcy5oYW5kbGVzLmluZGV4KCRobmRsKSA9PT0gMCkge1xuICAgICAgICB2YXIgaDJWYWwgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZTIuYXR0cignYXJpYS12YWx1ZW5vdycpKTtcbiAgICAgICAgbG9jYXRpb24gPSBsb2NhdGlvbiA+PSBoMlZhbCA/IGgyVmFsIC0gdGhpcy5vcHRpb25zLnN0ZXAgOiBsb2NhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoMVZhbCA9IHBhcnNlRmxvYXQodGhpcy4kaGFuZGxlLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XG4gICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPD0gaDFWYWwgPyBoMVZhbCArIHRoaXMub3B0aW9ucy5zdGVwIDogbG9jYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy90aGlzIGlzIGZvciBzaW5nbGUtaGFuZGxlZCB2ZXJ0aWNhbCBzbGlkZXJzLCBpdCBhZGp1c3RzIHRoZSB2YWx1ZSB0byBhY2NvdW50IGZvciB0aGUgc2xpZGVyIGJlaW5nIFwidXBzaWRlLWRvd25cIlxuICAgIC8vZm9yIGNsaWNrIGFuZCBkcmFnIGV2ZW50cywgaXQncyB3ZWlyZCBkdWUgdG8gdGhlIHNjYWxlKC0xLCAxKSBjc3MgcHJvcGVydHlcbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcnRpY2FsICYmICFub0ludmVydCkge1xuICAgICAgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuZW5kIC0gbG9jYXRpb247XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgdmVydCA9IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCxcbiAgICAgICAgaE9yVyA9IHZlcnQgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsXG4gICAgICAgIGxPclQgPSB2ZXJ0ID8gJ3RvcCcgOiAnbGVmdCcsXG4gICAgICAgIGhhbmRsZURpbSA9ICRobmRsWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2hPclddLFxuICAgICAgICBlbGVtRGltID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtoT3JXXSxcbiAgICAgICAgLy9wZXJjZW50YWdlIG9mIGJhciBtaW4vbWF4IHZhbHVlIGJhc2VkIG9uIGNsaWNrIG9yIGRyYWcgcG9pbnRcbiAgICAgICAgcGN0T2ZCYXIgPSBwZXJjZW50KGxvY2F0aW9uIC0gdGhpcy5vcHRpb25zLnN0YXJ0LCB0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KS50b0ZpeGVkKDIpLFxuICAgICAgICAvL251bWJlciBvZiBhY3R1YWwgcGl4ZWxzIHRvIHNoaWZ0IHRoZSBoYW5kbGUsIGJhc2VkIG9uIHRoZSBwZXJjZW50YWdlIG9idGFpbmVkIGFib3ZlXG4gICAgICAgIHB4VG9Nb3ZlID0gKGVsZW1EaW0gLSBoYW5kbGVEaW0pICogcGN0T2ZCYXIsXG4gICAgICAgIC8vcGVyY2VudGFnZSBvZiBiYXIgdG8gc2hpZnQgdGhlIGhhbmRsZVxuICAgICAgICBtb3ZlbWVudCA9IChwZXJjZW50KHB4VG9Nb3ZlLCBlbGVtRGltKSAqIDEwMCkudG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCk7XG4gICAgICAgIC8vZml4aW5nIHRoZSBkZWNpbWFsIHZhbHVlIGZvciB0aGUgbG9jYXRpb24gbnVtYmVyLCBpcyBwYXNzZWQgdG8gb3RoZXIgbWV0aG9kcyBhcyBhIGZpeGVkIGZsb2F0aW5nLXBvaW50IHZhbHVlXG4gICAgICAgIGxvY2F0aW9uID0gcGFyc2VGbG9hdChsb2NhdGlvbi50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKSk7XG4gICAgICAgIC8vIGRlY2xhcmUgZW1wdHkgb2JqZWN0IGZvciBjc3MgYWRqdXN0bWVudHMsIG9ubHkgdXNlZCB3aXRoIDIgaGFuZGxlZC1zbGlkZXJzXG4gICAgdmFyIGNzcyA9IHt9O1xuXG4gICAgdGhpcy5fc2V0VmFsdWVzKCRobmRsLCBsb2NhdGlvbik7XG5cbiAgICAvLyBUT0RPIHVwZGF0ZSB0byBjYWxjdWxhdGUgYmFzZWQgb24gdmFsdWVzIHNldCB0byByZXNwZWN0aXZlIGlucHV0cz8/XG4gICAgaWYgKGlzRGJsKSB7XG4gICAgICB2YXIgaXNMZWZ0SG5kbCA9IHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCkgPT09IDAsXG4gICAgICAgICAgLy9lbXB0eSB2YXJpYWJsZSwgd2lsbCBiZSB1c2VkIGZvciBtaW4taGVpZ2h0L3dpZHRoIGZvciBmaWxsIGJhclxuICAgICAgICAgIGRpbSxcbiAgICAgICAgICAvL3BlcmNlbnRhZ2Ugdy9oIG9mIHRoZSBoYW5kbGUgY29tcGFyZWQgdG8gdGhlIHNsaWRlciBiYXJcbiAgICAgICAgICBoYW5kbGVQY3QgPSAgfn4ocGVyY2VudChoYW5kbGVEaW0sIGVsZW1EaW0pICogMTAwKTtcbiAgICAgIC8vaWYgbGVmdCBoYW5kbGUsIHRoZSBtYXRoIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGlmIGl0J3MgdGhlIHJpZ2h0IGhhbmRsZSwgYW5kIHRoZSBsZWZ0L3RvcCBwcm9wZXJ0eSBuZWVkcyB0byBiZSBjaGFuZ2VkIGZvciB0aGUgZmlsbCBiYXJcbiAgICAgIGlmIChpc0xlZnRIbmRsKSB7XG4gICAgICAgIC8vbGVmdCBvciB0b3AgcGVyY2VudGFnZSB2YWx1ZSB0byBhcHBseSB0byB0aGUgZmlsbCBiYXIuXG4gICAgICAgIGNzc1tsT3JUXSA9IGAke21vdmVtZW50fSVgO1xuICAgICAgICAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci5cbiAgICAgICAgZGltID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyWzBdLnN0eWxlW2xPclRdKSAtIG1vdmVtZW50ICsgaGFuZGxlUGN0O1xuICAgICAgICAvL3RoaXMgY2FsbGJhY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgZXJyb3JzIGFuZCBhbGxvdyB0aGUgcHJvcGVyIHBsYWNlbWVudCBhbmQgaW5pdGlhbGl6YXRpb24gb2YgYSAyLWhhbmRsZWQgc2xpZGVyXG4gICAgICAgIC8vcGx1cywgaXQgbWVhbnMgd2UgZG9uJ3QgY2FyZSBpZiAnZGltJyBpc05hTiBvbiBpbml0LCBpdCB3b24ndCBiZSBpbiB0aGUgZnV0dXJlLlxuICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7IGNiKCk7IH0vL3RoaXMgaXMgb25seSBuZWVkZWQgZm9yIHRoZSBpbml0aWFsaXphdGlvbiBvZiAyIGhhbmRsZWQgc2xpZGVyc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9qdXN0IGNhY2hpbmcgdGhlIHZhbHVlIG9mIHRoZSBsZWZ0L2JvdHRvbSBoYW5kbGUncyBsZWZ0L3RvcCBwcm9wZXJ0eVxuICAgICAgICB2YXIgaGFuZGxlUG9zID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGVbMF0uc3R5bGVbbE9yVF0pO1xuICAgICAgICAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci4gVXNlIGlzTmFOIHRvIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzIGZvciBudW1iZXJzIDw9IDBcbiAgICAgICAgLy9iYXNlZCBvbiB0aGUgcGVyY2VudGFnZSBvZiBtb3ZlbWVudCBvZiB0aGUgaGFuZGxlIGJlaW5nIG1hbmlwdWxhdGVkLCBsZXNzIHRoZSBvcHBvc2luZyBoYW5kbGUncyBsZWZ0L3RvcCBwb3NpdGlvbiwgcGx1cyB0aGUgcGVyY2VudGFnZSB3L2ggb2YgdGhlIGhhbmRsZSBpdHNlbGZcbiAgICAgICAgZGltID0gbW92ZW1lbnQgLSAoaXNOYU4oaGFuZGxlUG9zKSA/IHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQvKCh0aGlzLm9wdGlvbnMuZW5kLXRoaXMub3B0aW9ucy5zdGFydCkvMTAwKSA6IGhhbmRsZVBvcykgKyBoYW5kbGVQY3Q7XG4gICAgICB9XG4gICAgICAvLyBhc3NpZ24gdGhlIG1pbi1oZWlnaHQvd2lkdGggdG8gb3VyIGNzcyBvYmplY3RcbiAgICAgIGNzc1tgbWluLSR7aE9yV31gXSA9IGAke2RpbX0lYDtcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50Lm9uZSgnZmluaXNoZWQuemYuYW5pbWF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGFuZGxlIGlzIGRvbmUgbW92aW5nLlxuICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgU2xpZGVyI21vdmVkXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdtb3ZlZC56Zi5zbGlkZXInLCBbJGhuZGxdKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgIC8vYmVjYXVzZSB3ZSBkb24ndCBrbm93IGV4YWN0bHkgaG93IHRoZSBoYW5kbGUgd2lsbCBiZSBtb3ZlZCwgY2hlY2sgdGhlIGFtb3VudCBvZiB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIG1vdmUuXG4gICAgdmFyIG1vdmVUaW1lID0gdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycpID8gMTAwMC82MCA6IHRoaXMub3B0aW9ucy5tb3ZlVGltZTtcblxuICAgIEZvdW5kYXRpb24uTW92ZShtb3ZlVGltZSwgJGhuZGwsIGZ1bmN0aW9uKCkge1xuICAgICAgLy9hZGp1c3RpbmcgdGhlIGxlZnQvdG9wIHByb3BlcnR5IG9mIHRoZSBoYW5kbGUsIGJhc2VkIG9uIHRoZSBwZXJjZW50YWdlIGNhbGN1bGF0ZWQgYWJvdmVcbiAgICAgICRobmRsLmNzcyhsT3JULCBgJHttb3ZlbWVudH0lYCk7XG5cbiAgICAgIGlmICghX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCkge1xuICAgICAgICAvL2lmIHNpbmdsZS1oYW5kbGVkLCBhIHNpbXBsZSBtZXRob2QgdG8gZXhwYW5kIHRoZSBmaWxsIGJhclxuICAgICAgICBfdGhpcy4kZmlsbC5jc3MoaE9yVywgYCR7cGN0T2ZCYXIgKiAxMDB9JWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9vdGhlcndpc2UsIHVzZSB0aGUgY3NzIG9iamVjdCB3ZSBjcmVhdGVkIGFib3ZlXG4gICAgICAgIF90aGlzLiRmaWxsLmNzcyhjc3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdmFsdWUgaGFzIG5vdCBiZWVuIGNoYW5nZSBmb3IgYSBnaXZlbiB0aW1lLlxuICAgICAqIEBldmVudCBTbGlkZXIjY2hhbmdlZFxuICAgICAqL1xuICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcbiAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlZC56Zi5zbGlkZXInLCBbJGhuZGxdKTtcbiAgICB9LCBfdGhpcy5vcHRpb25zLmNoYW5nZWREZWxheSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5pdGlhbCBhdHRyaWJ1dGUgZm9yIHRoZSBzbGlkZXIgZWxlbWVudC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSBpbmRleCBvZiB0aGUgY3VycmVudCBoYW5kbGUvaW5wdXQgdG8gdXNlLlxuICAgKi9cbiAgX3NldEluaXRBdHRyKGlkeCkge1xuICAgIHZhciBpZCA9IHRoaXMuaW5wdXRzLmVxKGlkeCkuYXR0cignaWQnKSB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdzbGlkZXInKTtcbiAgICB0aGlzLmlucHV0cy5lcShpZHgpLmF0dHIoe1xuICAgICAgJ2lkJzogaWQsXG4gICAgICAnbWF4JzogdGhpcy5vcHRpb25zLmVuZCxcbiAgICAgICdtaW4nOiB0aGlzLm9wdGlvbnMuc3RhcnQsXG4gICAgICAnc3RlcCc6IHRoaXMub3B0aW9ucy5zdGVwXG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVzLmVxKGlkeCkuYXR0cih7XG4gICAgICAncm9sZSc6ICdzbGlkZXInLFxuICAgICAgJ2FyaWEtY29udHJvbHMnOiBpZCxcbiAgICAgICdhcmlhLXZhbHVlbWF4JzogdGhpcy5vcHRpb25zLmVuZCxcbiAgICAgICdhcmlhLXZhbHVlbWluJzogdGhpcy5vcHRpb25zLnN0YXJ0LFxuICAgICAgJ2FyaWEtdmFsdWVub3cnOiBpZHggPT09IDAgPyB0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0IDogdGhpcy5vcHRpb25zLmluaXRpYWxFbmQsXG4gICAgICAnYXJpYS1vcmllbnRhdGlvbic6IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcsXG4gICAgICAndGFiaW5kZXgnOiAwXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYW5kIGBhcmlhLXZhbHVlbm93YCB2YWx1ZXMgZm9yIHRoZSBzbGlkZXIgZWxlbWVudC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBoYW5kbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSBmbG9hdGluZyBwb2ludCBvZiB0aGUgbmV3IHZhbHVlLlxuICAgKi9cbiAgX3NldFZhbHVlcygkaGFuZGxlLCB2YWwpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID8gdGhpcy5oYW5kbGVzLmluZGV4KCRoYW5kbGUpIDogMDtcbiAgICB0aGlzLmlucHV0cy5lcShpZHgpLnZhbCh2YWwpO1xuICAgICRoYW5kbGUuYXR0cignYXJpYS12YWx1ZW5vdycsIHZhbCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBldmVudHMgb24gdGhlIHNsaWRlciBlbGVtZW50LlxuICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgaGFuZGxlLlxuICAgKiBJZiB0aGVyZSBhcmUgdHdvIGhhbmRsZXMgYW5kIHRoZSBiYXIgd2FzIGNsaWNrZWQsIGl0IGRldGVybWluZXMgd2hpY2ggaGFuZGxlIHRvIG1vdmUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIHRoZSBgZXZlbnRgIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnQgaGFuZGxlIHRvIGNhbGN1bGF0ZSBmb3IsIGlmIHNlbGVjdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIC0gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGZvciB0aGUgbmV3IHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAqIFRPRE8gY2xlYW4gdGhpcyB1cCwgdGhlcmUncyBhIGxvdCBvZiByZXBlYXRlZCBjb2RlIGJldHdlZW4gdGhpcyBhbmQgdGhlIF9zZXRIYW5kbGVQb3MgZm4uXG4gICAqL1xuICBfaGFuZGxlRXZlbnQoZSwgJGhhbmRsZSwgdmFsKSB7XG4gICAgdmFyIHZhbHVlLCBoYXNWYWw7XG4gICAgaWYgKCF2YWwpIHsvL2NsaWNrIG9yIGRyYWcgZXZlbnRzXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIHZlcnRpY2FsID0gdGhpcy5vcHRpb25zLnZlcnRpY2FsLFxuICAgICAgICAgIHBhcmFtID0gdmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsXG4gICAgICAgICAgZGlyZWN0aW9uID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcbiAgICAgICAgICBldmVudE9mZnNldCA9IHZlcnRpY2FsID8gZS5wYWdlWSA6IGUucGFnZVgsXG4gICAgICAgICAgaGFsZk9mSGFuZGxlID0gdGhpcy4kaGFuZGxlWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3BhcmFtXSAvIDIsXG4gICAgICAgICAgYmFyRGltID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwYXJhbV0sXG4gICAgICAgICAgd2luZG93U2Nyb2xsID0gdmVydGljYWwgPyAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgOiAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpO1xuXG5cbiAgICAgIHZhciBlbGVtT2Zmc2V0ID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVtkaXJlY3Rpb25dO1xuXG4gICAgICAvLyB0b3VjaCBldmVudHMgZW11bGF0ZWQgYnkgdGhlIHRvdWNoIHV0aWwgZ2l2ZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBzY3JlZW4sIGFkZCB3aW5kb3cuc2Nyb2xsIHRvIGV2ZW50IGNvb3JkaW5hdGVzLi4uXG4gICAgICAvLyBiZXN0IHdheSB0byBndWVzcyB0aGlzIGlzIHNpbXVsYXRlZCBpcyBpZiBjbGllbnRZID09IHBhZ2VZXG4gICAgICBpZiAoZS5jbGllbnRZID09PSBlLnBhZ2VZKSB7IGV2ZW50T2Zmc2V0ID0gZXZlbnRPZmZzZXQgKyB3aW5kb3dTY3JvbGw7IH1cbiAgICAgIHZhciBldmVudEZyb21CYXIgPSBldmVudE9mZnNldCAtIGVsZW1PZmZzZXQ7XG4gICAgICB2YXIgYmFyWFk7XG4gICAgICBpZiAoZXZlbnRGcm9tQmFyIDwgMCkge1xuICAgICAgICBiYXJYWSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50RnJvbUJhciA+IGJhckRpbSkge1xuICAgICAgICBiYXJYWSA9IGJhckRpbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhclhZID0gZXZlbnRGcm9tQmFyO1xuICAgICAgfVxuICAgICAgb2Zmc2V0UGN0ID0gcGVyY2VudChiYXJYWSwgYmFyRGltKTtcblxuICAgICAgdmFsdWUgPSAodGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCkgKiBvZmZzZXRQY3QgKyB0aGlzLm9wdGlvbnMuc3RhcnQ7XG5cbiAgICAgIC8vIHR1cm4gZXZlcnl0aGluZyBhcm91bmQgZm9yIFJUTCwgeWF5IG1hdGghXG4gICAgICBpZiAoRm91bmRhdGlvbi5ydGwoKSAmJiAhdGhpcy5vcHRpb25zLnZlcnRpY2FsKSB7dmFsdWUgPSB0aGlzLm9wdGlvbnMuZW5kIC0gdmFsdWU7fVxuXG4gICAgICB2YWx1ZSA9IF90aGlzLl9hZGp1c3RWYWx1ZShudWxsLCB2YWx1ZSk7XG4gICAgICAvL2Jvb2xlYW4gZmxhZyBmb3IgdGhlIHNldEhhbmRsZVBvcyBmbiwgc3BlY2lmaWNhbGx5IGZvciB2ZXJ0aWNhbCBzbGlkZXJzXG4gICAgICBoYXNWYWwgPSBmYWxzZTtcblxuICAgICAgaWYgKCEkaGFuZGxlKSB7Ly9maWd1cmUgb3V0IHdoaWNoIGhhbmRsZSBpdCBpcywgcGFzcyBpdCB0byB0aGUgbmV4dCBmdW5jdGlvbi5cbiAgICAgICAgdmFyIGZpcnN0SG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZSwgZGlyZWN0aW9uLCBiYXJYWSwgcGFyYW0pLFxuICAgICAgICAgICAgc2VjbmRIbmRsUG9zID0gYWJzUG9zaXRpb24odGhpcy4kaGFuZGxlMiwgZGlyZWN0aW9uLCBiYXJYWSwgcGFyYW0pO1xuICAgICAgICAgICAgJGhhbmRsZSA9IGZpcnN0SG5kbFBvcyA8PSBzZWNuZEhuZGxQb3MgPyB0aGlzLiRoYW5kbGUgOiB0aGlzLiRoYW5kbGUyO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHsvL2NoYW5nZSBldmVudCBvbiBpbnB1dFxuICAgICAgdmFsdWUgPSB0aGlzLl9hZGp1c3RWYWx1ZShudWxsLCB2YWwpO1xuICAgICAgaGFzVmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRIYW5kbGVQb3MoJGhhbmRsZSwgdmFsdWUsIGhhc1ZhbCk7XG4gIH1cblxuICAvKipcbiAgICogQWRqdXN0ZXMgdmFsdWUgZm9yIGhhbmRsZSBpbiByZWdhcmQgdG8gc3RlcCB2YWx1ZS4gcmV0dXJucyBhZGp1c3RlZCB2YWx1ZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgc2VsZWN0ZWQgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSB2YWx1ZSB0byBhZGp1c3QuIHVzZWQgaWYgJGhhbmRsZSBpcyBmYWxzeVxuICAgKi9cbiAgX2FkanVzdFZhbHVlKCRoYW5kbGUsIHZhbHVlKSB7XG4gICAgdmFyIHZhbCxcbiAgICAgIHN0ZXAgPSB0aGlzLm9wdGlvbnMuc3RlcCxcbiAgICAgIGRpdiA9IHBhcnNlRmxvYXQoc3RlcC8yKSxcbiAgICAgIGxlZnQsIHByZXZfdmFsLCBuZXh0X3ZhbDtcbiAgICBpZiAoISEkaGFuZGxlKSB7XG4gICAgICB2YWwgPSBwYXJzZUZsb2F0KCRoYW5kbGUuYXR0cignYXJpYS12YWx1ZW5vdycpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YWwgPSB2YWx1ZTtcbiAgICB9XG4gICAgbGVmdCA9IHZhbCAlIHN0ZXA7XG4gICAgcHJldl92YWwgPSB2YWwgLSBsZWZ0O1xuICAgIG5leHRfdmFsID0gcHJldl92YWwgKyBzdGVwO1xuICAgIGlmIChsZWZ0ID09PSAwKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICB2YWwgPSB2YWwgPj0gcHJldl92YWwgKyBkaXYgPyBuZXh0X3ZhbCA6IHByZXZfdmFsO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNsaWRlciBlbGVtZW50cy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnQgaGFuZGxlIHRvIGFwcGx5IGxpc3RlbmVycyB0by5cbiAgICovXG4gIF9ldmVudHMoJGhhbmRsZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGN1ckhhbmRsZSxcbiAgICAgICAgdGltZXI7XG5cbiAgICAgIHRoaXMuaW5wdXRzLm9mZignY2hhbmdlLnpmLnNsaWRlcicpLm9uKCdjaGFuZ2UuemYuc2xpZGVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgaWR4ID0gX3RoaXMuaW5wdXRzLmluZGV4KCQodGhpcykpO1xuICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgX3RoaXMuaGFuZGxlcy5lcShpZHgpLCAkKHRoaXMpLnZhbCgpKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrU2VsZWN0KSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi5zbGlkZXInKS5vbignY2xpY2suemYuc2xpZGVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgICAgaWYgKCEkKGUudGFyZ2V0KS5pcygnW2RhdGEtc2xpZGVyLWhhbmRsZV0nKSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIF90aGlzLiRoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRyYWdnYWJsZSkge1xuICAgICAgdGhpcy5oYW5kbGVzLmFkZFRvdWNoKCk7XG5cbiAgICAgIHZhciAkYm9keSA9ICQoJ2JvZHknKTtcbiAgICAgICRoYW5kbGVcbiAgICAgICAgLm9mZignbW91c2Vkb3duLnpmLnNsaWRlcicpXG4gICAgICAgIC5vbignbW91c2Vkb3duLnpmLnNsaWRlcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAkaGFuZGxlLmFkZENsYXNzKCdpcy1kcmFnZ2luZycpO1xuICAgICAgICAgIF90aGlzLiRmaWxsLmFkZENsYXNzKCdpcy1kcmFnZ2luZycpOy8vXG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnLCB0cnVlKTtcblxuICAgICAgICAgIGN1ckhhbmRsZSA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcblxuICAgICAgICAgICRib2R5Lm9uKCdtb3VzZW1vdmUuemYuc2xpZGVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XG5cbiAgICAgICAgICB9KS5vbignbW91c2V1cC56Zi5zbGlkZXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgY3VySGFuZGxlKTtcblxuICAgICAgICAgICAgJGhhbmRsZS5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIF90aGlzLiRmaWxsLnJlbW92ZUNsYXNzKCdpcy1kcmFnZ2luZycpO1xuICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICRib2R5Lm9mZignbW91c2Vtb3ZlLnpmLnNsaWRlciBtb3VzZXVwLnpmLnNsaWRlcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC8vIHByZXZlbnQgZXZlbnRzIHRyaWdnZXJlZCBieSB0b3VjaFxuICAgICAgLm9uKCdzZWxlY3RzdGFydC56Zi5zbGlkZXIgdG91Y2htb3ZlLnpmLnNsaWRlcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgJGhhbmRsZS5vZmYoJ2tleWRvd24uemYuc2xpZGVyJykub24oJ2tleWRvd24uemYuc2xpZGVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIF8kaGFuZGxlID0gJCh0aGlzKSxcbiAgICAgICAgICBpZHggPSBfdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID8gX3RoaXMuaGFuZGxlcy5pbmRleChfJGhhbmRsZSkgOiAwLFxuICAgICAgICAgIG9sZFZhbHVlID0gcGFyc2VGbG9hdChfdGhpcy5pbnB1dHMuZXEoaWR4KS52YWwoKSksXG4gICAgICAgICAgbmV3VmFsdWU7XG5cbiAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcbiAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdTbGlkZXInLCB7XG4gICAgICAgIGRlY3JlYXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlIC0gX3RoaXMub3B0aW9ucy5zdGVwO1xuICAgICAgICB9LFxuICAgICAgICBpbmNyZWFzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvbGRWYWx1ZSArIF90aGlzLm9wdGlvbnMuc3RlcDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcmVhc2VfZmFzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvbGRWYWx1ZSAtIF90aGlzLm9wdGlvbnMuc3RlcCAqIDEwO1xuICAgICAgICB9LFxuICAgICAgICBpbmNyZWFzZV9mYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uKCkgeyAvLyBvbmx5IHNldCBoYW5kbGUgcG9zIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWQgc3BlY2lhbGx5XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIF90aGlzLl9zZXRIYW5kbGVQb3MoXyRoYW5kbGUsIG5ld1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvKmlmIChuZXdWYWx1ZSkgeyAvLyBpZiBwcmVzc2VkIGtleSBoYXMgc3BlY2lhbCBmdW5jdGlvbiwgdXBkYXRlIHZhbHVlXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMuX3NldEhhbmRsZVBvcyhfJGhhbmRsZSwgbmV3VmFsdWUpO1xuICAgICAgfSovXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIHNsaWRlciBwbHVnaW4uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuaGFuZGxlcy5vZmYoJy56Zi5zbGlkZXInKTtcbiAgICB0aGlzLmlucHV0cy5vZmYoJy56Zi5zbGlkZXInKTtcbiAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnNsaWRlcicpO1xuXG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG59XG5cblNsaWRlci5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIE1pbmltdW0gdmFsdWUgZm9yIHRoZSBzbGlkZXIgc2NhbGUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMFxuICAgKi9cbiAgc3RhcnQ6IDAsXG4gIC8qKlxuICAgKiBNYXhpbXVtIHZhbHVlIGZvciB0aGUgc2xpZGVyIHNjYWxlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDEwMFxuICAgKi9cbiAgZW5kOiAxMDAsXG4gIC8qKlxuICAgKiBNaW5pbXVtIHZhbHVlIGNoYW5nZSBwZXIgY2hhbmdlIGV2ZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDFcbiAgICovXG4gIHN0ZXA6IDEsXG4gIC8qKlxuICAgKiBWYWx1ZSBhdCB3aGljaCB0aGUgaGFuZGxlL2lucHV0ICoobGVmdCBoYW5kbGUvZmlyc3QgaW5wdXQpKiBzaG91bGQgYmUgc2V0IHRvIG9uIGluaXRpYWxpemF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDBcbiAgICovXG4gIGluaXRpYWxTdGFydDogMCxcbiAgLyoqXG4gICAqIFZhbHVlIGF0IHdoaWNoIHRoZSByaWdodCBoYW5kbGUvc2Vjb25kIGlucHV0IHNob3VsZCBiZSBzZXQgdG8gb24gaW5pdGlhbGl6YXRpb24uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMTAwXG4gICAqL1xuICBpbml0aWFsRW5kOiAxMDAsXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIGlucHV0IHRvIGJlIGxvY2F0ZWQgb3V0c2lkZSB0aGUgY29udGFpbmVyIGFuZCB2aXNpYmxlLiBTZXQgdG8gYnkgdGhlIEpTXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGJpbmRpbmc6IGZhbHNlLFxuICAvKipcbiAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGNsaWNrL3RhcCBvbiB0aGUgc2xpZGVyIGJhciB0byBzZWxlY3QgYSB2YWx1ZS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBjbGlja1NlbGVjdDogdHJ1ZSxcbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGFuZCB1c2UgdGhlIGB2ZXJ0aWNhbGAgY2xhc3MgdG8gY2hhbmdlIGFsaWdubWVudCB0byB2ZXJ0aWNhbC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgdmVydGljYWw6IGZhbHNlLFxuICAvKipcbiAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYWcgdGhlIHNsaWRlciBoYW5kbGUocykgdG8gc2VsZWN0IGEgdmFsdWUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgZHJhZ2dhYmxlOiB0cnVlLFxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIHNsaWRlciBhbmQgcHJldmVudHMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYmVpbmcgYXBwbGllZC4gRG91YmxlIGNoZWNrZWQgYnkgSlMgd2l0aCBgZGlzYWJsZWRDbGFzc2AuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgdXNlIG9mIHR3byBoYW5kbGVzLiBEb3VibGUgY2hlY2tlZCBieSB0aGUgSlMuIENoYW5nZXMgc29tZSBsb2dpYyBoYW5kbGluZy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgZG91YmxlU2lkZWQ6IGZhbHNlLFxuICAvKipcbiAgICogUG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlLlxuICAgKi9cbiAgLy8gc3RlcHM6IDEwMCxcbiAgLyoqXG4gICAqIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGUgcGx1Z2luIHNob3VsZCBnbyB0byBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDJcbiAgICovXG4gIGRlY2ltYWw6IDIsXG4gIC8qKlxuICAgKiBUaW1lIGRlbGF5IGZvciBkcmFnZ2VkIGVsZW1lbnRzLlxuICAgKi9cbiAgLy8gZHJhZ0RlbGF5OiAwLFxuICAvKipcbiAgICogVGltZSwgaW4gbXMsIHRvIGFuaW1hdGUgdGhlIG1vdmVtZW50IG9mIGEgc2xpZGVyIGhhbmRsZSBpZiB1c2VyIGNsaWNrcy90YXBzIG9uIHRoZSBiYXIuIE5lZWRzIHRvIGJlIG1hbnVhbGx5IHNldCBpZiB1cGRhdGluZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBTYXNzIHNldHRpbmdzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDIwMFxuICAgKi9cbiAgbW92ZVRpbWU6IDIwMCwvL3VwZGF0ZSB0aGlzIGlmIGNoYW5naW5nIHRoZSB0cmFuc2l0aW9uIHRpbWUgaW4gdGhlIHNhc3NcbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gZGlzYWJsZWQgc2xpZGVycy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnZGlzYWJsZWQnXG4gICAqL1xuICBkaXNhYmxlZENsYXNzOiAnZGlzYWJsZWQnLFxuICAvKipcbiAgICogV2lsbCBpbnZlcnQgdGhlIGRlZmF1bHQgbGF5b3V0IGZvciBhIHZlcnRpY2FsPHNwYW4gZGF0YS10b29sdGlwIHRpdGxlPVwid2hvIHdvdWxkIGRvIHRoaXM/Pz9cIj4gPC9zcGFuPnNsaWRlci5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgaW52ZXJ0VmVydGljYWw6IGZhbHNlLFxuICAvKipcbiAgICogTWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgYGNoYW5nZWQuemYtc2xpZGVyYCBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgdmFsdWUgY2hhbmdlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDUwMFxuICAgKi9cbiAgY2hhbmdlZERlbGF5OiA1MDBcbn07XG5cbmZ1bmN0aW9uIHBlcmNlbnQoZnJhYywgbnVtKSB7XG4gIHJldHVybiAoZnJhYyAvIG51bSk7XG59XG5mdW5jdGlvbiBhYnNQb3NpdGlvbigkaGFuZGxlLCBkaXIsIGNsaWNrUG9zLCBwYXJhbSkge1xuICByZXR1cm4gTWF0aC5hYnMoKCRoYW5kbGUucG9zaXRpb24oKVtkaXJdICsgKCRoYW5kbGVbcGFyYW1dKCkgLyAyKSkgLSBjbGlja1Bvcyk7XG59XG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihTbGlkZXIsICdTbGlkZXInKTtcblxufShqUXVlcnkpO1xuXG4vLyoqKioqKioqKnRoaXMgaXMgaW4gY2FzZSB3ZSBnbyB0byBzdGF0aWMsIGFic29sdXRlIHBvc2l0aW9ucyBpbnN0ZWFkIG9mIGR5bmFtaWMgcG9zaXRpb25pbmcqKioqKioqKlxuLy8gdGhpcy5zZXRTdGVwcyhmdW5jdGlvbigpIHtcbi8vICAgX3RoaXMuX2V2ZW50cygpO1xuLy8gICB2YXIgaW5pdFN0YXJ0ID0gX3RoaXMub3B0aW9ucy5wb3NpdGlvbnNbX3RoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQgLSAxXSB8fCBudWxsO1xuLy8gICB2YXIgaW5pdEVuZCA9IF90aGlzLm9wdGlvbnMuaW5pdGlhbEVuZCA/IF90aGlzLm9wdGlvbnMucG9zaXRpb25bX3RoaXMub3B0aW9ucy5pbml0aWFsRW5kIC0gMV0gOiBudWxsO1xuLy8gICBpZiAoaW5pdFN0YXJ0IHx8IGluaXRFbmQpIHtcbi8vICAgICBfdGhpcy5faGFuZGxlRXZlbnQoaW5pdFN0YXJ0LCBpbml0RW5kKTtcbi8vICAgfVxuLy8gfSk7XG5cbi8vKioqKioqKioqKip0aGUgb3RoZXIgcGFydCBvZiBhYnNvbHV0ZSBwb3NpdGlvbnMqKioqKioqKioqKioqXG4vLyBTbGlkZXIucHJvdG90eXBlLnNldFN0ZXBzID0gZnVuY3Rpb24oY2IpIHtcbi8vICAgdmFyIHBvc0NoYW5nZSA9IHRoaXMuJGVsZW1lbnQub3V0ZXJXaWR0aCgpIC8gdGhpcy5vcHRpb25zLnN0ZXBzO1xuLy8gICB2YXIgY291bnRlciA9IDBcbi8vICAgd2hpbGUoY291bnRlciA8IHRoaXMub3B0aW9ucy5zdGVwcykge1xuLy8gICAgIGlmIChjb3VudGVyKSB7XG4vLyAgICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25zLnB1c2godGhpcy5vcHRpb25zLnBvc2l0aW9uc1tjb3VudGVyIC0gMV0gKyBwb3NDaGFuZ2UpO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25zLnB1c2gocG9zQ2hhbmdlKTtcbi8vICAgICB9XG4vLyAgICAgY291bnRlcisrO1xuLy8gICB9XG4vLyAgIGNiKCk7XG4vLyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIFN0aWNreSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uc3RpY2t5XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqL1xuXG5jbGFzcyBTdGlja3kge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHN0aWNreSB0aGluZy5cbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIHN0aWNreS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIG9iamVjdCBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgZWxlbWVudCBwcm9ncmFtbWF0aWNhbGx5LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBTdGlja3kuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1N0aWNreScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBzdGlja3kgZWxlbWVudCBieSBhZGRpbmcgY2xhc3NlcywgZ2V0dGluZy9zZXR0aW5nIGRpbWVuc2lvbnMsIGJyZWFrcG9pbnRzIGFuZCBhdHRyaWJ1dGVzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdmFyICRwYXJlbnQgPSB0aGlzLiRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3RpY2t5LWNvbnRhaW5lcl0nKSxcbiAgICAgICAgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ3N0aWNreScpLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoISRwYXJlbnQubGVuZ3RoKSB7XG4gICAgICB0aGlzLndhc1dyYXBwZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLiRjb250YWluZXIgPSAkcGFyZW50Lmxlbmd0aCA/ICRwYXJlbnQgOiAkKHRoaXMub3B0aW9ucy5jb250YWluZXIpLndyYXBJbm5lcih0aGlzLiRlbGVtZW50KTtcbiAgICB0aGlzLiRjb250YWluZXIuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKTtcblxuICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKVxuICAgICAgICAgICAgICAgICAuYXR0cih7J2RhdGEtcmVzaXplJzogaWR9KTtcblxuICAgIHRoaXMuc2Nyb2xsQ291bnQgPSB0aGlzLm9wdGlvbnMuY2hlY2tFdmVyeTtcbiAgICB0aGlzLmlzU3R1Y2sgPSBmYWxzZTtcbiAgICAkKHdpbmRvdykub25lKCdsb2FkLnpmLnN0aWNreScsIGZ1bmN0aW9uKCl7XG4gICAgICBpZihfdGhpcy5vcHRpb25zLmFuY2hvciAhPT0gJycpe1xuICAgICAgICBfdGhpcy4kYW5jaG9yID0gJCgnIycgKyBfdGhpcy5vcHRpb25zLmFuY2hvcik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgX3RoaXMuX3BhcnNlUG9pbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbigpe1xuICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLl9ldmVudHMoaWQuc3BsaXQoJy0nKS5yZXZlcnNlKCkuam9pbignLScpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB1c2luZyBtdWx0aXBsZSBlbGVtZW50cyBhcyBhbmNob3JzLCBjYWxjdWxhdGVzIHRoZSB0b3AgYW5kIGJvdHRvbSBwaXhlbCB2YWx1ZXMgdGhlIHN0aWNreSB0aGluZyBzaG91bGQgc3RpY2sgYW5kIHVuc3RpY2sgb24uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BhcnNlUG9pbnRzKCkge1xuICAgIHZhciB0b3AgPSB0aGlzLm9wdGlvbnMudG9wQW5jaG9yID09IFwiXCIgPyAxIDogdGhpcy5vcHRpb25zLnRvcEFuY2hvcixcbiAgICAgICAgYnRtID0gdGhpcy5vcHRpb25zLmJ0bUFuY2hvcj09IFwiXCIgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IDogdGhpcy5vcHRpb25zLmJ0bUFuY2hvcixcbiAgICAgICAgcHRzID0gW3RvcCwgYnRtXSxcbiAgICAgICAgYnJlYWtzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHB0cy5sZW5ndGg7IGkgPCBsZW4gJiYgcHRzW2ldOyBpKyspIHtcbiAgICAgIHZhciBwdDtcbiAgICAgIGlmICh0eXBlb2YgcHRzW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICBwdCA9IHB0c1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwbGFjZSA9IHB0c1tpXS5zcGxpdCgnOicpLFxuICAgICAgICAgICAgYW5jaG9yID0gJChgIyR7cGxhY2VbMF19YCk7XG5cbiAgICAgICAgcHQgPSBhbmNob3Iub2Zmc2V0KCkudG9wO1xuICAgICAgICBpZiAocGxhY2VbMV0gJiYgcGxhY2VbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBwdCArPSBhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha3NbaV0gPSBwdDtcbiAgICB9XG5cblxuICAgIHRoaXMucG9pbnRzID0gYnJlYWtzO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIHBzdWVkby1yYW5kb20gaWQgZm9yIHVuaXF1ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBfZXZlbnRzKGlkKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgc2Nyb2xsTGlzdGVuZXIgPSB0aGlzLnNjcm9sbExpc3RlbmVyID0gYHNjcm9sbC56Zi4ke2lkfWA7XG4gICAgaWYgKHRoaXMuaXNPbikgeyByZXR1cm47IH1cbiAgICBpZiAodGhpcy5jYW5TdGljaykge1xuICAgICAgdGhpcy5pc09uID0gdHJ1ZTtcbiAgICAgICQod2luZG93KS5vZmYoc2Nyb2xsTGlzdGVuZXIpXG4gICAgICAgICAgICAgICAub24oc2Nyb2xsTGlzdGVuZXIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNjcm9sbENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQ291bnQgPSBfdGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7XG4gICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpXG4gICAgICAgICAgICAgICAgIC5vbigncmVzaXplbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uKGUsIGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jYWxjKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNhblN0aWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5pc09uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZXZlbnRzKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuaXNPbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wYXVzZUxpc3RlbmVycyhzY3JvbGxMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlcnMgZm9yIHNjcm9sbCBhbmQgY2hhbmdlIGV2ZW50cyBvbiBhbmNob3IuXG4gICAqIEBmaXJlcyBTdGlja3kjcGF1c2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNjcm9sbExpc3RlbmVyIC0gdW5pcXVlLCBuYW1lc3BhY2VkIHNjcm9sbCBsaXN0ZW5lciBhdHRhY2hlZCB0byBgd2luZG93YFxuICAgKi9cbiAgX3BhdXNlTGlzdGVuZXJzKHNjcm9sbExpc3RlbmVyKSB7XG4gICAgdGhpcy5pc09uID0gZmFsc2U7XG4gICAgJCh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcik7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaXMgcGF1c2VkIGR1ZSB0byByZXNpemUgZXZlbnQgc2hyaW5raW5nIHRoZSB2aWV3LlxuICAgICAqIEBldmVudCBTdGlja3kjcGF1c2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3BhdXNlLnpmLnN0aWNreScpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBvbiBldmVyeSBgc2Nyb2xsYCBldmVudCBhbmQgb24gYF9pbml0YFxuICAgKiBmaXJlcyBmdW5jdGlvbnMgYmFzZWQgb24gYm9vbGVhbnMgYW5kIGNhY2hlZCB2YWx1ZXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBjaGVja1NpemVzIC0gdHJ1ZSBpZiBwbHVnaW4gc2hvdWxkIHJlY2FsY3VsYXRlIHNpemVzIGFuZCBicmVha3BvaW50cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbCAtIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHBhc3NlZCBmcm9tIHNjcm9sbCBldmVudCBjYiBmdW5jdGlvbi4gSWYgbm90IHBhc3NlZCwgZGVmYXVsdHMgdG8gYHdpbmRvdy5wYWdlWU9mZnNldGAuXG4gICAqL1xuICBfY2FsYyhjaGVja1NpemVzLCBzY3JvbGwpIHtcbiAgICBpZiAoY2hlY2tTaXplcykgeyB0aGlzLl9zZXRTaXplcygpOyB9XG5cbiAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcbiAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghc2Nyb2xsKSB7IHNjcm9sbCA9IHdpbmRvdy5wYWdlWU9mZnNldDsgfVxuXG4gICAgaWYgKHNjcm9sbCA+PSB0aGlzLnRvcFBvaW50KSB7XG4gICAgICBpZiAoc2Nyb2xsIDw9IHRoaXMuYm90dG9tUG9pbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgICB0aGlzLl9zZXRTdGlja3koKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdHVjaykge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaXNTdHVjaykge1xuICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhdXNlcyB0aGUgJGVsZW1lbnQgdG8gYmVjb21lIHN0dWNrLlxuICAgKiBBZGRzIGBwb3NpdGlvbjogZml4ZWQ7YCwgYW5kIGhlbHBlciBjbGFzc2VzLlxuICAgKiBAZmlyZXMgU3RpY2t5I3N0dWNrdG9cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U3RpY2t5KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIHN0aWNrVG8gPSB0aGlzLm9wdGlvbnMuc3RpY2tUbyxcbiAgICAgICAgbXJnbiA9IHN0aWNrVG8gPT09ICd0b3AnID8gJ21hcmdpblRvcCcgOiAnbWFyZ2luQm90dG9tJyxcbiAgICAgICAgbm90U3R1Y2tUbyA9IHN0aWNrVG8gPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJyxcbiAgICAgICAgY3NzID0ge307XG5cbiAgICBjc3NbbXJnbl0gPSBgJHt0aGlzLm9wdGlvbnNbbXJnbl19ZW1gO1xuICAgIGNzc1tzdGlja1RvXSA9IDA7XG4gICAgY3NzW25vdFN0dWNrVG9dID0gJ2F1dG8nO1xuICAgIGNzc1snbGVmdCddID0gdGhpcy4kY29udGFpbmVyLm9mZnNldCgpLmxlZnQgKyBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRjb250YWluZXJbMF0pW1wicGFkZGluZy1sZWZ0XCJdLCAxMCk7XG4gICAgdGhpcy5pc1N0dWNrID0gdHJ1ZTtcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKGBpcy1hbmNob3JlZCBpcy1hdC0ke25vdFN0dWNrVG99YClcbiAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGBpcy1zdHVjayBpcy1hdC0ke3N0aWNrVG99YClcbiAgICAgICAgICAgICAgICAgLmNzcyhjc3MpXG4gICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSAkZWxlbWVudCBoYXMgYmVjb21lIGBwb3NpdGlvbjogZml4ZWQ7YFxuICAgICAgICAgICAgICAgICAgKiBOYW1lc3BhY2VkIHRvIGB0b3BgIG9yIGBib3R0b21gLCBlLmcuIGBzdGlja3kuemYuc3R1Y2t0bzp0b3BgXG4gICAgICAgICAgICAgICAgICAqIEBldmVudCBTdGlja3kjc3R1Y2t0b1xuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgLnRyaWdnZXIoYHN0aWNreS56Zi5zdHVja3RvOiR7c3RpY2tUb31gKTtcbiAgICB0aGlzLiRlbGVtZW50Lm9uKFwidHJhbnNpdGlvbmVuZCB3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kIE1TVHJhbnNpdGlvbkVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLl9zZXRTaXplcygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhdXNlcyB0aGUgJGVsZW1lbnQgdG8gYmVjb21lIHVuc3R1Y2suXG4gICAqIFJlbW92ZXMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXG4gICAqIEFkZHMgb3RoZXIgaGVscGVyIGNsYXNzZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNUb3AgLSB0ZWxscyB0aGUgZnVuY3Rpb24gaWYgdGhlICRlbGVtZW50IHNob3VsZCBhbmNob3IgdG8gdGhlIHRvcCBvciBib3R0b20gb2YgaXRzICRhbmNob3IgZWxlbWVudC5cbiAgICogQGZpcmVzIFN0aWNreSN1bnN0dWNrZnJvbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbW92ZVN0aWNreShpc1RvcCkge1xuICAgIHZhciBzdGlja1RvID0gdGhpcy5vcHRpb25zLnN0aWNrVG8sXG4gICAgICAgIHN0aWNrVG9Ub3AgPSBzdGlja1RvID09PSAndG9wJyxcbiAgICAgICAgY3NzID0ge30sXG4gICAgICAgIGFuY2hvclB0ID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLnBvaW50c1swXSA6IHRoaXMuYW5jaG9ySGVpZ2h0KSAtIHRoaXMuZWxlbUhlaWdodCxcbiAgICAgICAgbXJnbiA9IHN0aWNrVG9Ub3AgPyAnbWFyZ2luVG9wJyA6ICdtYXJnaW5Cb3R0b20nLFxuICAgICAgICBub3RTdHVja1RvID0gc3RpY2tUb1RvcCA/ICdib3R0b20nIDogJ3RvcCcsXG4gICAgICAgIHRvcE9yQm90dG9tID0gaXNUb3AgPyAndG9wJyA6ICdib3R0b20nO1xuXG4gICAgY3NzW21yZ25dID0gMDtcblxuICAgIGNzc1snYm90dG9tJ10gPSAnYXV0byc7XG4gICAgaWYoaXNUb3ApIHtcbiAgICAgIGNzc1sndG9wJ10gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjc3NbJ3RvcCddID0gYW5jaG9yUHQ7XG4gICAgfVxuXG4gICAgY3NzWydsZWZ0J10gPSAnJztcbiAgICB0aGlzLmlzU3R1Y2sgPSBmYWxzZTtcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKGBpcy1zdHVjayBpcy1hdC0ke3N0aWNrVG99YClcbiAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGBpcy1hbmNob3JlZCBpcy1hdC0ke3RvcE9yQm90dG9tfWApXG4gICAgICAgICAgICAgICAgIC5jc3MoY3NzKVxuICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBhbmNob3JlZC5cbiAgICAgICAgICAgICAgICAgICogTmFtZXNwYWNlZCB0byBgdG9wYCBvciBgYm90dG9tYCwgZS5nLiBgc3RpY2t5LnpmLnVuc3R1Y2tmcm9tOmJvdHRvbWBcbiAgICAgICAgICAgICAgICAgICogQGV2ZW50IFN0aWNreSN1bnN0dWNrZnJvbVxuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgLnRyaWdnZXIoYHN0aWNreS56Zi51bnN0dWNrZnJvbToke3RvcE9yQm90dG9tfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlICRlbGVtZW50IGFuZCAkY29udGFpbmVyIHNpemVzIGZvciBwbHVnaW4uXG4gICAqIENhbGxzIGBfc2V0QnJlYWtQb2ludHNgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbiBvZiBgX3NldEJyZWFrUG9pbnRzYC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRTaXplcyhjYikge1xuICAgIHRoaXMuY2FuU3RpY2sgPSBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc3RpY2t5T24pO1xuICAgIGlmICghdGhpcy5jYW5TdGljaykgeyBjYigpOyB9XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgbmV3RWxlbVdpZHRoID0gdGhpcy4kY29udGFpbmVyWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLFxuICAgICAgICBjb21wID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kY29udGFpbmVyWzBdKSxcbiAgICAgICAgcGRuZyA9IHBhcnNlSW50KGNvbXBbJ3BhZGRpbmctcmlnaHQnXSwgMTApO1xuXG4gICAgaWYgKHRoaXMuJGFuY2hvciAmJiB0aGlzLiRhbmNob3IubGVuZ3RoKSB7XG4gICAgICB0aGlzLmFuY2hvckhlaWdodCA9IHRoaXMuJGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcnNlUG9pbnRzKCk7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgJ21heC13aWR0aCc6IGAke25ld0VsZW1XaWR0aCAtIHBkbmd9cHhgXG4gICAgfSk7XG5cbiAgICB2YXIgbmV3Q29udGFpbmVySGVpZ2h0ID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgdGhpcy5jb250YWluZXJIZWlnaHQ7XG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuY3NzKFwiZGlzcGxheVwiKSA9PSBcIm5vbmVcIikge1xuICAgICAgbmV3Q29udGFpbmVySGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSBuZXdDb250YWluZXJIZWlnaHQ7XG4gICAgdGhpcy4kY29udGFpbmVyLmNzcyh7XG4gICAgICBoZWlnaHQ6IG5ld0NvbnRhaW5lckhlaWdodFxuICAgIH0pO1xuICAgIHRoaXMuZWxlbUhlaWdodCA9IG5ld0NvbnRhaW5lckhlaWdodDtcblxuICBcdGlmICh0aGlzLmlzU3R1Y2spIHtcbiAgXHRcdHRoaXMuJGVsZW1lbnQuY3NzKHtcImxlZnRcIjp0aGlzLiRjb250YWluZXIub2Zmc2V0KCkubGVmdCArIHBhcnNlSW50KGNvbXBbJ3BhZGRpbmctbGVmdCddLCAxMCl9KTtcbiAgXHR9XG5cbiAgICB0aGlzLl9zZXRCcmVha1BvaW50cyhuZXdDb250YWluZXJIZWlnaHQsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGNiKSB7IGNiKCk7IH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1cHBlciBhbmQgbG93ZXIgYnJlYWtwb2ludHMgZm9yIHRoZSBlbGVtZW50IHRvIGJlY29tZSBzdGlja3kvdW5zdGlja3kuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbGVtSGVpZ2h0IC0gcHggdmFsdWUgZm9yIHN0aWNreS4kZWxlbWVudCBoZWlnaHQsIGNhbGN1bGF0ZWQgYnkgYF9zZXRTaXplc2AuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGNvbXBsZXRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0QnJlYWtQb2ludHMoZWxlbUhlaWdodCwgY2IpIHtcbiAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcbiAgICAgIGlmIChjYikgeyBjYigpOyB9XG4gICAgICBlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHZhciBtVG9wID0gZW1DYWxjKHRoaXMub3B0aW9ucy5tYXJnaW5Ub3ApLFxuICAgICAgICBtQnRtID0gZW1DYWxjKHRoaXMub3B0aW9ucy5tYXJnaW5Cb3R0b20pLFxuICAgICAgICB0b3BQb2ludCA9IHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMF0gOiB0aGlzLiRhbmNob3Iub2Zmc2V0KCkudG9wLFxuICAgICAgICBib3R0b21Qb2ludCA9IHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gOiB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0LFxuICAgICAgICAvLyB0b3BQb2ludCA9IHRoaXMuJGFuY2hvci5vZmZzZXQoKS50b3AgfHwgdGhpcy5wb2ludHNbMF0sXG4gICAgICAgIC8vIGJvdHRvbVBvaW50ID0gdG9wUG9pbnQgKyB0aGlzLmFuY2hvckhlaWdodCB8fCB0aGlzLnBvaW50c1sxXSxcbiAgICAgICAgd2luSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdGlja1RvID09PSAndG9wJykge1xuICAgICAgdG9wUG9pbnQgLT0gbVRvcDtcbiAgICAgIGJvdHRvbVBvaW50IC09IChlbGVtSGVpZ2h0ICsgbVRvcCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc3RpY2tUbyA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRvcFBvaW50IC09ICh3aW5IZWlnaHQgLSAoZWxlbUhlaWdodCArIG1CdG0pKTtcbiAgICAgIGJvdHRvbVBvaW50IC09ICh3aW5IZWlnaHQgLSBtQnRtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy90aGlzIHdvdWxkIGJlIHRoZSBzdGlja1RvOiBib3RoIG9wdGlvbi4uLiB0cmlja3lcbiAgICB9XG5cbiAgICB0aGlzLnRvcFBvaW50ID0gdG9wUG9pbnQ7XG4gICAgdGhpcy5ib3R0b21Qb2ludCA9IGJvdHRvbVBvaW50O1xuXG4gICAgaWYgKGNiKSB7IGNiKCk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY3VycmVudCBzdGlja3kgZWxlbWVudC5cbiAgICogUmVzZXRzIHRoZSBlbGVtZW50IHRvIHRoZSB0b3AgcG9zaXRpb24gZmlyc3QuXG4gICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzLCBKUy1hZGRlZCBjc3MgcHJvcGVydGllcyBhbmQgY2xhc3NlcywgYW5kIHVud3JhcHMgdGhlICRlbGVtZW50IGlmIHRoZSBKUyBhZGRlZCB0aGUgJGNvbnRhaW5lci5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcblxuICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoYCR7dGhpcy5vcHRpb25zLnN0aWNreUNsYXNzfSBpcy1hbmNob3JlZCBpcy1hdC10b3BgKVxuICAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgICAgICAgICAgYm90dG9tOiAnJyxcbiAgICAgICAgICAgICAgICAgICAnbWF4LXdpZHRoJzogJydcbiAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgLm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpO1xuICAgIGlmICh0aGlzLiRhbmNob3IgJiYgdGhpcy4kYW5jaG9yLmxlbmd0aCkge1xuICAgICAgdGhpcy4kYW5jaG9yLm9mZignY2hhbmdlLnpmLnN0aWNreScpO1xuICAgIH1cbiAgICAkKHdpbmRvdykub2ZmKHRoaXMuc2Nyb2xsTGlzdGVuZXIpO1xuXG4gICAgaWYgKHRoaXMud2FzV3JhcHBlZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC51bndyYXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcylcbiAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcnXG4gICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG59XG5cblN0aWNreS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEN1c3RvbWl6YWJsZSBjb250YWluZXIgdGVtcGxhdGUuIEFkZCB5b3VyIG93biBjbGFzc2VzIGZvciBzdHlsaW5nIGFuZCBzaXppbmcuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJyZsdDtkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyIGNsYXNzPVwic21hbGwtNiBjb2x1bW5zXCImZ3Q7Jmx0Oy9kaXYmZ3Q7J1xuICAgKi9cbiAgY29udGFpbmVyOiAnPGRpdiBkYXRhLXN0aWNreS1jb250YWluZXI+PC9kaXY+JyxcbiAgLyoqXG4gICAqIExvY2F0aW9uIGluIHRoZSB2aWV3IHRoZSBlbGVtZW50IHN0aWNrcyB0by5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAndG9wJ1xuICAgKi9cbiAgc3RpY2tUbzogJ3RvcCcsXG4gIC8qKlxuICAgKiBJZiBhbmNob3JlZCB0byBhIHNpbmdsZSBlbGVtZW50LCB0aGUgaWQgb2YgdGhhdCBlbGVtZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdleGFtcGxlSWQnXG4gICAqL1xuICBhbmNob3I6ICcnLFxuICAvKipcbiAgICogSWYgdXNpbmcgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGFzIGFuY2hvciBwb2ludHMsIHRoZSBpZCBvZiB0aGUgdG9wIGFuY2hvci5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnZXhhbXBsZUlkOnRvcCdcbiAgICovXG4gIHRvcEFuY2hvcjogJycsXG4gIC8qKlxuICAgKiBJZiB1c2luZyBtb3JlIHRoYW4gb25lIGVsZW1lbnQgYXMgYW5jaG9yIHBvaW50cywgdGhlIGlkIG9mIHRoZSBib3R0b20gYW5jaG9yLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdleGFtcGxlSWQ6Ym90dG9tJ1xuICAgKi9cbiAgYnRtQW5jaG9yOiAnJyxcbiAgLyoqXG4gICAqIE1hcmdpbiwgaW4gYGVtYCdzIHRvIGFwcGx5IHRvIHRoZSB0b3Agb2YgdGhlIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIHN0aWNreS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAxXG4gICAqL1xuICBtYXJnaW5Ub3A6IDEsXG4gIC8qKlxuICAgKiBNYXJnaW4sIGluIGBlbWAncyB0byBhcHBseSB0byB0aGUgYm90dG9tIG9mIHRoZSBlbGVtZW50IHdoZW4gaXQgYmVjb21lcyBzdGlja3kuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMVxuICAgKi9cbiAgbWFyZ2luQm90dG9tOiAxLFxuICAvKipcbiAgICogQnJlYWtwb2ludCBzdHJpbmcgdGhhdCBpcyB0aGUgbWluaW11bSBzY3JlZW4gc2l6ZSBhbiBlbGVtZW50IHNob3VsZCBiZWNvbWUgc3RpY2t5LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdtZWRpdW0nXG4gICAqL1xuICBzdGlja3lPbjogJ21lZGl1bScsXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHN0aWNreSBlbGVtZW50LCBhbmQgcmVtb3ZlZCBvbiBkZXN0cnVjdGlvbi4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5YC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnc3RpY2t5J1xuICAgKi9cbiAgc3RpY2t5Q2xhc3M6ICdzdGlja3knLFxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byBzdGlja3kgY29udGFpbmVyLiBGb3VuZGF0aW9uIGRlZmF1bHRzIHRvIGBzdGlja3ktY29udGFpbmVyYC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnc3RpY2t5LWNvbnRhaW5lcidcbiAgICovXG4gIGNvbnRhaW5lckNsYXNzOiAnc3RpY2t5LWNvbnRhaW5lcicsXG4gIC8qKlxuICAgKiBOdW1iZXIgb2Ygc2Nyb2xsIGV2ZW50cyBiZXR3ZWVuIHRoZSBwbHVnaW4ncyByZWNhbGN1bGF0aW5nIHN0aWNreSBwb2ludHMuIFNldHRpbmcgaXQgdG8gYDBgIHdpbGwgY2F1c2UgaXQgdG8gcmVjYWxjIGV2ZXJ5IHNjcm9sbCBldmVudCwgc2V0dGluZyBpdCB0byBgLTFgIHdpbGwgcHJldmVudCByZWNhbGMgb24gc2Nyb2xsLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDUwXG4gICAqL1xuICBjaGVja0V2ZXJ5OiAtMVxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGVtIHZhbHVlc1xuICogQHBhcmFtIE51bWJlciB7ZW19IC0gbnVtYmVyIG9mIGVtJ3MgdG8gY2FsY3VsYXRlIGludG8gcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGVtQ2FsYyhlbSkge1xuICByZXR1cm4gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSwgbnVsbCkuZm9udFNpemUsIDEwKSAqIGVtO1xufVxuXG4vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oU3RpY2t5LCAnU3RpY2t5Jyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBUYWJzIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi50YWJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRpbWVyQW5kSW1hZ2VMb2FkZXIgaWYgdGFicyBjb250YWluIGltYWdlc1xuICovXG5cbmNsYXNzIFRhYnMge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0YWJzLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIFRhYnMjaW5pdFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIHRhYnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgVGFicy5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1RhYnMnKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdUYWJzJywge1xuICAgICAgJ0VOVEVSJzogJ29wZW4nLFxuICAgICAgJ1NQQUNFJzogJ29wZW4nLFxuICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxuICAgICAgJ0FSUk9XX1VQJzogJ3ByZXZpb3VzJyxcbiAgICAgICdBUlJPV19ET1dOJzogJ25leHQnLFxuICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnXG4gICAgICAvLyAnVEFCJzogJ25leHQnLFxuICAgICAgLy8gJ1NISUZUX1RBQic6ICdwcmV2aW91cydcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgdGFicyBieSBzaG93aW5nIGFuZCBmb2N1c2luZyAoaWYgYXV0b0ZvY3VzPXRydWUpIHRoZSBwcmVzZXQgYWN0aXZlIHRhYi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLiR0YWJUaXRsZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoYC4ke3RoaXMub3B0aW9ucy5saW5rQ2xhc3N9YCk7XG4gICAgdGhpcy4kdGFiQ29udGVudCA9ICQoYFtkYXRhLXRhYnMtY29udGVudD1cIiR7dGhpcy4kZWxlbWVudFswXS5pZH1cIl1gKTtcblxuICAgIHRoaXMuJHRhYlRpdGxlcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICRsaW5rID0gJGVsZW0uZmluZCgnYScpLFxuICAgICAgICAgIGlzQWN0aXZlID0gJGVsZW0uaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpLFxuICAgICAgICAgIGhhc2ggPSAkbGlua1swXS5oYXNoLnNsaWNlKDEpLFxuICAgICAgICAgIGxpbmtJZCA9ICRsaW5rWzBdLmlkID8gJGxpbmtbMF0uaWQgOiBgJHtoYXNofS1sYWJlbGAsXG4gICAgICAgICAgJHRhYkNvbnRlbnQgPSAkKGAjJHtoYXNofWApO1xuXG4gICAgICAkZWxlbS5hdHRyKHsncm9sZSc6ICdwcmVzZW50YXRpb24nfSk7XG5cbiAgICAgICRsaW5rLmF0dHIoe1xuICAgICAgICAncm9sZSc6ICd0YWInLFxuICAgICAgICAnYXJpYS1jb250cm9scyc6IGhhc2gsXG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogaXNBY3RpdmUsXG4gICAgICAgICdpZCc6IGxpbmtJZFxuICAgICAgfSk7XG5cbiAgICAgICR0YWJDb250ZW50LmF0dHIoe1xuICAgICAgICAncm9sZSc6ICd0YWJwYW5lbCcsXG4gICAgICAgICdhcmlhLWhpZGRlbic6ICFpc0FjdGl2ZSxcbiAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGxpbmtJZFxuICAgICAgfSk7XG5cbiAgICAgIGlmKGlzQWN0aXZlICYmIF90aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKXtcbiAgICAgICAgJGxpbmsuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCkge1xuICAgICAgdmFyICRpbWFnZXMgPSB0aGlzLiR0YWJDb250ZW50LmZpbmQoJ2ltZycpO1xuXG4gICAgICBpZiAoJGltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCgkaW1hZ2VzLCB0aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRIZWlnaHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHRoaXMuX2FkZEtleUhhbmRsZXIoKTtcbiAgICB0aGlzLl9hZGRDbGlja0hhbmRsZXIoKTtcbiAgICB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIgPSBudWxsO1xuICAgIFxuICAgIGlmICh0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpIHtcbiAgICAgIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciA9IHRoaXMuX3NldEhlaWdodC5iaW5kKHRoaXMpO1xuICAgICAgXG4gICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY2xpY2sgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgdGFicy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hZGRDbGlja0hhbmRsZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vZmYoJ2NsaWNrLnpmLnRhYnMnKVxuICAgICAgLm9uKCdjbGljay56Zi50YWJzJywgYC4ke3RoaXMub3B0aW9ucy5saW5rQ2xhc3N9YCwgZnVuY3Rpb24oZSl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJCh0aGlzKSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGtleWJvYXJkIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkS2V5SGFuZGxlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciAkZmlyc3RUYWIgPSBfdGhpcy4kZWxlbWVudC5maW5kKCdsaTpmaXJzdC1vZi10eXBlJyk7XG4gICAgdmFyICRsYXN0VGFiID0gX3RoaXMuJGVsZW1lbnQuZmluZCgnbGk6bGFzdC1vZi10eXBlJyk7XG5cbiAgICB0aGlzLiR0YWJUaXRsZXMub2ZmKCdrZXlkb3duLnpmLnRhYnMnKS5vbigna2V5ZG93bi56Zi50YWJzJywgZnVuY3Rpb24oZSl7XG4gICAgICBpZiAoZS53aGljaCA9PT0gOSkgcmV0dXJuO1xuICAgICAgXG5cbiAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyksXG4gICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgndWwnKS5jaGlsZHJlbignbGknKSxcbiAgICAgICAgJHByZXZFbGVtZW50LFxuICAgICAgICAkbmV4dEVsZW1lbnQ7XG5cbiAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaWYgKCQodGhpcykuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMud3JhcE9uS2V5cykge1xuICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gaSA9PT0gMCA/ICRlbGVtZW50cy5sYXN0KCkgOiAkZWxlbWVudHMuZXEoaS0xKTtcbiAgICAgICAgICAgICRuZXh0RWxlbWVudCA9IGkgPT09ICRlbGVtZW50cy5sZW5ndGggLTEgPyAkZWxlbWVudHMuZmlyc3QoKSA6ICRlbGVtZW50cy5lcShpKzEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaS0xKSk7XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSsxLCAkZWxlbWVudHMubGVuZ3RoLTEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ1RhYnMnLCB7XG4gICAgICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRlbGVtZW50LmZpbmQoJ1tyb2xlPVwidGFiXCJdJykuZm9jdXMoKTtcbiAgICAgICAgICBfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCRlbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRwcmV2RWxlbWVudC5maW5kKCdbcm9sZT1cInRhYlwiXScpLmZvY3VzKCk7XG4gICAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkcHJldkVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkbmV4dEVsZW1lbnQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKS5mb2N1cygpO1xuICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJG5leHRFbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSB0YWIgYCR0YXJnZXRDb250ZW50YCBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBUYWIgdG8gb3Blbi5cbiAgICogQGZpcmVzIFRhYnMjY2hhbmdlXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgX2hhbmRsZVRhYkNoYW5nZSgkdGFyZ2V0KSB7XG4gICAgdmFyICR0YWJMaW5rID0gJHRhcmdldC5maW5kKCdbcm9sZT1cInRhYlwiXScpLFxuICAgICAgICBoYXNoID0gJHRhYkxpbmtbMF0uaGFzaCxcbiAgICAgICAgJHRhcmdldENvbnRlbnQgPSB0aGlzLiR0YWJDb250ZW50LmZpbmQoaGFzaCksXG4gICAgICAgICRvbGRUYWIgPSB0aGlzLiRlbGVtZW50LlxuICAgICAgICAgIGZpbmQoYC4ke3RoaXMub3B0aW9ucy5saW5rQ2xhc3N9LmlzLWFjdGl2ZWApXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKVxuICAgICAgICAgIC5maW5kKCdbcm9sZT1cInRhYlwiXScpXG4gICAgICAgICAgLmF0dHIoeyAnYXJpYS1zZWxlY3RlZCc6ICdmYWxzZScgfSk7XG5cbiAgICAkKGAjJHskb2xkVGFiLmF0dHIoJ2FyaWEtY29udHJvbHMnKX1gKVxuICAgICAgLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKVxuICAgICAgLmF0dHIoeyAnYXJpYS1oaWRkZW4nOiAndHJ1ZScgfSk7XG5cbiAgICAkdGFyZ2V0LmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAgICR0YWJMaW5rLmF0dHIoeydhcmlhLXNlbGVjdGVkJzogJ3RydWUnfSk7XG5cbiAgICAkdGFyZ2V0Q29udGVudFxuICAgICAgLmFkZENsYXNzKCdpcy1hY3RpdmUnKVxuICAgICAgLmF0dHIoeydhcmlhLWhpZGRlbic6ICdmYWxzZSd9KTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgc3VjY2Vzc2Z1bGx5IGNoYW5nZWQgdGFicy5cbiAgICAgKiBAZXZlbnQgVGFicyNjaGFuZ2VcbiAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZS56Zi50YWJzJywgWyR0YXJnZXRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIGZvciBzZWxlY3RpbmcgYSBjb250ZW50IHBhbmUgdG8gZGlzcGxheS5cbiAgICogQHBhcmFtIHtqUXVlcnkgfCBTdHJpbmd9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiB0aGUgaWQgb2YgdGhlIHBhbmUgdG8gZGlzcGxheS5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBzZWxlY3RUYWIoZWxlbSkge1xuICAgIHZhciBpZFN0cjtcblxuICAgIGlmICh0eXBlb2YgZWxlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlkU3RyID0gZWxlbVswXS5pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWRTdHIgPSBlbGVtO1xuICAgIH1cblxuICAgIGlmIChpZFN0ci5pbmRleE9mKCcjJykgPCAwKSB7XG4gICAgICBpZFN0ciA9IGAjJHtpZFN0cn1gO1xuICAgIH1cblxuICAgIHZhciAkdGFyZ2V0ID0gdGhpcy4kdGFiVGl0bGVzLmZpbmQoYFtocmVmPVwiJHtpZFN0cn1cIl1gKS5wYXJlbnQoYC4ke3RoaXMub3B0aW9ucy5saW5rQ2xhc3N9YCk7XG5cbiAgICB0aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJHRhcmdldCk7XG4gIH07XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgZWFjaCBwYW5lbCB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWxsZXN0IHBhbmVsLlxuICAgKiBJZiBlbmFibGVkIGluIG9wdGlvbnMsIGdldHMgY2FsbGVkIG9uIG1lZGlhIHF1ZXJ5IGNoYW5nZS5cbiAgICogSWYgbG9hZGluZyBjb250ZW50IHZpYSBleHRlcm5hbCBzb3VyY2UsIGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgb3Igd2l0aCBfcmVmbG93LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRIZWlnaHQoKSB7XG4gICAgdmFyIG1heCA9IDA7XG4gICAgdGhpcy4kdGFiQ29udGVudFxuICAgICAgLmZpbmQoYC4ke3RoaXMub3B0aW9ucy5wYW5lbENsYXNzfWApXG4gICAgICAuY3NzKCdoZWlnaHQnLCAnJylcbiAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFuZWwgPSAkKHRoaXMpLFxuICAgICAgICAgICAgaXNBY3RpdmUgPSBwYW5lbC5oYXNDbGFzcygnaXMtYWN0aXZlJyk7XG5cbiAgICAgICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICAgIHBhbmVsLmNzcyh7J3Zpc2liaWxpdHknOiAnaGlkZGVuJywgJ2Rpc3BsYXknOiAnYmxvY2snfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuXG4gICAgICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgICBwYW5lbC5jc3Moe1xuICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiAnJyxcbiAgICAgICAgICAgICdkaXNwbGF5JzogJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1heCA9IHRlbXAgPiBtYXggPyB0ZW1wIDogbWF4O1xuICAgICAgfSlcbiAgICAgIC5jc3MoJ2hlaWdodCcsIGAke21heH1weGApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFuIHRhYnMuXG4gICAqIEBmaXJlcyBUYWJzI2Rlc3Ryb3llZFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAuZmluZChgLiR7dGhpcy5vcHRpb25zLmxpbmtDbGFzc31gKVxuICAgICAgLm9mZignLnpmLnRhYnMnKS5oaWRlKCkuZW5kKClcbiAgICAgIC5maW5kKGAuJHt0aGlzLm9wdGlvbnMucGFuZWxDbGFzc31gKVxuICAgICAgLmhpZGUoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpIHtcbiAgICAgIGlmICh0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgJCh3aW5kb3cpLm9mZignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cbn1cblxuVGFicy5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgd2luZG93IHRvIHNjcm9sbCB0byBjb250ZW50IG9mIGFjdGl2ZSBwYW5lIG9uIGxvYWQgaWYgc2V0IHRvIHRydWUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGF1dG9Gb2N1czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93cyBrZXlib2FyZCBpbnB1dCB0byAnd3JhcCcgYXJvdW5kIHRoZSB0YWIgbGlua3MuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgd3JhcE9uS2V5czogdHJ1ZSxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSB0YWIgY29udGVudCBwYW5lcyB0byBtYXRjaCBoZWlnaHRzIGlmIHNldCB0byB0cnVlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBtYXRjaEhlaWdodDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gYGxpYCdzIGluIHRhYiBsaW5rIGxpc3QuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3RhYnMtdGl0bGUnXG4gICAqL1xuICBsaW5rQ2xhc3M6ICd0YWJzLXRpdGxlJyxcblxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgY29udGVudCBjb250YWluZXJzLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICd0YWJzLXBhbmVsJ1xuICAgKi9cbiAgcGFuZWxDbGFzczogJ3RhYnMtcGFuZWwnXG59O1xuXG5mdW5jdGlvbiBjaGVja0NsYXNzKCRlbGVtKXtcbiAgcmV0dXJuICRlbGVtLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTtcbn1cblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKFRhYnMsICdUYWJzJyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBUb2dnbGVyIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi50b2dnbGVyXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICovXG5cbmNsYXNzIFRvZ2dsZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUb2dnbGVyLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIFRvZ2dsZXIjaW5pdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvZ2dsZXIuZGVmYXVsdHMsIGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9ICcnO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnVG9nZ2xlcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBUb2dnbGVyIHBsdWdpbiBieSBwYXJzaW5nIHRoZSB0b2dnbGUgY2xhc3MgZnJvbSBkYXRhLXRvZ2dsZXIsIG9yIGFuaW1hdGlvbiBjbGFzc2VzIGZyb20gZGF0YS1hbmltYXRlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciBpbnB1dDtcbiAgICAvLyBQYXJzZSBhbmltYXRpb24gY2xhc3NlcyBpZiB0aGV5IHdlcmUgc2V0XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XG4gICAgICBpbnB1dCA9IHRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KCcgJyk7XG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uSW4gPSBpbnB1dFswXTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uT3V0ID0gaW5wdXRbMV0gfHwgbnVsbDtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBwYXJzZSB0b2dnbGUgY2xhc3NcbiAgICBlbHNlIHtcbiAgICAgIGlucHV0ID0gdGhpcy4kZWxlbWVudC5kYXRhKCd0b2dnbGVyJyk7XG4gICAgICAvLyBBbGxvdyBmb3IgYSAuIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZ1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSBpbnB1dFswXSA9PT0gJy4nID8gaW5wdXQuc2xpY2UoMSkgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIHRvIHRyaWdnZXJzXG4gICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZDtcbiAgICAkKGBbZGF0YS1vcGVuPVwiJHtpZH1cIl0sIFtkYXRhLWNsb3NlPVwiJHtpZH1cIl0sIFtkYXRhLXRvZ2dsZT1cIiR7aWR9XCJdYClcbiAgICAgIC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgaWQpO1xuICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgaGlkZGVuLCBhZGQgYXJpYS1oaWRkZW5cbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0aGlzLiRlbGVtZW50LmlzKCc6aGlkZGVuJykgPyBmYWxzZSA6IHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIHRvZ2dsZSB0cmlnZ2VyLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ldmVudHMoKSB7XG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJ3RvZ2dsZS56Zi50cmlnZ2VyJykub24oJ3RvZ2dsZS56Zi50cmlnZ2VyJywgdGhpcy50b2dnbGUuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgdGFyZ2V0IGNsYXNzIG9uIHRoZSB0YXJnZXQgZWxlbWVudC4gQW4gZXZlbnQgaXMgZmlyZWQgZnJvbSB0aGUgb3JpZ2luYWwgdHJpZ2dlciBkZXBlbmRpbmcgb24gaWYgdGhlIHJlc3VsdGFudCBzdGF0ZSB3YXMgXCJvblwiIG9yIFwib2ZmXCIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAZmlyZXMgVG9nZ2xlciNvblxuICAgKiBAZmlyZXMgVG9nZ2xlciNvZmZcbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzWyB0aGlzLm9wdGlvbnMuYW5pbWF0ZSA/ICdfdG9nZ2xlQW5pbWF0ZScgOiAnX3RvZ2dsZUNsYXNzJ10oKTtcbiAgfVxuXG4gIF90b2dnbGVDbGFzcygpIHtcbiAgICB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMuY2xhc3NOYW1lKTtcblxuICAgIHZhciBpc09uID0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLmNsYXNzTmFtZSk7XG4gICAgaWYgKGlzT24pIHtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgaWYgdGhlIHRhcmdldCBlbGVtZW50IGhhcyB0aGUgY2xhc3MgYWZ0ZXIgYSB0b2dnbGUuXG4gICAgICAgKiBAZXZlbnQgVG9nZ2xlciNvblxuICAgICAgICovXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29uLnpmLnRvZ2dsZXInKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBkb2VzIG5vdCBoYXZlIHRoZSBjbGFzcyBhZnRlciBhIHRvZ2dsZS5cbiAgICAgICAqIEBldmVudCBUb2dnbGVyI29mZlxuICAgICAgICovXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29mZi56Zi50b2dnbGVyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQVJJQShpc09uKTtcbiAgfVxuXG4gIF90b2dnbGVBbmltYXRlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy4kZWxlbWVudC5pcygnOmhpZGRlbicpKSB7XG4gICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4odGhpcy4kZWxlbWVudCwgdGhpcy5hbmltYXRpb25JbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl91cGRhdGVBUklBKHRydWUpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ29uLnpmLnRvZ2dsZXInKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kZWxlbWVudCwgdGhpcy5hbmltYXRpb25PdXQsIGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fdXBkYXRlQVJJQShmYWxzZSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignb2ZmLnpmLnRvZ2dsZXInKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVBUklBKGlzT24pIHtcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09uID8gdHJ1ZSA6IGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgaW5zdGFuY2Ugb2YgVG9nZ2xlciBvbiB0aGUgZWxlbWVudC5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudG9nZ2xlcicpO1xuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5Ub2dnbGVyLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogVGVsbHMgdGhlIHBsdWdpbiBpZiB0aGUgZWxlbWVudCBzaG91bGQgYW5pbWF0ZWQgd2hlbiB0b2dnbGVkLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBhbmltYXRlOiBmYWxzZVxufTtcblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKFRvZ2dsZXIsICdUb2dnbGVyJyk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBUb29sdGlwIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi50b29sdGlwXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICovXG5cbmNsYXNzIFRvb2x0aXAge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIFRvb2x0aXAuXG4gICAqIEBjbGFzc1xuICAgKiBAZmlyZXMgVG9vbHRpcCNpbml0XG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhdHRhY2ggYSB0b29sdGlwIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB0byBleHRlbmQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgVG9vbHRpcC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNDbGljayA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1Rvb2x0aXAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgdG9vbHRpcCBieSBzZXR0aW5nIHRoZSBjcmVhdGluZyB0aGUgdGlwIGVsZW1lbnQsIGFkZGluZyBpdCdzIHRleHQsIHNldHRpbmcgcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIHNldHRpbmcgYXR0cmlidXRlcyBvbiB0aGUgYW5jaG9yLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdmFyIGVsZW1JZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1kZXNjcmliZWRieScpIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ3Rvb2x0aXAnKTtcblxuICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MgfHwgdGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLiRlbGVtZW50KTtcbiAgICB0aGlzLm9wdGlvbnMudGlwVGV4dCA9IHRoaXMub3B0aW9ucy50aXBUZXh0IHx8IHRoaXMuJGVsZW1lbnQuYXR0cigndGl0bGUnKTtcbiAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlID8gJCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpIDogdGhpcy5fYnVpbGRUZW1wbGF0ZShlbGVtSWQpO1xuXG4gICAgdGhpcy50ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KVxuICAgICAgICAudGV4dCh0aGlzLm9wdGlvbnMudGlwVGV4dClcbiAgICAgICAgLmhpZGUoKTtcblxuICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAndGl0bGUnOiAnJyxcbiAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogZWxlbUlkLFxuICAgICAgJ2RhdGEteWV0aS1ib3gnOiBlbGVtSWQsXG4gICAgICAnZGF0YS10b2dnbGUnOiBlbGVtSWQsXG4gICAgICAnZGF0YS1yZXNpemUnOiBlbGVtSWRcbiAgICB9KS5hZGRDbGFzcyh0aGlzLnRyaWdnZXJDbGFzcyk7XG5cbiAgICAvL2hlbHBlciB2YXJpYWJsZXMgdG8gdHJhY2sgbW92ZW1lbnQgb24gY29sbGlzaW9uc1xuICAgIHRoaXMudXNlZFBvc2l0aW9ucyA9IFtdO1xuICAgIHRoaXMuY291bnRlciA9IDQ7XG4gICAgdGhpcy5jbGFzc0NoYW5nZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2V2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyYWJzIHRoZSBjdXJyZW50IHBvc2l0aW9uaW5nIGNsYXNzLCBpZiBwcmVzZW50LCBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFBvc2l0aW9uQ2xhc3MoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkgeyByZXR1cm4gJyc7IH1cbiAgICAvLyB2YXIgcG9zaXRpb24gPSBlbGVtZW50LmF0dHIoJ2NsYXNzJykubWF0Y2goL3RvcHxsZWZ0fHJpZ2h0L2cpO1xuICAgIHZhciBwb3NpdGlvbiA9IGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC9cXGIodG9wfGxlZnR8cmlnaHQpXFxiL2cpO1xuICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID8gcG9zaXRpb25bMF0gOiAnJztcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH07XG4gIC8qKlxuICAgKiBidWlsZHMgdGhlIHRvb2x0aXAgZWxlbWVudCwgYWRkcyBhdHRyaWJ1dGVzLCBhbmQgcmV0dXJucyB0aGUgdGVtcGxhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnVpbGRUZW1wbGF0ZShpZCkge1xuICAgIHZhciB0ZW1wbGF0ZUNsYXNzZXMgPSAoYCR7dGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzc30gJHt0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzc30gJHt0aGlzLm9wdGlvbnMudGVtcGxhdGVDbGFzc2VzfWApLnRyaW0oKTtcbiAgICB2YXIgJHRlbXBsYXRlID0gICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3ModGVtcGxhdGVDbGFzc2VzKS5hdHRyKHtcbiAgICAgICdyb2xlJzogJ3Rvb2x0aXAnLFxuICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICdkYXRhLWlzLWFjdGl2ZSc6IGZhbHNlLFxuICAgICAgJ2RhdGEtaXMtZm9jdXMnOiBmYWxzZSxcbiAgICAgICdpZCc6IGlkXG4gICAgfSk7XG4gICAgcmV0dXJuICR0ZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGlmIGEgY29sbGlzaW9uIGV2ZW50IGlzIGRldGVjdGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbmluZyBjbGFzcyB0byB0cnlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgdGhpcy51c2VkUG9zaXRpb25zLnB1c2gocG9zaXRpb24gPyBwb3NpdGlvbiA6ICdib3R0b20nKTtcblxuICAgIC8vZGVmYXVsdCwgdHJ5IHN3aXRjaGluZyB0byBvcHBvc2l0ZSBzaWRlXG4gICAgaWYgKCFwb3NpdGlvbiAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpIDwgMCkpIHtcbiAgICAgIHRoaXMudGVtcGxhdGUuYWRkQ2xhc3MoJ3RvcCcpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0b3AnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJykgPCAwKSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA8IDApKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKVxuICAgICAgICAgIC5hZGRDbGFzcygncmlnaHQnKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpIHtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pXG4gICAgICAgICAgLmFkZENsYXNzKCdsZWZ0Jyk7XG4gICAgfVxuXG4gICAgLy9pZiBkZWZhdWx0IGNoYW5nZSBkaWRuJ3Qgd29yaywgdHJ5IGJvdHRvbSBvciBsZWZ0IGZpcnN0XG4gICAgZWxzZSBpZiAoIXBvc2l0aW9uICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigndG9wJykgPiAtMSkgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPCAwKSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZS5hZGRDbGFzcygnbGVmdCcpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0b3AnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJykgPiAtMSkgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPCAwKSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbilcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xlZnQnKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdyaWdodCcpID4gLTEpICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJykgPCAwKSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0JyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA+IC0xKSAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkpIHtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgIH1cbiAgICAvL2lmIG5vdGhpbmcgY2xlYXJlZCwgc2V0IHRvIGJvdHRvbVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgfVxuICAgIHRoaXMuY2xhc3NDaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLmNvdW50ZXItLTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXRzIHRoZSBwb3NpdGlvbiBjbGFzcyBvZiBhbiBlbGVtZW50IGFuZCByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYgdW50aWwgdGhlcmUgYXJlIG5vIG1vcmUgcG9zc2libGUgcG9zaXRpb25zIHRvIGF0dGVtcHQsIG9yIHRoZSB0b29sdGlwIGVsZW1lbnQgaXMgbm8gbG9uZ2VyIGNvbGxpZGluZy5cbiAgICogaWYgdGhlIHRvb2x0aXAgaXMgbGFyZ2VyIHRoYW4gdGhlIHNjcmVlbiB3aWR0aCwgZGVmYXVsdCB0byBmdWxsIHdpZHRoIC0gYW55IHVzZXIgc2VsZWN0ZWQgbWFyZ2luXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0UG9zaXRpb24oKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLnRlbXBsYXRlKSxcbiAgICAgICAgJHRpcERpbXMgPSBGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMudGVtcGxhdGUpLFxuICAgICAgICAkYW5jaG9yRGltcyA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksXG4gICAgICAgIGRpcmVjdGlvbiA9IChwb3NpdGlvbiA9PT0gJ2xlZnQnID8gJ2xlZnQnIDogKChwb3NpdGlvbiA9PT0gJ3JpZ2h0JykgPyAnbGVmdCcgOiAndG9wJykpLFxuICAgICAgICBwYXJhbSA9IChkaXJlY3Rpb24gPT09ICd0b3AnKSA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcbiAgICAgICAgb2Zmc2V0ID0gKHBhcmFtID09PSAnaGVpZ2h0JykgPyB0aGlzLm9wdGlvbnMudk9mZnNldCA6IHRoaXMub3B0aW9ucy5oT2Zmc2V0LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoKCR0aXBEaW1zLndpZHRoID49ICR0aXBEaW1zLndpbmRvd0RpbXMud2lkdGgpIHx8ICghdGhpcy5jb3VudGVyICYmICFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMudGVtcGxhdGUpKSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZS5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLnRlbXBsYXRlLCB0aGlzLiRlbGVtZW50LCAnY2VudGVyIGJvdHRvbScsIHRoaXMub3B0aW9ucy52T2Zmc2V0LCB0aGlzLm9wdGlvbnMuaE9mZnNldCwgdHJ1ZSkpLmNzcyh7XG4gICAgICAvLyB0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSwgdGhpcy4kZWxlbWVudCwgJ2NlbnRlciBib3R0b20nLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQsIHRydWUpKS5jc3Moe1xuICAgICAgICAnd2lkdGgnOiAkYW5jaG9yRGltcy53aW5kb3dEaW1zLndpZHRoIC0gKHRoaXMub3B0aW9ucy5oT2Zmc2V0ICogMiksXG4gICAgICAgICdoZWlnaHQnOiAnYXV0bydcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSwgdGhpcy4kZWxlbWVudCwnY2VudGVyICcgKyAocG9zaXRpb24gfHwgJ2JvdHRvbScpLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQpKTtcblxuICAgIHdoaWxlKCFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMudGVtcGxhdGUpICYmIHRoaXMuY291bnRlcikge1xuICAgICAgdGhpcy5fcmVwb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiByZXZlYWxzIHRoZSB0b29sdGlwLCBhbmQgZmlyZXMgYW4gZXZlbnQgdG8gY2xvc2UgYW55IG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcbiAgICogQGZpcmVzIFRvb2x0aXAjY2xvc2VtZVxuICAgKiBAZmlyZXMgVG9vbHRpcCNzaG93XG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dPbiAhPT0gJ2FsbCcgJiYgIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5zaG93T24pKSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdUaGUgc2NyZWVuIGlzIHRvbyBzbWFsbCB0byBkaXNwbGF5IHRoaXMgdG9vbHRpcCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy50ZW1wbGF0ZS5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuc2hvdygpO1xuICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB0byBjbG9zZSBhbGwgb3RoZXIgb3BlbiB0b29sdGlwcyBvbiB0aGUgcGFnZVxuICAgICAqIEBldmVudCBDbG9zZW1lI3Rvb2x0aXBcbiAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYudG9vbHRpcCcsIHRoaXMudGVtcGxhdGUuYXR0cignaWQnKSk7XG5cblxuICAgIHRoaXMudGVtcGxhdGUuYXR0cih7XG4gICAgICAnZGF0YS1pcy1hY3RpdmUnOiB0cnVlLFxuICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2VcbiAgICB9KTtcbiAgICBfdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy50ZW1wbGF0ZSk7XG4gICAgdGhpcy50ZW1wbGF0ZS5zdG9wKCkuaGlkZSgpLmNzcygndmlzaWJpbGl0eScsICcnKS5mYWRlSW4odGhpcy5vcHRpb25zLmZhZGVJbkR1cmF0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vbWF5YmUgZG8gc3R1ZmY/XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdG9vbHRpcCBpcyBzaG93blxuICAgICAqIEBldmVudCBUb29sdGlwI3Nob3dcbiAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYudG9vbHRpcCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBjdXJyZW50IHRvb2x0aXAsIGFuZCByZXNldHMgdGhlIHBvc2l0aW9uaW5nIGNsYXNzIGlmIGl0IHdhcyBjaGFuZ2VkIGR1ZSB0byBjb2xsaXNpb25cbiAgICogQGZpcmVzIFRvb2x0aXAjaGlkZVxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2hpZGluZycsIHRoaXMuJGVsZW1lbnQuZGF0YSgneWV0aS1ib3gnKSk7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnRlbXBsYXRlLnN0b3AoKS5hdHRyKHtcbiAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAnZGF0YS1pcy1hY3RpdmUnOiBmYWxzZVxuICAgIH0pLmZhZGVPdXQodGhpcy5vcHRpb25zLmZhZGVPdXREdXJhdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgX3RoaXMuaXNDbGljayA9IGZhbHNlO1xuICAgICAgaWYgKF90aGlzLmNsYXNzQ2hhbmdlZCkge1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZVxuICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhfdGhpcy5fZ2V0UG9zaXRpb25DbGFzcyhfdGhpcy50ZW1wbGF0ZSkpXG4gICAgICAgICAgICAgLmFkZENsYXNzKF90aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcyk7XG5cbiAgICAgICBfdGhpcy51c2VkUG9zaXRpb25zID0gW107XG4gICAgICAgX3RoaXMuY291bnRlciA9IDQ7XG4gICAgICAgX3RoaXMuY2xhc3NDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogZmlyZXMgd2hlbiB0aGUgdG9vbHRpcCBpcyBoaWRkZW5cbiAgICAgKiBAZXZlbnQgVG9vbHRpcCNoaWRlXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdoaWRlLnpmLnRvb2x0aXAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIHRvb2x0aXAgYW5kIGl0cyBhbmNob3JcbiAgICogVE9ETyBjb21iaW5lIHNvbWUgb2YgdGhlIGxpc3RlbmVycyBsaWtlIGZvY3VzIGFuZCBtb3VzZWVudGVyLCBldGMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyICR0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgdmFyIGlzRm9jdXMgPSBmYWxzZTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcikge1xuXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAub24oJ21vdXNlZW50ZXIuemYudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFfdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xuICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlbGVhdmUuemYudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgICBpZiAoIWlzRm9jdXMgfHwgKF90aGlzLmlzQ2xpY2sgJiYgIV90aGlzLm9wdGlvbnMuY2xpY2tPcGVuKSkge1xuICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ21vdXNlZG93bi56Zi50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoX3RoaXMuaXNDbGljaykge1xuICAgICAgICAgIC8vX3RoaXMuaGlkZSgpO1xuICAgICAgICAgIC8vIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5pc0NsaWNrID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoKF90aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyIHx8ICFfdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpKSAmJiAhX3RoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWRvd24uemYudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgX3RoaXMuaXNDbGljayA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlRm9yVG91Y2gpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vbigndGFwLnpmLnRvb2x0aXAgdG91Y2hlbmQuemYudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgX3RoaXMuaXNBY3RpdmUgPyBfdGhpcy5oaWRlKCkgOiBfdGhpcy5zaG93KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50Lm9uKHtcbiAgICAgIC8vICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXG4gICAgICAvLyAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuaGlkZS5iaW5kKHRoaXMpXG4gICAgICAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuaGlkZS5iaW5kKHRoaXMpXG4gICAgfSk7XG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAub24oJ2ZvY3VzLnpmLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlzRm9jdXMgPSB0cnVlO1xuICAgICAgICBpZiAoX3RoaXMuaXNDbGljaykge1xuICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBzaG93aW5nIG9wZW4gb24gY2xpY2tzLCB3ZSBuZWVkIHRvIHByZXRlbmQgYSBjbGljay1sYXVuY2hlZCBmb2N1cyBpc24ndFxuICAgICAgICAgIC8vIGEgcmVhbCBmb2N1cywgb3RoZXJ3aXNlIG9uIGhvdmVyIGFuZCBjb21lIGJhY2sgd2UgZ2V0IGJhZCBiZWhhdmlvclxuICAgICAgICAgIGlmKCFfdGhpcy5vcHRpb25zLmNsaWNrT3BlbikgeyBpc0ZvY3VzID0gZmFsc2U7IH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAub24oJ2ZvY3Vzb3V0LnpmLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaXNDbGljayA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICB9KVxuXG4gICAgICAub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF90aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgX3RoaXMuX3NldFBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZHMgYSB0b2dnbGUgbWV0aG9kLCBpbiBhZGRpdGlvbiB0byB0aGUgc3RhdGljIHNob3coKSAmIGhpZGUoKSBmdW5jdGlvbnNcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgdG9vbHRpcCwgcmVtb3ZlcyB0ZW1wbGF0ZSBlbGVtZW50IGZyb20gdGhlIHZpZXcuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3RpdGxlJywgdGhpcy50ZW1wbGF0ZS50ZXh0KCkpXG4gICAgICAgICAgICAgICAgIC5vZmYoJy56Zi50cmlnZ2VyIC56Zi50b290aXAnKVxuICAgICAgICAgICAgICAgIC8vICAucmVtb3ZlQ2xhc3MoJ2hhcy10aXAnKVxuICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieScpXG4gICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXlldGktYm94JylcbiAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtdG9nZ2xlJylcbiAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtcmVzaXplJyk7XG5cbiAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZSgpO1xuXG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG59XG5cblRvb2x0aXAuZGVmYXVsdHMgPSB7XG4gIGRpc2FibGVGb3JUb3VjaDogZmFsc2UsXG4gIC8qKlxuICAgKiBUaW1lLCBpbiBtcywgYmVmb3JlIGEgdG9vbHRpcCBzaG91bGQgb3BlbiBvbiBob3Zlci5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAyMDBcbiAgICovXG4gIGhvdmVyRGVsYXk6IDIwMCxcbiAgLyoqXG4gICAqIFRpbWUsIGluIG1zLCBhIHRvb2x0aXAgc2hvdWxkIHRha2UgdG8gZmFkZSBpbnRvIHZpZXcuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMTUwXG4gICAqL1xuICBmYWRlSW5EdXJhdGlvbjogMTUwLFxuICAvKipcbiAgICogVGltZSwgaW4gbXMsIGEgdG9vbHRpcCBzaG91bGQgdGFrZSB0byBmYWRlIG91dCBvZiB2aWV3LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDE1MFxuICAgKi9cbiAgZmFkZU91dER1cmF0aW9uOiAxNTAsXG4gIC8qKlxuICAgKiBEaXNhYmxlcyBob3ZlciBldmVudHMgZnJvbSBvcGVuaW5nIHRoZSB0b29sdGlwIGlmIHNldCB0byB0cnVlXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgZmFsc2VcbiAgICovXG4gIGRpc2FibGVIb3ZlcjogZmFsc2UsXG4gIC8qKlxuICAgKiBPcHRpb25hbCBhZGR0aW9uYWwgY2xhc3NlcyB0byBhcHBseSB0byB0aGUgdG9vbHRpcCB0ZW1wbGF0ZSBvbiBpbml0LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdteS1jb29sLXRpcC1jbGFzcydcbiAgICovXG4gIHRlbXBsYXRlQ2xhc3NlczogJycsXG4gIC8qKlxuICAgKiBOb24tb3B0aW9uYWwgY2xhc3MgYWRkZWQgdG8gdG9vbHRpcCB0ZW1wbGF0ZXMuIEZvdW5kYXRpb24gZGVmYXVsdCBpcyAndG9vbHRpcCcuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3Rvb2x0aXAnXG4gICAqL1xuICB0b29sdGlwQ2xhc3M6ICd0b29sdGlwJyxcbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIHRvb2x0aXAgYW5jaG9yIGVsZW1lbnQuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ2hhcy10aXAnXG4gICAqL1xuICB0cmlnZ2VyQ2xhc3M6ICdoYXMtdGlwJyxcbiAgLyoqXG4gICAqIE1pbmltdW0gYnJlYWtwb2ludCBzaXplIGF0IHdoaWNoIHRvIG9wZW4gdGhlIHRvb2x0aXAuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3NtYWxsJ1xuICAgKi9cbiAgc2hvd09uOiAnc21hbGwnLFxuICAvKipcbiAgICogQ3VzdG9tIHRlbXBsYXRlIHRvIGJlIHVzZWQgdG8gZ2VuZXJhdGUgbWFya3VwIGZvciB0b29sdGlwLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICcmbHQ7ZGl2IGNsYXNzPVwidG9vbHRpcFwiJmd0OyZsdDsvZGl2Jmd0OydcbiAgICovXG4gIHRlbXBsYXRlOiAnJyxcbiAgLyoqXG4gICAqIFRleHQgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwIHRlbXBsYXRlIG9uIG9wZW4uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ1NvbWUgY29vbCBzcGFjZSBmYWN0IGhlcmUuJ1xuICAgKi9cbiAgdGlwVGV4dDogJycsXG4gIHRvdWNoQ2xvc2VUZXh0OiAnVGFwIHRvIGNsb3NlLicsXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIHRvb2x0aXAgdG8gcmVtYWluIG9wZW4gaWYgdHJpZ2dlcmVkIHdpdGggYSBjbGljayBvciB0b3VjaCBldmVudC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBjbGlja09wZW46IHRydWUsXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIHBvc2l0aW9uaW5nIGNsYXNzZXMsIHNldCBieSB0aGUgSlNcbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAndG9wJ1xuICAgKi9cbiAgcG9zaXRpb25DbGFzczogJycsXG4gIC8qKlxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgdGVtcGxhdGUgc2hvdWxkIHB1c2ggYXdheSBmcm9tIHRoZSBhbmNob3Igb24gdGhlIFkgYXhpcy5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAxMFxuICAgKi9cbiAgdk9mZnNldDogMTAsXG4gIC8qKlxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgdGVtcGxhdGUgc2hvdWxkIHB1c2ggYXdheSBmcm9tIHRoZSBhbmNob3Igb24gdGhlIFggYXhpcywgaWYgYWxpZ25lZCB0byBhIHNpZGUuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMTJcbiAgICovXG4gIGhPZmZzZXQ6IDEyXG59O1xuXG4vKipcbiAqIFRPRE8gdXRpbGl6ZSByZXNpemUgZXZlbnQgdHJpZ2dlclxuICovXG5cbi8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihUb29sdGlwLCAnVG9vbHRpcCcpO1xuXG59KGpRdWVyeSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBQb2x5ZmlsbCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4oZnVuY3Rpb24oKSB7XG4gIGlmICghRGF0ZS5ub3cpXG4gICAgRGF0ZS5ub3cgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuXG4gIHZhciB2ZW5kb3JzID0gWyd3ZWJraXQnLCAnbW96J107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsraSkge1xuICAgICAgdmFyIHZwID0gdmVuZG9yc1tpXTtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdnArJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gKHdpbmRvd1t2cCsnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93W3ZwKydDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSk7XG4gIH1cbiAgaWYgKC9pUChhZHxob25lfG9kKS4qT1MgNi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICB8fCAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBuZXh0VGltZSA9IE1hdGgubWF4KGxhc3RUaW1lICsgMTYsIG5vdyk7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhsYXN0VGltZSA9IG5leHRUaW1lKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFRpbWUgLSBub3cpO1xuICAgIH07XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2xlYXJUaW1lb3V0O1xuICB9XG59KSgpO1xuXG52YXIgaW5pdENsYXNzZXMgICA9IFsnbXVpLWVudGVyJywgJ211aS1sZWF2ZSddO1xudmFyIGFjdGl2ZUNsYXNzZXMgPSBbJ211aS1lbnRlci1hY3RpdmUnLCAnbXVpLWxlYXZlLWFjdGl2ZSddO1xuXG4vLyBGaW5kIHRoZSByaWdodCBcInRyYW5zaXRpb25lbmRcIiBldmVudCBmb3IgdGhpcyBicm93c2VyXG52YXIgZW5kRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0cmFuc2l0aW9ucyA9IHtcbiAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnTW96VHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAnT1RyYW5zaXRpb24nOiAnb3RyYW5zaXRpb25lbmQnXG4gIH1cbiAgdmFyIGVsZW0gPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgZm9yICh2YXIgdCBpbiB0cmFuc2l0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZWxlbS5zdHlsZVt0XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uc1t0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFuaW1hdGUoaXNJbiwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICBlbGVtZW50ID0gJChlbGVtZW50KS5lcSgwKTtcblxuICBpZiAoIWVsZW1lbnQubGVuZ3RoKSByZXR1cm47XG5cbiAgaWYgKGVuZEV2ZW50ID09PSBudWxsKSB7XG4gICAgaXNJbiA/IGVsZW1lbnQuc2hvdygpIDogZWxlbWVudC5oaWRlKCk7XG4gICAgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5pdENsYXNzID0gaXNJbiA/IGluaXRDbGFzc2VzWzBdIDogaW5pdENsYXNzZXNbMV07XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzSW4gPyBhY3RpdmVDbGFzc2VzWzBdIDogYWN0aXZlQ2xhc3Nlc1sxXTtcblxuICAvLyBTZXQgdXAgdGhlIGFuaW1hdGlvblxuICByZXNldCgpO1xuICBlbGVtZW50LmFkZENsYXNzKGFuaW1hdGlvbik7XG4gIGVsZW1lbnQuY3NzKCd0cmFuc2l0aW9uJywgJ25vbmUnKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgIGVsZW1lbnQuYWRkQ2xhc3MoaW5pdENsYXNzKTtcbiAgICBpZiAoaXNJbikgZWxlbWVudC5zaG93KCk7XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IHRoZSBhbmltYXRpb25cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7XG4gICAgZWxlbWVudC5jc3MoJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgZWxlbWVudC5hZGRDbGFzcyhhY3RpdmVDbGFzcyk7XG4gIH0pO1xuXG4gIC8vIENsZWFuIHVwIHRoZSBhbmltYXRpb24gd2hlbiBpdCBmaW5pc2hlc1xuICBlbGVtZW50Lm9uZSgndHJhbnNpdGlvbmVuZCcsIGZpbmlzaCk7XG5cbiAgLy8gSGlkZXMgdGhlIGVsZW1lbnQgKGZvciBvdXQgYW5pbWF0aW9ucyksIHJlc2V0cyB0aGUgZWxlbWVudCwgYW5kIHJ1bnMgYSBjYWxsYmFja1xuICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgaWYgKCFpc0luKSBlbGVtZW50LmhpZGUoKTtcbiAgICByZXNldCgpO1xuICAgIGlmIChjYikgY2IuYXBwbHkoZWxlbWVudCk7XG4gIH1cblxuICAvLyBSZXNldHMgdHJhbnNpdGlvbnMgYW5kIHJlbW92ZXMgbW90aW9uLXNwZWNpZmljIGNsYXNzZXNcbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZWxlbWVudFswXS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAwO1xuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoaW5pdENsYXNzICsgJyAnICsgYWN0aXZlQ2xhc3MgKyAnICcgKyBhbmltYXRpb24pO1xuICB9XG59XG5cbnZhciBNb3Rpb25VSSA9IHtcbiAgYW5pbWF0ZUluOiBmdW5jdGlvbihlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XG4gICAgYW5pbWF0ZSh0cnVlLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKTtcbiAgfSxcblxuICBhbmltYXRlT3V0OiBmdW5jdGlvbihlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XG4gICAgYW5pbWF0ZShmYWxzZSwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYik7XG4gIH1cbn1cbiIsIi8vIFNuYXAuc3ZnIDAuNC4xXG4vL1xuLy8gQ29weXJpZ2h0IChjKSAyMDEzIOKAkyAyMDE1IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLy9cbi8vIGJ1aWxkOiAyMDE1LTA0LTEzXG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy8gXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vIFxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCBcXFxcXG4vLyDilIIgRXZlIDAuNC4yIC0gSmF2YVNjcmlwdCBFdmVudHMgTGlicmFyeSAgICAgICAgICAgICAgICAgICAgICDilIIgXFxcXFxuLy8g4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkIFxcXFxcbi8vIOKUgiBBdXRob3IgRG1pdHJ5IEJhcmFub3Zza2l5IChodHRwOi8vZG1pdHJ5LmJhcmFub3Zza2l5LmNvbS8pIOKUgiBcXFxcXG4vLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggXFxcXFxuXG4oZnVuY3Rpb24gKGdsb2IpIHtcbiAgICB2YXIgdmVyc2lvbiA9IFwiMC40LjJcIixcbiAgICAgICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICBzZXBhcmF0b3IgPSAvW1xcLlxcL10vLFxuICAgICAgICBjb21hc2VwYXJhdG9yID0gL1xccyosXFxzKi8sXG4gICAgICAgIHdpbGRjYXJkID0gXCIqXCIsXG4gICAgICAgIGZ1biA9IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBudW1zb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudF9ldmVudCxcbiAgICAgICAgc3RvcCxcbiAgICAgICAgZXZlbnRzID0ge246IHt9fSxcbiAgICAgICAgZmlyc3REZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2ldICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYXN0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoLS1pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2ldICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIC8qXFxcbiAgICAgKiBldmVcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogRmlyZXMgZXZlbnQgd2l0aCBnaXZlbiBgbmFtZWAsIGdpdmVuIHNjb3BlIGFuZCBvdGhlciBwYXJhbWV0ZXJzLlxuXG4gICAgID4gQXJndW1lbnRzXG5cbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlICpldmVudCosIGRvdCAoYC5gKSBvciBzbGFzaCAoYC9gKSBzZXBhcmF0ZWRcbiAgICAgLSBzY29wZSAob2JqZWN0KSBjb250ZXh0IGZvciB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgLSB2YXJhcmdzICguLi4pIHRoZSByZXN0IG9mIGFyZ3VtZW50cyB3aWxsIGJlIHNlbnQgdG8gZXZlbnQgaGFuZGxlcnNcblxuICAgICA9IChvYmplY3QpIGFycmF5IG9mIHJldHVybmVkIHZhbHVlcyBmcm9tIHRoZSBsaXN0ZW5lcnMuIEFycmF5IGhhcyB0d28gbWV0aG9kcyBgLmZpcnN0RGVmaW5lZCgpYCBhbmQgYC5sYXN0RGVmaW5lZCgpYCB0byBnZXQgZmlyc3Qgb3IgbGFzdCBub3QgYHVuZGVmaW5lZGAgdmFsdWUuXG4gICAgXFwqL1xuICAgICAgICBldmUgPSBmdW5jdGlvbiAobmFtZSwgc2NvcGUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50cyxcbiAgICAgICAgICAgICAgICBvbGRzdG9wID0gc3RvcCxcbiAgICAgICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBldmUubGlzdGVuZXJzKG5hbWUpLFxuICAgICAgICAgICAgICAgIHogPSAwLFxuICAgICAgICAgICAgICAgIGYgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBsLFxuICAgICAgICAgICAgICAgIGluZGV4ZWQgPSBbXSxcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IHt9LFxuICAgICAgICAgICAgICAgIG91dCA9IFtdLFxuICAgICAgICAgICAgICAgIGNlID0gY3VycmVudF9ldmVudCxcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIG91dC5maXJzdERlZmluZWQgPSBmaXJzdERlZmluZWQ7XG4gICAgICAgICAgICBvdXQubGFzdERlZmluZWQgPSBsYXN0RGVmaW5lZDtcbiAgICAgICAgICAgIGN1cnJlbnRfZXZlbnQgPSBuYW1lO1xuICAgICAgICAgICAgc3RvcCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKFwiekluZGV4XCIgaW4gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKGxpc3RlbmVyc1tpXS56SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uekluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtsaXN0ZW5lcnNbaV0uekluZGV4XSA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleGVkLnNvcnQobnVtc29ydCk7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXhlZFt6XSA8IDApIHtcbiAgICAgICAgICAgICAgICBsID0gcXVldWVbaW5kZXhlZFt6KytdXTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IG9sZHN0b3A7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChcInpJbmRleFwiIGluIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwuekluZGV4ID09IGluZGV4ZWRbel0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBxdWV1ZVtpbmRleGVkW3pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsICYmIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChsKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbbC56SW5kZXhdID0gbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcCA9IG9sZHN0b3A7XG4gICAgICAgICAgICBjdXJyZW50X2V2ZW50ID0gY2U7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuICAgICAgICAvLyBVbmRvY3VtZW50ZWQuIERlYnVnIG9ubHkuXG4gICAgICAgIGV2ZS5fZXZlbnRzID0gZXZlbnRzO1xuICAgIC8qXFxcbiAgICAgKiBldmUubGlzdGVuZXJzXG4gICAgIFsgbWV0aG9kIF1cblxuICAgICAqIEludGVybmFsIG1ldGhvZCB3aGljaCBnaXZlcyB5b3UgYXJyYXkgb2YgYWxsIGV2ZW50IGhhbmRsZXJzIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgdGhlIGdpdmVuIGBuYW1lYC5cblxuICAgICA+IEFyZ3VtZW50c1xuXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZFxuXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBldmVudCBoYW5kbGVyc1xuICAgIFxcKi9cbiAgICBldmUubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChzZXBhcmF0b3IpLFxuICAgICAgICAgICAgZSA9IGV2ZW50cyxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaWksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgamosXG4gICAgICAgICAgICBuZXMsXG4gICAgICAgICAgICBlcyA9IFtlXSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIG5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBlcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgZSA9IGVzW2pdLm47XG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbZVtuYW1lc1tpXV0sIGVbd2lsZGNhcmRdXTtcbiAgICAgICAgICAgICAgICBrID0gMjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoay0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1trXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChpdGVtLmYgfHwgW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXMgPSBuZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBldmUub25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJpbmRzIGdpdmVuIGV2ZW50IGhhbmRsZXIgd2l0aCBhIGdpdmVuIG5hbWUuIFlvdSBjYW4gdXNlIHdpbGRjYXJkcyDigJxgKmDigJ0gZm9yIHRoZSBuYW1lczpcbiAgICAgfCBldmUub24oXCIqLnVuZGVyLipcIiwgZik7XG4gICAgIHwgZXZlKFwibW91c2UudW5kZXIuZmxvb3JcIik7IC8vIHRyaWdnZXJzIGZcbiAgICAgKiBVc2UgQGV2ZSB0byB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cbiAgICAgKipcbiAgICAgPiBBcmd1bWVudHNcbiAgICAgKipcbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkLCB3aXRoIG9wdGlvbmFsIHdpbGRjYXJkc1xuICAgICAtIGYgKGZ1bmN0aW9uKSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICoqXG4gICAgID0gKGZ1bmN0aW9uKSByZXR1cm5lZCBmdW5jdGlvbiBhY2NlcHRzIGEgc2luZ2xlIG51bWVyaWMgcGFyYW1ldGVyIHRoYXQgcmVwcmVzZW50cyB6LWluZGV4IG9mIHRoZSBoYW5kbGVyLiBJdCBpcyBhbiBvcHRpb25hbCBmZWF0dXJlIGFuZCBvbmx5IHVzZWQgd2hlbiB5b3UgbmVlZCB0byBlbnN1cmUgdGhhdCBzb21lIHN1YnNldCBvZiBoYW5kbGVycyB3aWxsIGJlIGludm9rZWQgaW4gYSBnaXZlbiBvcmRlciwgZGVzcGl0ZSBvZiB0aGUgb3JkZXIgb2YgYXNzaWdubWVudC4gXG4gICAgID4gRXhhbXBsZTpcbiAgICAgfCBldmUub24oXCJtb3VzZVwiLCBlYXRJdCkoMik7XG4gICAgIHwgZXZlLm9uKFwibW91c2VcIiwgc2NyZWFtKTtcbiAgICAgfCBldmUub24oXCJtb3VzZVwiLCBjYXRjaEl0KSgxKTtcbiAgICAgKiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgYGNhdGNoSXRgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBgZWF0SXRgLlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgdG8gcHV0IHlvdXIgaGFuZGxlciBiZWZvcmUgbm9uLWluZGV4ZWQgaGFuZGxlcnMsIHNwZWNpZnkgYSBuZWdhdGl2ZSB2YWx1ZS5cbiAgICAgKiBOb3RlOiBJIGFzc3VtZSBtb3N0IG9mIHRoZSB0aW1lIHlvdSBkb27igJl0IG5lZWQgdG8gd29ycnkgYWJvdXQgei1pbmRleCwgYnV0IGl04oCZcyBuaWNlIHRvIGhhdmUgdGhpcyBmZWF0dXJlIOKAnGp1c3QgaW4gY2FzZeKAnS5cbiAgICBcXCovXG4gICAgZXZlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoY29tYXNlcGFyYXRvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoc2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgZSA9IGV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZXhpc3Q7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlID0gZS5uO1xuICAgICAgICAgICAgICAgICAgICBlID0gZS5oYXNPd25Qcm9wZXJ0eShuYW1lc1tpXSkgJiYgZVtuYW1lc1tpXV0gfHwgKGVbbmFtZXNbaV1dID0ge246IHt9fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUuZiA9IGUuZiB8fCBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGUuZi5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoZS5mW2ldID09IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIWV4aXN0ICYmIGUuZi5wdXNoKGYpO1xuICAgICAgICAgICAgfShuYW1lc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoekluZGV4KSB7XG4gICAgICAgICAgICBpZiAoK3pJbmRleCA9PSArekluZGV4KSB7XG4gICAgICAgICAgICAgICAgZi56SW5kZXggPSArekluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5mXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBmaXJlIGdpdmVuIGV2ZW50IHdpdGggb3B0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqIEFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSByZXN1bHQgZnVuY3Rpb24gd2lsbCBiZSBhbHNvXG4gICAgICogY29uY2F0ZWQgdG8gdGhlIGxpc3Qgb2YgZmluYWwgYXJndW1lbnRzLlxuICAgICB8IGVsLm9uY2xpY2sgPSBldmUuZihcImNsaWNrXCIsIDEsIDIpO1xuICAgICB8IGV2ZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgIHwgICAgIGNvbnNvbGUubG9nKGEsIGIsIGMpOyAvLyAxLCAyLCBbZXZlbnQgb2JqZWN0XVxuICAgICB8IH0pO1xuICAgICA+IEFyZ3VtZW50c1xuICAgICAtIGV2ZW50IChzdHJpbmcpIGV2ZW50IG5hbWVcbiAgICAgLSB2YXJhcmdzICjigKYpIGFuZCBhbnkgb3RoZXIgYXJndW1lbnRzXG4gICAgID0gKGZ1bmN0aW9uKSBwb3NzaWJsZSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgXFwqL1xuICAgIGV2ZS5mID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBhdHRycyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZS5hcHBseShudWxsLCBbZXZlbnQsIG51bGxdLmNvbmNhdChhdHRycykuY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5zdG9wXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJcyB1c2VkIGluc2lkZSBhbiBldmVudCBoYW5kbGVyIHRvIHN0b3AgdGhlIGV2ZW50LCBwcmV2ZW50aW5nIGFueSBzdWJzZXF1ZW50IGxpc3RlbmVycyBmcm9tIGZpcmluZy5cbiAgICBcXCovXG4gICAgZXZlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0b3AgPSAxO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5udFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ291bGQgYmUgdXNlZCBpbnNpZGUgZXZlbnQgaGFuZGxlciB0byBmaWd1cmUgb3V0IGFjdHVhbCBuYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKipcbiAgICAgPiBBcmd1bWVudHNcbiAgICAgKipcbiAgICAgLSBzdWJuYW1lIChzdHJpbmcpICNvcHRpb25hbCBzdWJuYW1lIG9mIHRoZSBldmVudFxuICAgICAqKlxuICAgICA9IChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBpZiBgc3VibmFtZWAgaXMgbm90IHNwZWNpZmllZFxuICAgICAqIG9yXG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCwgaWYgY3VycmVudCBldmVudOKAmXMgbmFtZSBjb250YWlucyBgc3VibmFtZWBcbiAgICBcXCovXG4gICAgZXZlLm50ID0gZnVuY3Rpb24gKHN1Ym5hbWUpIHtcbiAgICAgICAgaWYgKHN1Ym5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XFxcXC58XFxcXC98XilcIiArIHN1Ym5hbWUgKyBcIig/OlxcXFwufFxcXFwvfCQpXCIpLnRlc3QoY3VycmVudF9ldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRfZXZlbnQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLm50c1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ291bGQgYmUgdXNlZCBpbnNpZGUgZXZlbnQgaGFuZGxlciB0byBmaWd1cmUgb3V0IGFjdHVhbCBuYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKipcbiAgICAgKipcbiAgICAgPSAoYXJyYXkpIG5hbWVzIG9mIHRoZSBldmVudFxuICAgIFxcKi9cbiAgICBldmUubnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3VycmVudF9ldmVudC5zcGxpdChzZXBhcmF0b3IpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5vZmZcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZ2l2ZW4gZnVuY3Rpb24gZnJvbSB0aGUgbGlzdCBvZiBldmVudCBsaXN0ZW5lcnMgYXNzaWduZWQgdG8gZ2l2ZW4gbmFtZS5cbiAgICAgKiBJZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkIGFsbCB0aGUgZXZlbnRzIHdpbGwgYmUgY2xlYXJlZC5cbiAgICAgKipcbiAgICAgPiBBcmd1bWVudHNcbiAgICAgKipcbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkLCB3aXRoIG9wdGlvbmFsIHdpbGRjYXJkc1xuICAgICAtIGYgKGZ1bmN0aW9uKSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBldmUudW5iaW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQGV2ZS5vZmZcbiAgICBcXCovXG4gICAgZXZlLm9mZiA9IGV2ZS51bmJpbmQgPSBmdW5jdGlvbiAobmFtZSwgZikge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGV2ZS5fZXZlbnRzID0gZXZlbnRzID0ge246IHt9fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KGNvbWFzZXBhcmF0b3IpO1xuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGV2ZS5vZmYobmFtZXNbaV0sIGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzID0gbmFtZS5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHNwbGljZSxcbiAgICAgICAgICAgIGksIGlpLCBqLCBqaixcbiAgICAgICAgICAgIGN1ciA9IFtldmVudHNdO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXIubGVuZ3RoOyBqICs9IHNwbGljZS5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlID0gW2osIDFdO1xuICAgICAgICAgICAgICAgIGUgPSBjdXJbal0ubjtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNbaV0gIT0gd2lsZGNhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVbbmFtZXNbaV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2UucHVzaChlW25hbWVzW2ldXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlKSBpZiAoZVtoYXNdKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZS5wdXNoKGVba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyLnNwbGljZS5hcHBseShjdXIsIHNwbGljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBjdXIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgZSA9IGN1cltpXTtcbiAgICAgICAgICAgIHdoaWxlIChlLm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGUuZi5sZW5ndGg7IGogPCBqajsgaisrKSBpZiAoZS5mW2pdID09IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmYuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIWUuZi5sZW5ndGggJiYgZGVsZXRlIGUuZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlLm4pIGlmIChlLm5baGFzXShrZXkpICYmIGUubltrZXldLmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdW5jcyA9IGUubltrZXldLmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGZ1bmNzLmxlbmd0aDsgaiA8IGpqOyBqKyspIGlmIChmdW5jc1tqXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Muc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmNzLmxlbmd0aCAmJiBkZWxldGUgZS5uW2tleV0uZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlLmY7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGUubikgaWYgKGUubltoYXNdKGtleSkgJiYgZS5uW2tleV0uZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGUubltrZXldLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZSA9IGUubjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5vbmNlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCaW5kcyBnaXZlbiBldmVudCBoYW5kbGVyIHdpdGggYSBnaXZlbiBuYW1lIHRvIG9ubHkgcnVuIG9uY2UgdGhlbiB1bmJpbmQgaXRzZWxmLlxuICAgICB8IGV2ZS5vbmNlKFwibG9naW5cIiwgZik7XG4gICAgIHwgZXZlKFwibG9naW5cIik7IC8vIHRyaWdnZXJzIGZcbiAgICAgfCBldmUoXCJsb2dpblwiKTsgLy8gbm8gbGlzdGVuZXJzXG4gICAgICogVXNlIEBldmUgdG8gdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAgICoqXG4gICAgID4gQXJndW1lbnRzXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqKlxuICAgICA9IChmdW5jdGlvbikgc2FtZSByZXR1cm4gZnVuY3Rpb24gYXMgQGV2ZS5vblxuICAgIFxcKi9cbiAgICBldmUub25jZSA9IGZ1bmN0aW9uIChuYW1lLCBmKSB7XG4gICAgICAgIHZhciBmMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZS51bmJpbmQobmFtZSwgZjIpO1xuICAgICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV2ZS5vbihuYW1lLCBmMik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLnZlcnNpb25cbiAgICAgWyBwcm9wZXJ0eSAoc3RyaW5nKSBdXG4gICAgICoqXG4gICAgICogQ3VycmVudCB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LlxuICAgIFxcKi9cbiAgICBldmUudmVyc2lvbiA9IHZlcnNpb247XG4gICAgZXZlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJZb3UgYXJlIHJ1bm5pbmcgRXZlIFwiICsgdmVyc2lvbjtcbiAgICB9O1xuICAgICh0eXBlb2YgbW9kdWxlICE9IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpID8gKG1vZHVsZS5leHBvcnRzID0gZXZlKSA6ICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCA/IChkZWZpbmUoXCJldmVcIiwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXZlOyB9KSkgOiAoZ2xvYi5ldmUgPSBldmUpKTtcbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24gKGdsb2IsIGZhY3RvcnkpIHtcbiAgICAvLyBBTUQgc3VwcG9ydFxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlXG4gICAgICAgIGRlZmluZShbXCJldmVcIl0sIGZ1bmN0aW9uIChldmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KGdsb2IsIGV2ZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTmV4dCBmb3IgTm9kZS5qcyBvciBDb21tb25KU1xuICAgICAgICB2YXIgZXZlID0gcmVxdWlyZSgnZXZlJyk7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShnbG9iLCBldmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAoZ2xvYiBpcyB3aW5kb3cpXG4gICAgICAgIC8vIFNuYXAgYWRkcyBpdHNlbGYgdG8gd2luZG93XG4gICAgICAgIGZhY3RvcnkoZ2xvYiwgZ2xvYi5ldmUpO1xuICAgIH1cbn0od2luZG93IHx8IHRoaXMsIGZ1bmN0aW9uICh3aW5kb3csIGV2ZSkge1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgbWluYSA9IChmdW5jdGlvbiAoZXZlKSB7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSB7fSxcbiAgICByZXF1ZXN0QW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhIGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSxcbiAgICBpZGdlbiA9IDAsXG4gICAgaWRwcmVmaXggPSBcIk1cIiArICgrbmV3IERhdGUpLnRvU3RyaW5nKDM2KSxcbiAgICBJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkcHJlZml4ICsgKGlkZ2VuKyspLnRvU3RyaW5nKDM2KTtcbiAgICB9LFxuICAgIGRpZmYgPSBmdW5jdGlvbiAoYSwgYiwgQSwgQikge1xuICAgICAgICBpZiAoaXNBcnJheShhKSkge1xuICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBkaWZmKGFbaV0sIGIsIEFbaV0sIEIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlmID0gKEEgLSBhKSAvIChCIC0gYik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYmIpIHtcbiAgICAgICAgICAgIHJldHVybiBhICsgZGlmICogKGJiIC0gYik7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0aW1lciA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICtuZXcgRGF0ZTtcbiAgICB9LFxuICAgIHN0YSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRzID0gYS5zIC0gdmFsO1xuICAgICAgICBhLmIgKz0gYS5kdXIgKiBkcztcbiAgICAgICAgYS5CICs9IGEuZHVyICogZHM7XG4gICAgICAgIGEucyA9IHZhbDtcbiAgICB9LFxuICAgIHNwZWVkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGEuc3BkO1xuICAgICAgICB9XG4gICAgICAgIGEuc3BkID0gdmFsO1xuICAgIH0sXG4gICAgZHVyYXRpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5kdXI7XG4gICAgICAgIH1cbiAgICAgICAgYS5zID0gYS5zICogdmFsIC8gYS5kdXI7XG4gICAgICAgIGEuZHVyID0gdmFsO1xuICAgIH0sXG4gICAgc3RvcGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGRlbGV0ZSBhbmltYXRpb25zW2EuaWRdO1xuICAgICAgICBhLnVwZGF0ZSgpO1xuICAgICAgICBldmUoXCJtaW5hLnN0b3AuXCIgKyBhLmlkLCBhKTtcbiAgICB9LFxuICAgIHBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmIChhLnBkaWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgYW5pbWF0aW9uc1thLmlkXTtcbiAgICAgICAgYS51cGRhdGUoKTtcbiAgICAgICAgYS5wZGlmID0gYS5nZXQoKSAtIGEuYjtcbiAgICB9LFxuICAgIHJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBpZiAoIWEucGRpZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGEuYiA9IGEuZ2V0KCkgLSBhLnBkaWY7XG4gICAgICAgIGRlbGV0ZSBhLnBkaWY7XG4gICAgICAgIGFuaW1hdGlvbnNbYS5pZF0gPSBhO1xuICAgIH0sXG4gICAgdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICByZXM7XG4gICAgICAgIGlmIChpc0FycmF5KGEuc3RhcnQpKSB7XG4gICAgICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGEuc3RhcnQubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIHJlc1tqXSA9ICthLnN0YXJ0W2pdICtcbiAgICAgICAgICAgICAgICAgICAgKGEuZW5kW2pdIC0gYS5zdGFydFtqXSkgKiBhLmVhc2luZyhhLnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gK2Euc3RhcnQgKyAoYS5lbmQgLSBhLnN0YXJ0KSAqIGEuZWFzaW5nKGEucyk7XG4gICAgICAgIH1cbiAgICAgICAgYS5zZXQocmVzKTtcbiAgICB9LFxuICAgIGZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGVuID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBhbmltYXRpb25zKSBpZiAoYW5pbWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgdmFyIGEgPSBhbmltYXRpb25zW2ldLFxuICAgICAgICAgICAgICAgIGIgPSBhLmdldCgpLFxuICAgICAgICAgICAgICAgIHJlcztcbiAgICAgICAgICAgIGxlbisrO1xuICAgICAgICAgICAgYS5zID0gKGIgLSBhLmIpIC8gKGEuZHVyIC8gYS5zcGQpO1xuICAgICAgICAgICAgaWYgKGEucyA+PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFuaW1hdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgYS5zID0gMTtcbiAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmUoXCJtaW5hLmZpbmlzaC5cIiArIGEuaWQsIGEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuICYmIHJlcXVlc3RBbmltRnJhbWUoZnJhbWUpO1xuICAgIH0sXG4gICAgLypcXFxuICAgICAqIG1pbmFcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEdlbmVyaWMgYW5pbWF0aW9uIG9mIG51bWJlcnNcbiAgICAgKipcbiAgICAgLSBhIChudW1iZXIpIHN0YXJ0IF9zbGF2ZV8gbnVtYmVyXG4gICAgIC0gQSAobnVtYmVyKSBlbmQgX3NsYXZlXyBudW1iZXJcbiAgICAgLSBiIChudW1iZXIpIHN0YXJ0IF9tYXN0ZXJfIG51bWJlciAoc3RhcnQgdGltZSBpbiBnZW5lcmFsIGNhc2UpXG4gICAgIC0gQiAobnVtYmVyKSBlbmQgX21hc3Rlcl8gbnVtYmVyIChlbmQgdGltZSBpbiBnZXJlYWwgY2FzZSlcbiAgICAgLSBnZXQgKGZ1bmN0aW9uKSBnZXR0ZXIgb2YgX21hc3Rlcl8gbnVtYmVyIChzZWUgQG1pbmEudGltZSlcbiAgICAgLSBzZXQgKGZ1bmN0aW9uKSBzZXR0ZXIgb2YgX3NsYXZlXyBudW1iZXJcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uLCBkZWZhdWx0IGlzIEBtaW5hLmxpbmVhclxuICAgICA9IChvYmplY3QpIGFuaW1hdGlvbiBkZXNjcmlwdG9yXG4gICAgIG8ge1xuICAgICBvICAgICAgICAgaWQgKHN0cmluZykgYW5pbWF0aW9uIGlkLFxuICAgICBvICAgICAgICAgc3RhcnQgKG51bWJlcikgc3RhcnQgX3NsYXZlXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBlbmQgKG51bWJlcikgZW5kIF9zbGF2ZV8gbnVtYmVyLFxuICAgICBvICAgICAgICAgYiAobnVtYmVyKSBzdGFydCBfbWFzdGVyXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBzIChudW1iZXIpIGFuaW1hdGlvbiBzdGF0dXMgKDAuLjEpLFxuICAgICBvICAgICAgICAgZHVyIChudW1iZXIpIGFuaW1hdGlvbiBkdXJhdGlvbixcbiAgICAgbyAgICAgICAgIHNwZCAobnVtYmVyKSBhbmltYXRpb24gc3BlZWQsXG4gICAgIG8gICAgICAgICBnZXQgKGZ1bmN0aW9uKSBnZXR0ZXIgb2YgX21hc3Rlcl8gbnVtYmVyIChzZWUgQG1pbmEudGltZSksXG4gICAgIG8gICAgICAgICBzZXQgKGZ1bmN0aW9uKSBzZXR0ZXIgb2YgX3NsYXZlXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBlYXNpbmcgKGZ1bmN0aW9uKSBlYXNpbmcgZnVuY3Rpb24sIGRlZmF1bHQgaXMgQG1pbmEubGluZWFyLFxuICAgICBvICAgICAgICAgc3RhdHVzIChmdW5jdGlvbikgc3RhdHVzIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBzcGVlZCAoZnVuY3Rpb24pIHNwZWVkIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBkdXJhdGlvbiAoZnVuY3Rpb24pIGR1cmF0aW9uIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBzdG9wIChmdW5jdGlvbikgYW5pbWF0aW9uIHN0b3BwZXJcbiAgICAgbyAgICAgICAgIHBhdXNlIChmdW5jdGlvbikgcGF1c2VzIHRoZSBhbmltYXRpb25cbiAgICAgbyAgICAgICAgIHJlc3VtZSAoZnVuY3Rpb24pIHJlc3VtZXMgdGhlIGFuaW1hdGlvblxuICAgICBvICAgICAgICAgdXBkYXRlIChmdW5jdGlvbikgY2FsbGVzIHNldHRlciB3aXRoIHRoZSByaWdodCB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBtaW5hID0gZnVuY3Rpb24gKGEsIEEsIGIsIEIsIGdldCwgc2V0LCBlYXNpbmcpIHtcbiAgICAgICAgdmFyIGFuaW0gPSB7XG4gICAgICAgICAgICBpZDogSUQoKSxcbiAgICAgICAgICAgIHN0YXJ0OiBhLFxuICAgICAgICAgICAgZW5kOiBBLFxuICAgICAgICAgICAgYjogYixcbiAgICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgICBkdXI6IEIgLSBiLFxuICAgICAgICAgICAgc3BkOiAxLFxuICAgICAgICAgICAgZ2V0OiBnZXQsXG4gICAgICAgICAgICBzZXQ6IHNldCxcbiAgICAgICAgICAgIGVhc2luZzogZWFzaW5nIHx8IG1pbmEubGluZWFyLFxuICAgICAgICAgICAgc3RhdHVzOiBzdGEsXG4gICAgICAgICAgICBzcGVlZDogc3BlZWQsXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICBzdG9wOiBzdG9waXQsXG4gICAgICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgICAgICByZXN1bWU6IHJlc3VtZSxcbiAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGlvbnNbYW5pbS5pZF0gPSBhbmltO1xuICAgICAgICB2YXIgbGVuID0gMCwgaTtcbiAgICAgICAgZm9yIChpIGluIGFuaW1hdGlvbnMpIGlmIChhbmltYXRpb25zLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIGlmIChsZW4gPT0gMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlbiA9PSAxICYmIHJlcXVlc3RBbmltRnJhbWUoZnJhbWUpO1xuICAgICAgICByZXR1cm4gYW5pbTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLnRpbWVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZS4gRXF1aXZhbGVudCB0bzpcbiAgICAgfCBmdW5jdGlvbiAoKSB7XG4gICAgIHwgICAgIHJldHVybiAobmV3IERhdGUpLmdldFRpbWUoKTtcbiAgICAgfCB9XG4gICAgXFwqL1xuICAgIG1pbmEudGltZSA9IHRpbWVyO1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmdldEJ5SWRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gYW5pbWF0aW9uIGJ5IGl0cyBpZFxuICAgICAtIGlkIChzdHJpbmcpIGFuaW1hdGlvbidzIGlkXG4gICAgID0gKG9iamVjdCkgU2VlIEBtaW5hXG4gICAgXFwqL1xuICAgIG1pbmEuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uc1tpZF0gfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIG1pbmEubGluZWFyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEZWZhdWx0IGxpbmVhciBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmxpbmVhciA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuZWFzZW91dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRWFzZW91dCBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmVhc2VvdXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3cobiwgMS43KTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmVhc2VpblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRWFzZWluIGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuZWFzZWluID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KG4sIC40OCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5lYXNlaW5vdXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEVhc2Vpbm91dCBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmVhc2Vpbm91dCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmIChuID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxID0gLjQ4IC0gbiAvIDEuMDQsXG4gICAgICAgICAgICBRID0gTWF0aC5zcXJ0KC4xNzM0ICsgcSAqIHEpLFxuICAgICAgICAgICAgeCA9IFEgLSBxLFxuICAgICAgICAgICAgWCA9IE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMykgKiAoeCA8IDAgPyAtMSA6IDEpLFxuICAgICAgICAgICAgeSA9IC1RIC0gcSxcbiAgICAgICAgICAgIFkgPSBNYXRoLnBvdyhNYXRoLmFicyh5KSwgMSAvIDMpICogKHkgPCAwID8gLTEgOiAxKSxcbiAgICAgICAgICAgIHQgPSBYICsgWSArIC41O1xuICAgICAgICByZXR1cm4gKDEgLSB0KSAqIDMgKiB0ICogdCArIHQgKiB0ICogdDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmJhY2tpblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQmFja2luIGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuYmFja2luID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICByZXR1cm4gbiAqIG4gKiAoKHMgKyAxKSAqIG4gLSBzKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmJhY2tvdXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJhY2tvdXQgZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5iYWNrb3V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4gLSAxO1xuICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiBuICogbiAqICgocyArIDEpICogbiArIHMpICsgMTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmVsYXN0aWNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEVsYXN0aWMgZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5lbGFzdGljID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPT0gISFuKSB7XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwICogbikgKiBNYXRoLnNpbigobiAtIC4wNzUpICpcbiAgICAgICAgICAgICgyICogTWF0aC5QSSkgLyAuMykgKyAxO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuYm91bmNlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCb3VuY2UgZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5ib3VuY2UgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgcyA9IDcuNTYyNSxcbiAgICAgICAgICAgIHAgPSAyLjc1LFxuICAgICAgICAgICAgbDtcbiAgICAgICAgaWYgKG4gPCAoMSAvIHApKSB7XG4gICAgICAgICAgICBsID0gcyAqIG4gKiBuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG4gPCAoMiAvIHApKSB7XG4gICAgICAgICAgICAgICAgbiAtPSAoMS41IC8gcCk7XG4gICAgICAgICAgICAgICAgbCA9IHMgKiBuICogbiArIC43NTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gPCAoMi41IC8gcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbiAtPSAoMi4yNSAvIHApO1xuICAgICAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjkzNzU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbiAtPSAoMi42MjUgLyBwKTtcbiAgICAgICAgICAgICAgICAgICAgbCA9IHMgKiBuICogbiArIC45ODQzNzU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsO1xuICAgIH07XG4gICAgd2luZG93Lm1pbmEgPSBtaW5hO1xuICAgIHJldHVybiBtaW5hO1xufSkodHlwZW9mIGV2ZSA9PSBcInVuZGVmaW5lZFwiID8gZnVuY3Rpb24gKCkge30gOiBldmUpO1xuLy8gQ29weXJpZ2h0IChjKSAyMDEzIC0gMjAxNSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy8gXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vIFxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxudmFyIFNuYXAgPSAoZnVuY3Rpb24ocm9vdCkge1xuU25hcC52ZXJzaW9uID0gXCIwLjQuMFwiO1xuLypcXFxuICogU25hcFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ3JlYXRlcyBhIGRyYXdpbmcgc3VyZmFjZSBvciB3cmFwcyBleGlzdGluZyBTVkcgZWxlbWVudC5cbiAqKlxuIC0gd2lkdGggKG51bWJlcnxzdHJpbmcpIHdpZHRoIG9mIHN1cmZhY2VcbiAtIGhlaWdodCAobnVtYmVyfHN0cmluZykgaGVpZ2h0IG9mIHN1cmZhY2VcbiAqIG9yXG4gLSBET00gKFNWR0VsZW1lbnQpIGVsZW1lbnQgdG8gYmUgd3JhcHBlZCBpbnRvIFNuYXAgc3RydWN0dXJlXG4gKiBvclxuIC0gYXJyYXkgKGFycmF5KSBhcnJheSBvZiBlbGVtZW50cyAod2lsbCByZXR1cm4gc2V0IG9mIGVsZW1lbnRzKVxuICogb3JcbiAtIHF1ZXJ5IChzdHJpbmcpIENTUyBxdWVyeSBzZWxlY3RvclxuID0gKG9iamVjdCkgQEVsZW1lbnRcblxcKi9cbmZ1bmN0aW9uIFNuYXAodywgaCkge1xuICAgIGlmICh3KSB7XG4gICAgICAgIGlmICh3Lm5vZGVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcCh3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXModywgXCJhcnJheVwiKSAmJiBTbmFwLnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuc2V0LmFwcGx5KFNuYXAsIHcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggPT0gbnVsbCkge1xuICAgICAgICAgICAgdyA9IGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3IoU3RyaW5nKHcpKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHcgPSB3ID09IG51bGwgPyBcIjEwMCVcIiA6IHc7XG4gICAgaCA9IGggPT0gbnVsbCA/IFwiMTAwJVwiIDogaDtcbiAgICByZXR1cm4gbmV3IFBhcGVyKHcsIGgpO1xufVxuU25hcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJTbmFwIHZcIiArIHRoaXMudmVyc2lvbjtcbn07XG5TbmFwLl8gPSB7fTtcbnZhciBnbG9iID0ge1xuICAgIHdpbjogcm9vdC53aW5kb3csXG4gICAgZG9jOiByb290LndpbmRvdy5kb2N1bWVudFxufTtcblNuYXAuXy5nbG9iID0gZ2xvYjtcbnZhciBoYXMgPSBcImhhc093blByb3BlcnR5XCIsXG4gICAgU3RyID0gU3RyaW5nLFxuICAgIHRvRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgIHRvSW50ID0gcGFyc2VJbnQsXG4gICAgbWF0aCA9IE1hdGgsXG4gICAgbW1heCA9IG1hdGgubWF4LFxuICAgIG1taW4gPSBtYXRoLm1pbixcbiAgICBhYnMgPSBtYXRoLmFicyxcbiAgICBwb3cgPSBtYXRoLnBvdyxcbiAgICBQSSA9IG1hdGguUEksXG4gICAgcm91bmQgPSBtYXRoLnJvdW5kLFxuICAgIEUgPSBcIlwiLFxuICAgIFMgPSBcIiBcIixcbiAgICBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgSVNVUkwgPSAvXnVybFxcKFsnXCJdPyhbXlxcKV0rPylbJ1wiXT9cXCkkL2ksXG4gICAgY29sb3VyUmVnRXhwID0gL15cXHMqKCgjW2EtZlxcZF17Nn0pfCgjW2EtZlxcZF17M30pfHJnYmE/XFwoXFxzKihbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rJT8oPzpcXHMqLFxccypbXFxkXFwuXSslPyk/KVxccypcXCl8aHNiYT9cXChcXHMqKFtcXGRcXC5dKyg/OmRlZ3xcXHhiMHwlKT9cXHMqLFxccypbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyg/OiU/XFxzKixcXHMqW1xcZFxcLl0rKT8lPylcXHMqXFwpfGhzbGE/XFwoXFxzKihbXFxkXFwuXSsoPzpkZWd8XFx4YjB8JSk/XFxzKixcXHMqW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSsoPzolP1xccyosXFxzKltcXGRcXC5dKyk/JT8pXFxzKlxcKSlcXHMqJC9pLFxuICAgIGJlemllcnJnID0gL14oPzpjdWJpYy0pP2JlemllclxcKChbXixdKyksKFteLF0rKSwoW14sXSspLChbXlxcKV0rKVxcKS8sXG4gICAgcmVVUkxWYWx1ZSA9IC9edXJsXFwoIz8oW14pXSspXFwpJC8sXG4gICAgc2VwYXJhdG9yID0gU25hcC5fLnNlcGFyYXRvciA9IC9bLFxcc10rLyxcbiAgICB3aGl0ZXNwYWNlID0gL1tcXHNdL2csXG4gICAgY29tbWFTcGFjZXMgPSAvW1xcc10qLFtcXHNdKi8sXG4gICAgaHNyZyA9IHtoczogMSwgcmc6IDF9LFxuICAgIHBhdGhDb21tYW5kID0gLyhbYS16XSlbXFxzLF0qKCgtP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/W1xcc10qLD9bXFxzXSopKykvaWcsXG4gICAgdENvbW1hbmQgPSAvKFtyc3RtXSlbXFxzLF0qKCgtP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/W1xcc10qLD9bXFxzXSopKykvaWcsXG4gICAgcGF0aFZhbHVlcyA9IC8oLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcXFxkKyk/KVtcXHNdKiw/W1xcc10qL2lnLFxuICAgIGlkZ2VuID0gMCxcbiAgICBpZHByZWZpeCA9IFwiU1wiICsgKCtuZXcgRGF0ZSkudG9TdHJpbmcoMzYpLFxuICAgIElEID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiAoZWwgJiYgZWwudHlwZSA/IGVsLnR5cGUgOiBFKSArIGlkcHJlZml4ICsgKGlkZ2VuKyspLnRvU3RyaW5nKDM2KTtcbiAgICB9LFxuICAgIHhsaW5rID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgeG1sbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgaHViID0ge30sXG4gICAgVVJMID0gU25hcC51cmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBcInVybCgnI1wiICsgdXJsICsgXCInKVwiO1xuICAgIH07XG5cbmZ1bmN0aW9uICQoZWwsIGF0dHIpIHtcbiAgICBpZiAoYXR0cikge1xuICAgICAgICBpZiAoZWwgPT0gXCIjdGV4dFwiKSB7XG4gICAgICAgICAgICBlbCA9IGdsb2IuZG9jLmNyZWF0ZVRleHROb2RlKGF0dHIudGV4dCB8fCBhdHRyW1wiI3RleHRcIl0gfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsID09IFwiI2NvbW1lbnRcIikge1xuICAgICAgICAgICAgZWwgPSBnbG9iLmRvYy5jcmVhdGVDb21tZW50KGF0dHIudGV4dCB8fCBhdHRyW1wiI3RleHRcIl0gfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBlbCA9ICQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXR0ciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyLnN1YnN0cmluZygwLCA2KSA9PSBcInhsaW5rOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGVOUyh4bGluaywgYXR0ci5zdWJzdHJpbmcoNikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5zdWJzdHJpbmcoMCwgNCkgPT0gXCJ4bWw6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZU5TKHhtbG5zLCBhdHRyLnN1YnN0cmluZyg0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwubm9kZVZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHIpIGlmIChhdHRyW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBTdHIoYXR0cltrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDYpID09IFwieGxpbms6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rLCBrZXkuc3Vic3RyaW5nKDYpLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleS5zdWJzdHJpbmcoMCwgNCkgPT0gXCJ4bWw6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhtbG5zLCBrZXkuc3Vic3RyaW5nKDQpLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcInRleHRcIiBpbiBhdHRyKSB7XG4gICAgICAgICAgICBlbC5ub2RlVmFsdWUgPSBhdHRyLnRleHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGdsb2IuZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxucywgZWwpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG59XG5TbmFwLl8uJCA9ICQ7XG5TbmFwLl8uaWQgPSBJRDtcbmZ1bmN0aW9uIGdldEF0dHJzKGVsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cmlidXRlcyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb3V0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXR0cnNbaV0ubmFtZXNwYWNlVVJJID09IHhsaW5rKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJ4bGluazpcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgKz0gYXR0cnNbaV0ubmFtZTtcbiAgICAgICAgb3V0W25hbWVdID0gYXR0cnNbaV0udGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpcyhvLCB0eXBlKSB7XG4gICAgdHlwZSA9IFN0ci5wcm90b3R5cGUudG9Mb3dlckNhc2UuY2FsbCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PSBcImZpbml0ZVwiKSB7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShvKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJhcnJheVwiICYmXG4gICAgICAgIChvIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KG8pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICAodHlwZSA9PSBcIm51bGxcIiAmJiBvID09PSBudWxsKSB8fFxuICAgICAgICAgICAgKHR5cGUgPT0gdHlwZW9mIG8gJiYgbyAhPT0gbnVsbCkgfHxcbiAgICAgICAgICAgICh0eXBlID09IFwib2JqZWN0XCIgJiYgbyA9PT0gT2JqZWN0KG8pKSB8fFxuICAgICAgICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSA9PSB0eXBlO1xufVxuLypcXFxuICogU25hcC5mb3JtYXRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJlcGxhY2VzIGNvbnN0cnVjdGlvbiBvZiB0eXBlIGB7PG5hbWU+fWAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXJndW1lbnRcbiAqKlxuIC0gdG9rZW4gKHN0cmluZykgc3RyaW5nIHRvIGZvcm1hdFxuIC0ganNvbiAob2JqZWN0KSBvYmplY3Qgd2hpY2ggcHJvcGVydGllcyBhcmUgdXNlZCBhcyBhIHJlcGxhY2VtZW50XG4gPSAoc3RyaW5nKSBmb3JtYXR0ZWQgc3RyaW5nXG4gPiBVc2FnZVxuIHwgLy8gdGhpcyBkcmF3cyBhIHJlY3Rhbmd1bGFyIHNoYXBlIGVxdWl2YWxlbnQgdG8gXCJNMTAsMjBoNDB2NTBoLTQwelwiXG4gfCBwYXBlci5wYXRoKFNuYXAuZm9ybWF0KFwiTXt4fSx7eX1oe2RpbS53aWR0aH12e2RpbS5oZWlnaHR9aHtkaW1bJ25lZ2F0aXZlIHdpZHRoJ119elwiLCB7XG4gfCAgICAgeDogMTAsXG4gfCAgICAgeTogMjAsXG4gfCAgICAgZGltOiB7XG4gfCAgICAgICAgIHdpZHRoOiA0MCxcbiB8ICAgICAgICAgaGVpZ2h0OiA1MCxcbiB8ICAgICAgICAgXCJuZWdhdGl2ZSB3aWR0aFwiOiAtNDBcbiB8ICAgICB9XG4gfCB9KSk7XG5cXCovXG5TbmFwLmZvcm1hdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRva2VuUmVnZXggPSAvXFx7KFteXFx9XSspXFx9L2csXG4gICAgICAgIG9iak5vdGF0aW9uUmVnZXggPSAvKD86KD86XnxcXC4pKC4rPykoPz1cXFt8XFwufCR8XFwoKXxcXFsoJ3xcIikoLis/KVxcMlxcXSkoXFwoXFwpKT8vZywgLy8gbWF0Y2hlcyAueHh4eHggb3IgW1wieHh4eHhcIl0gdG8gcnVuIG92ZXIgb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgcmVwbGFjZXIgPSBmdW5jdGlvbiAoYWxsLCBrZXksIG9iaikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG9iajtcbiAgICAgICAgICAgIGtleS5yZXBsYWNlKG9iak5vdGF0aW9uUmVnZXgsIGZ1bmN0aW9uIChhbGwsIG5hbWUsIHF1b3RlLCBxdW90ZWROYW1lLCBpc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBxdW90ZWROYW1lO1xuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcyA9PSBcImZ1bmN0aW9uXCIgJiYgaXNGdW5jICYmIChyZXMgPSByZXMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXMgPSAocmVzID09IG51bGwgfHwgcmVzID09IG9iaiA/IGFsbCA6IHJlcykgKyBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgb2JqKSB7XG4gICAgICAgIHJldHVybiBTdHIoc3RyKS5yZXBsYWNlKHRva2VuUmVnZXgsIGZ1bmN0aW9uIChhbGwsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKGFsbCwga2V5LCBvYmopO1xuICAgICAgICB9KTtcbiAgICB9O1xufSkoKTtcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09IFwiZnVuY3Rpb25cIiB8fCBPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciByZXMgPSBuZXcgb2JqLmNvbnN0cnVjdG9yO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChvYmpbaGFzXShrZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gY2xvbmUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuU25hcC5fLmNsb25lID0gY2xvbmU7XG5mdW5jdGlvbiByZXB1c2goYXJyYXksIGl0ZW0pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LnB1c2goYXJyYXkuc3BsaWNlKGksIDEpWzBdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWNoZXIoZiwgc2NvcGUsIHBvc3Rwcm9jZXNzb3IpIHtcbiAgICBmdW5jdGlvbiBuZXdmKCkge1xuICAgICAgICB2YXIgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgICAgIGFyZ3MgPSBhcmcuam9pbihcIlxcdTI0MDBcIiksXG4gICAgICAgICAgICBjYWNoZSA9IG5ld2YuY2FjaGUgPSBuZXdmLmNhY2hlIHx8IHt9LFxuICAgICAgICAgICAgY291bnQgPSBuZXdmLmNvdW50ID0gbmV3Zi5jb3VudCB8fCBbXTtcbiAgICAgICAgaWYgKGNhY2hlW2hhc10oYXJncykpIHtcbiAgICAgICAgICAgIHJlcHVzaChjb3VudCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gcG9zdHByb2Nlc3NvciA/IHBvc3Rwcm9jZXNzb3IoY2FjaGVbYXJnc10pIDogY2FjaGVbYXJnc107XG4gICAgICAgIH1cbiAgICAgICAgY291bnQubGVuZ3RoID49IDFlMyAmJiBkZWxldGUgY2FjaGVbY291bnQuc2hpZnQoKV07XG4gICAgICAgIGNvdW50LnB1c2goYXJncyk7XG4gICAgICAgIGNhY2hlW2FyZ3NdID0gZi5hcHBseShzY29wZSwgYXJnKTtcbiAgICAgICAgcmV0dXJuIHBvc3Rwcm9jZXNzb3IgPyBwb3N0cHJvY2Vzc29yKGNhY2hlW2FyZ3NdKSA6IGNhY2hlW2FyZ3NdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Zjtcbn1cblNuYXAuXy5jYWNoZXIgPSBjYWNoZXI7XG5mdW5jdGlvbiBhbmdsZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgaWYgKHgzID09IG51bGwpIHtcbiAgICAgICAgdmFyIHggPSB4MSAtIHgyLFxuICAgICAgICAgICAgeSA9IHkxIC0geTI7XG4gICAgICAgIGlmICgheCAmJiAheSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgxODAgKyBtYXRoLmF0YW4yKC15LCAteCkgKiAxODAgLyBQSSArIDM2MCkgJSAzNjA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlKHgxLCB5MSwgeDMsIHkzKSAtIGFuZ2xlKHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG59XG5mdW5jdGlvbiByYWQoZGVnKSB7XG4gICAgcmV0dXJuIGRlZyAlIDM2MCAqIFBJIC8gMTgwO1xufVxuZnVuY3Rpb24gZGVnKHJhZCkge1xuICAgIHJldHVybiByYWQgKiAxODAgLyBQSSAlIDM2MDtcbn1cbmZ1bmN0aW9uIHhfeSgpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgUyArIHRoaXMueTtcbn1cbmZ1bmN0aW9uIHhfeV93X2goKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIFMgKyB0aGlzLnkgKyBTICsgdGhpcy53aWR0aCArIFwiIFxceGQ3IFwiICsgdGhpcy5oZWlnaHQ7XG59XG5cbi8qXFxcbiAqIFNuYXAucmFkXG4gWyBtZXRob2QgXVxuICoqXG4gKiBUcmFuc2Zvcm0gYW5nbGUgdG8gcmFkaWFuc1xuIC0gZGVnIChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcbiA9IChudW1iZXIpIGFuZ2xlIGluIHJhZGlhbnNcblxcKi9cblNuYXAucmFkID0gcmFkO1xuLypcXFxuICogU25hcC5kZWdcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFRyYW5zZm9ybSBhbmdsZSB0byBkZWdyZWVzXG4gLSByYWQgKG51bWJlcikgYW5nbGUgaW4gcmFkaWFuc1xuID0gKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuXFwqL1xuU25hcC5kZWcgPSBkZWc7XG4vKlxcXG4gKiBTbmFwLnNpblxuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5zaW4oKWAgb25seSB3b3JrcyB3aXRoIGRlZ3JlZXMsIG5vdCByYWRpYW5zLlxuIC0gYW5nbGUgKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuID0gKG51bWJlcikgc2luXG5cXCovXG5TbmFwLnNpbiA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgIHJldHVybiBtYXRoLnNpbihTbmFwLnJhZChhbmdsZSkpO1xufTtcbi8qXFxcbiAqIFNuYXAudGFuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLnRhbigpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBhbmdsZSAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzXG4gPSAobnVtYmVyKSB0YW5cblxcKi9cblNuYXAudGFuID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgcmV0dXJuIG1hdGgudGFuKFNuYXAucmFkKGFuZ2xlKSk7XG59O1xuLypcXFxuICogU25hcC5jb3NcbiBbIG1ldGhvZCBdXG4gKipcbiAqIEVxdWl2YWxlbnQgdG8gYE1hdGguY29zKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIGFuZ2xlIChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcbiA9IChudW1iZXIpIGNvc1xuXFwqL1xuU25hcC5jb3MgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICByZXR1cm4gbWF0aC5jb3MoU25hcC5yYWQoYW5nbGUpKTtcbn07XG4vKlxcXG4gKiBTbmFwLmFzaW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIEVxdWl2YWxlbnQgdG8gYE1hdGguYXNpbigpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBudW0gKG51bWJlcikgdmFsdWVcbiA9IChudW1iZXIpIGFzaW4gaW4gZGVncmVlc1xuXFwqL1xuU25hcC5hc2luID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBTbmFwLmRlZyhtYXRoLmFzaW4obnVtKSk7XG59O1xuLypcXFxuICogU25hcC5hY29zXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmFjb3MoKWAgb25seSB3b3JrcyB3aXRoIGRlZ3JlZXMsIG5vdCByYWRpYW5zLlxuIC0gbnVtIChudW1iZXIpIHZhbHVlXG4gPSAobnVtYmVyKSBhY29zIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuYWNvcyA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gU25hcC5kZWcobWF0aC5hY29zKG51bSkpO1xufTtcbi8qXFxcbiAqIFNuYXAuYXRhblxuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5hdGFuKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIG51bSAobnVtYmVyKSB2YWx1ZVxuID0gKG51bWJlcikgYXRhbiBpbiBkZWdyZWVzXG5cXCovXG5TbmFwLmF0YW4gPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIFNuYXAuZGVnKG1hdGguYXRhbihudW0pKTtcbn07XG4vKlxcXG4gKiBTbmFwLmF0YW4yXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmF0YW4yKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIG51bSAobnVtYmVyKSB2YWx1ZVxuID0gKG51bWJlcikgYXRhbjIgaW4gZGVncmVlc1xuXFwqL1xuU25hcC5hdGFuMiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gU25hcC5kZWcobWF0aC5hdGFuMihudW0pKTtcbn07XG4vKlxcXG4gKiBTbmFwLmFuZ2xlXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGFuIGFuZ2xlIGJldHdlZW4gdHdvIG9yIHRocmVlIHBvaW50c1xuID4gUGFyYW1ldGVyc1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gLSB4MyAobnVtYmVyKSAjb3B0aW9uYWwgeCBjb29yZCBvZiB0aGlyZCBwb2ludFxuIC0geTMgKG51bWJlcikgI29wdGlvbmFsIHkgY29vcmQgb2YgdGhpcmQgcG9pbnRcbiA9IChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuYW5nbGUgPSBhbmdsZTtcbi8qXFxcbiAqIFNuYXAubGVuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuID4gUGFyYW1ldGVyc1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gPSAobnVtYmVyKSBkaXN0YW5jZVxuXFwqL1xuU25hcC5sZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KFNuYXAubGVuMih4MSwgeTEsIHgyLCB5MikpO1xufTtcbi8qXFxcbiAqIFNuYXAubGVuMlxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuID4gUGFyYW1ldGVyc1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gPSAobnVtYmVyKSBkaXN0YW5jZVxuXFwqL1xuU25hcC5sZW4yID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuICh4MSAtIHgyKSAqICh4MSAtIHgyKSArICh5MSAtIHkyKSAqICh5MSAtIHkyKTtcbn07XG4vKlxcXG4gKiBTbmFwLmNsb3Nlc3RQb2ludFxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBjbG9zZXN0IHBvaW50IHRvIGEgZ2l2ZW4gb25lIG9uIGEgZ2l2ZW4gcGF0aC5cbiA+IFBhcmFtZXRlcnNcbiAtIHBhdGggKEVsZW1lbnQpIHBhdGggZWxlbWVudFxuIC0geCAobnVtYmVyKSB4IGNvb3JkIG9mIGEgcG9pbnRcbiAtIHkgKG51bWJlcikgeSBjb29yZCBvZiBhIHBvaW50XG4gPSAob2JqZWN0KSBpbiBmb3JtYXRcbiB7XG4gICAgeCAobnVtYmVyKSB4IGNvb3JkIG9mIHRoZSBwb2ludCBvbiB0aGUgcGF0aFxuICAgIHkgKG51bWJlcikgeSBjb29yZCBvZiB0aGUgcG9pbnQgb24gdGhlIHBhdGhcbiAgICBsZW5ndGggKG51bWJlcikgbGVuZ3RoIG9mIHRoZSBwYXRoIHRvIHRoZSBwb2ludFxuICAgIGRpc3RhbmNlIChudW1iZXIpIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIHBvaW50IHRvIHRoZSBwYXRoXG4gfVxuXFwqL1xuLy8gQ29waWVkIGZyb20gaHR0cDovL2JsLm9ja3Mub3JnL21ib3N0b2NrLzgwMjc2MzdcblNuYXAuY2xvc2VzdFBvaW50ID0gZnVuY3Rpb24gKHBhdGgsIHgsIHkpIHtcbiAgICBmdW5jdGlvbiBkaXN0YW5jZTIocCkge1xuICAgICAgICB2YXIgZHggPSBwLnggLSB4LFxuICAgICAgICAgICAgZHkgPSBwLnkgLSB5O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIHZhciBwYXRoTm9kZSA9IHBhdGgubm9kZSxcbiAgICAgICAgcGF0aExlbmd0aCA9IHBhdGhOb2RlLmdldFRvdGFsTGVuZ3RoKCksXG4gICAgICAgIHByZWNpc2lvbiA9IHBhdGhMZW5ndGggLyBwYXRoTm9kZS5wYXRoU2VnTGlzdC5udW1iZXJPZkl0ZW1zICogLjEyNSxcbiAgICAgICAgYmVzdCxcbiAgICAgICAgYmVzdExlbmd0aCxcbiAgICAgICAgYmVzdERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICAvLyBsaW5lYXIgc2NhbiBmb3IgY29hcnNlIGFwcHJveGltYXRpb25cbiAgICBmb3IgKHZhciBzY2FuLCBzY2FuTGVuZ3RoID0gMCwgc2NhbkRpc3RhbmNlOyBzY2FuTGVuZ3RoIDw9IHBhdGhMZW5ndGg7IHNjYW5MZW5ndGggKz0gcHJlY2lzaW9uKSB7XG4gICAgICAgIGlmICgoc2NhbkRpc3RhbmNlID0gZGlzdGFuY2UyKHNjYW4gPSBwYXRoTm9kZS5nZXRQb2ludEF0TGVuZ3RoKHNjYW5MZW5ndGgpKSkgPCBiZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGJlc3QgPSBzY2FuLCBiZXN0TGVuZ3RoID0gc2Nhbkxlbmd0aCwgYmVzdERpc3RhbmNlID0gc2NhbkRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYmluYXJ5IHNlYXJjaCBmb3IgcHJlY2lzZSBlc3RpbWF0ZVxuICAgIHByZWNpc2lvbiAqPSAuNTtcbiAgICB3aGlsZSAocHJlY2lzaW9uID4gLjUpIHtcbiAgICAgICAgdmFyIGJlZm9yZSxcbiAgICAgICAgICAgIGFmdGVyLFxuICAgICAgICAgICAgYmVmb3JlTGVuZ3RoLFxuICAgICAgICAgICAgYWZ0ZXJMZW5ndGgsXG4gICAgICAgICAgICBiZWZvcmVEaXN0YW5jZSxcbiAgICAgICAgICAgIGFmdGVyRGlzdGFuY2U7XG4gICAgICAgIGlmICgoYmVmb3JlTGVuZ3RoID0gYmVzdExlbmd0aCAtIHByZWNpc2lvbikgPj0gMCAmJiAoYmVmb3JlRGlzdGFuY2UgPSBkaXN0YW5jZTIoYmVmb3JlID0gcGF0aE5vZGUuZ2V0UG9pbnRBdExlbmd0aChiZWZvcmVMZW5ndGgpKSkgPCBiZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGJlc3QgPSBiZWZvcmUsIGJlc3RMZW5ndGggPSBiZWZvcmVMZW5ndGgsIGJlc3REaXN0YW5jZSA9IGJlZm9yZURpc3RhbmNlO1xuICAgICAgICB9IGVsc2UgaWYgKChhZnRlckxlbmd0aCA9IGJlc3RMZW5ndGggKyBwcmVjaXNpb24pIDw9IHBhdGhMZW5ndGggJiYgKGFmdGVyRGlzdGFuY2UgPSBkaXN0YW5jZTIoYWZ0ZXIgPSBwYXRoTm9kZS5nZXRQb2ludEF0TGVuZ3RoKGFmdGVyTGVuZ3RoKSkpIDwgYmVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICBiZXN0ID0gYWZ0ZXIsIGJlc3RMZW5ndGggPSBhZnRlckxlbmd0aCwgYmVzdERpc3RhbmNlID0gYWZ0ZXJEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiAqPSAuNTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJlc3QgPSB7XG4gICAgICAgIHg6IGJlc3QueCxcbiAgICAgICAgeTogYmVzdC55LFxuICAgICAgICBsZW5ndGg6IGJlc3RMZW5ndGgsXG4gICAgICAgIGRpc3RhbmNlOiBNYXRoLnNxcnQoYmVzdERpc3RhbmNlKVxuICAgIH07XG4gICAgcmV0dXJuIGJlc3Q7XG59XG4vKlxcXG4gKiBTbmFwLmlzXG4gWyBtZXRob2QgXVxuICoqXG4gKiBIYW5keSByZXBsYWNlbWVudCBmb3IgdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gLSBvICjigKYpIGFueSBvYmplY3Qgb3IgcHJpbWl0aXZlXG4gLSB0eXBlIChzdHJpbmcpIG5hbWUgb2YgdGhlIHR5cGUsIGUuZy4sIGBzdHJpbmdgLCBgZnVuY3Rpb25gLCBgbnVtYmVyYCwgZXRjLlxuID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBnaXZlbiB2YWx1ZSBpcyBvZiBnaXZlbiB0eXBlXG5cXCovXG5TbmFwLmlzID0gaXM7XG4vKlxcXG4gKiBTbmFwLnNuYXBUb1xuIFsgbWV0aG9kIF1cbiAqKlxuICogU25hcHMgZ2l2ZW4gdmFsdWUgdG8gZ2l2ZW4gZ3JpZFxuIC0gdmFsdWVzIChhcnJheXxudW1iZXIpIGdpdmVuIGFycmF5IG9mIHZhbHVlcyBvciBzdGVwIG9mIHRoZSBncmlkXG4gLSB2YWx1ZSAobnVtYmVyKSB2YWx1ZSB0byBhZGp1c3RcbiAtIHRvbGVyYW5jZSAobnVtYmVyKSAjb3B0aW9uYWwgbWF4aW11bSBkaXN0YW5jZSB0byB0aGUgdGFyZ2V0IHZhbHVlIHRoYXQgd291bGQgdHJpZ2dlciB0aGUgc25hcC4gRGVmYXVsdCBpcyBgMTBgLlxuID0gKG51bWJlcikgYWRqdXN0ZWQgdmFsdWVcblxcKi9cblNuYXAuc25hcFRvID0gZnVuY3Rpb24gKHZhbHVlcywgdmFsdWUsIHRvbGVyYW5jZSkge1xuICAgIHRvbGVyYW5jZSA9IGlzKHRvbGVyYW5jZSwgXCJmaW5pdGVcIikgPyB0b2xlcmFuY2UgOiAxMDtcbiAgICBpZiAoaXModmFsdWVzLCBcImFycmF5XCIpKSB7XG4gICAgICAgIHZhciBpID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgaWYgKGFicyh2YWx1ZXNbaV0gLSB2YWx1ZSkgPD0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzID0gK3ZhbHVlcztcbiAgICAgICAgdmFyIHJlbSA9IHZhbHVlICUgdmFsdWVzO1xuICAgICAgICBpZiAocmVtIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgLSByZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbSA+IHZhbHVlcyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gcmVtICsgdmFsdWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vLyBDb2xvdXJcbi8qXFxcbiAqIFNuYXAuZ2V0UkdCXG4gWyBtZXRob2QgXVxuICoqXG4gKiBQYXJzZXMgY29sb3Igc3RyaW5nIGFzIFJHQiBvYmplY3RcbiAtIGNvbG9yIChzdHJpbmcpIGNvbG9yIHN0cmluZyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICMgPHVsPlxuICMgICAgIDxsaT5Db2xvciBuYW1lICg8Y29kZT5yZWQ8L2NvZGU+LCA8Y29kZT5ncmVlbjwvY29kZT4sIDxjb2RlPmNvcm5mbG93ZXJibHVlPC9jb2RlPiwgZXRjKTwvbGk+XG4gIyAgICAgPGxpPiPigKLigKLigKIg4oCUIHNob3J0ZW5lZCBIVE1MIGNvbG9yOiAoPGNvZGU+IzAwMDwvY29kZT4sIDxjb2RlPiNmYzA8L2NvZGU+LCBldGMuKTwvbGk+XG4gIyAgICAgPGxpPiPigKLigKLigKLigKLigKLigKIg4oCUIGZ1bGwgbGVuZ3RoIEhUTUwgY29sb3I6ICg8Y29kZT4jMDAwMDAwPC9jb2RlPiwgPGNvZGU+I2JkMjMwMDwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+cmdiKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxzIHZhbHVlczogKDxjb2RlPnJnYigyMDAsJm5ic3A7MTAwLCZuYnNwOzApPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5yZ2JhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+cmdiKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTogKDxjb2RlPnJnYigxMDAlLCZuYnNwOzE3NSUsJm5ic3A7MCUpPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5yZ2JhKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzYijigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgaHVlLCBzYXR1cmF0aW9uIGFuZCBicmlnaHRuZXNzIHZhbHVlczogKDxjb2RlPmhzYigwLjUsJm5ic3A7MC4yNSwmbmJzcDsxKTwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+aHNiYSjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzYijigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgc2FtZSBhcyBhYm92ZSwgYnV0IGluICU8L2xpPlxuICMgICAgIDxsaT5oc2JhKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzbCjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgaHVlLCBzYXR1cmF0aW9uIGFuZCBsdW1pbm9zaXR5IHZhbHVlczogKDxjb2RlPmhzYigwLjUsJm5ic3A7MC4yNSwmbmJzcDswLjUpPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5oc2xhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+aHNsKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTwvbGk+XG4gIyAgICAgPGxpPmhzbGEo4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjIDwvdWw+XG4gKiBOb3RlIHRoYXQgYCVgIGNhbiBiZSB1c2VkIGFueSB0aW1lOiBgcmdiKDIwJSwgMjU1LCA1MCUpYC5cbiA9IChvYmplY3QpIFJHQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgciAobnVtYmVyKSByZWQsXG4gbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAoixcbiBvICAgICBlcnJvciAoYm9vbGVhbikgdHJ1ZSBpZiBzdHJpbmcgY2FuJ3QgYmUgcGFyc2VkXG4gbyB9XG5cXCovXG5TbmFwLmdldFJHQiA9IGNhY2hlcihmdW5jdGlvbiAoY29sb3VyKSB7XG4gICAgaWYgKCFjb2xvdXIgfHwgISEoKGNvbG91ciA9IFN0cihjb2xvdXIpKS5pbmRleE9mKFwiLVwiKSArIDEpKSB7XG4gICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG4gICAgfVxuICAgIGlmIChjb2xvdXIgPT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIHtyOiAtMSwgZzogLTEsIGI6IC0xLCBoZXg6IFwibm9uZVwiLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xuICAgIH1cbiAgICAhKGhzcmdbaGFzXShjb2xvdXIudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMCwgMikpIHx8IGNvbG91ci5jaGFyQXQoKSA9PSBcIiNcIikgJiYgKGNvbG91ciA9IHRvSGV4KGNvbG91cikpO1xuICAgIGlmICghY29sb3VyKSB7XG4gICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG4gICAgfVxuICAgIHZhciByZXMsXG4gICAgICAgIHJlZCxcbiAgICAgICAgZ3JlZW4sXG4gICAgICAgIGJsdWUsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHQsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgcmdiID0gY29sb3VyLm1hdGNoKGNvbG91clJlZ0V4cCk7XG4gICAgaWYgKHJnYikge1xuICAgICAgICBpZiAocmdiWzJdKSB7XG4gICAgICAgICAgICBibHVlID0gdG9JbnQocmdiWzJdLnN1YnN0cmluZyg1KSwgMTYpO1xuICAgICAgICAgICAgZ3JlZW4gPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDMsIDUpLCAxNik7XG4gICAgICAgICAgICByZWQgPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDEsIDMpLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJnYlszXSkge1xuICAgICAgICAgICAgYmx1ZSA9IHRvSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgzKSkgKyB0LCAxNik7XG4gICAgICAgICAgICBncmVlbiA9IHRvSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgyKSkgKyB0LCAxNik7XG4gICAgICAgICAgICByZWQgPSB0b0ludCgodCA9IHJnYlszXS5jaGFyQXQoMSkpICsgdCwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2JbNF0pIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHJnYls0XS5zcGxpdChjb21tYVNwYWNlcyk7XG4gICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgKj0gMi41NSk7XG4gICAgICAgICAgICBncmVlbiA9IHRvRmxvYXQodmFsdWVzWzFdKTtcbiAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuICo9IDIuNTUpO1xuICAgICAgICAgICAgYmx1ZSA9IHRvRmxvYXQodmFsdWVzWzJdKTtcbiAgICAgICAgICAgIHZhbHVlc1syXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGJsdWUgKj0gMi41NSk7XG4gICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcInJnYmFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICB2YWx1ZXNbM10gJiYgdmFsdWVzWzNdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAob3BhY2l0eSAvPSAxMDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2JbNV0pIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHJnYls1XS5zcGxpdChjb21tYVNwYWNlcyk7XG4gICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgLz0gMTAwKTtcbiAgICAgICAgICAgIGdyZWVuID0gdG9GbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgdmFsdWVzWzFdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoZ3JlZW4gLz0gMTAwKTtcbiAgICAgICAgICAgIGJsdWUgPSB0b0Zsb2F0KHZhbHVlc1syXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMl0uc2xpY2UoLTEpID09IFwiJVwiICYmIChibHVlIC89IDEwMCk7XG4gICAgICAgICAgICAodmFsdWVzWzBdLnNsaWNlKC0zKSA9PSBcImRlZ1wiIHx8IHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCJcXHhiMFwiKSAmJiAocmVkIC89IDM2MCk7XG4gICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcImhzYmFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICB2YWx1ZXNbM10gJiYgdmFsdWVzWzNdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAob3BhY2l0eSAvPSAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuaHNiMnJnYihyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmdiWzZdKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSByZ2JbNl0uc3BsaXQoY29tbWFTcGFjZXMpO1xuICAgICAgICAgICAgcmVkID0gdG9GbG9hdCh2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAocmVkIC89IDEwMCk7XG4gICAgICAgICAgICBncmVlbiA9IHRvRmxvYXQodmFsdWVzWzFdKTtcbiAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuIC89IDEwMCk7XG4gICAgICAgICAgICBibHVlID0gdG9GbG9hdCh2YWx1ZXNbMl0pO1xuICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAvPSAxMDApO1xuICAgICAgICAgICAgKHZhbHVlc1swXS5zbGljZSgtMykgPT0gXCJkZWdcIiB8fCB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiXFx4YjBcIikgJiYgKHJlZCAvPSAzNjApO1xuICAgICAgICAgICAgcmdiWzFdLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNCkgPT0gXCJoc2xhXCIgJiYgKG9wYWNpdHkgPSB0b0Zsb2F0KHZhbHVlc1szXSkpO1xuICAgICAgICAgICAgdmFsdWVzWzNdICYmIHZhbHVlc1szXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKG9wYWNpdHkgLz0gMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLmhzbDJyZ2IocmVkLCBncmVlbiwgYmx1ZSwgb3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVkID0gbW1pbihtYXRoLnJvdW5kKHJlZCksIDI1NSk7XG4gICAgICAgIGdyZWVuID0gbW1pbihtYXRoLnJvdW5kKGdyZWVuKSwgMjU1KTtcbiAgICAgICAgYmx1ZSA9IG1taW4obWF0aC5yb3VuZChibHVlKSwgMjU1KTtcbiAgICAgICAgb3BhY2l0eSA9IG1taW4obW1heChvcGFjaXR5LCAwKSwgMSk7XG4gICAgICAgIHJnYiA9IHtyOiByZWQsIGc6IGdyZWVuLCBiOiBibHVlLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xuICAgICAgICByZ2IuaGV4ID0gXCIjXCIgKyAoMTY3NzcyMTYgfCBibHVlIHwgKGdyZWVuIDw8IDgpIHwgKHJlZCA8PCAxNikpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICAgICAgcmdiLm9wYWNpdHkgPSBpcyhvcGFjaXR5LCBcImZpbml0ZVwiKSA/IG9wYWNpdHkgOiAxO1xuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH1cbiAgICByZXR1cm4ge3I6IC0xLCBnOiAtMSwgYjogLTEsIGhleDogXCJub25lXCIsIGVycm9yOiAxLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xufSwgU25hcCk7XG4vKlxcXG4gKiBTbmFwLmhzYlxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgSFNCIHZhbHVlcyB0byBhIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcbiAtIGggKG51bWJlcikgaHVlXG4gLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAtIGIgKG51bWJlcikgdmFsdWUgb3IgYnJpZ2h0bmVzc1xuID0gKHN0cmluZykgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuXFwqL1xuU25hcC5oc2IgPSBjYWNoZXIoZnVuY3Rpb24gKGgsIHMsIGIpIHtcbiAgICByZXR1cm4gU25hcC5oc2IycmdiKGgsIHMsIGIpLmhleDtcbn0pO1xuLypcXFxuICogU25hcC5oc2xcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIEhTTCB2YWx1ZXMgdG8gYSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG4gLSBoIChudW1iZXIpIGh1ZVxuIC0gcyAobnVtYmVyKSBzYXR1cmF0aW9uXG4gLSBsIChudW1iZXIpIGx1bWlub3NpdHlcbiA9IChzdHJpbmcpIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcblxcKi9cblNuYXAuaHNsID0gY2FjaGVyKGZ1bmN0aW9uIChoLCBzLCBsKSB7XG4gICAgcmV0dXJuIFNuYXAuaHNsMnJnYihoLCBzLCBsKS5oZXg7XG59KTtcbi8qXFxcbiAqIFNuYXAucmdiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBSR0IgdmFsdWVzIHRvIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuIC0gciAobnVtYmVyKSByZWRcbiAtIGcgKG51bWJlcikgZ3JlZW5cbiAtIGIgKG51bWJlcikgYmx1ZVxuID0gKHN0cmluZykgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuXFwqL1xuU25hcC5yZ2IgPSBjYWNoZXIoZnVuY3Rpb24gKHIsIGcsIGIsIG8pIHtcbiAgICBpZiAoaXMobywgXCJmaW5pdGVcIikpIHtcbiAgICAgICAgdmFyIHJvdW5kID0gbWF0aC5yb3VuZDtcbiAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIFtyb3VuZChyKSwgcm91bmQoZyksIHJvdW5kKGIpLCArby50b0ZpeGVkKDIpXSArIFwiKVwiO1xuICAgIH1cbiAgICByZXR1cm4gXCIjXCIgKyAoMTY3NzcyMTYgfCBiIHwgKGcgPDwgOCkgfCAociA8PCAxNikpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbn0pO1xudmFyIHRvSGV4ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIGkgPSBnbG9iLmRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0gfHwgZ2xvYi5kb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdmdcIilbMF0sXG4gICAgICAgIHJlZCA9IFwicmdiKDI1NSwgMCwgMClcIjtcbiAgICB0b0hleCA9IGNhY2hlcihmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgaWYgKGNvbG9yLnRvTG93ZXJDYXNlKCkgPT0gXCJyZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHJlZDtcbiAgICAgICAgfVxuICAgICAgICBpLnN0eWxlLmNvbG9yID0gcmVkO1xuICAgICAgICBpLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgICAgIHZhciBvdXQgPSBnbG9iLmRvYy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGksIEUpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKTtcbiAgICAgICAgcmV0dXJuIG91dCA9PSByZWQgPyBudWxsIDogb3V0O1xuICAgIH0pO1xuICAgIHJldHVybiB0b0hleChjb2xvcik7XG59LFxuaHNidG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiaHNiKFwiICsgW3RoaXMuaCwgdGhpcy5zLCB0aGlzLmJdICsgXCIpXCI7XG59LFxuaHNsdG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiaHNsKFwiICsgW3RoaXMuaCwgdGhpcy5zLCB0aGlzLmxdICsgXCIpXCI7XG59LFxucmdidG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BhY2l0eSA9PSAxIHx8IHRoaXMub3BhY2l0eSA9PSBudWxsID9cbiAgICAgICAgICAgIHRoaXMuaGV4IDpcbiAgICAgICAgICAgIFwicmdiYShcIiArIFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLm9wYWNpdHldICsgXCIpXCI7XG59LFxucHJlcGFyZVJHQiA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgaWYgKGcgPT0gbnVsbCAmJiBpcyhyLCBcIm9iamVjdFwiKSAmJiBcInJcIiBpbiByICYmIFwiZ1wiIGluIHIgJiYgXCJiXCIgaW4gcikge1xuICAgICAgICBiID0gci5iO1xuICAgICAgICBnID0gci5nO1xuICAgICAgICByID0gci5yO1xuICAgIH1cbiAgICBpZiAoZyA9PSBudWxsICYmIGlzKHIsIHN0cmluZykpIHtcbiAgICAgICAgdmFyIGNsciA9IFNuYXAuZ2V0UkdCKHIpO1xuICAgICAgICByID0gY2xyLnI7XG4gICAgICAgIGcgPSBjbHIuZztcbiAgICAgICAgYiA9IGNsci5iO1xuICAgIH1cbiAgICBpZiAociA+IDEgfHwgZyA+IDEgfHwgYiA+IDEpIHtcbiAgICAgICAgciAvPSAyNTU7XG4gICAgICAgIGcgLz0gMjU1O1xuICAgICAgICBiIC89IDI1NTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn0sXG5wYWNrYWdlUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIsIG8pIHtcbiAgICByID0gbWF0aC5yb3VuZChyICogMjU1KTtcbiAgICBnID0gbWF0aC5yb3VuZChnICogMjU1KTtcbiAgICBiID0gbWF0aC5yb3VuZChiICogMjU1KTtcbiAgICB2YXIgcmdiID0ge1xuICAgICAgICByOiByLFxuICAgICAgICBnOiBnLFxuICAgICAgICBiOiBiLFxuICAgICAgICBvcGFjaXR5OiBpcyhvLCBcImZpbml0ZVwiKSA/IG8gOiAxLFxuICAgICAgICBoZXg6IFNuYXAucmdiKHIsIGcsIGIpLFxuICAgICAgICB0b1N0cmluZzogcmdidG9TdHJpbmdcbiAgICB9O1xuICAgIGlzKG8sIFwiZmluaXRlXCIpICYmIChyZ2Iub3BhY2l0eSA9IG8pO1xuICAgIHJldHVybiByZ2I7XG59O1xuLypcXFxuICogU25hcC5jb2xvclxuIFsgbWV0aG9kIF1cbiAqKlxuICogUGFyc2VzIHRoZSBjb2xvciBzdHJpbmcgYW5kIHJldHVybnMgYW4gb2JqZWN0IGZlYXR1cmluZyB0aGUgY29sb3IncyBjb21wb25lbnQgdmFsdWVzXG4gLSBjbHIgKHN0cmluZykgY29sb3Igc3RyaW5nIGluIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZvcm1hdHMgKHNlZSBAU25hcC5nZXRSR0IpXG4gPSAob2JqZWN0KSBDb21iaW5lZCBSR0IvSFNCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICByIChudW1iZXIpIHJlZCxcbiBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiLFxuIG8gICAgIGVycm9yIChib29sZWFuKSBgdHJ1ZWAgaWYgc3RyaW5nIGNhbid0IGJlIHBhcnNlZCxcbiBvICAgICBoIChudW1iZXIpIGh1ZSxcbiBvICAgICBzIChudW1iZXIpIHNhdHVyYXRpb24sXG4gbyAgICAgdiAobnVtYmVyKSB2YWx1ZSAoYnJpZ2h0bmVzcyksXG4gbyAgICAgbCAobnVtYmVyKSBsaWdodG5lc3NcbiBvIH1cblxcKi9cblNuYXAuY29sb3IgPSBmdW5jdGlvbiAoY2xyKSB7XG4gICAgdmFyIHJnYjtcbiAgICBpZiAoaXMoY2xyLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBjbHIgJiYgXCJzXCIgaW4gY2xyICYmIFwiYlwiIGluIGNscikge1xuICAgICAgICByZ2IgPSBTbmFwLmhzYjJyZ2IoY2xyKTtcbiAgICAgICAgY2xyLnIgPSByZ2IucjtcbiAgICAgICAgY2xyLmcgPSByZ2IuZztcbiAgICAgICAgY2xyLmIgPSByZ2IuYjtcbiAgICAgICAgY2xyLm9wYWNpdHkgPSAxO1xuICAgICAgICBjbHIuaGV4ID0gcmdiLmhleDtcbiAgICB9IGVsc2UgaWYgKGlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gY2xyICYmIFwic1wiIGluIGNsciAmJiBcImxcIiBpbiBjbHIpIHtcbiAgICAgICAgcmdiID0gU25hcC5oc2wycmdiKGNscik7XG4gICAgICAgIGNsci5yID0gcmdiLnI7XG4gICAgICAgIGNsci5nID0gcmdiLmc7XG4gICAgICAgIGNsci5iID0gcmdiLmI7XG4gICAgICAgIGNsci5vcGFjaXR5ID0gMTtcbiAgICAgICAgY2xyLmhleCA9IHJnYi5oZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzKGNsciwgXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGNsciA9IFNuYXAuZ2V0UkdCKGNscik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJyXCIgaW4gY2xyICYmIFwiZ1wiIGluIGNsciAmJiBcImJcIiBpbiBjbHIgJiYgIShcImVycm9yXCIgaW4gY2xyKSkge1xuICAgICAgICAgICAgcmdiID0gU25hcC5yZ2IyaHNsKGNscik7XG4gICAgICAgICAgICBjbHIuaCA9IHJnYi5oO1xuICAgICAgICAgICAgY2xyLnMgPSByZ2IucztcbiAgICAgICAgICAgIGNsci5sID0gcmdiLmw7XG4gICAgICAgICAgICByZ2IgPSBTbmFwLnJnYjJoc2IoY2xyKTtcbiAgICAgICAgICAgIGNsci52ID0gcmdiLmI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHIgPSB7aGV4OiBcIm5vbmVcIn07XG4gICAgICAgICAgICBjbHIuciA9IGNsci5nID0gY2xyLmIgPSBjbHIuaCA9IGNsci5zID0gY2xyLnYgPSBjbHIubCA9IC0xO1xuICAgICAgICAgICAgY2xyLmVycm9yID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbHIudG9TdHJpbmcgPSByZ2J0b1N0cmluZztcbiAgICByZXR1cm4gY2xyO1xufTtcbi8qXFxcbiAqIFNuYXAuaHNiMnJnYlxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgSFNCIHZhbHVlcyB0byBhbiBSR0Igb2JqZWN0XG4gLSBoIChudW1iZXIpIGh1ZVxuIC0gcyAobnVtYmVyKSBzYXR1cmF0aW9uXG4gLSB2IChudW1iZXIpIHZhbHVlIG9yIGJyaWdodG5lc3NcbiA9IChvYmplY3QpIFJHQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgciAobnVtYmVyKSByZWQsXG4gbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAolxuIG8gfVxuXFwqL1xuU25hcC5oc2IycmdiID0gZnVuY3Rpb24gKGgsIHMsIHYsIG8pIHtcbiAgICBpZiAoaXMoaCwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gaCAmJiBcInNcIiBpbiBoICYmIFwiYlwiIGluIGgpIHtcbiAgICAgICAgdiA9IGguYjtcbiAgICAgICAgcyA9IGgucztcbiAgICAgICAgbyA9IGgubztcbiAgICAgICAgaCA9IGguaDtcbiAgICB9XG4gICAgaCAqPSAzNjA7XG4gICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgaCA9IChoICUgMzYwKSAvIDYwO1xuICAgIEMgPSB2ICogcztcbiAgICBYID0gQyAqICgxIC0gYWJzKGggJSAyIC0gMSkpO1xuICAgIFIgPSBHID0gQiA9IHYgLSBDO1xuXG4gICAgaCA9IH5+aDtcbiAgICBSICs9IFtDLCBYLCAwLCAwLCBYLCBDXVtoXTtcbiAgICBHICs9IFtYLCBDLCBDLCBYLCAwLCAwXVtoXTtcbiAgICBCICs9IFswLCAwLCBYLCBDLCBDLCBYXVtoXTtcbiAgICByZXR1cm4gcGFja2FnZVJHQihSLCBHLCBCLCBvKTtcbn07XG4vKlxcXG4gKiBTbmFwLmhzbDJyZ2JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIEhTTCB2YWx1ZXMgdG8gYW4gUkdCIG9iamVjdFxuIC0gaCAobnVtYmVyKSBodWVcbiAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuIC0gbCAobnVtYmVyKSBsdW1pbm9zaXR5XG4gPSAob2JqZWN0KSBSR0Igb2JqZWN0IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuIG8ge1xuIG8gICAgIHIgKG51bWJlcikgcmVkLFxuIG8gICAgIGcgKG51bWJlcikgZ3JlZW4sXG4gbyAgICAgYiAobnVtYmVyKSBibHVlLFxuIG8gICAgIGhleCAoc3RyaW5nKSBjb2xvciBpbiBIVE1ML0NTUyBmb3JtYXQ6ICPigKLigKLigKLigKLigKLigKJcbiBvIH1cblxcKi9cblNuYXAuaHNsMnJnYiA9IGZ1bmN0aW9uIChoLCBzLCBsLCBvKSB7XG4gICAgaWYgKGlzKGgsIFwib2JqZWN0XCIpICYmIFwiaFwiIGluIGggJiYgXCJzXCIgaW4gaCAmJiBcImxcIiBpbiBoKSB7XG4gICAgICAgIGwgPSBoLmw7XG4gICAgICAgIHMgPSBoLnM7XG4gICAgICAgIGggPSBoLmg7XG4gICAgfVxuICAgIGlmIChoID4gMSB8fCBzID4gMSB8fCBsID4gMSkge1xuICAgICAgICBoIC89IDM2MDtcbiAgICAgICAgcyAvPSAxMDA7XG4gICAgICAgIGwgLz0gMTAwO1xuICAgIH1cbiAgICBoICo9IDM2MDtcbiAgICB2YXIgUiwgRywgQiwgWCwgQztcbiAgICBoID0gKGggJSAzNjApIC8gNjA7XG4gICAgQyA9IDIgKiBzICogKGwgPCAuNSA/IGwgOiAxIC0gbCk7XG4gICAgWCA9IEMgKiAoMSAtIGFicyhoICUgMiAtIDEpKTtcbiAgICBSID0gRyA9IEIgPSBsIC0gQyAvIDI7XG5cbiAgICBoID0gfn5oO1xuICAgIFIgKz0gW0MsIFgsIDAsIDAsIFgsIENdW2hdO1xuICAgIEcgKz0gW1gsIEMsIEMsIFgsIDAsIDBdW2hdO1xuICAgIEIgKz0gWzAsIDAsIFgsIEMsIEMsIFhdW2hdO1xuICAgIHJldHVybiBwYWNrYWdlUkdCKFIsIEcsIEIsIG8pO1xufTtcbi8qXFxcbiAqIFNuYXAucmdiMmhzYlxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgUkdCIHZhbHVlcyB0byBhbiBIU0Igb2JqZWN0XG4gLSByIChudW1iZXIpIHJlZFxuIC0gZyAobnVtYmVyKSBncmVlblxuIC0gYiAobnVtYmVyKSBibHVlXG4gPSAob2JqZWN0KSBIU0Igb2JqZWN0IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuIG8ge1xuIG8gICAgIGggKG51bWJlcikgaHVlLFxuIG8gICAgIHMgKG51bWJlcikgc2F0dXJhdGlvbixcbiBvICAgICBiIChudW1iZXIpIGJyaWdodG5lc3NcbiBvIH1cblxcKi9cblNuYXAucmdiMmhzYiA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgYiA9IHByZXBhcmVSR0IociwgZywgYik7XG4gICAgciA9IGJbMF07XG4gICAgZyA9IGJbMV07XG4gICAgYiA9IGJbMl07XG5cbiAgICB2YXIgSCwgUywgViwgQztcbiAgICBWID0gbW1heChyLCBnLCBiKTtcbiAgICBDID0gViAtIG1taW4ociwgZywgYik7XG4gICAgSCA9IChDID09IDAgPyBudWxsIDpcbiAgICAgICAgIFYgPT0gciA/IChnIC0gYikgLyBDIDpcbiAgICAgICAgIFYgPT0gZyA/IChiIC0gcikgLyBDICsgMiA6XG4gICAgICAgICAgICAgICAgICAociAtIGcpIC8gQyArIDRcbiAgICAgICAgKTtcbiAgICBIID0gKChIICsgMzYwKSAlIDYpICogNjAgLyAzNjA7XG4gICAgUyA9IEMgPT0gMCA/IDAgOiBDIC8gVjtcbiAgICByZXR1cm4ge2g6IEgsIHM6IFMsIGI6IFYsIHRvU3RyaW5nOiBoc2J0b1N0cmluZ307XG59O1xuLypcXFxuICogU25hcC5yZ2IyaHNsXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBSR0IgdmFsdWVzIHRvIGFuIEhTTCBvYmplY3RcbiAtIHIgKG51bWJlcikgcmVkXG4gLSBnIChudW1iZXIpIGdyZWVuXG4gLSBiIChudW1iZXIpIGJsdWVcbiA9IChvYmplY3QpIEhTTCBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgaCAobnVtYmVyKSBodWUsXG4gbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uLFxuIG8gICAgIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuIG8gfVxuXFwqL1xuU25hcC5yZ2IyaHNsID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICBiID0gcHJlcGFyZVJHQihyLCBnLCBiKTtcbiAgICByID0gYlswXTtcbiAgICBnID0gYlsxXTtcbiAgICBiID0gYlsyXTtcblxuICAgIHZhciBILCBTLCBMLCBNLCBtLCBDO1xuICAgIE0gPSBtbWF4KHIsIGcsIGIpO1xuICAgIG0gPSBtbWluKHIsIGcsIGIpO1xuICAgIEMgPSBNIC0gbTtcbiAgICBIID0gKEMgPT0gMCA/IG51bGwgOlxuICAgICAgICAgTSA9PSByID8gKGcgLSBiKSAvIEMgOlxuICAgICAgICAgTSA9PSBnID8gKGIgLSByKSAvIEMgKyAyIDpcbiAgICAgICAgICAgICAgICAgIChyIC0gZykgLyBDICsgNCk7XG4gICAgSCA9ICgoSCArIDM2MCkgJSA2KSAqIDYwIC8gMzYwO1xuICAgIEwgPSAoTSArIG0pIC8gMjtcbiAgICBTID0gKEMgPT0gMCA/IDAgOlxuICAgICAgICAgTCA8IC41ID8gQyAvICgyICogTCkgOlxuICAgICAgICAgICAgICAgICAgQyAvICgyIC0gMiAqIEwpKTtcbiAgICByZXR1cm4ge2g6IEgsIHM6IFMsIGw6IEwsIHRvU3RyaW5nOiBoc2x0b1N0cmluZ307XG59O1xuXG4vLyBUcmFuc2Zvcm1hdGlvbnNcbi8qXFxcbiAqIFNuYXAucGFyc2VQYXRoU3RyaW5nXG4gWyBtZXRob2QgXVxuICoqXG4gKiBVdGlsaXR5IG1ldGhvZFxuICoqXG4gKiBQYXJzZXMgZ2l2ZW4gcGF0aCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBhcnJheXMgb2YgcGF0aCBzZWdtZW50c1xuIC0gcGF0aFN0cmluZyAoc3RyaW5nfGFycmF5KSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBzZWdtZW50cyAoaW4gdGhlIGxhc3QgY2FzZSBpdCBpcyByZXR1cm5lZCBzdHJhaWdodCBhd2F5KVxuID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50c1xuXFwqL1xuU25hcC5wYXJzZVBhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xuICAgIGlmICghcGF0aFN0cmluZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHB0aCA9IFNuYXAucGF0aChwYXRoU3RyaW5nKTtcbiAgICBpZiAocHRoLmFycikge1xuICAgICAgICByZXR1cm4gU25hcC5wYXRoLmNsb25lKHB0aC5hcnIpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcGFyYW1Db3VudHMgPSB7YTogNywgYzogNiwgbzogMiwgaDogMSwgbDogMiwgbTogMiwgcjogNCwgcTogNCwgczogNCwgdDogMiwgdjogMSwgdTogMywgejogMH0sXG4gICAgICAgIGRhdGEgPSBbXTtcbiAgICBpZiAoaXMocGF0aFN0cmluZywgXCJhcnJheVwiKSAmJiBpcyhwYXRoU3RyaW5nWzBdLCBcImFycmF5XCIpKSB7IC8vIHJvdWdoIGFzc3VtcHRpb25cbiAgICAgICAgZGF0YSA9IFNuYXAucGF0aC5jbG9uZShwYXRoU3RyaW5nKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgICBTdHIocGF0aFN0cmluZykucmVwbGFjZShwYXRoQ29tbWFuZCwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXSxcbiAgICAgICAgICAgICAgICBuYW1lID0gYi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgYy5yZXBsYWNlKHBhdGhWYWx1ZXMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgYiAmJiBwYXJhbXMucHVzaCgrYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwibVwiICYmIHBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCAyKSkpO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcImxcIjtcbiAgICAgICAgICAgICAgICBiID0gYiA9PSBcIm1cIiA/IFwibFwiIDogXCJMXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcIm9cIiAmJiBwYXJhbXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2IsIHBhcmFtc1swXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJyXCIpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB3aGlsZSAocGFyYW1zLmxlbmd0aCA+PSBwYXJhbUNvdW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgcGFyYW1Db3VudHNbbmFtZV0pKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbUNvdW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRhLnRvU3RyaW5nID0gU25hcC5wYXRoLnRvU3RyaW5nO1xuICAgIHB0aC5hcnIgPSBTbmFwLnBhdGguY2xvbmUoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuLypcXFxuICogU25hcC5wYXJzZVRyYW5zZm9ybVN0cmluZ1xuIFsgbWV0aG9kIF1cbiAqKlxuICogVXRpbGl0eSBtZXRob2RcbiAqKlxuICogUGFyc2VzIGdpdmVuIHRyYW5zZm9ybSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnNcbiAtIFRTdHJpbmcgKHN0cmluZ3xhcnJheSkgdHJhbnNmb3JtIHN0cmluZyBvciBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnMgKGluIHRoZSBsYXN0IGNhc2UgaXQgaXMgcmV0dXJuZWQgc3RyYWlnaHQgYXdheSlcbiA9IChhcnJheSkgYXJyYXkgb2YgdHJhbnNmb3JtYXRpb25zXG5cXCovXG52YXIgcGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBTbmFwLnBhcnNlVHJhbnNmb3JtU3RyaW5nID0gZnVuY3Rpb24gKFRTdHJpbmcpIHtcbiAgICBpZiAoIVRTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBwYXJhbUNvdW50cyA9IHtyOiAzLCBzOiA0LCB0OiAyLCBtOiA2fSxcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgIGlmIChpcyhUU3RyaW5nLCBcImFycmF5XCIpICYmIGlzKFRTdHJpbmdbMF0sIFwiYXJyYXlcIikpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICBkYXRhID0gU25hcC5wYXRoLmNsb25lKFRTdHJpbmcpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgIFN0cihUU3RyaW5nKS5yZXBsYWNlKHRDb21tYW5kLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBiLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjLnJlcGxhY2UocGF0aFZhbHVlcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBiICYmIHBhcmFtcy5wdXNoKCtiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRhLnRvU3RyaW5nID0gU25hcC5wYXRoLnRvU3RyaW5nO1xuICAgIHJldHVybiBkYXRhO1xufTtcbmZ1bmN0aW9uIHN2Z1RyYW5zZm9ybTJzdHJpbmcodHN0cikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB0c3RyID0gdHN0ci5yZXBsYWNlKC8oPzpefFxccykoXFx3KylcXCgoW14pXSspXFwpL2csIGZ1bmN0aW9uIChhbGwsIG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMuc3BsaXQoL1xccyosXFxzKnxcXHMrLyk7XG4gICAgICAgIGlmIChuYW1lID09IFwicm90YXRlXCIgJiYgcGFyYW1zLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaCgwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSBcInNjYWxlXCIpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcy5zbGljZSgwLCAyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW1zWzBdLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSBcInNrZXdYXCIpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtcIm1cIiwgMSwgMCwgbWF0aC50YW4ocmFkKHBhcmFtc1swXSkpLCAxLCAwLCAwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcInNrZXdZXCIpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtcIm1cIiwgMSwgbWF0aC50YW4ocmFkKHBhcmFtc1swXSkpLCAwLCAxLCAwLCAwXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMucHVzaChbbmFtZS5jaGFyQXQoMCldLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsO1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59XG5TbmFwLl8uc3ZnVHJhbnNmb3JtMnN0cmluZyA9IHN2Z1RyYW5zZm9ybTJzdHJpbmc7XG5TbmFwLl8ucmdUcmFuc2Zvcm0gPSAvXlthLXpdW1xcc10qLT9cXC4/XFxkL2k7XG5mdW5jdGlvbiB0cmFuc2Zvcm0ybWF0cml4KHRzdHIsIGJib3gpIHtcbiAgICB2YXIgdGRhdGEgPSBwYXJzZVRyYW5zZm9ybVN0cmluZyh0c3RyKSxcbiAgICAgICAgbSA9IG5ldyBTbmFwLk1hdHJpeDtcbiAgICBpZiAodGRhdGEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGRhdGEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIHQgPSB0ZGF0YVtpXSxcbiAgICAgICAgICAgICAgICB0bGVuID0gdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY29tbWFuZCA9IFN0cih0WzBdKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIGFic29sdXRlID0gdFswXSAhPSBjb21tYW5kLFxuICAgICAgICAgICAgICAgIGludmVyID0gYWJzb2x1dGUgPyBtLmludmVydCgpIDogMCxcbiAgICAgICAgICAgICAgICB4MSxcbiAgICAgICAgICAgICAgICB5MSxcbiAgICAgICAgICAgICAgICB4MixcbiAgICAgICAgICAgICAgICB5MixcbiAgICAgICAgICAgICAgICBiYjtcbiAgICAgICAgICAgIGlmIChjb21tYW5kID09IFwidFwiICYmIHRsZW4gPT0gMil7XG4gICAgICAgICAgICAgICAgbS50cmFuc2xhdGUodFsxXSwgMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJ0XCIgJiYgdGxlbiA9PSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gaW52ZXIueCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBpbnZlci55KDAsIDApO1xuICAgICAgICAgICAgICAgICAgICB4MiA9IGludmVyLngodFsxXSwgdFsyXSk7XG4gICAgICAgICAgICAgICAgICAgIHkyID0gaW52ZXIueSh0WzFdLCB0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgbS50cmFuc2xhdGUoeDIgLSB4MSwgeTIgLSB5MSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbS50cmFuc2xhdGUodFsxXSwgdFsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwiclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRsZW4gPT0gMikge1xuICAgICAgICAgICAgICAgICAgICBiYiA9IGJiIHx8IGJib3g7XG4gICAgICAgICAgICAgICAgICAgIG0ucm90YXRlKHRbMV0sIGJiLnggKyBiYi53aWR0aCAvIDIsIGJiLnkgKyBiYi5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRsZW4gPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzJdLCB0WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gaW52ZXIueSh0WzJdLCB0WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucm90YXRlKHRbMV0sIHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnJvdGF0ZSh0WzFdLCB0WzJdLCB0WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PSBcInNcIikge1xuICAgICAgICAgICAgICAgIGlmICh0bGVuID09IDIgfHwgdGxlbiA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJiID0gYmIgfHwgYmJveDtcbiAgICAgICAgICAgICAgICAgICAgbS5zY2FsZSh0WzFdLCB0W3RsZW4gLSAxXSwgYmIueCArIGJiLndpZHRoIC8gMiwgYmIueSArIGJiLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGxlbiA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBpbnZlci54KHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5zY2FsZSh0WzFdLCB0WzFdLCB4MiwgeTIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5zY2FsZSh0WzFdLCB0WzFdLCB0WzJdLCB0WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGxlbiA9PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBpbnZlci54KHRbM10sIHRbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbM10sIHRbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5zY2FsZSh0WzFdLCB0WzJdLCB4MiwgeTIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5zY2FsZSh0WzFdLCB0WzJdLCB0WzNdLCB0WzRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PSBcIm1cIiAmJiB0bGVuID09IDcpIHtcbiAgICAgICAgICAgICAgICBtLmFkZCh0WzFdLCB0WzJdLCB0WzNdLCB0WzRdLCB0WzVdLCB0WzZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbn1cblNuYXAuXy50cmFuc2Zvcm0ybWF0cml4ID0gdHJhbnNmb3JtMm1hdHJpeDtcblNuYXAuX3VuaXQycHggPSB1bml0MnB4O1xudmFyIGNvbnRhaW5zID0gZ2xvYi5kb2MuY29udGFpbnMgfHwgZ2xvYi5kb2MuY29tcGFyZURvY3VtZW50UG9zaXRpb24gP1xuICAgIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBhZG93biA9IGEubm9kZVR5cGUgPT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcbiAgICAgICAgICAgIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgcmV0dXJuIGEgPT0gYnVwIHx8ICEhKGJ1cCAmJiBidXAubm9kZVR5cGUgPT0gMSAmJiAoXG4gICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMgP1xuICAgICAgICAgICAgICAgICAgICBhZG93bi5jb250YWlucyhidXApIDpcbiAgICAgICAgICAgICAgICAgICAgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGJ1cCkgJiAxNlxuICAgICAgICAgICAgKSk7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgIHdoaWxlIChiKSB7XG4gICAgICAgICAgICAgICAgYiA9IGIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoYiA9PSBhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbmZ1bmN0aW9uIGdldFNvbWVEZWZzKGVsKSB7XG4gICAgdmFyIHAgPSAoZWwubm9kZS5vd25lclNWR0VsZW1lbnQgJiYgd3JhcChlbC5ub2RlLm93bmVyU1ZHRWxlbWVudCkpIHx8XG4gICAgICAgICAgICAoZWwubm9kZS5wYXJlbnROb2RlICYmIHdyYXAoZWwubm9kZS5wYXJlbnROb2RlKSkgfHxcbiAgICAgICAgICAgIFNuYXAuc2VsZWN0KFwic3ZnXCIpIHx8XG4gICAgICAgICAgICBTbmFwKDAsIDApLFxuICAgICAgICBwZGVmcyA9IHAuc2VsZWN0KFwiZGVmc1wiKSxcbiAgICAgICAgZGVmcyAgPSBwZGVmcyA9PSBudWxsID8gZmFsc2UgOiBwZGVmcy5ub2RlO1xuICAgIGlmICghZGVmcykge1xuICAgICAgICBkZWZzID0gbWFrZShcImRlZnNcIiwgcC5ub2RlKS5ub2RlO1xuICAgIH1cbiAgICByZXR1cm4gZGVmcztcbn1cbmZ1bmN0aW9uIGdldFNvbWVTVkcoZWwpIHtcbiAgICByZXR1cm4gZWwubm9kZS5vd25lclNWR0VsZW1lbnQgJiYgd3JhcChlbC5ub2RlLm93bmVyU1ZHRWxlbWVudCkgfHwgU25hcC5zZWxlY3QoXCJzdmdcIik7XG59XG5TbmFwLl8uZ2V0U29tZURlZnMgPSBnZXRTb21lRGVmcztcblNuYXAuXy5nZXRTb21lU1ZHID0gZ2V0U29tZVNWRztcbmZ1bmN0aW9uIHVuaXQycHgoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHN2ZyA9IGdldFNvbWVTVkcoZWwpLm5vZGUsXG4gICAgICAgIG91dCA9IHt9LFxuICAgICAgICBtZ3IgPSBzdmcucXVlcnlTZWxlY3RvcihcIi5zdmctLS1tZ3JcIik7XG4gICAgaWYgKCFtZ3IpIHtcbiAgICAgICAgbWdyID0gJChcInJlY3RcIik7XG4gICAgICAgICQobWdyLCB7eDogLTllOSwgeTogLTllOSwgd2lkdGg6IDEwLCBoZWlnaHQ6IDEwLCBcImNsYXNzXCI6IFwic3ZnLS0tbWdyXCIsIGZpbGw6IFwibm9uZVwifSk7XG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChtZ3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRXKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgPT0gK3ZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICAkKG1nciwge3dpZHRoOiB2YWx9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBtZ3IuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgPT0gK3ZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICAkKG1nciwge2hlaWdodDogdmFsfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbWdyLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldChuYW0sIGYpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0W25hbV0gPSBmKGVsLmF0dHIobmFtKSB8fCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChuYW0gPT0gbmFtZSkge1xuICAgICAgICAgICAgb3V0ID0gZih2YWx1ZSA9PSBudWxsID8gZWwuYXR0cihuYW0pIHx8IDAgOiB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChlbC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgICBzZXQoXCJyeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcInJ5XCIsIGdldEgpO1xuICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICAgIHNldChcIndpZHRoXCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwiaGVpZ2h0XCIsIGdldEgpO1xuICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgc2V0KFwieFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcInlcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2lyY2xlXCI6XG4gICAgICAgICAgICBzZXQoXCJjeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImN5XCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwiclwiLCBnZXRXKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICBzZXQoXCJjeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImN5XCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwicnhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJyeVwiLCBnZXRIKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgICAgICBzZXQoXCJ4MVwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcIngyXCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwieTFcIiwgZ2V0SCk7XG4gICAgICAgICAgICBzZXQoXCJ5MlwiLCBnZXRIKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXJrZXJcIjpcbiAgICAgICAgICAgIHNldChcInJlZlhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJtYXJrZXJXaWR0aFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcInJlZllcIiwgZ2V0SCk7XG4gICAgICAgICAgICBzZXQoXCJtYXJrZXJIZWlnaHRcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmFkaWFsR3JhZGllbnRcIjpcbiAgICAgICAgICAgIHNldChcImZ4XCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwiZnlcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidHNwYW5cIjpcbiAgICAgICAgICAgIHNldChcImR4XCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwiZHlcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2V0KG5hbWUsIGdldFcpO1xuICAgIH1cbiAgICBzdmcucmVtb3ZlQ2hpbGQobWdyKTtcbiAgICByZXR1cm4gb3V0O1xufVxuLypcXFxuICogU25hcC5zZWxlY3RcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFdyYXBzIGEgRE9NIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IENTUyBzZWxlY3RvciBhcyBARWxlbWVudFxuIC0gcXVlcnkgKHN0cmluZykgQ1NTIHNlbGVjdG9yIG9mIHRoZSBlbGVtZW50XG4gPSAoRWxlbWVudCkgdGhlIGN1cnJlbnQgZWxlbWVudFxuXFwqL1xuU25hcC5zZWxlY3QgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICBxdWVyeSA9IFN0cihxdWVyeSkucmVwbGFjZSgvKFteXFxcXF0pOi9nLCBcIiQxXFxcXDpcIik7XG4gICAgcmV0dXJuIHdyYXAoZ2xvYi5kb2MucXVlcnlTZWxlY3RvcihxdWVyeSkpO1xufTtcbi8qXFxcbiAqIFNuYXAuc2VsZWN0QWxsXG4gWyBtZXRob2QgXVxuICoqXG4gKiBXcmFwcyBET00gZWxlbWVudHMgc3BlY2lmaWVkIGJ5IENTUyBzZWxlY3RvciBhcyBzZXQgb3IgYXJyYXkgb2YgQEVsZW1lbnRcbiAtIHF1ZXJ5IChzdHJpbmcpIENTUyBzZWxlY3RvciBvZiB0aGUgZWxlbWVudFxuID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcblxcKi9cblNuYXAuc2VsZWN0QWxsID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgdmFyIG5vZGVsaXN0ID0gZ2xvYi5kb2MucXVlcnlTZWxlY3RvckFsbChxdWVyeSksXG4gICAgICAgIHNldCA9IChTbmFwLnNldCB8fCBBcnJheSkoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNldC5wdXNoKHdyYXAobm9kZWxpc3RbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbn07XG5cbmZ1bmN0aW9uIGFkZDJncm91cChsaXN0KSB7XG4gICAgaWYgKCFpcyhsaXN0LCBcImFycmF5XCIpKSB7XG4gICAgICAgIGxpc3QgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIH1cbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGogPSAwLFxuICAgICAgICBub2RlID0gdGhpcy5ub2RlO1xuICAgIHdoaWxlICh0aGlzW2ldKSBkZWxldGUgdGhpc1tpKytdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0W2ldLnR5cGUgPT0gXCJzZXRcIikge1xuICAgICAgICAgICAgbGlzdFtpXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZWwubm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobGlzdFtpXS5ub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXNbaisrXSA9IHdyYXAoY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbi8vIEh1YiBnYXJiYWdlIGNvbGxlY3RvciBldmVyeSAxMHNcbnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaHViKSBpZiAoaHViW2hhc10oa2V5KSkge1xuICAgICAgICB2YXIgZWwgPSBodWJba2V5XSxcbiAgICAgICAgICAgIG5vZGUgPSBlbC5ub2RlO1xuICAgICAgICBpZiAoZWwudHlwZSAhPSBcInN2Z1wiICYmICFub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBlbC50eXBlID09IFwic3ZnXCIgJiYgKCFub2RlLnBhcmVudE5vZGUgfHwgXCJvd25lclNWR0VsZW1lbnRcIiBpbiBub2RlLnBhcmVudE5vZGUgJiYgIW5vZGUub3duZXJTVkdFbGVtZW50KSkge1xuICAgICAgICAgICAgZGVsZXRlIGh1YltrZXldO1xuICAgICAgICB9XG4gICAgfVxufSwgMWU0KTtcbmZ1bmN0aW9uIEVsZW1lbnQoZWwpIHtcbiAgICBpZiAoZWwuc25hcCBpbiBodWIpIHtcbiAgICAgICAgcmV0dXJuIGh1YltlbC5zbmFwXTtcbiAgICB9XG4gICAgdmFyIHN2ZztcbiAgICB0cnkge1xuICAgICAgICBzdmcgPSBlbC5vd25lclNWR0VsZW1lbnQ7XG4gICAgfSBjYXRjaChlKSB7fVxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm5vZGVcbiAgICAgWyBwcm9wZXJ0eSAob2JqZWN0KSBdXG4gICAgICoqXG4gICAgICogR2l2ZXMgeW91IGEgcmVmZXJlbmNlIHRvIHRoZSBET00gb2JqZWN0LCBzbyB5b3UgY2FuIGFzc2lnbiBldmVudCBoYW5kbGVycyBvciBqdXN0IG1lc3MgYXJvdW5kLlxuICAgICA+IFVzYWdlXG4gICAgIHwgLy8gZHJhdyBhIGNpcmNsZSBhdCBjb29yZGluYXRlIDEwLDEwIHdpdGggcmFkaXVzIG9mIDEwXG4gICAgIHwgdmFyIGMgPSBwYXBlci5jaXJjbGUoMTAsIDEwLCAxMCk7XG4gICAgIHwgYy5ub2RlLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgIHwgICAgIGMuYXR0cihcImZpbGxcIiwgXCJyZWRcIik7XG4gICAgIHwgfTtcbiAgICBcXCovXG4gICAgdGhpcy5ub2RlID0gZWw7XG4gICAgaWYgKHN2Zykge1xuICAgICAgICB0aGlzLnBhcGVyID0gbmV3IFBhcGVyKHN2Zyk7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnR5cGVcbiAgICAgWyBwcm9wZXJ0eSAoc3RyaW5nKSBdXG4gICAgICoqXG4gICAgICogU1ZHIHRhZyBuYW1lIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgIFxcKi9cbiAgICB0aGlzLnR5cGUgPSBlbC50YWdOYW1lIHx8IGVsLm5vZGVOYW1lO1xuICAgIHZhciBpZCA9IHRoaXMuaWQgPSBJRCh0aGlzKTtcbiAgICB0aGlzLmFuaW1zID0ge307XG4gICAgdGhpcy5fID0ge1xuICAgICAgICB0cmFuc2Zvcm06IFtdXG4gICAgfTtcbiAgICBlbC5zbmFwID0gaWQ7XG4gICAgaHViW2lkXSA9IHRoaXM7XG4gICAgaWYgKHRoaXMudHlwZSA9PSBcImdcIikge1xuICAgICAgICB0aGlzLmFkZCA9IGFkZDJncm91cDtcbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSBpbiB7ZzogMSwgbWFzazogMSwgcGF0dGVybjogMSwgc3ltYm9sOiAxfSkge1xuICAgICAgICBmb3IgKHZhciBtZXRob2QgaW4gUGFwZXIucHJvdG90eXBlKSBpZiAoUGFwZXIucHJvdG90eXBlW2hhc10obWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpc1ttZXRob2RdID0gUGFwZXIucHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgIH1cbiAgICB9XG59XG4gICAvKlxcXG4gICAgICogRWxlbWVudC5hdHRyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHZXRzIG9yIHNldHMgZ2l2ZW4gYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudC5cbiAgICAgKipcbiAgICAgLSBwYXJhbXMgKG9iamVjdCkgY29udGFpbnMga2V5LXZhbHVlIHBhaXJzIG9mIGF0dHJpYnV0ZXMgeW91IHdhbnQgdG8gc2V0XG4gICAgICogb3JcbiAgICAgLSBwYXJhbSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgPSAoRWxlbWVudCkgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqIG9yXG4gICAgID0gKHN0cmluZykgdmFsdWUgb2YgYXR0cmlidXRlXG4gICAgID4gVXNhZ2VcbiAgICAgfCBlbC5hdHRyKHtcbiAgICAgfCAgICAgZmlsbDogXCIjZmMwXCIsXG4gICAgIHwgICAgIHN0cm9rZTogXCIjMDAwXCIsXG4gICAgIHwgICAgIHN0cm9rZVdpZHRoOiAyLCAvLyBDYW1lbENhc2UuLi5cbiAgICAgfCAgICAgXCJmaWxsLW9wYWNpdHlcIjogMC41LCAvLyBvciBkYXNoLXNlcGFyYXRlZCBuYW1lc1xuICAgICB8ICAgICB3aWR0aDogXCIqPTJcIiAvLyBwcmVmaXhlZCB2YWx1ZXNcbiAgICAgfCB9KTtcbiAgICAgfCBjb25zb2xlLmxvZyhlbC5hdHRyKFwiZmlsbFwiKSk7IC8vICNmYzBcbiAgICAgKiBQcmVmaXhlZCB2YWx1ZXMgaW4gZm9ybWF0IGBcIis9MTBcImAgc3VwcG9ydGVkLiBBbGwgZm91ciBvcGVyYXRpb25zXG4gICAgICogKGArYCwgYC1gLCBgKmAgYW5kIGAvYCkgY291bGQgYmUgdXNlZC4gT3B0aW9uYWxseSB5b3UgY2FuIHVzZSB1bml0cyBmb3IgYCtgXG4gICAgICogYW5kIGAtYDogYFwiKz0yZW1cImAuXG4gICAgXFwqL1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZSA9IGVsLm5vZGU7XG4gICAgICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbm9kZS5ub2RlVmFsdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgb3V0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhdHRyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbYXR0cltpXS5ub2RlTmFtZV0gPSBhdHRyW2ldLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHBhcmFtcywgXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBqc29uID0ge307XG4gICAgICAgICAgICAgICAganNvbltwYXJhbXNdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0ganNvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZShcInNuYXAudXRpbC5nZXRhdHRyLlwiICsgcGFyYW1zLCBlbCkuZmlyc3REZWZpbmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgYXR0IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1toYXNdKGF0dCkpIHtcbiAgICAgICAgICAgICAgICBldmUoXCJzbmFwLnV0aWwuYXR0ci5cIiArIGF0dCwgZWwsIHBhcmFtc1thdHRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbi8qXFxcbiAqIFNuYXAucGFyc2VcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFBhcnNlcyBTVkcgZnJhZ21lbnQgYW5kIGNvbnZlcnRzIGl0IGludG8gYSBARnJhZ21lbnRcbiAqKlxuIC0gc3ZnIChzdHJpbmcpIFNWRyBzdHJpbmdcbiA9IChGcmFnbWVudCkgdGhlIEBGcmFnbWVudFxuXFwqL1xuU25hcC5wYXJzZSA9IGZ1bmN0aW9uIChzdmcpIHtcbiAgICB2YXIgZiA9IGdsb2IuZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgZnVsbCA9IHRydWUsXG4gICAgICAgIGRpdiA9IGdsb2IuZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc3ZnID0gU3RyKHN2Zyk7XG4gICAgaWYgKCFzdmcubWF0Y2goL15cXHMqPFxccypzdmcoPzpcXHN8PikvKSkge1xuICAgICAgICBzdmcgPSBcIjxzdmc+XCIgKyBzdmcgKyBcIjwvc3ZnPlwiO1xuICAgICAgICBmdWxsID0gZmFsc2U7XG4gICAgfVxuICAgIGRpdi5pbm5lckhUTUwgPSBzdmc7XG4gICAgc3ZnID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdO1xuICAgIGlmIChzdmcpIHtcbiAgICAgICAgaWYgKGZ1bGwpIHtcbiAgICAgICAgICAgIGYgPSBzdmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBmLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGYpO1xufTtcbmZ1bmN0aW9uIEZyYWdtZW50KGZyYWcpIHtcbiAgICB0aGlzLm5vZGUgPSBmcmFnO1xufVxuLypcXFxuICogU25hcC5mcmFnbWVudFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ3JlYXRlcyBhIERPTSBmcmFnbWVudCBmcm9tIGEgZ2l2ZW4gbGlzdCBvZiBlbGVtZW50cyBvciBzdHJpbmdzXG4gKipcbiAtIHZhcmFyZ3MgKOKApikgU1ZHIHN0cmluZ1xuID0gKEZyYWdtZW50KSB0aGUgQEZyYWdtZW50XG5cXCovXG5TbmFwLmZyYWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgZiA9IGdsb2IuZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcmdzW2ldO1xuICAgICAgICBpZiAoaXRlbS5ub2RlICYmIGl0ZW0ubm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChpdGVtLm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBmLmFwcGVuZENoaWxkKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmLmFwcGVuZENoaWxkKFNuYXAucGFyc2UoaXRlbSkubm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChmKTtcbn07XG5cbmZ1bmN0aW9uIG1ha2UobmFtZSwgcGFyZW50KSB7XG4gICAgdmFyIHJlcyA9ICQobmFtZSk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHJlcyk7XG4gICAgdmFyIGVsID0gd3JhcChyZXMpO1xuICAgIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIFBhcGVyKHcsIGgpIHtcbiAgICB2YXIgcmVzLFxuICAgICAgICBkZXNjLFxuICAgICAgICBkZWZzLFxuICAgICAgICBwcm90byA9IFBhcGVyLnByb3RvdHlwZTtcbiAgICBpZiAodyAmJiB3LnRhZ05hbWUgPT0gXCJzdmdcIikge1xuICAgICAgICBpZiAody5zbmFwIGluIGh1Yikge1xuICAgICAgICAgICAgcmV0dXJuIGh1Ylt3LnNuYXBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb2MgPSB3Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHJlcyA9IG5ldyBFbGVtZW50KHcpO1xuICAgICAgICBkZXNjID0gdy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRlc2NcIilbMF07XG4gICAgICAgIGRlZnMgPSB3LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGVmc1wiKVswXTtcbiAgICAgICAgaWYgKCFkZXNjKSB7XG4gICAgICAgICAgICBkZXNjID0gJChcImRlc2NcIik7XG4gICAgICAgICAgICBkZXNjLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShcIkNyZWF0ZWQgd2l0aCBTbmFwXCIpKTtcbiAgICAgICAgICAgIHJlcy5ub2RlLmFwcGVuZENoaWxkKGRlc2MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmcykge1xuICAgICAgICAgICAgZGVmcyA9ICQoXCJkZWZzXCIpO1xuICAgICAgICAgICAgcmVzLm5vZGUuYXBwZW5kQ2hpbGQoZGVmcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLmRlZnMgPSBkZWZzO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvdG8pIGlmIChwcm90b1toYXNdKGtleSkpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gcHJvdG9ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXMucGFwZXIgPSByZXMucm9vdCA9IHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSBtYWtlKFwic3ZnXCIsIGdsb2IuZG9jLmJvZHkpO1xuICAgICAgICAkKHJlcy5ub2RlLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLjEsXG4gICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgIHhtbG5zOiB4bWxuc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHdyYXAoZG9tKSB7XG4gICAgaWYgKCFkb20pIHtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgaWYgKGRvbSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgZG9tIGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgaWYgKGRvbS50YWdOYW1lICYmIGRvbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJzdmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IFBhcGVyKGRvbSk7XG4gICAgfVxuICAgIGlmIChkb20udGFnTmFtZSAmJiBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwib2JqZWN0XCIgJiYgZG9tLnR5cGUgPT0gXCJpbWFnZS9zdmcreG1sXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXBlcihkb20uY29udGVudERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50KGRvbSk7XG59XG5cblNuYXAuXy5tYWtlID0gbWFrZTtcblNuYXAuXy53cmFwID0gd3JhcDtcbi8qXFxcbiAqIFBhcGVyLmVsXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDcmVhdGVzIGFuIGVsZW1lbnQgb24gcGFwZXIgd2l0aCBhIGdpdmVuIG5hbWUgYW5kIG5vIGF0dHJpYnV0ZXNcbiAqKlxuIC0gbmFtZSAoc3RyaW5nKSB0YWcgbmFtZVxuIC0gYXR0ciAob2JqZWN0KSBhdHRyaWJ1dGVzXG4gPSAoRWxlbWVudCkgdGhlIGN1cnJlbnQgZWxlbWVudFxuID4gVXNhZ2VcbiB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApOyAvLyBpcyB0aGUgc2FtZSBhcy4uLlxuIHwgdmFyIGMgPSBwYXBlci5lbChcImNpcmNsZVwiKS5hdHRyKHtcbiB8ICAgICBjeDogMTAsXG4gfCAgICAgY3k6IDEwLFxuIHwgICAgIHI6IDEwXG4gfCB9KTtcbiB8IC8vIGFuZCB0aGUgc2FtZSBhc1xuIHwgdmFyIGMgPSBwYXBlci5lbChcImNpcmNsZVwiLCB7XG4gfCAgICAgY3g6IDEwLFxuIHwgICAgIGN5OiAxMCxcbiB8ICAgICByOiAxMFxuIHwgfSk7XG5cXCovXG5QYXBlci5wcm90b3R5cGUuZWwgPSBmdW5jdGlvbiAobmFtZSwgYXR0cikge1xuICAgIHZhciBlbCA9IG1ha2UobmFtZSwgdGhpcy5ub2RlKTtcbiAgICBhdHRyICYmIGVsLmF0dHIoYXR0cik7XG4gICAgcmV0dXJuIGVsO1xufTtcbi8qXFxcbiAqIEVsZW1lbnQuY2hpbGRyZW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgYXJyYXkgb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudC5cbiA9IChhcnJheSkgYXJyYXkgb2YgRWxlbWVudHNcblxcKi9cbkVsZW1lbnQucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvdXQgPSBbXSxcbiAgICAgICAgY2ggPSB0aGlzLm5vZGUuY2hpbGROb2RlcztcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjaC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IFNuYXAoY2hbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbmZ1bmN0aW9uIGpzb25GaWxsZXIocm9vdCwgbykge1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHJvb3QubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiByb290W2ldLnR5cGUsXG4gICAgICAgICAgICAgICAgYXR0cjogcm9vdFtpXS5hdHRyKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHJvb3RbaV0uY2hpbGRyZW4oKTtcbiAgICAgICAgby5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBqc29uRmlsbGVyKGNoaWxkcmVuLCBpdGVtLmNoaWxkTm9kZXMgPSBbXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKlxcXG4gKiBFbGVtZW50LnRvSlNPTlxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGVsZW1lbnQgYW5kIGFsbCBpdHMgY2hpbGRyZW4uXG4gPSAob2JqZWN0KSBpbiBmb3JtYXRcbiBvIHtcbiBvICAgICB0eXBlIChzdHJpbmcpIHRoaXMudHlwZSxcbiBvICAgICBhdHRyIChvYmplY3QpIGF0dHJpYnV0ZXMgbWFwLFxuIG8gICAgIGNoaWxkTm9kZXMgKGFycmF5KSBvcHRpb25hbCBhcnJheSBvZiBjaGlsZHJlbiBpbiB0aGUgc2FtZSBmb3JtYXRcbiBvIH1cblxcKi9cbkVsZW1lbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAganNvbkZpbGxlcihbdGhpc10sIG91dCk7XG4gICAgcmV0dXJuIG91dFswXTtcbn07XG4vLyBkZWZhdWx0XG5ldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0clwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF0dCA9IGV2ZS5udCgpO1xuICAgIGF0dCA9IGF0dC5zdWJzdHJpbmcoYXR0Lmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgIHZhciBjc3MgPSBhdHQucmVwbGFjZSgvW0EtWl0vZywgZnVuY3Rpb24gKGxldHRlcikge1xuICAgICAgICByZXR1cm4gXCItXCIgKyBsZXR0ZXIudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgICBpZiAoY3NzQXR0cltoYXNdKGNzcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKGNzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICQodGhpcy5ub2RlLCBhdHQpO1xuICAgIH1cbn0pO1xudmFyIGNzc0F0dHIgPSB7XG4gICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIjogMCxcbiAgICBcImJhc2VsaW5lLXNoaWZ0XCI6IDAsXG4gICAgXCJjbGlwXCI6IDAsXG4gICAgXCJjbGlwLXBhdGhcIjogMCxcbiAgICBcImNsaXAtcnVsZVwiOiAwLFxuICAgIFwiY29sb3JcIjogMCxcbiAgICBcImNvbG9yLWludGVycG9sYXRpb25cIjogMCxcbiAgICBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiOiAwLFxuICAgIFwiY29sb3ItcHJvZmlsZVwiOiAwLFxuICAgIFwiY29sb3ItcmVuZGVyaW5nXCI6IDAsXG4gICAgXCJjdXJzb3JcIjogMCxcbiAgICBcImRpcmVjdGlvblwiOiAwLFxuICAgIFwiZGlzcGxheVwiOiAwLFxuICAgIFwiZG9taW5hbnQtYmFzZWxpbmVcIjogMCxcbiAgICBcImVuYWJsZS1iYWNrZ3JvdW5kXCI6IDAsXG4gICAgXCJmaWxsXCI6IDAsXG4gICAgXCJmaWxsLW9wYWNpdHlcIjogMCxcbiAgICBcImZpbGwtcnVsZVwiOiAwLFxuICAgIFwiZmlsdGVyXCI6IDAsXG4gICAgXCJmbG9vZC1jb2xvclwiOiAwLFxuICAgIFwiZmxvb2Qtb3BhY2l0eVwiOiAwLFxuICAgIFwiZm9udFwiOiAwLFxuICAgIFwiZm9udC1mYW1pbHlcIjogMCxcbiAgICBcImZvbnQtc2l6ZVwiOiAwLFxuICAgIFwiZm9udC1zaXplLWFkanVzdFwiOiAwLFxuICAgIFwiZm9udC1zdHJldGNoXCI6IDAsXG4gICAgXCJmb250LXN0eWxlXCI6IDAsXG4gICAgXCJmb250LXZhcmlhbnRcIjogMCxcbiAgICBcImZvbnQtd2VpZ2h0XCI6IDAsXG4gICAgXCJnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsXCI6IDAsXG4gICAgXCJnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiOiAwLFxuICAgIFwiaW1hZ2UtcmVuZGVyaW5nXCI6IDAsXG4gICAgXCJrZXJuaW5nXCI6IDAsXG4gICAgXCJsZXR0ZXItc3BhY2luZ1wiOiAwLFxuICAgIFwibGlnaHRpbmctY29sb3JcIjogMCxcbiAgICBcIm1hcmtlclwiOiAwLFxuICAgIFwibWFya2VyLWVuZFwiOiAwLFxuICAgIFwibWFya2VyLW1pZFwiOiAwLFxuICAgIFwibWFya2VyLXN0YXJ0XCI6IDAsXG4gICAgXCJtYXNrXCI6IDAsXG4gICAgXCJvcGFjaXR5XCI6IDAsXG4gICAgXCJvdmVyZmxvd1wiOiAwLFxuICAgIFwicG9pbnRlci1ldmVudHNcIjogMCxcbiAgICBcInNoYXBlLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwic3RvcC1jb2xvclwiOiAwLFxuICAgIFwic3RvcC1vcGFjaXR5XCI6IDAsXG4gICAgXCJzdHJva2VcIjogMCxcbiAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogMCxcbiAgICBcInN0cm9rZS1kYXNob2Zmc2V0XCI6IDAsXG4gICAgXCJzdHJva2UtbGluZWNhcFwiOiAwLFxuICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IDAsXG4gICAgXCJzdHJva2UtbWl0ZXJsaW1pdFwiOiAwLFxuICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogMCxcbiAgICBcInN0cm9rZS13aWR0aFwiOiAwLFxuICAgIFwidGV4dC1hbmNob3JcIjogMCxcbiAgICBcInRleHQtZGVjb3JhdGlvblwiOiAwLFxuICAgIFwidGV4dC1yZW5kZXJpbmdcIjogMCxcbiAgICBcInVuaWNvZGUtYmlkaVwiOiAwLFxuICAgIFwidmlzaWJpbGl0eVwiOiAwLFxuICAgIFwid29yZC1zcGFjaW5nXCI6IDAsXG4gICAgXCJ3cml0aW5nLW1vZGVcIjogMFxufTtcblxuZXZlLm9uKFwic25hcC51dGlsLmF0dHJcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGF0dCA9IGV2ZS5udCgpLFxuICAgICAgICBhdHRyID0ge307XG4gICAgYXR0ID0gYXR0LnN1YnN0cmluZyhhdHQubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgYXR0clthdHRdID0gdmFsdWU7XG4gICAgdmFyIHN0eWxlID0gYXR0LnJlcGxhY2UoLy0oXFx3KS9naSwgZnVuY3Rpb24gKGFsbCwgbGV0dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pLFxuICAgICAgICBjc3MgPSBhdHQucmVwbGFjZSgvW0EtWl0vZywgZnVuY3Rpb24gKGxldHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFwiLVwiICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgIGlmIChjc3NBdHRyW2hhc10oY3NzKSkge1xuICAgICAgICB0aGlzLm5vZGUuc3R5bGVbc3R5bGVdID0gdmFsdWUgPT0gbnVsbCA/IEUgOiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAkKHRoaXMubm9kZSwgYXR0cik7XG4gICAgfVxufSk7XG4oZnVuY3Rpb24gKHByb3RvKSB7fShQYXBlci5wcm90b3R5cGUpKTtcblxuLy8gc2ltcGxlIGFqYXhcbi8qXFxcbiAqIFNuYXAuYWpheFxuIFsgbWV0aG9kIF1cbiAqKlxuICogU2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIEFqYXhcbiAqKlxuIC0gdXJsIChzdHJpbmcpIFVSTFxuIC0gcG9zdERhdGEgKG9iamVjdHxzdHJpbmcpIGRhdGEgZm9yIHBvc3QgcmVxdWVzdFxuIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSBjYWxsYmFja1xuIC0gc2NvcGUgKG9iamVjdCkgI29wdGlvbmFsIHNjb3BlIG9mIGNhbGxiYWNrXG4gKiBvclxuIC0gdXJsIChzdHJpbmcpIFVSTFxuIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSBjYWxsYmFja1xuIC0gc2NvcGUgKG9iamVjdCkgI29wdGlvbmFsIHNjb3BlIG9mIGNhbGxiYWNrXG4gPSAoWE1MSHR0cFJlcXVlc3QpIHRoZSBYTUxIdHRwUmVxdWVzdCBvYmplY3QsIGp1c3QgaW4gY2FzZVxuXFwqL1xuU25hcC5hamF4ID0gZnVuY3Rpb24gKHVybCwgcG9zdERhdGEsIGNhbGxiYWNrLCBzY29wZSl7XG4gICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCxcbiAgICAgICAgaWQgPSBJRCgpO1xuICAgIGlmIChyZXEpIHtcbiAgICAgICAgaWYgKGlzKHBvc3REYXRhLCBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzY29wZSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBwb3N0RGF0YTtcbiAgICAgICAgICAgIHBvc3REYXRhID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChpcyhwb3N0RGF0YSwgXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIHZhciBwZCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBvc3REYXRhKSBpZiAocG9zdERhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHBkLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwb3N0RGF0YVtrZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3N0RGF0YSA9IHBkLmpvaW4oXCImXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlcS5vcGVuKChwb3N0RGF0YSA/IFwiUE9TVFwiIDogXCJHRVRcIiksIHVybCwgdHJ1ZSk7XG4gICAgICAgIGlmIChwb3N0RGF0YSkge1xuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIik7XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGV2ZS5vbmNlKFwic25hcC5hamF4LlwiICsgaWQgKyBcIi4wXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGV2ZS5vbmNlKFwic25hcC5hamF4LlwiICsgaWQgKyBcIi4yMDBcIiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFqYXguXCIgKyBpZCArIFwiLjMwNFwiLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlICE9IDQpIHJldHVybjtcbiAgICAgICAgICAgIGV2ZShcInNuYXAuYWpheC5cIiArIGlkICsgXCIuXCIgKyByZXEuc3RhdHVzLCBzY29wZSwgcmVxKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXE7XG4gICAgICAgIH1cbiAgICAgICAgcmVxLnNlbmQocG9zdERhdGEpO1xuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH1cbn07XG4vKlxcXG4gKiBTbmFwLmxvYWRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIExvYWRzIGV4dGVybmFsIFNWRyBmaWxlIGFzIGEgQEZyYWdtZW50IChzZWUgQFNuYXAuYWpheCBmb3IgbW9yZSBhZHZhbmNlZCBBSkFYKVxuICoqXG4gLSB1cmwgKHN0cmluZykgVVJMXG4gLSBjYWxsYmFjayAoZnVuY3Rpb24pIGNhbGxiYWNrXG4gLSBzY29wZSAob2JqZWN0KSAjb3B0aW9uYWwgc2NvcGUgb2YgY2FsbGJhY2tcblxcKi9cblNuYXAubG9hZCA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgIFNuYXAuYWpheCh1cmwsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgdmFyIGYgPSBTbmFwLnBhcnNlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICBzY29wZSA/IGNhbGxiYWNrLmNhbGwoc2NvcGUsIGYpIDogY2FsbGJhY2soZik7XG4gICAgfSk7XG59O1xudmFyIGdldE9mZnNldCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcbiAgICAgICAgYm9keSA9IGRvYy5ib2R5LFxuICAgICAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgY2xpZW50VG9wID0gZG9jRWxlbS5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCwgY2xpZW50TGVmdCA9IGRvY0VsZW0uY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCxcbiAgICAgICAgdG9wICA9IGJveC50b3AgICsgKGcud2luLnBhZ2VZT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wICkgLSBjbGllbnRUb3AsXG4gICAgICAgIGxlZnQgPSBib3gubGVmdCArIChnLndpbi5wYWdlWE9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0KSAtIGNsaWVudExlZnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeTogdG9wLFxuICAgICAgICB4OiBsZWZ0XG4gICAgfTtcbn07XG4vKlxcXG4gKiBTbmFwLmdldEVsZW1lbnRCeVBvaW50XG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIHlvdSB0b3Btb3N0IGVsZW1lbnQgdW5kZXIgZ2l2ZW4gcG9pbnQuXG4gKipcbiA9IChvYmplY3QpIFNuYXAgZWxlbWVudCBvYmplY3RcbiAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgd2luZG93XG4gLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHdpbmRvd1xuID4gVXNhZ2VcbiB8IFNuYXAuZ2V0RWxlbWVudEJ5UG9pbnQobW91c2VYLCBtb3VzZVkpLmF0dHIoe3N0cm9rZTogXCIjZjAwXCJ9KTtcblxcKi9cblNuYXAuZ2V0RWxlbWVudEJ5UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBwYXBlciA9IHRoaXMsXG4gICAgICAgIHN2ZyA9IHBhcGVyLmNhbnZhcyxcbiAgICAgICAgdGFyZ2V0ID0gZ2xvYi5kb2MuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAoZ2xvYi53aW4ub3BlcmEgJiYgdGFyZ2V0LnRhZ05hbWUgPT0gXCJzdmdcIikge1xuICAgICAgICB2YXIgc28gPSBnZXRPZmZzZXQodGFyZ2V0KSxcbiAgICAgICAgICAgIHNyID0gdGFyZ2V0LmNyZWF0ZVNWR1JlY3QoKTtcbiAgICAgICAgc3IueCA9IHggLSBzby54O1xuICAgICAgICBzci55ID0geSAtIHNvLnk7XG4gICAgICAgIHNyLndpZHRoID0gc3IuaGVpZ2h0ID0gMTtcbiAgICAgICAgdmFyIGhpdHMgPSB0YXJnZXQuZ2V0SW50ZXJzZWN0aW9uTGlzdChzciwgbnVsbCk7XG4gICAgICAgIGlmIChoaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gaGl0c1toaXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcCh0YXJnZXQpO1xufTtcbi8qXFxcbiAqIFNuYXAucGx1Z2luXG4gWyBtZXRob2QgXVxuICoqXG4gKiBMZXQgeW91IHdyaXRlIHBsdWdpbnMuIFlvdSBwYXNzIGluIGEgZnVuY3Rpb24gd2l0aCBmaXZlIGFyZ3VtZW50cywgbGlrZSB0aGlzOlxuIHwgU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iYWwsIEZyYWdtZW50KSB7XG4gfCAgICAgU25hcC5uZXdtZXRob2QgPSBmdW5jdGlvbiAoKSB7fTtcbiB8ICAgICBFbGVtZW50LnByb3RvdHlwZS5uZXdtZXRob2QgPSBmdW5jdGlvbiAoKSB7fTtcbiB8ICAgICBQYXBlci5wcm90b3R5cGUubmV3bWV0aG9kID0gZnVuY3Rpb24gKCkge307XG4gfCB9KTtcbiAqIEluc2lkZSB0aGUgZnVuY3Rpb24geW91IGhhdmUgYWNjZXNzIHRvIGFsbCBtYWluIG9iamVjdHMgKGFuZCB0aGVpclxuICogcHJvdG90eXBlcykuIFRoaXMgYWxsb3cgeW91IHRvIGV4dGVuZCBhbnl0aGluZyB5b3Ugd2FudC5cbiAqKlxuIC0gZiAoZnVuY3Rpb24pIHlvdXIgcGx1Z2luIGJvZHlcblxcKi9cblNuYXAucGx1Z2luID0gZnVuY3Rpb24gKGYpIHtcbiAgICBmKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCk7XG59O1xuZ2xvYi53aW4uU25hcCA9IFNuYXA7XG5yZXR1cm4gU25hcDtcbn0od2luZG93IHx8IHRoaXMpKTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCkge1xuICAgIHZhciBlbHByb3RvID0gRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgIGlzID0gU25hcC5pcyxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICB1bml0MnB4ID0gU25hcC5fdW5pdDJweCxcbiAgICAgICAgJCA9IFNuYXAuXy4kLFxuICAgICAgICBtYWtlID0gU25hcC5fLm1ha2UsXG4gICAgICAgIGdldFNvbWVEZWZzID0gU25hcC5fLmdldFNvbWVEZWZzLFxuICAgICAgICBoYXMgPSBcImhhc093blByb3BlcnR5XCIsXG4gICAgICAgIHdyYXAgPSBTbmFwLl8ud3JhcDtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXRCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggZGVzY3JpcHRvciBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBib3VuZGluZyBib3ggZGVzY3JpcHRvcjpcbiAgICAgbyB7XG4gICAgIG8gICAgIGN4OiAobnVtYmVyKSB4IG9mIHRoZSBjZW50ZXIsXG4gICAgIG8gICAgIGN5OiAobnVtYmVyKSB4IG9mIHRoZSBjZW50ZXIsXG4gICAgIG8gICAgIGg6IChudW1iZXIpIGhlaWdodCxcbiAgICAgbyAgICAgaGVpZ2h0OiAobnVtYmVyKSBoZWlnaHQsXG4gICAgIG8gICAgIHBhdGg6IChzdHJpbmcpIHBhdGggY29tbWFuZCBmb3IgdGhlIGJveCxcbiAgICAgbyAgICAgcjA6IChudW1iZXIpIHJhZGl1cyBvZiBhIGNpcmNsZSB0aGF0IGZ1bGx5IGVuY2xvc2VzIHRoZSBib3gsXG4gICAgIG8gICAgIHIxOiAobnVtYmVyKSByYWRpdXMgb2YgdGhlIHNtYWxsZXN0IGNpcmNsZSB0aGF0IGNhbiBiZSBlbmNsb3NlZCxcbiAgICAgbyAgICAgcjI6IChudW1iZXIpIHJhZGl1cyBvZiB0aGUgbGFyZ2VzdCBjaXJjbGUgdGhhdCBjYW4gYmUgZW5jbG9zZWQsXG4gICAgIG8gICAgIHZiOiAoc3RyaW5nKSBib3ggYXMgYSB2aWV3Ym94IGNvbW1hbmQsXG4gICAgIG8gICAgIHc6IChudW1iZXIpIHdpZHRoLFxuICAgICBvICAgICB3aWR0aDogKG51bWJlcikgd2lkdGgsXG4gICAgIG8gICAgIHgyOiAobnVtYmVyKSB4IG9mIHRoZSByaWdodCBzaWRlLFxuICAgICBvICAgICB4OiAobnVtYmVyKSB4IG9mIHRoZSBsZWZ0IHNpZGUsXG4gICAgIG8gICAgIHkyOiAobnVtYmVyKSB5IG9mIHRoZSBib3R0b20gZWRnZSxcbiAgICAgbyAgICAgeTogKG51bWJlcikgeSBvZiB0aGUgdG9wIGVkZ2VcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0QkJveCA9IGZ1bmN0aW9uIChpc1dpdGhvdXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKCFTbmFwLk1hdHJpeCB8fCAhU25hcC5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWwgPSB0aGlzLFxuICAgICAgICAgICAgbSA9IG5ldyBTbmFwLk1hdHJpeDtcbiAgICAgICAgaWYgKGVsLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVsLnR5cGUgPT0gXCJ1c2VcIikge1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhvdXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBtID0gbS5hZGQoZWwudHJhbnNmb3JtKCkubG9jYWxNYXRyaXgudHJhbnNsYXRlKGVsLmF0dHIoXCJ4XCIpIHx8IDAsIGVsLmF0dHIoXCJ5XCIpIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5vcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIGVsID0gZWwub3JpZ2luYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBocmVmID0gZWwuYXR0cihcInhsaW5rOmhyZWZcIik7XG4gICAgICAgICAgICAgICAgZWwgPSBlbC5vcmlnaW5hbCA9IGVsLm5vZGUub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChocmVmLnN1YnN0cmluZyhocmVmLmluZGV4T2YoXCIjXCIpICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfID0gZWwuXyxcbiAgICAgICAgICAgIHBhdGhmaW5kZXIgPSBTbmFwLnBhdGguZ2V0W2VsLnR5cGVdIHx8IFNuYXAucGF0aC5nZXQuZGVmbHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNXaXRob3V0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgXy5iYm94d3QgPSBwYXRoZmluZGVyID8gU25hcC5wYXRoLmdldEJCb3goZWwucmVhbFBhdGggPSBwYXRoZmluZGVyKGVsKSkgOiBTbmFwLl8uYm94KGVsLm5vZGUuZ2V0QkJveCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveChfLmJib3h3dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnJlYWxQYXRoID0gcGF0aGZpbmRlcihlbCk7XG4gICAgICAgICAgICAgICAgZWwubWF0cml4ID0gZWwudHJhbnNmb3JtKCkubG9jYWxNYXRyaXg7XG4gICAgICAgICAgICAgICAgXy5iYm94ID0gU25hcC5wYXRoLmdldEJCb3goU25hcC5wYXRoLm1hcChlbC5yZWFsUGF0aCwgbS5hZGQoZWwubWF0cml4KSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KF8uYmJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG9lc27igJl0IGdpdmUgeW91IGJib3ggb2YgaGlkZGVuIGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcm9wU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBleHRyYWN0VHJhbnNmb3JtKGVsLCB0c3RyKSB7XG4gICAgICAgIGlmICh0c3RyID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkb1JldHVybiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcImxpbmVhckdyYWRpZW50XCIgfHwgZWwudHlwZSA9PSBcInJhZGlhbEdyYWRpZW50XCIpIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gZWwubm9kZS5nZXRBdHRyaWJ1dGUoXCJncmFkaWVudFRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PSBcInBhdHRlcm5cIikge1xuICAgICAgICAgICAgICAgIHRzdHIgPSBlbC5ub2RlLmdldEF0dHJpYnV0ZShcInBhdHRlcm5UcmFuc2Zvcm1cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRzdHIgPSBlbC5ub2RlLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU25hcC5NYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0c3RyID0gU25hcC5fLnN2Z1RyYW5zZm9ybTJzdHJpbmcodHN0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIVNuYXAuXy5yZ1RyYW5zZm9ybS50ZXN0KHRzdHIpKSB7XG4gICAgICAgICAgICAgICAgdHN0ciA9IFNuYXAuXy5zdmdUcmFuc2Zvcm0yc3RyaW5nKHRzdHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gU3RyKHRzdHIpLnJlcGxhY2UoL1xcLnszfXxcXHUyMDI2L2csIGVsLl8udHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzKHRzdHIsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gU25hcC5wYXRoID8gU25hcC5wYXRoLnRvU3RyaW5nLmNhbGwodHN0cikgOiBTdHIodHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fLnRyYW5zZm9ybSA9IHRzdHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG0gPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeCh0c3RyLCBlbC5nZXRCQm94KDEpKTtcbiAgICAgICAgaWYgKGRvUmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLm1hdHJpeCA9IG07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudHJhbnNmb3JtXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICAgKipcbiAgICAgLSB0c3RyIChzdHJpbmcpIHRyYW5zZm9ybSBzdHJpbmcgaW4gU25hcCBvciBTVkcgZm9ybWF0XG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKiBvclxuICAgICA9IChvYmplY3QpIHRyYW5zZm9ybWF0aW9uIGRlc2NyaXB0b3I6XG4gICAgIG8ge1xuICAgICBvICAgICBzdHJpbmcgKHN0cmluZykgdHJhbnNmb3JtIHN0cmluZyxcbiAgICAgbyAgICAgZ2xvYmFsTWF0cml4IChNYXRyaXgpIG1hdHJpeCBvZiBhbGwgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgdG8gZWxlbWVudCBvciBpdHMgcGFyZW50cyxcbiAgICAgbyAgICAgbG9jYWxNYXRyaXggKE1hdHJpeCkgbWF0cml4IG9mIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIG9ubHkgdG8gdGhlIGVsZW1lbnQsXG4gICAgIG8gICAgIGRpZmZNYXRyaXggKE1hdHJpeCkgbWF0cml4IG9mIGRpZmZlcmVuY2UgYmV0d2VlbiBnbG9iYWwgYW5kIGxvY2FsIHRyYW5zZm9ybWF0aW9ucyxcbiAgICAgbyAgICAgZ2xvYmFsIChzdHJpbmcpIGdsb2JhbCB0cmFuc2Zvcm1hdGlvbiBhcyBzdHJpbmcsXG4gICAgIG8gICAgIGxvY2FsIChzdHJpbmcpIGxvY2FsIHRyYW5zZm9ybWF0aW9uIGFzIHN0cmluZyxcbiAgICAgbyAgICAgdG9TdHJpbmcgKGZ1bmN0aW9uKSByZXR1cm5zIGBzdHJpbmdgIHByb3BlcnR5XG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0c3RyKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBpZiAodHN0ciA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcGFwYSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZ2xvYmFsID0gbmV3IFNuYXAuTWF0cml4KHRoaXMubm9kZS5nZXRDVE0oKSksXG4gICAgICAgICAgICAgICAgbG9jYWwgPSBleHRyYWN0VHJhbnNmb3JtKHRoaXMpLFxuICAgICAgICAgICAgICAgIG1zID0gW2xvY2FsXSxcbiAgICAgICAgICAgICAgICBtID0gbmV3IFNuYXAuTWF0cml4LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbG9jYWxTdHJpbmcgPSBsb2NhbC50b1RyYW5zZm9ybVN0cmluZygpLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9IFN0cihsb2NhbCkgPT0gU3RyKHRoaXMubWF0cml4KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyKF8udHJhbnNmb3JtKSA6IGxvY2FsU3RyaW5nO1xuICAgICAgICAgICAgd2hpbGUgKHBhcGEudHlwZSAhPSBcInN2Z1wiICYmIChwYXBhID0gcGFwYS5wYXJlbnQoKSkpIHtcbiAgICAgICAgICAgICAgICBtcy5wdXNoKGV4dHJhY3RUcmFuc2Zvcm0ocGFwYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IG1zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZChtc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICAgICAgICAgIGdsb2JhbE1hdHJpeDogZ2xvYmFsLFxuICAgICAgICAgICAgICAgIHRvdGFsTWF0cml4OiBtLFxuICAgICAgICAgICAgICAgIGxvY2FsTWF0cml4OiBsb2NhbCxcbiAgICAgICAgICAgICAgICBkaWZmTWF0cml4OiBnbG9iYWwuY2xvbmUoKS5hZGQobG9jYWwuaW52ZXJ0KCkpLFxuICAgICAgICAgICAgICAgIGdsb2JhbDogZ2xvYmFsLnRvVHJhbnNmb3JtU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdG90YWw6IG0udG9UcmFuc2Zvcm1TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBsb2NhbDogbG9jYWxTdHJpbmcsXG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IHByb3BTdHJpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRzdHIgaW5zdGFuY2VvZiBTbmFwLk1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSB0c3RyO1xuICAgICAgICAgICAgdGhpcy5fLnRyYW5zZm9ybSA9IHRzdHIudG9UcmFuc2Zvcm1TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhY3RUcmFuc2Zvcm0odGhpcywgdHN0cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIiB8fCB0aGlzLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtncmFkaWVudFRyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09IFwicGF0dGVyblwiKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtwYXR0ZXJuVHJhbnNmb3JtOiB0aGlzLm1hdHJpeH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMubm9kZSwge3RyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucGFyZW50XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50J3MgcGFyZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGhpcy5ub2RlLnBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYXBwZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBlbGVtZW50IHRvIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnR8U2V0KSBlbGVtZW50IHRvIGFwcGVuZFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWRkXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuYXBwZW5kXG4gICAgXFwqL1xuICAgIGVscHJvdG8uYXBwZW5kID0gZWxwcm90by5hZGQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBlbC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5hZGQoZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChlbC5ub2RlKTtcbiAgICAgICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFwcGVuZFRvXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBcHBlbmRzIHRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBwYXJlbnQgZWxlbWVudCB0byBhcHBlbmQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIGNoaWxkIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5hcHBlbmRUbyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgICAgICBlbC5hcHBlbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5wcmVwZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gZWxlbWVudCB0byB0aGUgY3VycmVudCBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgZWxlbWVudCB0byBwcmVwZW5kXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnByZXBlbmQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3Q7XG4gICAgICAgICAgICAgICAgZWwuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdC5hZnRlcihlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5wcmVwZW5kKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGVsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoZWwubm9kZSwgdGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5hZGQgJiYgdGhpcy5hZGQoKTtcbiAgICAgICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgICAgIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5wcmVwZW5kVG9cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFByZXBlbmRzIHRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBwYXJlbnQgZWxlbWVudCB0byBwcmVwZW5kIHRvXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjaGlsZCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucHJlcGVuZFRvID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIGVsLnByZXBlbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYmVmb3JlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIGdpdmVuIGVsZW1lbnQgYmVmb3JlIHRoZSBjdXJyZW50IG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IHRvIGluc2VydFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5iZWZvcmUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsLnR5cGUgPT0gXCJzZXRcIikge1xuICAgICAgICAgICAgdmFyIGl0ID0gdGhpcztcbiAgICAgICAgICAgIGVsLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGl0Lm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwubm9kZSwgaXQubm9kZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLm5vZGUsIHRoaXMubm9kZSk7XG4gICAgICAgIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgZWwucGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFmdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnQpIGVsZW1lbnQgdG8gaW5zZXJ0XG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmFmdGVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLm5vZGUsIHRoaXMubm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbC5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuYWRkKCk7XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5pbnNlcnRCZWZvcmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IG5leHQgdG8gd2hvbSBpbnNlcnQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICBlbC5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubm9kZSwgZWwubm9kZSk7XG4gICAgICAgIHRoaXMucGFwZXIgPSBlbC5wYXBlcjtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgZWwucGFyZW50KCkgJiYgZWwucGFyZW50KCkuYWRkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5zZXJ0QWZ0ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IG5leHQgdG8gd2hvbSBpbnNlcnQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50KCk7XG4gICAgICAgIGVsLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLCBlbC5ub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgdGhpcy5wYXBlciA9IGVsLnBhcGVyO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFkZCgpO1xuICAgICAgICBlbC5wYXJlbnQoKSAmJiBlbC5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudCBmcm9tIHRoZSBET01cbiAgICAgPSAoRWxlbWVudCkgdGhlIGRldGFjaGVkIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZSAmJiB0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICBkZWxldGUgdGhpcy5wYXBlcjtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5zZWxlY3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEdhdGhlcnMgdGhlIG5lc3RlZCBARWxlbWVudCBtYXRjaGluZyB0aGUgZ2l2ZW4gc2V0IG9mIENTUyBzZWxlY3RvcnNcbiAgICAgKipcbiAgICAgLSBxdWVyeSAoc3RyaW5nKSBDU1Mgc2VsZWN0b3JcbiAgICAgPSAoRWxlbWVudCkgcmVzdWx0IG9mIHF1ZXJ5IHNlbGVjdGlvblxuICAgIFxcKi9cbiAgICBlbHByb3RvLnNlbGVjdCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0aGlzLm5vZGUucXVlcnlTZWxlY3RvcihxdWVyeSkpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc2VsZWN0QWxsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHYXRoZXJzIG5lc3RlZCBARWxlbWVudCBvYmplY3RzIG1hdGNoaW5nIHRoZSBnaXZlbiBzZXQgb2YgQ1NTIHNlbGVjdG9yc1xuICAgICAqKlxuICAgICAtIHF1ZXJ5IChzdHJpbmcpIENTUyBzZWxlY3RvclxuICAgICA9IChTZXR8YXJyYXkpIHJlc3VsdCBvZiBxdWVyeSBzZWxlY3Rpb25cbiAgICBcXCovXG4gICAgZWxwcm90by5zZWxlY3RBbGwgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIG5vZGVsaXN0ID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICAgICAgc2V0ID0gKFNuYXAuc2V0IHx8IEFycmF5KSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZXQucHVzaCh3cmFwKG5vZGVsaXN0W2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFzUFhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBlbGVtZW50IGFzIGEgYHB4YCB2YWx1ZSAobm90ICUsIGVtLCBldGMuKVxuICAgICAqKlxuICAgICAtIGF0dHIgKHN0cmluZykgYXR0cmlidXRlIG5hbWVcbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSAjb3B0aW9uYWwgYXR0cmlidXRlIHZhbHVlXG4gICAgID0gKEVsZW1lbnQpIHJlc3VsdCBvZiBxdWVyeSBzZWxlY3Rpb25cbiAgICBcXCovXG4gICAgZWxwcm90by5hc1BYID0gZnVuY3Rpb24gKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuYXR0cihhdHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gK3VuaXQycHgodGhpcywgYXR0ciwgdmFsdWUpO1xuICAgIH07XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQudXNlKCk6IEkgc3VnZ2VzdCBhZGRpbmcgYSBub3RlIGFib3V0IGhvdyB0byBhY2Nlc3MgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhlIHJldHVybmVkIDx1c2U+IGluc3RhbnRpYXRlcy4gSXQncyBhIHBhcnQgb2YgU1ZHIHdpdGggd2hpY2ggb3JkaW5hcnkgd2ViIGRldmVsb3BlcnMgbWF5IGJlIGxlYXN0IGZhbWlsaWFyLlxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGA8dXNlPmAgZWxlbWVudCBsaW5rZWQgdG8gdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgYDx1c2U+YCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXNlLFxuICAgICAgICAgICAgaWQgPSB0aGlzLm5vZGUuaWQ7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5pZDtcbiAgICAgICAgICAgICQodGhpcy5ub2RlLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIiB8fCB0aGlzLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiIHx8XG4gICAgICAgICAgICB0aGlzLnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICAgIHVzZSA9IG1ha2UodGhpcy50eXBlLCB0aGlzLm5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1c2UgPSBtYWtlKFwidXNlXCIsIHRoaXMubm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAkKHVzZS5ub2RlLCB7XG4gICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogXCIjXCIgKyBpZFxuICAgICAgICB9KTtcbiAgICAgICAgdXNlLm9yaWdpbmFsID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHVzZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZpeGlkcyhlbCkge1xuICAgICAgICB2YXIgZWxzID0gZWwuc2VsZWN0QWxsKFwiKlwiKSxcbiAgICAgICAgICAgIGl0LFxuICAgICAgICAgICAgdXJsID0gL15cXHMqdXJsXFwoKFwifCd8KSguKilcXDFcXClcXHMqJC8sXG4gICAgICAgICAgICBpZHMgPSBbXSxcbiAgICAgICAgICAgIHVzZXMgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gdXJsdGVzdChpdCwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9ICQoaXQubm9kZSwgbmFtZSk7XG4gICAgICAgICAgICB2YWwgPSB2YWwgJiYgdmFsLm1hdGNoKHVybCk7XG4gICAgICAgICAgICB2YWwgPSB2YWwgJiYgdmFsWzJdO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwuY2hhckF0KCkgPT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdXNlc1t2YWxdID0gKHVzZXNbdmFsXSB8fCBbXSkuY29uY2F0KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBhdHRyW25hbWVdID0gVVJMKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgJChpdC5ub2RlLCBhdHRyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaW5rdGVzdChpdCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9ICQoaXQubm9kZSwgXCJ4bGluazpocmVmXCIpO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwuY2hhckF0KCkgPT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdXNlc1t2YWxdID0gKHVzZXNbdmFsXSB8fCBbXSkuY29uY2F0KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5hdHRyKFwieGxpbms6aHJlZlwiLCBcIiNcIiArIGlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaXQgPSBlbHNbaV07XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcImZpbGxcIik7XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcInN0cm9rZVwiKTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwiZmlsdGVyXCIpO1xuICAgICAgICAgICAgdXJsdGVzdChpdCwgXCJtYXNrXCIpO1xuICAgICAgICAgICAgdXJsdGVzdChpdCwgXCJjbGlwLXBhdGhcIik7XG4gICAgICAgICAgICBsaW5rdGVzdChpdCk7XG4gICAgICAgICAgICB2YXIgb2xkaWQgPSAkKGl0Lm5vZGUsIFwiaWRcIik7XG4gICAgICAgICAgICBpZiAob2xkaWQpIHtcbiAgICAgICAgICAgICAgICAkKGl0Lm5vZGUsIHtpZDogaXQuaWR9KTtcbiAgICAgICAgICAgICAgICBpZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9sZDogb2xkaWQsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdC5pZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gaWRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmcyA9IHVzZXNbaWRzW2ldLm9sZF07XG4gICAgICAgICAgICBpZiAoZnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBmcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZzW2pdKGlkc1tpXS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmNsb25lXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGVsZW1lbnQgYW5kIGluc2VydHMgaXQgYWZ0ZXIgdGhlIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPSAoRWxlbWVudCkgdGhlIGNsb25lXG4gICAgXFwqL1xuICAgIGVscHJvdG8uY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXAodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgIGlmICgkKGNsb25lLm5vZGUsIFwiaWRcIikpIHtcbiAgICAgICAgICAgICQoY2xvbmUubm9kZSwge2lkOiBjbG9uZS5pZH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpeGlkcyhjbG9uZSk7XG4gICAgICAgIGNsb25lLmluc2VydEFmdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b0RlZnNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIE1vdmVzIGVsZW1lbnQgdG8gdGhlIHNoYXJlZCBgPGRlZnM+YCBhcmVhXG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udG9EZWZzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVmcyA9IGdldFNvbWVEZWZzKHRoaXMpO1xuICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9QYXR0ZXJuXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgYDxwYXR0ZXJuPmAgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKipcbiAgICAgKiBUbyBjcmVhdGUgYSBwYXR0ZXJuIHlvdSBoYXZlIHRvIHNwZWNpZnkgdGhlIHBhdHRlcm4gcmVjdDpcbiAgICAgLSB4IChzdHJpbmd8bnVtYmVyKVxuICAgICAtIHkgKHN0cmluZ3xudW1iZXIpXG4gICAgIC0gd2lkdGggKHN0cmluZ3xudW1iZXIpXG4gICAgIC0gaGVpZ2h0IChzdHJpbmd8bnVtYmVyKVxuICAgICA9IChFbGVtZW50KSB0aGUgYDxwYXR0ZXJuPmAgZWxlbWVudFxuICAgICAqIFlvdSBjYW4gdXNlIHBhdHRlcm4gbGF0ZXIgb24gYXMgYW4gYXJndW1lbnQgZm9yIGBmaWxsYCBhdHRyaWJ1dGU6XG4gICAgIHwgdmFyIHAgPSBwYXBlci5wYXRoKFwiTTEwLTUtMTAsMTVNMTUsMCwwLDE1TTAtNS0yMCwxNVwiKS5hdHRyKHtcbiAgICAgfCAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICB8ICAgICAgICAgc3Ryb2tlOiBcIiNiYWRhNTVcIixcbiAgICAgfCAgICAgICAgIHN0cm9rZVdpZHRoOiA1XG4gICAgIHwgICAgIH0pLnBhdHRlcm4oMCwgMCwgMTAsIDEwKSxcbiAgICAgfCAgICAgYyA9IHBhcGVyLmNpcmNsZSgyMDAsIDIwMCwgMTAwKTtcbiAgICAgfCBjLmF0dHIoe1xuICAgICB8ICAgICBmaWxsOiBwXG4gICAgIHwgfSk7XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucGF0dGVybiA9IGVscHJvdG8udG9QYXR0ZXJuID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHAgPSBtYWtlKFwicGF0dGVyblwiLCBnZXRTb21lRGVmcyh0aGlzKSk7XG4gICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmdldEJCb3goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoeCwgXCJvYmplY3RcIikgJiYgXCJ4XCIgaW4geCkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHdpZHRoID0geC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuICAgICAgICAkKHAubm9kZSwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHBhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLFxuICAgICAgICAgICAgaWQ6IHAuaWQsXG4gICAgICAgICAgICB2aWV3Qm94OiBbeCwgeSwgd2lkdGgsIGhlaWdodF0uam9pbihcIiBcIilcbiAgICAgICAgfSk7XG4gICAgICAgIHAubm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuLy8gU0lFUlJBIEVsZW1lbnQubWFya2VyKCk6IGNsYXJpZnkgd2hhdCBhIHJlZmVyZW5jZSBwb2ludCBpcy4gRS5nLiwgaGVscHMgeW91IG9mZnNldCB0aGUgb2JqZWN0IGZyb20gaXRzIGVkZ2Ugc3VjaCBhcyB3aGVuIGNlbnRlcmluZyBpdCBvdmVyIGEgcGF0aC5cbi8vIFNJRVJSQSBFbGVtZW50Lm1hcmtlcigpOiBJIHN1Z2dlc3QgdGhlIG1ldGhvZCBzaG91bGQgYWNjZXB0IGRlZmF1bHQgcmVmZXJlbmNlIHBvaW50IHZhbHVlcy4gIFBlcmhhcHMgY2VudGVyZWQgd2l0aCAocmVmWCA9IHdpZHRoLzIpIGFuZCAocmVmWSA9IGhlaWdodC8yKT8gQWxzbywgY291bGRuJ3QgaXQgYXNzdW1lIHRoZSBlbGVtZW50J3MgY3VycmVudCBfd2lkdGhfIGFuZCBfaGVpZ2h0Xz8gQW5kIHBsZWFzZSBzcGVjaWZ5IHdoYXQgX3hfIGFuZCBfeV8gbWVhbjogb2Zmc2V0cz8gSWYgc28sIGZyb20gd2hlcmU/ICBDb3VsZG4ndCB0aGV5IGFsc28gYmUgYXNzaWduZWQgZGVmYXVsdCB2YWx1ZXM/XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubWFya2VyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgYDxtYXJrZXI+YCBlbGVtZW50IGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqKlxuICAgICAqIFRvIGNyZWF0ZSBhIG1hcmtlciB5b3UgaGF2ZSB0byBzcGVjaWZ5IHRoZSBib3VuZGluZyByZWN0IGFuZCByZWZlcmVuY2UgcG9pbnQ6XG4gICAgIC0geCAobnVtYmVyKVxuICAgICAtIHkgKG51bWJlcilcbiAgICAgLSB3aWR0aCAobnVtYmVyKVxuICAgICAtIGhlaWdodCAobnVtYmVyKVxuICAgICAtIHJlZlggKG51bWJlcilcbiAgICAgLSByZWZZIChudW1iZXIpXG4gICAgID0gKEVsZW1lbnQpIHRoZSBgPG1hcmtlcj5gIGVsZW1lbnRcbiAgICAgKiBZb3UgY2FuIHNwZWNpZnkgdGhlIG1hcmtlciBsYXRlciBhcyBhbiBhcmd1bWVudCBmb3IgYG1hcmtlci1zdGFydGAsIGBtYXJrZXItZW5kYCwgYG1hcmtlci1taWRgLCBhbmQgYG1hcmtlcmAgYXR0cmlidXRlcy4gVGhlIGBtYXJrZXJgIGF0dHJpYnV0ZSBwbGFjZXMgdGhlIG1hcmtlciBhdCBldmVyeSBwb2ludCBhbG9uZyB0aGUgcGF0aCwgYW5kIGBtYXJrZXItbWlkYCBwbGFjZXMgdGhlbSBhdCBldmVyeSBwb2ludCBleGNlcHQgdGhlIHN0YXJ0IGFuZCBlbmQuXG4gICAgXFwqL1xuICAgIC8vIFRPRE8gYWRkIHVzYWdlIGZvciBtYXJrZXJzXG4gICAgZWxwcm90by5tYXJrZXIgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmVmWCwgcmVmWSkge1xuICAgICAgICB2YXIgcCA9IG1ha2UoXCJtYXJrZXJcIiwgZ2V0U29tZURlZnModGhpcykpO1xuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpICYmIFwieFwiIGluIHgpIHtcbiAgICAgICAgICAgIHkgPSB4Lnk7XG4gICAgICAgICAgICB3aWR0aCA9IHgud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB4LmhlaWdodDtcbiAgICAgICAgICAgIHJlZlggPSB4LnJlZlggfHwgeC5jeDtcbiAgICAgICAgICAgIHJlZlkgPSB4LnJlZlkgfHwgeC5jeTtcbiAgICAgICAgICAgIHggPSB4Lng7XG4gICAgICAgIH1cbiAgICAgICAgJChwLm5vZGUsIHtcbiAgICAgICAgICAgIHZpZXdCb3g6IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XS5qb2luKFwiIFwiKSxcbiAgICAgICAgICAgIG1hcmtlcldpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIG1hcmtlckhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgb3JpZW50OiBcImF1dG9cIixcbiAgICAgICAgICAgIHJlZlg6IHJlZlggfHwgMCxcbiAgICAgICAgICAgIHJlZlk6IHJlZlkgfHwgMCxcbiAgICAgICAgICAgIGlkOiBwLmlkXG4gICAgICAgIH0pO1xuICAgICAgICBwLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcbiAgICAvLyBhbmltYXRpb25cbiAgICBmdW5jdGlvbiBzbGljZShmcm9tLCB0bywgZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFycikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGFyci5zbGljZShmcm9tLCB0byk7XG4gICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGYgPyBmKHJlcykgOiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAoYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMuZHVyID0gbXM7XG4gICAgICAgIGVhc2luZyAmJiAodGhpcy5lYXNpbmcgPSBlYXNpbmcpO1xuICAgICAgICBjYWxsYmFjayAmJiAodGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFNuYXAuXy5BbmltYXRpb24gPSBBbmltYXRpb247XG4gICAgLypcXFxuICAgICAqIFNuYXAuYW5pbWF0aW9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGFuIGFuaW1hdGlvbiBvYmplY3RcbiAgICAgKipcbiAgICAgLSBhdHRyIChvYmplY3QpIGF0dHJpYnV0ZXMgb2YgZmluYWwgZGVzdGluYXRpb25cbiAgICAgLSBkdXJhdGlvbiAobnVtYmVyKSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgb25lIG9mIGVhc2luZyBmdW5jdGlvbnMgb2YgQG1pbmEgb3IgY3VzdG9tIG9uZVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZmlyZXMgd2hlbiBhbmltYXRpb24gZW5kc1xuICAgICA9IChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3RcbiAgICBcXCovXG4gICAgU25hcC5hbmltYXRpb24gPSBmdW5jdGlvbiAoYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5BbmltXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGEgc2V0IG9mIGFuaW1hdGlvbnMgdGhhdCBtYXkgYmUgYWJsZSB0byBtYW5pcHVsYXRlIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICBhbmltIChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3QsXG4gICAgIG8gICAgIG1pbmEgKG9iamVjdCkgQG1pbmEgb2JqZWN0LFxuICAgICBvICAgICBjdXJTdGF0dXMgKG51bWJlcikgMC4uMSDigJQgc3RhdHVzIG9mIHRoZSBhbmltYXRpb246IDAg4oCUIGp1c3Qgc3RhcnRlZCwgMSDigJQganVzdCBmaW5pc2hlZCxcbiAgICAgbyAgICAgc3RhdHVzIChmdW5jdGlvbikgZ2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RvcCAoZnVuY3Rpb24pIHN0b3BzIHRoZSBhbmltYXRpb25cbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5BbmltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLFxuICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGlkIGluIGVsLmFuaW1zKSBpZiAoZWwuYW5pbXNbaGFzXShpZCkpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbTogbmV3IEFuaW1hdGlvbihhLl9hdHRycywgYS5kdXIsIGEuZWFzaW5nLCBhLl9jYWxsYmFjayksXG4gICAgICAgICAgICAgICAgICAgIG1pbmE6IGEsXG4gICAgICAgICAgICAgICAgICAgIGN1clN0YXR1czogYS5zdGF0dXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGF0dXModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0oZWwuYW5pbXNbaWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmFuaW1hdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJ1bnMgZ2VuZXJpYyBhbmltYXRpb24gb2Ygb25lIG51bWJlciBpbnRvIGFub3RoZXIgd2l0aCBhIGNhcmluZyBmdW5jdGlvblxuICAgICAqKlxuICAgICAtIGZyb20gKG51bWJlcnxhcnJheSkgbnVtYmVyIG9yIGFycmF5IG9mIG51bWJlcnNcbiAgICAgLSB0byAobnVtYmVyfGFycmF5KSBudW1iZXIgb3IgYXJyYXkgb2YgbnVtYmVyc1xuICAgICAtIHNldHRlciAoZnVuY3Rpb24pIGNhcmluZyBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG51bWJlciBhcmd1bWVudFxuICAgICAtIGR1cmF0aW9uIChudW1iZXIpIGR1cmF0aW9uLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIGZyb20gQG1pbmEgb3IgY3VzdG9tXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGFuaW1hdGlvbiBlbmRzXG4gICAgID0gKG9iamVjdCkgYW5pbWF0aW9uIG9iamVjdCBpbiBAbWluYSBmb3JtYXRcbiAgICAgbyB7XG4gICAgIG8gICAgIGlkIChzdHJpbmcpIGFuaW1hdGlvbiBpZCwgY29uc2lkZXIgaXQgcmVhZC1vbmx5LFxuICAgICBvICAgICBkdXJhdGlvbiAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgZWFzaW5nIChmdW5jdGlvbikgZWFzaW5nLFxuICAgICBvICAgICBzcGVlZCAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgc3BlZWQgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RhdHVzIChmdW5jdGlvbikgZ2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RvcCAoZnVuY3Rpb24pIHN0b3BzIHRoZSBhbmltYXRpb25cbiAgICAgbyB9XG4gICAgIHwgdmFyIHJlY3QgPSBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApO1xuICAgICB8IFNuYXAuYW5pbWF0ZSgwLCAxMCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICB8ICAgICByZWN0LmF0dHIoe1xuICAgICB8ICAgICAgICAgeDogdmFsXG4gICAgIHwgICAgIH0pO1xuICAgICB8IH0sIDEwMDApO1xuICAgICB8IC8vIGluIGdpdmVuIGNvbnRleHQgaXMgZXF1aXZhbGVudCB0b1xuICAgICB8IHJlY3QuYW5pbWF0ZSh7eDogMTB9LCAxMDAwKTtcbiAgICBcXCovXG4gICAgU25hcC5hbmltYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCBzZXR0ZXIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWFzaW5nID09IFwiZnVuY3Rpb25cIiAmJiAhZWFzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICBlYXNpbmcgPSBtaW5hLmxpbmVhcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gbWluYS50aW1lKCksXG4gICAgICAgICAgICBhbmltID0gbWluYShmcm9tLCB0bywgbm93LCBub3cgKyBtcywgbWluYS50aW1lLCBzZXR0ZXIsIGVhc2luZyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGV2ZS5vbmNlKFwibWluYS5maW5pc2guXCIgKyBhbmltLmlkLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBhbmltO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU3RvcHMgYWxsIHRoZSBhbmltYXRpb25zIGZvciB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5pbXMgPSB0aGlzLmluQW5pbSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhbmltcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBhbmltc1tpXS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hbmltYXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBbmltYXRlcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICAtIGF0dHJzIChvYmplY3QpIGtleS12YWx1ZSBwYWlycyBvZiBkZXN0aW5hdGlvbiBhdHRyaWJ1dGVzXG4gICAgIC0gZHVyYXRpb24gKG51bWJlcikgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIGZyb20gQG1pbmEgb3IgY3VzdG9tXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB3aGVuIHRoZSBhbmltYXRpb24gZW5kc1xuICAgICA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChhdHRycywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIEFuaW1hdGlvbikge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhdHRycy5jYWxsYmFjaztcbiAgICAgICAgICAgIGVhc2luZyA9IGF0dHJzLmVhc2luZztcbiAgICAgICAgICAgIG1zID0gYXR0cnMuZHVyO1xuICAgICAgICAgICAgYXR0cnMgPSBhdHRycy5hdHRyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBma2V5cyA9IFtdLCB0a2V5cyA9IFtdLCBrZXlzID0ge30sIGZyb20sIHRvLCBmLCBlcSxcbiAgICAgICAgICAgIGVsID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSBpZiAoYXR0cnNbaGFzXShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoZWwuZXF1YWwpIHtcbiAgICAgICAgICAgICAgICBlcSA9IGVsLmVxdWFsKGtleSwgU3RyKGF0dHJzW2tleV0pKTtcbiAgICAgICAgICAgICAgICBmcm9tID0gZXEuZnJvbTtcbiAgICAgICAgICAgICAgICB0byA9IGVxLnRvO1xuICAgICAgICAgICAgICAgIGYgPSBlcS5mO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gK2VsLmF0dHIoa2V5KTtcbiAgICAgICAgICAgICAgICB0byA9ICthdHRyc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IGlzKGZyb20sIFwiYXJyYXlcIikgPyBmcm9tLmxlbmd0aCA6IDE7XG4gICAgICAgICAgICBrZXlzW2tleV0gPSBzbGljZShma2V5cy5sZW5ndGgsIGZrZXlzLmxlbmd0aCArIGxlbiwgZik7XG4gICAgICAgICAgICBma2V5cyA9IGZrZXlzLmNvbmNhdChmcm9tKTtcbiAgICAgICAgICAgIHRrZXlzID0gdGtleXMuY29uY2F0KHRvKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gbWluYS50aW1lKCksXG4gICAgICAgICAgICBhbmltID0gbWluYShma2V5cywgdGtleXMsIG5vdywgbm93ICsgbXMsIG1pbmEudGltZSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGtleXMpIGlmIChrZXlzW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyW2tleV0gPSBrZXlzW2tleV0odmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuYXR0cihhdHRyKTtcbiAgICAgICAgICAgIH0sIGVhc2luZyk7XG4gICAgICAgIGVsLmFuaW1zW2FuaW0uaWRdID0gYW5pbTtcbiAgICAgICAgYW5pbS5fYXR0cnMgPSBhdHRycztcbiAgICAgICAgYW5pbS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgZXZlKFwic25hcC5hbmltY3JlYXRlZC5cIiArIGVsLmlkLCBhbmltKTtcbiAgICAgICAgZXZlLm9uY2UoXCJtaW5hLmZpbmlzaC5cIiArIGFuaW0uaWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbC5hbmltc1thbmltLmlkXTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlLm9uY2UoXCJtaW5hLnN0b3AuXCIgKyBhbmltLmlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWxldGUgZWwuYW5pbXNbYW5pbS5pZF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICB2YXIgZWxkYXRhID0ge307XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZGF0YVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBvciByZXRyaWV2ZXMgZ2l2ZW4gdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGdpdmVuIGtleS4gKERvbuKAmXQgY29uZnVzZVxuICAgICAqIHdpdGggYGRhdGEtYCBhdHRyaWJ1dGVzKVxuICAgICAqXG4gICAgICogU2VlIGFsc28gQEVsZW1lbnQucmVtb3ZlRGF0YVxuICAgICAtIGtleSAoc3RyaW5nKSBrZXkgdG8gc3RvcmUgZGF0YVxuICAgICAtIHZhbHVlIChhbnkpICNvcHRpb25hbCB2YWx1ZSB0byBzdG9yZVxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgICogb3IsIGlmIHZhbHVlIGlzIG5vdCBzcGVjaWZpZWQ6XG4gICAgID0gKGFueSkgdmFsdWVcbiAgICAgPiBVc2FnZVxuICAgICB8IGZvciAodmFyIGkgPSAwLCBpIDwgNSwgaSsrKSB7XG4gICAgIHwgICAgIHBhcGVyLmNpcmNsZSgxMCArIDE1ICogaSwgMTAsIDEwKVxuICAgICB8ICAgICAgICAgIC5hdHRyKHtmaWxsOiBcIiMwMDBcIn0pXG4gICAgIHwgICAgICAgICAgLmRhdGEoXCJpXCIsIGkpXG4gICAgIHwgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgfCAgICAgICAgICAgICBhbGVydCh0aGlzLmRhdGEoXCJpXCIpKTtcbiAgICAgfCAgICAgICAgICB9KTtcbiAgICAgfCB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZGF0YSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZWxkYXRhW3RoaXMuaWRdID0gZWxkYXRhW3RoaXMuaWRdIHx8IHt9O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKXtcbiAgICAgICAgICAgIGV2ZShcInNuYXAuZGF0YS5nZXQuXCIgKyB0aGlzLmlkLCB0aGlzLCBkYXRhLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGlmIChTbmFwLmlzKGtleSwgXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGtleSkgaWYgKGtleVtoYXNdKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YShpLCBrZXlbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZShcInNuYXAuZGF0YS5nZXQuXCIgKyB0aGlzLmlkLCB0aGlzLCBkYXRhW2tleV0sIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICBldmUoXCJzbmFwLmRhdGEuc2V0LlwiICsgdGhpcy5pZCwgdGhpcywgdmFsdWUsIGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucmVtb3ZlRGF0YVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYW4gZWxlbWVudCBieSBnaXZlbiBrZXkuXG4gICAgICogSWYga2V5IGlzIG5vdCBwcm92aWRlZCwgcmVtb3ZlcyBhbGwgdGhlIGRhdGEgb2YgdGhlIGVsZW1lbnQuXG4gICAgIC0ga2V5IChzdHJpbmcpICNvcHRpb25hbCBrZXlcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnJlbW92ZURhdGEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxkYXRhW3RoaXMuaWRdID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGRhdGFbdGhpcy5pZF0gJiYgZGVsZXRlIGVsZGF0YVt0aGlzLmlkXVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQub3V0ZXJTVkdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgU1ZHIGNvZGUgZm9yIHRoZSBlbGVtZW50LCBlcXVpdmFsZW50IHRvIEhUTUwncyBgb3V0ZXJIVE1MYC5cbiAgICAgKlxuICAgICAqIFNlZSBhbHNvIEBFbGVtZW50LmlubmVyU1ZHXG4gICAgID0gKHN0cmluZykgU1ZHIGNvZGUgZm9yIHRoZSBlbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvU3RyaW5nXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQub3V0ZXJTVkdcbiAgICBcXCovXG4gICAgZWxwcm90by5vdXRlclNWRyA9IGVscHJvdG8udG9TdHJpbmcgPSB0b1N0cmluZygxKTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5pbm5lclNWR1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBTVkcgY29kZSBmb3IgdGhlIGVsZW1lbnQncyBjb250ZW50cywgZXF1aXZhbGVudCB0byBIVE1MJ3MgYGlubmVySFRNTGBcbiAgICAgPSAoc3RyaW5nKSBTVkcgY29kZSBmb3IgdGhlIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5pbm5lclNWRyA9IHRvU3RyaW5nKCk7XG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHR5cGUgPyBcIjxcIiArIHRoaXMudHlwZSA6IFwiXCIsXG4gICAgICAgICAgICAgICAgYXR0ciA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGNobGQgPSB0aGlzLm5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXR0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIiBcIiArIGF0dHJbaV0ubmFtZSArICc9XCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyW2ldLnZhbHVlLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNobGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHlwZSAmJiAocmVzICs9IFwiPlwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGNobGQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hsZFtpXS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gY2hsZFtpXS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hsZFtpXS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gd3JhcChjaGxkW2ldKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR5cGUgJiYgKHJlcyArPSBcIjwvXCIgKyB0aGlzLnR5cGUgKyBcIj5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgJiYgKHJlcyArPSBcIi8+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxwcm90by50b0RhdGFVUkwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh3aW5kb3cgJiYgd2luZG93LmJ0b2EpIHtcbiAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuZ2V0QkJveCgpLFxuICAgICAgICAgICAgICAgIHN2ZyA9IFNuYXAuZm9ybWF0KCc8c3ZnIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgd2lkdGg9XCJ7d2lkdGh9XCIgaGVpZ2h0PVwie2hlaWdodH1cIiB2aWV3Qm94PVwie3h9IHt5fSB7d2lkdGh9IHtoZWlnaHR9XCI+e2NvbnRlbnRzfTwvc3ZnPicsIHtcbiAgICAgICAgICAgICAgICB4OiArYmIueC50b0ZpeGVkKDMpLFxuICAgICAgICAgICAgICAgIHk6ICtiYi55LnRvRml4ZWQoMyksXG4gICAgICAgICAgICAgICAgd2lkdGg6ICtiYi53aWR0aC50b0ZpeGVkKDMpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogK2JiLmhlaWdodC50b0ZpeGVkKDMpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRzOiB0aGlzLm91dGVyU1ZHKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN2ZykpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLypcXFxuICAgICAqIEZyYWdtZW50LnNlbGVjdFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBFbGVtZW50LnNlbGVjdFxuICAgIFxcKi9cbiAgICBGcmFnbWVudC5wcm90b3R5cGUuc2VsZWN0ID0gZWxwcm90by5zZWxlY3Q7XG4gICAgLypcXFxuICAgICAqIEZyYWdtZW50LnNlbGVjdEFsbFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBFbGVtZW50LnNlbGVjdEFsbFxuICAgIFxcKi9cbiAgICBGcmFnbWVudC5wcm90b3R5cGUuc2VsZWN0QWxsID0gZWxwcm90by5zZWxlY3RBbGw7XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLyBcbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCkge1xuICAgIHZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgbWF0aCA9IE1hdGgsXG4gICAgICAgIEUgPSBcIlwiO1xuICAgIGZ1bmN0aW9uIE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgIGlmIChiID09IG51bGwgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbChhKSA9PSBcIltvYmplY3QgU1ZHTWF0cml4XVwiKSB7XG4gICAgICAgICAgICB0aGlzLmEgPSBhLmE7XG4gICAgICAgICAgICB0aGlzLmIgPSBhLmI7XG4gICAgICAgICAgICB0aGlzLmMgPSBhLmM7XG4gICAgICAgICAgICB0aGlzLmQgPSBhLmQ7XG4gICAgICAgICAgICB0aGlzLmUgPSBhLmU7XG4gICAgICAgICAgICB0aGlzLmYgPSBhLmY7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hID0gK2E7XG4gICAgICAgICAgICB0aGlzLmIgPSArYjtcbiAgICAgICAgICAgIHRoaXMuYyA9ICtjO1xuICAgICAgICAgICAgdGhpcy5kID0gK2Q7XG4gICAgICAgICAgICB0aGlzLmUgPSArZTtcbiAgICAgICAgICAgIHRoaXMuZiA9ICtmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hID0gMTtcbiAgICAgICAgICAgIHRoaXMuYiA9IDA7XG4gICAgICAgICAgICB0aGlzLmMgPSAwO1xuICAgICAgICAgICAgdGhpcy5kID0gMTtcbiAgICAgICAgICAgIHRoaXMuZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIChmdW5jdGlvbiAobWF0cml4cHJvdG8pIHtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguYWRkXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBBZGRzIHRoZSBnaXZlbiBtYXRyaXggdG8gZXhpc3Rpbmcgb25lXG4gICAgICAgICAtIGEgKG51bWJlcilcbiAgICAgICAgIC0gYiAobnVtYmVyKVxuICAgICAgICAgLSBjIChudW1iZXIpXG4gICAgICAgICAtIGQgKG51bWJlcilcbiAgICAgICAgIC0gZSAobnVtYmVyKVxuICAgICAgICAgLSBmIChudW1iZXIpXG4gICAgICAgICAqIG9yXG4gICAgICAgICAtIG1hdHJpeCAob2JqZWN0KSBATWF0cml4XG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uYWRkID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbW10sIFtdLCBbXV0sXG4gICAgICAgICAgICAgICAgbSA9IFtbdGhpcy5hLCB0aGlzLmMsIHRoaXMuZV0sIFt0aGlzLmIsIHRoaXMuZCwgdGhpcy5mXSwgWzAsIDAsIDFdXSxcbiAgICAgICAgICAgICAgICBtYXRyaXggPSBbW2EsIGMsIGVdLCBbYiwgZCwgZl0sIFswLCAwLCAxXV0sXG4gICAgICAgICAgICAgICAgeCwgeSwgeiwgcmVzO1xuXG4gICAgICAgICAgICBpZiAoYSAmJiBhIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgbWF0cml4ID0gW1thLmEsIGEuYywgYS5lXSwgW2EuYiwgYS5kLCBhLmZdLCBbMCwgMCwgMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgMzsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh5ID0gMDsgeSA8IDM7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHogPSAwOyB6IDwgMzsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gbVt4XVt6XSAqIG1hdHJpeFt6XVt5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRbeF1beV0gPSByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hID0gb3V0WzBdWzBdO1xuICAgICAgICAgICAgdGhpcy5iID0gb3V0WzFdWzBdO1xuICAgICAgICAgICAgdGhpcy5jID0gb3V0WzBdWzFdO1xuICAgICAgICAgICAgdGhpcy5kID0gb3V0WzFdWzFdO1xuICAgICAgICAgICAgdGhpcy5lID0gb3V0WzBdWzJdO1xuICAgICAgICAgICAgdGhpcy5mID0gb3V0WzFdWzJdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LmludmVydFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoZSBtYXRyaXhcbiAgICAgICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmludmVydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgeCA9IG1lLmEgKiBtZS5kIC0gbWUuYiAqIG1lLmM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtZS5kIC8geCwgLW1lLmIgLyB4LCAtbWUuYyAvIHgsIG1lLmEgLyB4LCAobWUuYyAqIG1lLmYgLSBtZS5kICogbWUuZSkgLyB4LCAobWUuYiAqIG1lLmUgLSBtZS5hICogbWUuZikgLyB4KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguY2xvbmVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXRyaXhcbiAgICAgICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLmUsIHRoaXMuZik7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnRyYW5zbGF0ZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogVHJhbnNsYXRlIHRoZSBtYXRyaXhcbiAgICAgICAgIC0geCAobnVtYmVyKSBob3Jpem9udGFsIG9mZnNldCBkaXN0YW5jZVxuICAgICAgICAgLSB5IChudW1iZXIpIHZlcnRpY2FsIG9mZnNldCBkaXN0YW5jZVxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoMSwgMCwgMCwgMSwgeCwgeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnNjYWxlXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBTY2FsZXMgdGhlIG1hdHJpeFxuICAgICAgICAgLSB4IChudW1iZXIpIGFtb3VudCB0byBiZSBzY2FsZWQsIHdpdGggYDFgIHJlc3VsdGluZyBpbiBubyBjaGFuZ2VcbiAgICAgICAgIC0geSAobnVtYmVyKSAjb3B0aW9uYWwgYW1vdW50IHRvIHNjYWxlIGFsb25nIHRoZSB2ZXJ0aWNhbCBheGlzLiAoT3RoZXJ3aXNlIGB4YCBhcHBsaWVzIHRvIGJvdGggYXhlcy4pXG4gICAgICAgICAtIGN4IChudW1iZXIpICNvcHRpb25hbCBob3Jpem9udGFsIG9yaWdpbiBwb2ludCBmcm9tIHdoaWNoIHRvIHNjYWxlXG4gICAgICAgICAtIGN5IChudW1iZXIpICNvcHRpb25hbCB2ZXJ0aWNhbCBvcmlnaW4gcG9pbnQgZnJvbSB3aGljaCB0byBzY2FsZVxuICAgICAgICAgKiBEZWZhdWx0IGN4LCBjeSBpcyB0aGUgbWlkZGxlIHBvaW50IG9mIHRoZSBlbGVtZW50LlxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnNjYWxlID0gZnVuY3Rpb24gKHgsIHksIGN4LCBjeSkge1xuICAgICAgICAgICAgeSA9PSBudWxsICYmICh5ID0geCk7XG4gICAgICAgICAgICAoY3ggfHwgY3kpICYmIHRoaXMuYWRkKDEsIDAsIDAsIDEsIGN4LCBjeSk7XG4gICAgICAgICAgICB0aGlzLmFkZCh4LCAwLCAwLCB5LCAwLCAwKTtcbiAgICAgICAgICAgIChjeCB8fCBjeSkgJiYgdGhpcy5hZGQoMSwgMCwgMCwgMSwgLWN4LCAtY3kpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnJvdGF0ZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUm90YXRlcyB0aGUgbWF0cml4XG4gICAgICAgICAtIGEgKG51bWJlcikgYW5nbGUgb2Ygcm90YXRpb24sIGluIGRlZ3JlZXNcbiAgICAgICAgIC0geCAobnVtYmVyKSBob3Jpem9udGFsIG9yaWdpbiBwb2ludCBmcm9tIHdoaWNoIHRvIHJvdGF0ZVxuICAgICAgICAgLSB5IChudW1iZXIpIHZlcnRpY2FsIG9yaWdpbiBwb2ludCBmcm9tIHdoaWNoIHRvIHJvdGF0ZVxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnJvdGF0ZSA9IGZ1bmN0aW9uIChhLCB4LCB5KSB7XG4gICAgICAgICAgICBhID0gU25hcC5yYWQoYSk7XG4gICAgICAgICAgICB4ID0geCB8fCAwO1xuICAgICAgICAgICAgeSA9IHkgfHwgMDtcbiAgICAgICAgICAgIHZhciBjb3MgPSArbWF0aC5jb3MoYSkudG9GaXhlZCg5KSxcbiAgICAgICAgICAgICAgICBzaW4gPSArbWF0aC5zaW4oYSkudG9GaXhlZCg5KTtcbiAgICAgICAgICAgIHRoaXMuYWRkKGNvcywgc2luLCAtc2luLCBjb3MsIHgsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKDEsIDAsIDAsIDEsIC14LCAteSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnhcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgeCBjb29yZGluYXRlIGZvciBnaXZlbiBwb2ludCBhZnRlciB0cmFuc2Zvcm1hdGlvbiBkZXNjcmliZWQgYnkgdGhlIG1hdHJpeC4gU2VlIGFsc28gQE1hdHJpeC55XG4gICAgICAgICAtIHggKG51bWJlcilcbiAgICAgICAgIC0geSAobnVtYmVyKVxuICAgICAgICAgPSAobnVtYmVyKSB4XG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8ueCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geCAqIHRoaXMuYSArIHkgKiB0aGlzLmMgKyB0aGlzLmU7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnlcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgeSBjb29yZGluYXRlIGZvciBnaXZlbiBwb2ludCBhZnRlciB0cmFuc2Zvcm1hdGlvbiBkZXNjcmliZWQgYnkgdGhlIG1hdHJpeC4gU2VlIGFsc28gQE1hdHJpeC54XG4gICAgICAgICAtIHggKG51bWJlcilcbiAgICAgICAgIC0geSAobnVtYmVyKVxuICAgICAgICAgPSAobnVtYmVyKSB5XG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8ueSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geCAqIHRoaXMuYiArIHkgKiB0aGlzLmQgKyB0aGlzLmY7XG4gICAgICAgIH07XG4gICAgICAgIG1hdHJpeHByb3RvLmdldCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXNbU3RyLmZyb21DaGFyQ29kZSg5NyArIGkpXS50b0ZpeGVkKDQpO1xuICAgICAgICB9O1xuICAgICAgICBtYXRyaXhwcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm1hdHJpeChcIiArIFt0aGlzLmdldCgwKSwgdGhpcy5nZXQoMSksIHRoaXMuZ2V0KDIpLCB0aGlzLmdldCgzKSwgdGhpcy5nZXQoNCksIHRoaXMuZ2V0KDUpXS5qb2luKCkgKyBcIilcIjtcbiAgICAgICAgfTtcbiAgICAgICAgbWF0cml4cHJvdG8ub2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmUudG9GaXhlZCg0KSwgdGhpcy5mLnRvRml4ZWQoNCldO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBub3JtKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhWzBdICogYVswXSArIGFbMV0gKiBhWzFdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShhKSB7XG4gICAgICAgICAgICB2YXIgbWFnID0gbWF0aC5zcXJ0KG5vcm0oYSkpO1xuICAgICAgICAgICAgYVswXSAmJiAoYVswXSAvPSBtYWcpO1xuICAgICAgICAgICAgYVsxXSAmJiAoYVsxXSAvPSBtYWcpO1xuICAgICAgICB9XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LmRldGVybWluYW50XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBGaW5kcyBkZXRlcm1pbmFudCBvZiB0aGUgZ2l2ZW4gbWF0cml4LlxuICAgICAgICAgPSAobnVtYmVyKSBkZXRlcm1pbmFudFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmRldGVybWluYW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYSAqIHRoaXMuZCAtIHRoaXMuYiAqIHRoaXMuYztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc3BsaXRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNwbGl0cyBtYXRyaXggaW50byBwcmltaXRpdmUgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICA9IChvYmplY3QpIGluIGZvcm1hdDpcbiAgICAgICAgIG8gZHggKG51bWJlcikgdHJhbnNsYXRpb24gYnkgeFxuICAgICAgICAgbyBkeSAobnVtYmVyKSB0cmFuc2xhdGlvbiBieSB5XG4gICAgICAgICBvIHNjYWxleCAobnVtYmVyKSBzY2FsZSBieSB4XG4gICAgICAgICBvIHNjYWxleSAobnVtYmVyKSBzY2FsZSBieSB5XG4gICAgICAgICBvIHNoZWFyIChudW1iZXIpIHNoZWFyXG4gICAgICAgICBvIHJvdGF0ZSAobnVtYmVyKSByb3RhdGlvbiBpbiBkZWdcbiAgICAgICAgIG8gaXNTaW1wbGUgKGJvb2xlYW4pIGNvdWxkIGl0IGJlIHJlcHJlc2VudGVkIHZpYSBzaW1wbGUgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc3BsaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgICAgICAvLyB0cmFuc2xhdGlvblxuICAgICAgICAgICAgb3V0LmR4ID0gdGhpcy5lO1xuICAgICAgICAgICAgb3V0LmR5ID0gdGhpcy5mO1xuXG4gICAgICAgICAgICAvLyBzY2FsZSBhbmQgc2hlYXJcbiAgICAgICAgICAgIHZhciByb3cgPSBbW3RoaXMuYSwgdGhpcy5jXSwgW3RoaXMuYiwgdGhpcy5kXV07XG4gICAgICAgICAgICBvdXQuc2NhbGV4ID0gbWF0aC5zcXJ0KG5vcm0ocm93WzBdKSk7XG4gICAgICAgICAgICBub3JtYWxpemUocm93WzBdKTtcblxuICAgICAgICAgICAgb3V0LnNoZWFyID0gcm93WzBdWzBdICogcm93WzFdWzBdICsgcm93WzBdWzFdICogcm93WzFdWzFdO1xuICAgICAgICAgICAgcm93WzFdID0gW3Jvd1sxXVswXSAtIHJvd1swXVswXSAqIG91dC5zaGVhciwgcm93WzFdWzFdIC0gcm93WzBdWzFdICogb3V0LnNoZWFyXTtcblxuICAgICAgICAgICAgb3V0LnNjYWxleSA9IG1hdGguc3FydChub3JtKHJvd1sxXSkpO1xuICAgICAgICAgICAgbm9ybWFsaXplKHJvd1sxXSk7XG4gICAgICAgICAgICBvdXQuc2hlYXIgLz0gb3V0LnNjYWxleTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGV0ZXJtaW5hbnQoKSA8IDApIHtcbiAgICAgICAgICAgICAgICBvdXQuc2NhbGV4ID0gLW91dC5zY2FsZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJvdGF0aW9uXG4gICAgICAgICAgICB2YXIgc2luID0gLXJvd1swXVsxXSxcbiAgICAgICAgICAgICAgICBjb3MgPSByb3dbMV1bMV07XG4gICAgICAgICAgICBpZiAoY29zIDwgMCkge1xuICAgICAgICAgICAgICAgIG91dC5yb3RhdGUgPSBTbmFwLmRlZyhtYXRoLmFjb3MoY29zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnJvdGF0ZSA9IDM2MCAtIG91dC5yb3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQucm90YXRlID0gU25hcC5kZWcobWF0aC5hc2luKHNpbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXQuaXNTaW1wbGUgPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmIChvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpIHx8ICFvdXQucm90YXRlKTtcbiAgICAgICAgICAgIG91dC5pc1N1cGVyU2ltcGxlID0gIStvdXQuc2hlYXIudG9GaXhlZCg5KSAmJiBvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICAgICAgb3V0Lm5vUm90YXRpb24gPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgudG9UcmFuc2Zvcm1TdHJpbmdcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgdHJhbnNmb3JtIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgZ2l2ZW4gbWF0cml4XG4gICAgICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybSBzdHJpbmdcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by50b1RyYW5zZm9ybVN0cmluZyA9IGZ1bmN0aW9uIChzaG9ydGVyKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNob3J0ZXIgfHwgdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgaWYgKCErcy5zaGVhci50b0ZpeGVkKDkpKSB7XG4gICAgICAgICAgICAgICAgcy5zY2FsZXggPSArcy5zY2FsZXgudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICBzLnNjYWxleSA9ICtzLnNjYWxleS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgIHMucm90YXRlID0gK3Mucm90YXRlLnRvRml4ZWQoNCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICAocy5keCB8fCBzLmR5ID8gXCJ0XCIgKyBbK3MuZHgudG9GaXhlZCg0KSwgK3MuZHkudG9GaXhlZCg0KV0gOiBFKSArIFxuICAgICAgICAgICAgICAgICAgICAgICAgKHMuc2NhbGV4ICE9IDEgfHwgcy5zY2FsZXkgIT0gMSA/IFwic1wiICsgW3Muc2NhbGV4LCBzLnNjYWxleSwgMCwgMF0gOiBFKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5yb3RhdGUgPyBcInJcIiArIFsrcy5yb3RhdGUudG9GaXhlZCg0KSwgMCwgMF0gOiBFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibVwiICsgW3RoaXMuZ2V0KDApLCB0aGlzLmdldCgxKSwgdGhpcy5nZXQoMiksIHRoaXMuZ2V0KDMpLCB0aGlzLmdldCg0KSwgdGhpcy5nZXQoNSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pKE1hdHJpeC5wcm90b3R5cGUpO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLk1hdHJpeFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogTWF0cml4IGNvbnN0cnVjdG9yLCBleHRlbmQgb24geW91ciBvd24gcmlzay5cbiAgICAgKiBUbyBjcmVhdGUgbWF0cmljZXMgdXNlIEBTbmFwLm1hdHJpeC5cbiAgICBcXCovXG4gICAgU25hcC5NYXRyaXggPSBNYXRyaXg7XG4gICAgLypcXFxuICAgICAqIFNuYXAubWF0cml4XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYSBtYXRyaXggYmFzZWQgb24gdGhlIGdpdmVuIHBhcmFtZXRlcnNcbiAgICAgLSBhIChudW1iZXIpXG4gICAgIC0gYiAobnVtYmVyKVxuICAgICAtIGMgKG51bWJlcilcbiAgICAgLSBkIChudW1iZXIpXG4gICAgIC0gZSAobnVtYmVyKVxuICAgICAtIGYgKG51bWJlcilcbiAgICAgKiBvclxuICAgICAtIHN2Z01hdHJpeCAoU1ZHTWF0cml4KVxuICAgICA9IChvYmplY3QpIEBNYXRyaXhcbiAgICBcXCovXG4gICAgU25hcC5tYXRyaXggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB9O1xufSk7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgbWFrZSA9IFNuYXAuXy5tYWtlLFxuICAgICAgICB3cmFwID0gU25hcC5fLndyYXAsXG4gICAgICAgIGlzID0gU25hcC5pcyxcbiAgICAgICAgZ2V0U29tZURlZnMgPSBTbmFwLl8uZ2V0U29tZURlZnMsXG4gICAgICAgIHJlVVJMVmFsdWUgPSAvXnVybFxcKCM/KFteKV0rKVxcKSQvLFxuICAgICAgICAkID0gU25hcC5fLiQsXG4gICAgICAgIFVSTCA9IFNuYXAudXJsLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIHNlcGFyYXRvciA9IFNuYXAuXy5zZXBhcmF0b3IsXG4gICAgICAgIEUgPSBcIlwiO1xuICAgIC8vIEF0dHJpYnV0ZXMgZXZlbnQgaGFuZGxlcnNcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXNrXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudCAmJiB2YWx1ZS5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBnZXRTb21lRGVmcyh0aGlzKS5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09IFwibWFza1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hc2sgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFzayA9IG1ha2UoXCJtYXNrXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBtYXNrLm5vZGUuYXBwZW5kQ2hpbGQodmFsdWUubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhbWFzay5ub2RlLmlkICYmICQobWFzay5ub2RlLCB7XG4gICAgICAgICAgICAgICAgaWQ6IG1hc2suaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBtYXNrOiBVUkwobWFzay5pZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgKGZ1bmN0aW9uIChjbGlwSXQpIHtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xpcFwiLCBjbGlwSXQpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5jbGlwLXBhdGhcIiwgY2xpcEl0KTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xpcFBhdGhcIiwgY2xpcEl0KTtcbiAgICB9KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PSBcImNsaXBQYXRoXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGlwID0gbWFrZShcImNsaXBQYXRoXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjbGlwLm5vZGUuYXBwZW5kQ2hpbGQodmFsdWUubm9kZSk7XG4gICAgICAgICAgICAgICAgIWNsaXAubm9kZS5pZCAmJiAkKGNsaXAubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBpZDogY2xpcC5pZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBcImNsaXAtcGF0aFwiOiBVUkwoY2xpcC5ub2RlLmlkIHx8IGNsaXAuaWQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICBmdW5jdGlvbiBmaWxsU3Ryb2tlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZyYWdtZW50ICYmIHZhbHVlLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZS5ub2RlLmZpcnN0Q2hpbGQudGFnTmFtZSA9PSBcInJhZGlhbEdyYWRpZW50XCIgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS5ub2RlLmZpcnN0Q2hpbGQudGFnTmFtZSA9PSBcImxpbmVhckdyYWRpZW50XCIgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS5ub2RlLmZpcnN0Q2hpbGQudGFnTmFtZSA9PSBcInBhdHRlcm5cIikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBnZXRTb21lRGVmcyh0aGlzKS5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PSBcInJhZGlhbEdyYWRpZW50XCIgfHwgdmFsdWUudHlwZSA9PSBcImxpbmVhckdyYWRpZW50XCJcbiAgICAgICAgICAgICAgICAgICB8fCB2YWx1ZS50eXBlID09IFwicGF0dGVyblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUubm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh2YWx1ZS5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHZhbHVlLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsbCA9IFVSTCh2YWx1ZS5ub2RlLmlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWxsID0gdmFsdWUuYXR0cihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbGwgPSBTbmFwLmNvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsbC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JhZCA9IFNuYXAoZ2V0U29tZURlZnModGhpcykub3duZXJTVkdFbGVtZW50KS5ncmFkaWVudCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdyYWQubm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZ3JhZC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBncmFkLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsID0gVVJMKGdyYWQubm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWxsID0gU3RyKGZpbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBmaWxsO1xuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIGF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5zdHlsZVtuYW1lXSA9IEU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmZpbGxcIiwgZmlsbFN0cm9rZShcImZpbGxcIikpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnN0cm9rZVwiLCBmaWxsU3Ryb2tlKFwic3Ryb2tlXCIpKTtcbiAgICB2YXIgZ3JhZHJnID0gL14oW2xyXSkoPzpcXCgoW14pXSopXFwpKT8oLiopJC9pO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5ncmFkLnBhcnNlXCIsIGZ1bmN0aW9uIHBhcnNlR3JhZChzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gU3RyKHN0cmluZyk7XG4gICAgICAgIHZhciB0b2tlbnMgPSBzdHJpbmcubWF0Y2goZ3JhZHJnKTtcbiAgICAgICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gdG9rZW5zWzFdLFxuICAgICAgICAgICAgcGFyYW1zID0gdG9rZW5zWzJdLFxuICAgICAgICAgICAgc3RvcHMgPSB0b2tlbnNbM107XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcy5zcGxpdCgvXFxzKixcXHMqLykubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuICtlbCA9PSBlbCA/ICtlbCA6IGVsO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT0gMSAmJiBwYXJhbXNbMF0gPT0gMCkge1xuICAgICAgICAgICAgcGFyYW1zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgc3RvcHMgPSBzdG9wcy5zcGxpdChcIi1cIik7XG4gICAgICAgIHN0b3BzID0gc3RvcHMubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgZWwgPSBlbC5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBlbFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlbFsxXSkge1xuICAgICAgICAgICAgICAgIG91dC5vZmZzZXQgPSBwYXJzZUZsb2F0KGVsWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgc3RvcHM6IHN0b3BzXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5kXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICBpZiAoaXModmFsdWUsIFwiYXJyYXlcIikgJiYgaXModmFsdWVbMF0sIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gU25hcC5wYXRoLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gU3RyKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9bcnVvXS9pKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBTbmFwLnBhdGgudG9BYnNvbHV0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm5vZGUsIHtkOiB2YWx1ZX0pO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci4jdGV4dFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgdmFsdWUgPSBTdHIodmFsdWUpO1xuICAgICAgICB2YXIgdHh0ID0gZ2xvYi5kb2MuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHR4dCk7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnBhdGhcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHRoaXMuYXR0cih7ZDogdmFsdWV9KTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xhc3NcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc05hbWUuYmFzZVZhbCA9IHZhbHVlO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci52aWV3Qm94XCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdmI7XG4gICAgICAgIGlmIChpcyh2YWx1ZSwgXCJvYmplY3RcIikgJiYgXCJ4XCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIHZiID0gW3ZhbHVlLngsIHZhbHVlLnksIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHRdLmpvaW4oXCIgXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzKHZhbHVlLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICB2YiA9IHZhbHVlLmpvaW4oXCIgXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICAgICAgdmlld0JveDogdmJcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnRyYW5zZm9ybVwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0odmFsdWUpO1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5yXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwicmVjdFwiKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICByeDogdmFsdWUsXG4gICAgICAgICAgICAgICAgcnk6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci50ZXh0cGF0aFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgdmFyIGlkLCB0cCwgbm9kZTtcbiAgICAgICAgICAgIGlmICghdmFsdWUgJiYgdGhpcy50ZXh0UGF0aCkge1xuICAgICAgICAgICAgICAgIHRwID0gdGhpcy50ZXh0UGF0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHAubm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0cC5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50ZXh0UGF0aDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXModmFsdWUsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZnMgPSBnZXRTb21lRGVmcyh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHdyYXAoZGVmcy5wYXJlbnROb2RlKS5wYXRoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHBhdGgubm9kZSk7XG4gICAgICAgICAgICAgICAgaWQgPSBwYXRoLmlkO1xuICAgICAgICAgICAgICAgIHBhdGguYXR0cih7aWQ6IGlkfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHZhbHVlLmF0dHIoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB2YWx1ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmF0dHIoe2lkOiBpZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgdHAgPSB0aGlzLnRleHRQYXRoO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHRwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRwLmF0dHIoe1wieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHAgPSAkKFwidGV4dFBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4bGluazpocmVmXCI6IFwiI1wiICsgaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwLmFwcGVuZENoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0cCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFBhdGggPSB3cmFwKHRwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIudGV4dFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICAgICAgdHVuZXIgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9ICQoXCJ0c3BhblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzKGNodW5rLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZENoaWxkKHR1bmVyKGNodW5rW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kQ2hpbGQoZ2xvYi5kb2MuY3JlYXRlVGV4dE5vZGUoY2h1bmspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQubm9ybWFsaXplICYmIG91dC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0dW5lZCA9IHR1bmVyKHZhbHVlKTtcbiAgICAgICAgICAgIHdoaWxlICh0dW5lZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0dW5lZC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBldmUuc3RvcCgpO1xuICAgIH0pKC0xKTtcbiAgICBmdW5jdGlvbiBzZXRGb250U2l6ZSh2YWx1ZSkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICBpZiAodmFsdWUgPT0gK3ZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlLmZvbnRTaXplID0gdmFsdWU7XG4gICAgfVxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmZvbnRTaXplXCIsIHNldEZvbnRTaXplKSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuZm9udC1zaXplXCIsIHNldEZvbnRTaXplKSgtMSk7XG5cblxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnRyYW5zZm9ybVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgpO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci50ZXh0cGF0aFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRQYXRoO1xuICAgIH0pKC0xKTtcbiAgICAvLyBNYXJrZXJzXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gZ2V0dGVyKGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGdsb2IuZG9jLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwibWFya2VyLVwiICsgZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTbmFwKGdsb2IuZG9jLmdldEVsZW1lbnRCeUlkKHN0eWxlLm1hdGNoKHJlVVJMVmFsdWUpWzFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0ZXIoZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFwibWFya2VyXCIgKyBlbmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBlbmQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIlwiIHx8ICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGVbbmFtZV0gPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PSBcIm1hcmtlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHZhbHVlLm5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodmFsdWUubm9kZSwge2lkOiB2YWx1ZS5pZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zdHlsZVtuYW1lXSA9IFVSTChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlci1lbmRcIiwgZ2V0dGVyKFwiZW5kXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlckVuZFwiLCBnZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIubWFya2VyLXN0YXJ0XCIsIGdldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlclN0YXJ0XCIsIGdldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlci1taWRcIiwgZ2V0dGVyKFwibWlkXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlck1pZFwiLCBnZXR0ZXIoXCJtaWRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyLWVuZFwiLCBzZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyRW5kXCIsIHNldHRlcihcImVuZFwiKSkoLTEpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXJrZXItc3RhcnRcIiwgc2V0dGVyKFwic3RhcnRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyU3RhcnRcIiwgc2V0dGVyKFwic3RhcnRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyLW1pZFwiLCBzZXR0ZXIoXCJtaWRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyTWlkXCIsIHNldHRlcihcIm1pZFwiKSkoLTEpO1xuICAgIH0oKSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJyZWN0XCIgJiYgJCh0aGlzLm5vZGUsIFwicnhcIikgPT0gJCh0aGlzLm5vZGUsIFwicnlcIikpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzLm5vZGUsIFwicnhcIik7XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZnVuY3Rpb24gdGV4dEV4dHJhY3Qobm9kZSkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goY2hpLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpLnRhZ05hbWUgPT0gXCJ0c3BhblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIGNoaS5maXJzdENoaWxkLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goY2hpLmZpcnN0Q2hpbGQubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaCh0ZXh0RXh0cmFjdChjaGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIudGV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIgfHwgdGhpcy50eXBlID09IFwidHNwYW5cIikge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSB0ZXh0RXh0cmFjdCh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG91dC5sZW5ndGggPT0gMSA/IG91dFswXSA6IG91dDtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci4jdGV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQ7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnZpZXdCb3hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICB2YXIgdmIgPSAkKHRoaXMubm9kZSwgXCJ2aWV3Qm94XCIpO1xuICAgICAgICBpZiAodmIpIHtcbiAgICAgICAgICAgIHZiID0gdmIuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KCt2YlswXSwgK3ZiWzFdLCArdmJbMl0sICt2YlszXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIucG9pbnRzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSAkKHRoaXMubm9kZSwgXCJwb2ludHNcIik7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICByZXR1cm4gcC5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnBhdGhcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9ICQodGhpcy5ub2RlLCBcImRcIik7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5jbGFzc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuY2xhc3NOYW1lLmJhc2VWYWw7XG4gICAgfSkoLTEpO1xuICAgIGZ1bmN0aW9uIGdldEZvbnRTaXplKCkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlLmZvbnRTaXplO1xuICAgIH1cbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5mb250U2l6ZVwiLCBnZXRGb250U2l6ZSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZvbnQtc2l6ZVwiLCBnZXRGb250U2l6ZSkoLTEpO1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxNCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYiwgRnJhZ21lbnQpIHtcbiAgICB2YXIgcmdOb3RTcGFjZSA9IC9cXFMrL2csXG4gICAgICAgIHJnQmFkU3BhY2UgPSAvW1xcdFxcclxcblxcZl0vZyxcbiAgICAgICAgcmdUcmltID0gLyheXFxzK3xcXHMrJCkvZyxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICBlbHByb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWRkQ2xhc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZ2l2ZW4gY2xhc3MgbmFtZSBvciBsaXN0IG9mIGNsYXNzIG5hbWVzIHRvIHRoZSBlbGVtZW50LlxuICAgICAtIHZhbHVlIChzdHJpbmcpIGNsYXNzIG5hbWUgb3Igc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgY2xhc3MgbmFtZXNcbiAgICAgKipcbiAgICAgPSAoRWxlbWVudCkgb3JpZ2luYWwgZWxlbWVudC5cbiAgICBcXCovXG4gICAgZWxwcm90by5hZGRDbGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IFN0cih2YWx1ZSB8fCBcIlwiKS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXSxcbiAgICAgICAgICAgIGVsZW0gPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsLFxuICAgICAgICAgICAgY3VyQ2xhc3NlcyA9IGNsYXNzTmFtZS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICBjbGF6eixcbiAgICAgICAgICAgIGZpbmFsVmFsdWU7XG5cbiAgICAgICAgaWYgKGNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW2orK10pKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gY3VyQ2xhc3Nlcy5pbmRleE9mKGNsYXp6KTtcbiAgICAgICAgICAgICAgICBpZiAoIX5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyQ2xhc3Nlcy5wdXNoKGNsYXp6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBjdXJDbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSBmaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUuYmFzZVZhbCA9IGZpbmFsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVDbGFzc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBnaXZlbiBjbGFzcyBuYW1lIG9yIGxpc3Qgb2YgY2xhc3MgbmFtZXMgZnJvbSB0aGUgZWxlbWVudC5cbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSBjbGFzcyBuYW1lIG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIG9yaWdpbmFsIGVsZW1lbnQuXG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBTdHIodmFsdWUgfHwgXCJcIikubWF0Y2gocmdOb3RTcGFjZSkgfHwgW10sXG4gICAgICAgICAgICBlbGVtID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUuYmFzZVZhbCxcbiAgICAgICAgICAgIGN1ckNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2gocmdOb3RTcGFjZSkgfHwgW10sXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgY2xhenosXG4gICAgICAgICAgICBmaW5hbFZhbHVlO1xuICAgICAgICBpZiAoY3VyQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbaisrXSkpIHtcbiAgICAgICAgICAgICAgICBwb3MgPSBjdXJDbGFzc2VzLmluZGV4T2YoY2xhenopO1xuICAgICAgICAgICAgICAgIGlmICh+cG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ckNsYXNzZXMuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gY3VyQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgIT0gZmluYWxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lLmJhc2VWYWwgPSBmaW5hbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaGFzQ2xhc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZWxlbWVudCBoYXMgYSBnaXZlbiBjbGFzcyBuYW1lIGluIHRoZSBsaXN0IG9mIGNsYXNzIG5hbWVzIGFwcGxpZWQgdG8gaXQuXG4gICAgIC0gdmFsdWUgKHN0cmluZykgY2xhc3MgbmFtZVxuICAgICAqKlxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQgaGFzIGdpdmVuIGNsYXNzXG4gICAgXFwqL1xuICAgIGVscHJvdG8uaGFzQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsLFxuICAgICAgICAgICAgY3VyQ2xhc3NlcyA9IGNsYXNzTmFtZS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuICEhfmN1ckNsYXNzZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b2dnbGVDbGFzc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkIG9yIHJlbW92ZSBvbmUgb3IgbW9yZSBjbGFzc2VzIGZyb20gdGhlIGVsZW1lbnQsIGRlcGVuZGluZyBvbiBlaXRoZXJcbiAgICAgKiB0aGUgY2xhc3PigJlzIHByZXNlbmNlIG9yIHRoZSB2YWx1ZSBvZiB0aGUgYGZsYWdgIGFyZ3VtZW50LlxuICAgICAtIHZhbHVlIChzdHJpbmcpIGNsYXNzIG5hbWUgb3Igc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgY2xhc3MgbmFtZXNcbiAgICAgLSBmbGFnIChib29sZWFuKSB2YWx1ZSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgY2xhc3Mgc2hvdWxkIGJlIGFkZGVkIG9yIHJlbW92ZWRcbiAgICAgKipcbiAgICAgPSAoRWxlbWVudCkgb3JpZ2luYWwgZWxlbWVudC5cbiAgICBcXCovXG4gICAgZWxwcm90by50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSwgZmxhZykge1xuICAgICAgICBpZiAoZmxhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZmxhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZENsYXNzKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ2xhc3ModmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjbGFzc2VzID0gKHZhbHVlIHx8IFwiXCIpLm1hdGNoKHJnTm90U3BhY2UpIHx8IFtdLFxuICAgICAgICAgICAgZWxlbSA9IHRoaXMubm9kZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lLmJhc2VWYWwsXG4gICAgICAgICAgICBjdXJDbGFzc2VzID0gY2xhc3NOYW1lLm1hdGNoKHJnTm90U3BhY2UpIHx8IFtdLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIGNsYXp6LFxuICAgICAgICAgICAgZmluYWxWYWx1ZTtcbiAgICAgICAgaiA9IDA7XG4gICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW2orK10pKSB7XG4gICAgICAgICAgICBwb3MgPSBjdXJDbGFzc2VzLmluZGV4T2YoY2xhenopO1xuICAgICAgICAgICAgaWYgKH5wb3MpIHtcbiAgICAgICAgICAgICAgICBjdXJDbGFzc2VzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJDbGFzc2VzLnB1c2goY2xhenopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxWYWx1ZSA9IGN1ckNsYXNzZXMuam9pbihcIiBcIik7XG4gICAgICAgIGlmIChjbGFzc05hbWUgIT0gZmluYWxWYWx1ZSkge1xuICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUuYmFzZVZhbCA9IGZpbmFsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIG9wZXJhdG9ycyA9IHtcbiAgICAgICAgICAgIFwiK1wiOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCArIHk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiLVwiOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCAtIHk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiL1wiOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCAvIHk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiKlwiOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCAqIHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIHJlVW5pdCA9IC9bYS16XSskL2ksXG4gICAgICAgIHJlQWRkb24gPSAvXlxccyooWytcXC1cXC8qXSlcXHMqPVxccyooW1xcZC5lRStcXC1dKylcXHMqKFteXFxkXFxzXSspP1xccyokLztcbiAgICBmdW5jdGlvbiBnZXROdW1iZXIodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFVuaXQodW5pdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICt2YWwudG9GaXhlZCgzKSArIHVuaXQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyXCIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIHBsdXMgPSBTdHIodmFsKS5tYXRjaChyZUFkZG9uKTtcbiAgICAgICAgaWYgKHBsdXMpIHtcbiAgICAgICAgICAgIHZhciBldm50ID0gZXZlLm50KCksXG4gICAgICAgICAgICAgICAgbmFtZSA9IGV2bnQuc3Vic3RyaW5nKGV2bnQubGFzdEluZGV4T2YoXCIuXCIpICsgMSksXG4gICAgICAgICAgICAgICAgYSA9IHRoaXMuYXR0cihuYW1lKSxcbiAgICAgICAgICAgICAgICBhdHIgPSB7fTtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IHBsdXNbM10gfHwgXCJcIixcbiAgICAgICAgICAgICAgICBhVW5pdCA9IGEubWF0Y2gocmVVbml0KSxcbiAgICAgICAgICAgICAgICBvcCA9IG9wZXJhdG9yc1twbHVzWzFdXTtcbiAgICAgICAgICAgIGlmIChhVW5pdCAmJiBhVW5pdCA9PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgdmFsID0gb3AocGFyc2VGbG9hdChhKSwgK3BsdXNbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhID0gdGhpcy5hc1BYKG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhbCA9IG9wKHRoaXMuYXNQWChuYW1lKSwgdGhpcy5hc1BYKG5hbWUsIHBsdXNbMl0gKyB1bml0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOYU4oYSkgfHwgaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0cltuYW1lXSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuYXR0cihhdHIpO1xuICAgICAgICB9XG4gICAgfSkoLTEwKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZXF1YWxcIiwgZnVuY3Rpb24gKG5hbWUsIGIpIHtcbiAgICAgICAgdmFyIEEsIEIsIGEgPSBTdHIodGhpcy5hdHRyKG5hbWUpIHx8IFwiXCIpLFxuICAgICAgICAgICAgZWwgPSB0aGlzLFxuICAgICAgICAgICAgYnBsdXMgPSBTdHIoYikubWF0Y2gocmVBZGRvbik7XG4gICAgICAgIGlmIChicGx1cykge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHZhciB1bml0ID0gYnBsdXNbM10gfHwgXCJcIixcbiAgICAgICAgICAgICAgICBhVW5pdCA9IGEubWF0Y2gocmVVbml0KSxcbiAgICAgICAgICAgICAgICBvcCA9IG9wZXJhdG9yc1ticGx1c1sxXV07XG4gICAgICAgICAgICBpZiAoYVVuaXQgJiYgYVVuaXQgPT0gdW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IHBhcnNlRmxvYXQoYSksXG4gICAgICAgICAgICAgICAgICAgIHRvOiBvcChwYXJzZUZsb2F0KGEpLCArYnBsdXNbMl0pLFxuICAgICAgICAgICAgICAgICAgICBmOiBnZXRVbml0KGFVbml0KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmFzUFgobmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogYSxcbiAgICAgICAgICAgICAgICAgICAgdG86IG9wKGEsIHRoaXMuYXNQWChuYW1lLCBicGx1c1syXSArIHVuaXQpKSxcbiAgICAgICAgICAgICAgICAgICAgZjogZ2V0TnVtYmVyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKC0xMCk7XG59KTtcbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy8gXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vIFxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYiwgRnJhZ21lbnQpIHtcbiAgICB2YXIgcHJvdG8gPSBQYXBlci5wcm90b3R5cGUsXG4gICAgICAgIGlzID0gU25hcC5pcztcbiAgICAvKlxcXG4gICAgICogUGFwZXIucmVjdFxuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgKiBEcmF3cyBhIHJlY3RhbmdsZVxuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGVmdCBjb3JuZXJcbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgY29ybmVyXG4gICAgIC0gd2lkdGggKG51bWJlcikgd2lkdGhcbiAgICAgLSBoZWlnaHQgKG51bWJlcikgaGVpZ2h0XG4gICAgIC0gcnggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgcmFkaXVzIGZvciByb3VuZGVkIGNvcm5lcnMsIGRlZmF1bHQgaXMgMFxuICAgICAtIHJ5IChudW1iZXIpICNvcHRpb25hbCB2ZXJ0aWNhbCByYWRpdXMgZm9yIHJvdW5kZWQgY29ybmVycywgZGVmYXVsdCBpcyByeCBvciAwXG4gICAgID0gKG9iamVjdCkgdGhlIGByZWN0YCBlbGVtZW50XG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCAvLyByZWd1bGFyIHJlY3RhbmdsZVxuICAgICB8IHZhciBjID0gcGFwZXIucmVjdCgxMCwgMTAsIDUwLCA1MCk7XG4gICAgIHwgLy8gcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzXG4gICAgIHwgdmFyIGMgPSBwYXBlci5yZWN0KDQwLCA0MCwgNTAsIDUwLCAxMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgcngsIHJ5KSB7XG4gICAgICAgIHZhciBhdHRyO1xuICAgICAgICBpZiAocnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnkgPSByeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoeCwgXCJvYmplY3RcIikgJiYgeCA9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgICAgICBhdHRyID0geDtcbiAgICAgICAgfSBlbHNlIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPSB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgICAgIGhlaWdodDogaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyeCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0ci5yeCA9IHJ4O1xuICAgICAgICAgICAgICAgIGF0dHIucnkgPSByeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcInJlY3RcIiwgYXR0cik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuY2lyY2xlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIGNpcmNsZVxuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBjZW50cmVcbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0gciAobnVtYmVyKSByYWRpdXNcbiAgICAgPSAob2JqZWN0KSB0aGUgYGNpcmNsZWAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5jaXJjbGUoNTAsIDUwLCA0MCk7XG4gICAgXFwqL1xuICAgIHByb3RvLmNpcmNsZSA9IGZ1bmN0aW9uIChjeCwgY3ksIHIpIHtcbiAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgIGlmIChpcyhjeCwgXCJvYmplY3RcIikgJiYgY3ggPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgICAgYXR0ciA9IGN4O1xuICAgICAgICB9IGVsc2UgaWYgKGN4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPSB7XG4gICAgICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICByOiByXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwiY2lyY2xlXCIsIGF0dHIpO1xuICAgIH07XG5cbiAgICB2YXIgcHJlbG9hZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIG9uZXJyb3IoKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzcmMsIGYpIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSBnbG9iLmRvYy5jcmVhdGVFbGVtZW50KFwiaW1nXCIpLFxuICAgICAgICAgICAgICAgIGJvZHkgPSBnbG9iLmRvYy5ib2R5O1xuICAgICAgICAgICAgaW1nLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTk5OTllbTt0b3A6LTk5OTllbVwiO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmLmNhbGwoaW1nKTtcbiAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoaW1nKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgICAgICBpbWcuc3JjID0gc3JjO1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKlxcXG4gICAgICogUGFwZXIuaW1hZ2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFBsYWNlcyBhbiBpbWFnZSBvbiB0aGUgc3VyZmFjZVxuICAgICAqKlxuICAgICAtIHNyYyAoc3RyaW5nKSBVUkkgb2YgdGhlIHNvdXJjZSBpbWFnZVxuICAgICAtIHggKG51bWJlcikgeCBvZmZzZXQgcG9zaXRpb25cbiAgICAgLSB5IChudW1iZXIpIHkgb2Zmc2V0IHBvc2l0aW9uXG4gICAgIC0gd2lkdGggKG51bWJlcikgd2lkdGggb2YgdGhlIGltYWdlXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAgICAgPSAob2JqZWN0KSB0aGUgYGltYWdlYCBlbGVtZW50XG4gICAgICogb3JcbiAgICAgPSAob2JqZWN0KSBTbmFwIGVsZW1lbnQgb2JqZWN0IHdpdGggdHlwZSBgaW1hZ2VgXG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgYyA9IHBhcGVyLmltYWdlKFwiYXBwbGUucG5nXCIsIDEwLCAxMCwgODAsIDgwKTtcbiAgICBcXCovXG4gICAgcHJvdG8uaW1hZ2UgPSBmdW5jdGlvbiAoc3JjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWwoXCJpbWFnZVwiKTtcbiAgICAgICAgaWYgKGlzKHNyYywgXCJvYmplY3RcIikgJiYgXCJzcmNcIiBpbiBzcmMpIHtcbiAgICAgICAgICAgIGVsLmF0dHIoc3JjKTtcbiAgICAgICAgfSBlbHNlIGlmIChzcmMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHNldCA9IHtcbiAgICAgICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogc3JjLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHggIT0gbnVsbCAmJiB5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQueCA9IHg7XG4gICAgICAgICAgICAgICAgc2V0LnkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpZHRoICE9IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICBzZXQuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVsb2FkKHNyYywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBTbmFwLl8uJChlbC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5vZmZzZXRIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTbmFwLl8uJChlbC5ub2RlLCBzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5lbGxpcHNlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhbiBlbGxpcHNlXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZVxuICAgICAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBjZW50cmVcbiAgICAgLSByeCAobnVtYmVyKSBob3Jpem9udGFsIHJhZGl1c1xuICAgICAtIHJ5IChudW1iZXIpIHZlcnRpY2FsIHJhZGl1c1xuICAgICA9IChvYmplY3QpIHRoZSBgZWxsaXBzZWAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5lbGxpcHNlKDUwLCA1MCwgNDAsIDIwKTtcbiAgICBcXCovXG4gICAgcHJvdG8uZWxsaXBzZSA9IGZ1bmN0aW9uIChjeCwgY3ksIHJ4LCByeSkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgaWYgKGlzKGN4LCBcIm9iamVjdFwiKSAmJiBjeCA9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgICAgICBhdHRyID0gY3g7XG4gICAgICAgIH0gZWxzZSBpZiAoY3ggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0ciA9e1xuICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgICAgcng6IHJ4LFxuICAgICAgICAgICAgICAgIHJ5OiByeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcImVsbGlwc2VcIiwgYXR0cik7XG4gICAgfTtcbiAgICAvLyBTSUVSUkEgUGFwZXIucGF0aCgpOiBVbmNsZWFyIGZyb20gdGhlIGxpbmsgd2hhdCBhIENhdG11bGwtUm9tIGN1cnZldG8gaXMsIGFuZCB3aHkgaXQgd291bGQgbWFrZSBsaWZlIGFueSBlYXNpZXIuXG4gICAgLypcXFxuICAgICAqIFBhcGVyLnBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPHBhdGg+YCBlbGVtZW50IHVzaW5nIHRoZSBnaXZlbiBzdHJpbmcgYXMgdGhlIHBhdGgncyBkZWZpbml0aW9uXG4gICAgIC0gcGF0aFN0cmluZyAoc3RyaW5nKSAjb3B0aW9uYWwgcGF0aCBzdHJpbmcgaW4gU1ZHIGZvcm1hdFxuICAgICAqIFBhdGggc3RyaW5nIGNvbnNpc3RzIG9mIG9uZS1sZXR0ZXIgY29tbWFuZHMsIGZvbGxvd2VkIGJ5IGNvbW1hIHNlcHJhcmF0ZWQgYXJndW1lbnRzIGluIG51bWVyaWNhbCBmb3JtLiBFeGFtcGxlOlxuICAgICB8IFwiTTEwLDIwTDMwLDQwXCJcbiAgICAgKiBUaGlzIGV4YW1wbGUgZmVhdHVyZXMgdHdvIGNvbW1hbmRzOiBgTWAsIHdpdGggYXJndW1lbnRzIGAoMTAsIDIwKWAgYW5kIGBMYCB3aXRoIGFyZ3VtZW50cyBgKDMwLCA0MClgLiBVcHBlcmNhc2UgbGV0dGVyIGNvbW1hbmRzIGV4cHJlc3MgY29vcmRpbmF0ZXMgaW4gYWJzb2x1dGUgdGVybXMsIHdoaWxlIGxvd2VyY2FzZSBjb21tYW5kcyBleHByZXNzIHRoZW0gaW4gcmVsYXRpdmUgdGVybXMgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBkZWNsYXJlZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAjIDxwPkhlcmUgaXMgc2hvcnQgbGlzdCBvZiBjb21tYW5kcyBhdmFpbGFibGUsIGZvciBtb3JlIGRldGFpbHMgc2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVwiIHRpdGxlPVwiRGV0YWlscyBvZiBhIHBhdGgncyBkYXRhIGF0dHJpYnV0ZSdzIGZvcm1hdCBhcmUgZGVzY3JpYmVkIGluIHRoZSBTVkcgc3BlY2lmaWNhdGlvbi5cIj5TVkcgcGF0aCBzdHJpbmcgZm9ybWF0PC9hPiBvciA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vU1ZHL1R1dG9yaWFsL1BhdGhzXCI+YXJ0aWNsZSBhYm91dCBwYXRoIHN0cmluZ3MgYXQgTUROPC9hPi48L3A+XG4gICAgICMgPHRhYmxlPjx0aGVhZD48dHI+PHRoPkNvbW1hbmQ8L3RoPjx0aD5OYW1lPC90aD48dGg+UGFyYW1ldGVyczwvdGg+PC90cj48L3RoZWFkPjx0Ym9keT5cbiAgICAgIyA8dHI+PHRkPk08L3RkPjx0ZD5tb3ZldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5aPC90ZD48dGQ+Y2xvc2VwYXRoPC90ZD48dGQ+KG5vbmUpPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+TDwvdGQ+PHRkPmxpbmV0bzwvdGQ+PHRkPih4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkg8L3RkPjx0ZD5ob3Jpem9udGFsIGxpbmV0bzwvdGQ+PHRkPngrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+VjwvdGQ+PHRkPnZlcnRpY2FsIGxpbmV0bzwvdGQ+PHRkPnkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+QzwvdGQ+PHRkPmN1cnZldG88L3RkPjx0ZD4oeDEgeTEgeDIgeTIgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5TPC90ZD48dGQ+c21vb3RoIGN1cnZldG88L3RkPjx0ZD4oeDIgeTIgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5RPC90ZD48dGQ+cXVhZHJhdGljIELDqXppZXIgY3VydmV0bzwvdGQ+PHRkPih4MSB5MSB4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlQ8L3RkPjx0ZD5zbW9vdGggcXVhZHJhdGljIELDqXppZXIgY3VydmV0bzwvdGQ+PHRkPih4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkE8L3RkPjx0ZD5lbGxpcHRpY2FsIGFyYzwvdGQ+PHRkPihyeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlI8L3RkPjx0ZD48YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXRtdWxs4oCTUm9tX3NwbGluZSNDYXRtdWxsLkUyLjgwLjkzUm9tX3NwbGluZVwiPkNhdG11bGwtUm9tIGN1cnZldG88L2E+KjwvdGQ+PHRkPngxIHkxICh4IHkpKzwvdGQ+PC90cj48L3Rib2R5PjwvdGFibGU+XG4gICAgICogKiBfQ2F0bXVsbC1Sb20gY3VydmV0b18gaXMgYSBub3Qgc3RhbmRhcmQgU1ZHIGNvbW1hbmQgYW5kIGFkZGVkIHRvIG1ha2UgbGlmZSBlYXNpZXIuXG4gICAgICogTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlbiBhIHBhdGggY29uc2lzdHMgb2Ygb25seSB0aHJlZSBjb21tYW5kczogYE0xMCwxMFLigKZ6YC4gSW4gdGhpcyBjYXNlIHRoZSBwYXRoIGNvbm5lY3RzIGJhY2sgdG8gaXRzIHN0YXJ0aW5nIHBvaW50LlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5wYXRoKFwiTTEwIDEwTDkwIDkwXCIpO1xuICAgICB8IC8vIGRyYXcgYSBkaWFnb25hbCBsaW5lOlxuICAgICB8IC8vIG1vdmUgdG8gMTAsMTAsIGxpbmUgdG8gOTAsOTBcbiAgICBcXCovXG4gICAgcHJvdG8ucGF0aCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBhdHRyO1xuICAgICAgICBpZiAoaXMoZCwgXCJvYmplY3RcIikgJiYgIWlzKGQsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIGF0dHIgPSBkO1xuICAgICAgICB9IGVsc2UgaWYgKGQpIHtcbiAgICAgICAgICAgIGF0dHIgPSB7ZDogZH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJwYXRoXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBncm91cCBlbGVtZW50XG4gICAgICoqXG4gICAgIC0gdmFyYXJncyAo4oCmKSAjb3B0aW9uYWwgZWxlbWVudHMgdG8gbmVzdCB3aXRoaW4gdGhlIGdyb3VwXG4gICAgID0gKG9iamVjdCkgdGhlIGBnYCBlbGVtZW50XG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgYzEgPSBwYXBlci5jaXJjbGUoKSxcbiAgICAgfCAgICAgYzIgPSBwYXBlci5yZWN0KCksXG4gICAgIHwgICAgIGcgPSBwYXBlci5nKGMyLCBjMSk7IC8vIG5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgZWxlbWVudHMgaXMgZGlmZmVyZW50XG4gICAgICogb3JcbiAgICAgfCB2YXIgYzEgPSBwYXBlci5jaXJjbGUoKSxcbiAgICAgfCAgICAgYzIgPSBwYXBlci5yZWN0KCksXG4gICAgIHwgICAgIGcgPSBwYXBlci5nKCk7XG4gICAgIHwgZy5hZGQoYzIsIGMxKTtcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIFBhcGVyLmdyb3VwXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQFBhcGVyLmdcbiAgICBcXCovXG4gICAgcHJvdG8uZ3JvdXAgPSBwcm90by5nID0gZnVuY3Rpb24gKGZpcnN0KSB7XG4gICAgICAgIHZhciBhdHRyLFxuICAgICAgICAgICAgZWwgPSB0aGlzLmVsKFwiZ1wiKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBmaXJzdCAmJiAhZmlyc3QudHlwZSkge1xuICAgICAgICAgICAgZWwuYXR0cihmaXJzdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWwuYWRkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5zdmdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBuZXN0ZWQgU1ZHIGVsZW1lbnQuXG4gICAgIC0geCAobnVtYmVyKSBAb3B0aW9uYWwgWCBvZiB0aGUgZWxlbWVudFxuICAgICAtIHkgKG51bWJlcikgQG9wdGlvbmFsIFkgb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB3aWR0aCAobnVtYmVyKSBAb3B0aW9uYWwgd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgICAgLSBoZWlnaHQgKG51bWJlcikgQG9wdGlvbmFsIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgICAtIHZieCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBYXG4gICAgIC0gdmJ5IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFlcbiAgICAgLSB2YncgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggd2lkdGhcbiAgICAgLSB2YmggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggaGVpZ2h0XG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgdGhlIGBzdmdgIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgcHJvdG8uc3ZnID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHZieCwgdmJ5LCB2YncsIHZiaCkge1xuICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpICYmIHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0cnMgPSB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLnggPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLnkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRycy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZieCAhPSBudWxsICYmIHZieSAhPSBudWxsICYmIHZidyAhPSBudWxsICYmIHZiaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMudmlld0JveCA9IFt2YngsIHZieSwgdmJ3LCB2YmhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwic3ZnXCIsIGF0dHJzKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5tYXNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFcXVpdmFsZW50IGluIGJlaGF2aW91ciB0byBAUGFwZXIuZywgZXhjZXB0IGl04oCZcyBhIG1hc2suXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgdGhlIGBtYXNrYCBlbGVtZW50XG4gICAgICoqXG4gICAgXFwqL1xuICAgIHByb3RvLm1hc2sgPSBmdW5jdGlvbiAoZmlyc3QpIHtcbiAgICAgICAgdmFyIGF0dHIsXG4gICAgICAgICAgICBlbCA9IHRoaXMuZWwoXCJtYXNrXCIpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIGZpcnN0ICYmICFmaXJzdC50eXBlKSB7XG4gICAgICAgICAgICBlbC5hdHRyKGZpcnN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbC5hZGQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnB0cm5cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEVxdWl2YWxlbnQgaW4gYmVoYXZpb3VyIHRvIEBQYXBlci5nLCBleGNlcHQgaXTigJlzIGEgcGF0dGVybi5cbiAgICAgLSB4IChudW1iZXIpIEBvcHRpb25hbCBYIG9mIHRoZSBlbGVtZW50XG4gICAgIC0geSAobnVtYmVyKSBAb3B0aW9uYWwgWSBvZiB0aGUgZWxlbWVudFxuICAgICAtIHdpZHRoIChudW1iZXIpIEBvcHRpb25hbCB3aWR0aCBvZiB0aGUgZWxlbWVudFxuICAgICAtIGhlaWdodCAobnVtYmVyKSBAb3B0aW9uYWwgaGVpZ2h0IG9mIHRoZSBlbGVtZW50XG4gICAgIC0gdmJ4IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFhcbiAgICAgLSB2YnkgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggWVxuICAgICAtIHZidyAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCB3aWR0aFxuICAgICAtIHZiaCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBoZWlnaHRcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSB0aGUgYHBhdHRlcm5gIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgcHJvdG8ucHRybiA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB2eCwgdnksIHZ3LCB2aCkge1xuICAgICAgICBpZiAoaXMoeCwgXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIgPSB7cGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJ9O1xuICAgICAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAgICAgICBhdHRyLnggPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICAgICAgICBhdHRyLnkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2eCAhPSBudWxsICYmIHZ5ICE9IG51bGwgJiYgdncgIT0gbnVsbCAmJiB2aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0ci52aWV3Qm94ID0gW3Z4LCB2eSwgdncsIHZoXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0ci52aWV3Qm94ID0gW3ggfHwgMCwgeSB8fCAwLCB3aWR0aCB8fCAwLCBoZWlnaHQgfHwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJwYXR0ZXJuXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnVzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIDx1c2U+IGVsZW1lbnQuXG4gICAgIC0gaWQgKHN0cmluZykgQG9wdGlvbmFsIGlkIG9mIGVsZW1lbnQgdG8gbGlua1xuICAgICAqIG9yXG4gICAgIC0gaWQgKEVsZW1lbnQpIEBvcHRpb25hbCBlbGVtZW50IHRvIGxpbmtcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSB0aGUgYHVzZWAgZWxlbWVudFxuICAgICAqKlxuICAgIFxcKi9cbiAgICBwcm90by51c2UgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpZCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlkLmF0dHIoXCJpZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZC5hdHRyKHtpZDogU25hcC5fLmlkKGlkKX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZCA9IGlkLmF0dHIoXCJpZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChTdHJpbmcoaWQpLmNoYXJBdCgpID09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbChcInVzZVwiLCB7XCJ4bGluazpocmVmXCI6IFwiI1wiICsgaWR9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50LnByb3RvdHlwZS51c2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnN5bWJvbFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIDxzeW1ib2w+IGVsZW1lbnQuXG4gICAgIC0gdmJ4IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFhcbiAgICAgLSB2YnkgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggWVxuICAgICAtIHZidyAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCB3aWR0aFxuICAgICAtIHZiaCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBoZWlnaHRcbiAgICAgPSAob2JqZWN0KSB0aGUgYHN5bWJvbGAgZWxlbWVudFxuICAgICAqKlxuICAgIFxcKi9cbiAgICBwcm90by5zeW1ib2wgPSBmdW5jdGlvbiAodngsIHZ5LCB2dywgdmgpIHtcbiAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgaWYgKHZ4ICE9IG51bGwgJiYgdnkgIT0gbnVsbCAmJiB2dyAhPSBudWxsICYmIHZoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIudmlld0JveCA9IFt2eCwgdnksIHZ3LCB2aF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5lbChcInN5bWJvbFwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci50ZXh0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIHRleHQgc3RyaW5nXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgcG9zaXRpb25cbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBwb3NpdGlvblxuICAgICAtIHRleHQgKHN0cmluZ3xhcnJheSkgVGhlIHRleHQgc3RyaW5nIHRvIGRyYXcgb3IgYXJyYXkgb2Ygc3RyaW5ncyB0byBuZXN0IHdpdGhpbiBzZXBhcmF0ZSBgPHRzcGFuPmAgZWxlbWVudHNcbiAgICAgPSAob2JqZWN0KSB0aGUgYHRleHRgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciB0MSA9IHBhcGVyLnRleHQoNTAsIDUwLCBcIlNuYXBcIik7XG4gICAgIHwgdmFyIHQyID0gcGFwZXIudGV4dCg1MCwgNTAsIFtcIlNcIixcIm5cIixcImFcIixcInBcIl0pO1xuICAgICB8IC8vIFRleHQgcGF0aCB1c2FnZVxuICAgICB8IHQxLmF0dHIoe3RleHRwYXRoOiBcIk0xMCwxMEwxMDAsMTAwXCJ9KTtcbiAgICAgfCAvLyBvclxuICAgICB8IHZhciBwdGggPSBwYXBlci5wYXRoKFwiTTEwLDEwTDEwMCwxMDBcIik7XG4gICAgIHwgdDEuYXR0cih7dGV4dHBhdGg6IHB0aH0pO1xuICAgIFxcKi9cbiAgICBwcm90by50ZXh0ID0gZnVuY3Rpb24gKHgsIHksIHRleHQpIHtcbiAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBhdHRyID0geDtcbiAgICAgICAgfSBlbHNlIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPSB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQgfHwgXCJcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcInRleHRcIiwgYXR0cik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIubGluZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSBsaW5lXG4gICAgICoqXG4gICAgIC0geDEgKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uIG9mIHRoZSBzdGFydFxuICAgICAtIHkxIChudW1iZXIpIHkgY29vcmRpbmF0ZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnRcbiAgICAgLSB4MiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgcG9zaXRpb24gb2YgdGhlIGVuZFxuICAgICAtIHkyIChudW1iZXIpIHkgY29vcmRpbmF0ZSBwb3NpdGlvbiBvZiB0aGUgZW5kXG4gICAgID0gKG9iamVjdCkgdGhlIGBsaW5lYCBlbGVtZW50XG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgdDEgPSBwYXBlci5saW5lKDUwLCA1MCwgMTAwLCAxMDApO1xuICAgIFxcKi9cbiAgICBwcm90by5saW5lID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmIChpcyh4MSwgXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGF0dHIgPSB4MTtcbiAgICAgICAgfSBlbHNlIGlmICh4MSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICAgICAgIHkyOiB5MlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcImxpbmVcIiwgYXR0cik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIucG9seWxpbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERyYXdzIGEgcG9seWxpbmVcbiAgICAgKipcbiAgICAgLSBwb2ludHMgKGFycmF5KSBhcnJheSBvZiBwb2ludHNcbiAgICAgKiBvclxuICAgICAtIHZhcmFyZ3MgKOKApikgcG9pbnRzXG4gICAgID0gKG9iamVjdCkgdGhlIGBwb2x5bGluZWAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIHAxID0gcGFwZXIucG9seWxpbmUoWzEwLCAxMCwgMTAwLCAxMDBdKTtcbiAgICAgfCB2YXIgcDIgPSBwYXBlci5wb2x5bGluZSgxMCwgMTAsIDEwMCwgMTAwKTtcbiAgICBcXCovXG4gICAgcHJvdG8ucG9seWxpbmUgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcG9pbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICBpZiAoaXMocG9pbnRzLCBcIm9iamVjdFwiKSAmJiAhaXMocG9pbnRzLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBhdHRyID0gcG9pbnRzO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge3BvaW50czogcG9pbnRzfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcInBvbHlsaW5lXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnBvbHlnb25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERyYXdzIGEgcG9seWdvbi4gU2VlIEBQYXBlci5wb2x5bGluZVxuICAgIFxcKi9cbiAgICBwcm90by5wb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgaWYgKGlzKHBvaW50cywgXCJvYmplY3RcIikgJiYgIWlzKHBvaW50cywgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgYXR0ciA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0ciA9IHtwb2ludHM6IHBvaW50c307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJwb2x5Z29uXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLy8gZ3JhZGllbnRzXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQgPSBTbmFwLl8uJDtcbiAgICAgICAgLy8gZ3JhZGllbnRzJyBoZWxwZXJzXG4gICAgICAgIGZ1bmN0aW9uIEdzdG9wcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdEFsbChcInN0b3BcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gR2FkZFN0b3AoY29sb3IsIG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHN0b3AgPSAkKFwic3RvcFwiKSxcbiAgICAgICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6ICtvZmZzZXQgKyBcIiVcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb2xvciA9IFNuYXAuY29sb3IoY29sb3IpO1xuICAgICAgICAgICAgYXR0cltcInN0b3AtY29sb3JcIl0gPSBjb2xvci5oZXg7XG4gICAgICAgICAgICBpZiAoY29sb3Iub3BhY2l0eSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhdHRyW1wic3RvcC1vcGFjaXR5XCJdID0gY29sb3Iub3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQoc3RvcCwgYXR0cik7XG4gICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoc3RvcCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBHZ2V0QkJveCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJsaW5lYXJHcmFkaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHgxID0gJCh0aGlzLm5vZGUsIFwieDFcIikgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgeDIgPSAkKHRoaXMubm9kZSwgXCJ4MlwiKSB8fCAxLFxuICAgICAgICAgICAgICAgICAgICB5MSA9ICQodGhpcy5ub2RlLCBcInkxXCIpIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHkyID0gJCh0aGlzLm5vZGUsIFwieTJcIikgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveCh4MSwgeTEsIG1hdGguYWJzKHgyIC0geDEpLCBtYXRoLmFicyh5MiAtIHkxKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjeCA9IHRoaXMubm9kZS5jeCB8fCAuNSxcbiAgICAgICAgICAgICAgICAgICAgY3kgPSB0aGlzLm5vZGUuY3kgfHwgLjUsXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0aGlzLm5vZGUuciB8fCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KGN4IC0gciwgY3kgLSByLCByICogMiwgciAqIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdyYWRpZW50KGRlZnMsIHN0cikge1xuICAgICAgICAgICAgdmFyIGdyYWQgPSBldmUoXCJzbmFwLnV0aWwuZ3JhZC5wYXJzZVwiLCBudWxsLCBzdHIpLmZpcnN0RGVmaW5lZCgpLFxuICAgICAgICAgICAgICAgIGVsO1xuICAgICAgICAgICAgaWYgKCFncmFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFkLnBhcmFtcy51bnNoaWZ0KGRlZnMpO1xuICAgICAgICAgICAgaWYgKGdyYWQudHlwZS50b0xvd2VyQ2FzZSgpID09IFwibFwiKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBncmFkaWVudExpbmVhci5hcHBseSgwLCBncmFkLnBhcmFtcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gZ3JhZGllbnRSYWRpYWwuYXBwbHkoMCwgZ3JhZC5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYWQudHlwZSAhPSBncmFkLnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdG9wcyA9IGdyYWQuc3RvcHMsXG4gICAgICAgICAgICAgICAgbGVuID0gc3RvcHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMCxcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNlZWQoaSwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSAoZW5kIC0gc3RhcnQpIC8gKGkgLSBqKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gajsgayA8IGk7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBzdG9wc1trXS5vZmZzZXQgPSArKCtzdGFydCArIHN0ZXAgKiAoayAtIGopKS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgaWYgKFwib2Zmc2V0XCIgaW4gc3RvcHNbaV0pIHtcbiAgICAgICAgICAgICAgICBzZWVkKGksIHN0b3BzW2ldLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wc1tsZW5dLm9mZnNldCA9IHN0b3BzW2xlbl0ub2Zmc2V0IHx8IDEwMDtcbiAgICAgICAgICAgIHNlZWQobGVuLCBzdG9wc1tsZW5dLm9mZnNldCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgICAgICAgICBlbC5hZGRTdG9wKHN0b3AuY29sb3IsIHN0b3Aub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBncmFkaWVudExpbmVhcihkZWZzLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAgICAgdmFyIGVsID0gU25hcC5fLm1ha2UoXCJsaW5lYXJHcmFkaWVudFwiLCBkZWZzKTtcbiAgICAgICAgICAgIGVsLnN0b3BzID0gR3N0b3BzO1xuICAgICAgICAgICAgZWwuYWRkU3RvcCA9IEdhZGRTdG9wO1xuICAgICAgICAgICAgZWwuZ2V0QkJveCA9IEdnZXRCQm94O1xuICAgICAgICAgICAgaWYgKHgxICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAkKGVsLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ3JhZGllbnRSYWRpYWwoZGVmcywgY3gsIGN5LCByLCBmeCwgZnkpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IFNuYXAuXy5tYWtlKFwicmFkaWFsR3JhZGllbnRcIiwgZGVmcyk7XG4gICAgICAgICAgICBlbC5zdG9wcyA9IEdzdG9wcztcbiAgICAgICAgICAgIGVsLmFkZFN0b3AgPSBHYWRkU3RvcDtcbiAgICAgICAgICAgIGVsLmdldEJCb3ggPSBHZ2V0QkJveDtcbiAgICAgICAgICAgIGlmIChjeCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgJChlbC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgICAgICByOiByXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnggIT0gbnVsbCAmJiBmeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgJChlbC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ4OiBmeCxcbiAgICAgICAgICAgICAgICAgICAgZnk6IGZ5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBQYXBlci5ncmFkaWVudFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgICAgICoqXG4gICAgICAgICAtIGdyYWRpZW50IChzdHJpbmcpIGdyYWRpZW50IGRlc2NyaXB0b3JcbiAgICAgICAgID4gR3JhZGllbnQgRGVzY3JpcHRvclxuICAgICAgICAgKiBUaGUgZ3JhZGllbnQgZGVzY3JpcHRvciBpcyBhbiBleHByZXNzaW9uIGZvcm1hdHRlZCBhc1xuICAgICAgICAgKiBmb2xsb3dzOiBgPHR5cGU+KDxjb29yZHM+KTxjb2xvcnM+YC4gIFRoZSBgPHR5cGU+YCBjYW4gYmVcbiAgICAgICAgICogZWl0aGVyIGxpbmVhciBvciByYWRpYWwuICBUaGUgdXBwZXJjYXNlIGBMYCBvciBgUmAgbGV0dGVyc1xuICAgICAgICAgKiBpbmRpY2F0ZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvZmZzZXQgZnJvbSB0aGUgU1ZHIHN1cmZhY2UuXG4gICAgICAgICAqIExvd2VyY2FzZSBgbGAgb3IgYHJgIGxldHRlcnMgaW5kaWNhdGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICogY2FsY3VsYXRlZCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgZ3JhZGllbnQgaXNcbiAgICAgICAgICogYXBwbGllZC4gIENvb3JkaW5hdGVzIHNwZWNpZnkgYSBsaW5lYXIgZ3JhZGllbnQgdmVjdG9yIGFzXG4gICAgICAgICAqIGB4MWAsIGB5MWAsIGB4MmAsIGB5MmAsIG9yIGEgcmFkaWFsIGdyYWRpZW50IGFzIGBjeGAsIGBjeWAsXG4gICAgICAgICAqIGByYCBhbmQgb3B0aW9uYWwgYGZ4YCwgYGZ5YCBzcGVjaWZ5aW5nIGEgZm9jYWwgcG9pbnQgYXdheVxuICAgICAgICAgKiBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZS4gU3BlY2lmeSBgPGNvbG9ycz5gIGFzIGEgbGlzdFxuICAgICAgICAgKiBvZiBkYXNoLXNlcGFyYXRlZCBDU1MgY29sb3IgdmFsdWVzLiAgRWFjaCBjb2xvciBtYXkgYmVcbiAgICAgICAgICogZm9sbG93ZWQgYnkgYSBjdXN0b20gb2Zmc2V0IHZhbHVlLCBzZXBhcmF0ZWQgd2l0aCBhIGNvbG9uXG4gICAgICAgICAqIGNoYXJhY3Rlci5cbiAgICAgICAgID4gRXhhbXBsZXNcbiAgICAgICAgICogTGluZWFyIGdyYWRpZW50LCByZWxhdGl2ZSBmcm9tIHRvcC1sZWZ0IGNvcm5lciB0byBib3R0b20tcmlnaHRcbiAgICAgICAgICogY29ybmVyLCBmcm9tIGJsYWNrIHRocm91Z2ggcmVkIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwibCgwLCAwLCAxLCAxKSMwMDAtI2YwMC0jZmZmXCIpO1xuICAgICAgICAgKiBMaW5lYXIgZ3JhZGllbnQsIGFic29sdXRlIGZyb20gKDAsIDApIHRvICgxMDAsIDEwMCksIGZyb20gYmxhY2tcbiAgICAgICAgICogdGhyb3VnaCByZWQgYXQgMjUlIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwiTCgwLCAwLCAxMDAsIDEwMCkjMDAwLSNmMDA6MjUtI2ZmZlwiKTtcbiAgICAgICAgICogUmFkaWFsIGdyYWRpZW50LCByZWxhdGl2ZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQgd2l0aCByYWRpdXNcbiAgICAgICAgICogaGFsZiB0aGUgd2lkdGgsIGZyb20gYmxhY2sgdG8gd2hpdGU6XG4gICAgICAgICB8IHZhciBnID0gcGFwZXIuZ3JhZGllbnQoXCJyKDAuNSwgMC41LCAwLjUpIzAwMC0jZmZmXCIpO1xuICAgICAgICAgKiBUbyBhcHBseSB0aGUgZ3JhZGllbnQ6XG4gICAgICAgICB8IHBhcGVyLmNpcmNsZSg1MCwgNTAsIDQwKS5hdHRyKHtcbiAgICAgICAgIHwgICAgIGZpbGw6IGdcbiAgICAgICAgIHwgfSk7XG4gICAgICAgICA9IChvYmplY3QpIHRoZSBgZ3JhZGllbnRgIGVsZW1lbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBwcm90by5ncmFkaWVudCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBncmFkaWVudCh0aGlzLmRlZnMsIHN0cik7XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvLmdyYWRpZW50TGluZWFyID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnRMaW5lYXIodGhpcy5kZWZzLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvLmdyYWRpZW50UmFkaWFsID0gZnVuY3Rpb24gKGN4LCBjeSwgciwgZngsIGZ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnRSYWRpYWwodGhpcy5kZWZzLCBjeCwgY3ksIHIsIGZ4LCBmeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogUGFwZXIudG9TdHJpbmdcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgU1ZHIGNvZGUgZm9yIHRoZSBAUGFwZXJcbiAgICAgICAgID0gKHN0cmluZykgU1ZHIGNvZGUgZm9yIHRoZSBAUGFwZXJcbiAgICAgICAgXFwqL1xuICAgICAgICBwcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm5vZGUub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICBmID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgICAgICBkID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICAgICAgc3ZnID0gdGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICBmLmFwcGVuZENoaWxkKGQpO1xuICAgICAgICAgICAgZC5hcHBlbmRDaGlsZChzdmcpO1xuICAgICAgICAgICAgU25hcC5fLiQoc3ZnLCB7eG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0pO1xuICAgICAgICAgICAgcmVzID0gZC5pbm5lckhUTUw7XG4gICAgICAgICAgICBmLnJlbW92ZUNoaWxkKGYuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIFBhcGVyLnRvRGF0YVVSTFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBTVkcgY29kZSBmb3IgdGhlIEBQYXBlciBhcyBEYXRhIFVSSSBzdHJpbmcuXG4gICAgICAgICA9IChzdHJpbmcpIERhdGEgVVJJIHN0cmluZ1xuICAgICAgICBcXCovXG4gICAgICAgIHByb3RvLnRvRGF0YVVSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cgJiYgd2luZG93LmJ0b2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodGhpcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBQYXBlci5jbGVhclxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgY2hpbGQgbm9kZXMgb2YgdGhlIHBhcGVyLCBleGNlcHQgPGRlZnM+LlxuICAgICAgICBcXCovXG4gICAgICAgIHByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lICE9IFwiZGVmc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm90by5jbGVhci5jYWxsKHtub2RlOiBub2RlfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0oKSk7XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLyBcbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iKSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBjbG9uZSA9IFNuYXAuXy5jbG9uZSxcbiAgICAgICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICBwMnMgPSAvLD8oW2Etel0pLD8vZ2ksXG4gICAgICAgIHRvRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgICBtYXRoID0gTWF0aCxcbiAgICAgICAgUEkgPSBtYXRoLlBJLFxuICAgICAgICBtbWluID0gbWF0aC5taW4sXG4gICAgICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICAgICAgcG93ID0gbWF0aC5wb3csXG4gICAgICAgIGFicyA9IG1hdGguYWJzO1xuICAgIGZ1bmN0aW9uIHBhdGhzKHBzKSB7XG4gICAgICAgIHZhciBwID0gcGF0aHMucHMgPSBwYXRocy5wcyB8fCB7fTtcbiAgICAgICAgaWYgKHBbcHNdKSB7XG4gICAgICAgICAgICBwW3BzXS5zbGVlcCA9IDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBbcHNdID0ge1xuICAgICAgICAgICAgICAgIHNsZWVwOiAxMDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcCkgaWYgKHBbaGFzXShrZXkpICYmIGtleSAhPSBwcykge1xuICAgICAgICAgICAgICAgIHBba2V5XS5zbGVlcC0tO1xuICAgICAgICAgICAgICAgICFwW2tleV0uc2xlZXAgJiYgZGVsZXRlIHBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwW3BzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm94KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHkgPSB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHdpZHRoID0geC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgaDogaGVpZ2h0LFxuICAgICAgICAgICAgeDI6IHggKyB3aWR0aCxcbiAgICAgICAgICAgIHkyOiB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgY3g6IHggKyB3aWR0aCAvIDIsXG4gICAgICAgICAgICBjeTogeSArIGhlaWdodCAvIDIsXG4gICAgICAgICAgICByMTogbWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgcjI6IG1hdGgubWF4KHdpZHRoLCBoZWlnaHQpIC8gMixcbiAgICAgICAgICAgIHIwOiBtYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgcGF0aDogcmVjdFBhdGgoeCwgeSwgd2lkdGgsIGhlaWdodCksXG4gICAgICAgICAgICB2YjogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oXCIgXCIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKFwiLFwiKS5yZXBsYWNlKHAycywgXCIkMVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aENsb25lKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcmVzID0gY2xvbmUocGF0aEFycmF5KTtcbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYmV6bGVuKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kRG90c0F0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSxcbiAgICAgICAgICAgICAgICBnZXRUb3RMZW4ocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIGxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExlbmd0aEZhY3RvcnkoaXN0b3RhbCwgc3VicGF0aCkge1xuICAgICAgICBmdW5jdGlvbiBPKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICsoK3ZhbCkudG9GaXhlZCgzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5fLmNhY2hlcihmdW5jdGlvbiAocGF0aCwgbGVuZ3RoLCBvbmx5c3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChwYXRoIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLmF0dHIoXCJkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgICAgICB2YXIgeCwgeSwgcCwgbCwgc3AgPSBcIlwiLCBzdWJwYXRocyA9IHt9LCBwb2ludCxcbiAgICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gK3BbMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuICsgbCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnBhdGggJiYgIXN1YnBhdGhzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBnZXRQb2ludEF0U2VnbWVudExlbmd0aCh4LCB5LCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCBwWzZdLCBsZW5ndGggLSBsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwICs9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDXCIgKyBPKHBvaW50LnN0YXJ0LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LnN0YXJ0LnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50Lm0ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQubS55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC55KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlzdGFydCkge3JldHVybiBzcDt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicGF0aHMuc3RhcnQgPSBzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNXCIgKyBPKHBvaW50LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LnkpICsgXCJDXCIgKyBPKHBvaW50Lm4ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQubi55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC5lbmQueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQuZW5kLnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBbNV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBbNl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuICs9IGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArcFs2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXN0b3RhbCAmJiAhc3VicGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gZ2V0UG9pbnRBdFNlZ21lbnRMZW5ndGgoeCwgeSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgcFs2XSwgbGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IGw7XG4gICAgICAgICAgICAgICAgICAgIHggPSArcFs1XTtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICtwWzZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcCArPSBwLnNoaWZ0KCkgKyBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicGF0aHMuZW5kID0gc3A7XG4gICAgICAgICAgICBwb2ludCA9IGlzdG90YWwgPyBsZW4gOiBzdWJwYXRoID8gc3VicGF0aHMgOiBmaW5kRG90c0F0U2VnbWVudCh4LCB5LCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSwgbnVsbCwgU25hcC5fLmNsb25lKTtcbiAgICB9XG4gICAgdmFyIGdldFRvdGFsTGVuZ3RoID0gZ2V0TGVuZ3RoRmFjdG9yeSgxKSxcbiAgICAgICAgZ2V0UG9pbnRBdExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoKSxcbiAgICAgICAgZ2V0U3VicGF0aHNBdExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoMCwgMSk7XG4gICAgZnVuY3Rpb24gZmluZERvdHNBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQpIHtcbiAgICAgICAgdmFyIHQxID0gMSAtIHQsXG4gICAgICAgICAgICB0MTMgPSBwb3codDEsIDMpLFxuICAgICAgICAgICAgdDEyID0gcG93KHQxLCAyKSxcbiAgICAgICAgICAgIHQyID0gdCAqIHQsXG4gICAgICAgICAgICB0MyA9IHQyICogdCxcbiAgICAgICAgICAgIHggPSB0MTMgKiBwMXggKyB0MTIgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgdDMgKiBwMngsXG4gICAgICAgICAgICB5ID0gdDEzICogcDF5ICsgdDEyICogMyAqIHQgKiBjMXkgKyB0MSAqIDMgKiB0ICogdCAqIGMyeSArIHQzICogcDJ5LFxuICAgICAgICAgICAgbXggPSBwMXggKyAyICogdCAqIChjMXggLSBwMXgpICsgdDIgKiAoYzJ4IC0gMiAqIGMxeCArIHAxeCksXG4gICAgICAgICAgICBteSA9IHAxeSArIDIgKiB0ICogKGMxeSAtIHAxeSkgKyB0MiAqIChjMnkgLSAyICogYzF5ICsgcDF5KSxcbiAgICAgICAgICAgIG54ID0gYzF4ICsgMiAqIHQgKiAoYzJ4IC0gYzF4KSArIHQyICogKHAyeCAtIDIgKiBjMnggKyBjMXgpLFxuICAgICAgICAgICAgbnkgPSBjMXkgKyAyICogdCAqIChjMnkgLSBjMXkpICsgdDIgKiAocDJ5IC0gMiAqIGMyeSArIGMxeSksXG4gICAgICAgICAgICBheCA9IHQxICogcDF4ICsgdCAqIGMxeCxcbiAgICAgICAgICAgIGF5ID0gdDEgKiBwMXkgKyB0ICogYzF5LFxuICAgICAgICAgICAgY3ggPSB0MSAqIGMyeCArIHQgKiBwMngsXG4gICAgICAgICAgICBjeSA9IHQxICogYzJ5ICsgdCAqIHAyeSxcbiAgICAgICAgICAgIGFscGhhID0gKDkwIC0gbWF0aC5hdGFuMihteCAtIG54LCBteSAtIG55KSAqIDE4MCAvIFBJKTtcbiAgICAgICAgLy8gKG14ID4gbnggfHwgbXkgPCBueSkgJiYgKGFscGhhICs9IDE4MCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIG06IHt4OiBteCwgeTogbXl9LFxuICAgICAgICAgICAgbjoge3g6IG54LCB5OiBueX0sXG4gICAgICAgICAgICBzdGFydDoge3g6IGF4LCB5OiBheX0sXG4gICAgICAgICAgICBlbmQ6IHt4OiBjeCwgeTogY3l9LFxuICAgICAgICAgICAgYWxwaGE6IGFscGhhXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJlemllckJCb3gocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnkpIHtcbiAgICAgICAgaWYgKCFTbmFwLmlzKHAxeCwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgcDF4ID0gW3AxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmJveCA9IGN1cnZlRGltLmFwcGx5KG51bGwsIHAxeCk7XG4gICAgICAgIHJldHVybiBib3goXG4gICAgICAgICAgICBiYm94Lm1pbi54LFxuICAgICAgICAgICAgYmJveC5taW4ueSxcbiAgICAgICAgICAgIGJib3gubWF4LnggLSBiYm94Lm1pbi54LFxuICAgICAgICAgICAgYmJveC5tYXgueSAtIGJib3gubWluLnlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gIHggPj0gYmJveC54ICYmXG4gICAgICAgICAgICAgICAgeCA8PSBiYm94LnggKyBiYm94LndpZHRoICYmXG4gICAgICAgICAgICAgICAgeSA+PSBiYm94LnkgJiZcbiAgICAgICAgICAgICAgICB5IDw9IGJib3gueSArIGJib3guaGVpZ2h0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0JCb3hJbnRlcnNlY3QoYmJveDEsIGJib3gyKSB7XG4gICAgICAgIGJib3gxID0gYm94KGJib3gxKTtcbiAgICAgICAgYmJveDIgPSBib3goYmJveDIpO1xuICAgICAgICByZXR1cm4gaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueDIsIGJib3gxLnkpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueCwgYmJveDEueTIpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueDIsIGJib3gxLnkyKVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngsIGJib3gyLnkpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueDIsIGJib3gyLnkpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueCwgYmJveDIueTIpXG4gICAgICAgICAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueDIsIGJib3gyLnkyKVxuICAgICAgICAgICAgfHwgKGJib3gxLnggPCBiYm94Mi54MiAmJiBiYm94MS54ID4gYmJveDIueFxuICAgICAgICAgICAgICAgIHx8IGJib3gyLnggPCBiYm94MS54MiAmJiBiYm94Mi54ID4gYmJveDEueClcbiAgICAgICAgICAgICYmIChiYm94MS55IDwgYmJveDIueTIgJiYgYmJveDEueSA+IGJib3gyLnlcbiAgICAgICAgICAgICAgICB8fCBiYm94Mi55IDwgYmJveDEueTIgJiYgYmJveDIueSA+IGJib3gxLnkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNlMyh0LCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICB2YXIgdDEgPSAtMyAqIHAxICsgOSAqIHAyIC0gOSAqIHAzICsgMyAqIHA0LFxuICAgICAgICAgICAgdDIgPSB0ICogdDEgKyA2ICogcDEgLSAxMiAqIHAyICsgNiAqIHAzO1xuICAgICAgICByZXR1cm4gdCAqIHQyIC0gMyAqIHAxICsgMyAqIHAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB6KSB7XG4gICAgICAgIGlmICh6ID09IG51bGwpIHtcbiAgICAgICAgICAgIHogPSAxO1xuICAgICAgICB9XG4gICAgICAgIHogPSB6ID4gMSA/IDEgOiB6IDwgMCA/IDAgOiB6O1xuICAgICAgICB2YXIgejIgPSB6IC8gMixcbiAgICAgICAgICAgIG4gPSAxMixcbiAgICAgICAgICAgIFR2YWx1ZXMgPSBbLS4xMjUyLC4xMjUyLC0uMzY3OCwuMzY3OCwtLjU4NzMsLjU4NzMsLS43Njk5LC43Njk5LC0uOTA0MSwuOTA0MSwtLjk4MTYsLjk4MTZdLFxuICAgICAgICAgICAgQ3ZhbHVlcyA9IFswLjI0OTEsMC4yNDkxLDAuMjMzNSwwLjIzMzUsMC4yMDMyLDAuMjAzMiwwLjE2MDEsMC4xNjAxLDAuMTA2OSwwLjEwNjksMC4wNDcyLDAuMDQ3Ml0sXG4gICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGN0ID0gejIgKiBUdmFsdWVzW2ldICsgejIsXG4gICAgICAgICAgICAgICAgeGJhc2UgPSBiYXNlMyhjdCwgeDEsIHgyLCB4MywgeDQpLFxuICAgICAgICAgICAgICAgIHliYXNlID0gYmFzZTMoY3QsIHkxLCB5MiwgeTMsIHk0KSxcbiAgICAgICAgICAgICAgICBjb21iID0geGJhc2UgKiB4YmFzZSArIHliYXNlICogeWJhc2U7XG4gICAgICAgICAgICBzdW0gKz0gQ3ZhbHVlc1tpXSAqIG1hdGguc3FydChjb21iKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gejIgKiBzdW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRvdExlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGxsKSB7XG4gICAgICAgIGlmIChsbCA8IDAgfHwgYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCkgPCBsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gMSxcbiAgICAgICAgICAgIHN0ZXAgPSB0IC8gMixcbiAgICAgICAgICAgIHQyID0gdCAtIHN0ZXAsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZSA9IC4wMTtcbiAgICAgICAgbCA9IGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHQyKTtcbiAgICAgICAgd2hpbGUgKGFicyhsIC0gbGwpID4gZSkge1xuICAgICAgICAgICAgc3RlcCAvPSAyO1xuICAgICAgICAgICAgdDIgKz0gKGwgPCBsbCA/IDEgOiAtMSkgKiBzdGVwO1xuICAgICAgICAgICAgbCA9IGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHQyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyc2VjdCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbW1heCh4MSwgeDIpIDwgbW1pbih4MywgeDQpIHx8XG4gICAgICAgICAgICBtbWluKHgxLCB4MikgPiBtbWF4KHgzLCB4NCkgfHxcbiAgICAgICAgICAgIG1tYXgoeTEsIHkyKSA8IG1taW4oeTMsIHk0KSB8fFxuICAgICAgICAgICAgbW1pbih5MSwgeTIpID4gbW1heCh5MywgeTQpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBueCA9ICh4MSAqIHkyIC0geTEgKiB4MikgKiAoeDMgLSB4NCkgLSAoeDEgLSB4MikgKiAoeDMgKiB5NCAtIHkzICogeDQpLFxuICAgICAgICAgICAgbnkgPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gKHgxIC0geDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzIC0geDQpO1xuXG4gICAgICAgIGlmICghZGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHggPSBueCAvIGRlbm9taW5hdG9yLFxuICAgICAgICAgICAgcHkgPSBueSAvIGRlbm9taW5hdG9yLFxuICAgICAgICAgICAgcHgyID0gK3B4LnRvRml4ZWQoMiksXG4gICAgICAgICAgICBweTIgPSArcHkudG9GaXhlZCgyKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcHgyIDwgK21taW4oeDEsIHgyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweDIgPiArbW1heCh4MSwgeDIpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB4MiA8ICttbWluKHgzLCB4NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHgyID4gK21tYXgoeDMsIHg0KS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweTIgPCArbW1pbih5MSwgeTIpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB5MiA+ICttbWF4KHkxLCB5MikudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyIDwgK21taW4oeTMsIHk0KS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweTIgPiArbW1heCh5MywgeTQpLnRvRml4ZWQoMilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt4OiBweCwgeTogcHl9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcihiZXoxLCBiZXoyKSB7XG4gICAgICAgIHJldHVybiBpbnRlckhlbHBlcihiZXoxLCBiZXoyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJDb3VudChiZXoxLCBiZXoyKSB7XG4gICAgICAgIHJldHVybiBpbnRlckhlbHBlcihiZXoxLCBiZXoyLCAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJIZWxwZXIoYmV6MSwgYmV6MiwganVzdENvdW50KSB7XG4gICAgICAgIHZhciBiYm94MSA9IGJlemllckJCb3goYmV6MSksXG4gICAgICAgICAgICBiYm94MiA9IGJlemllckJCb3goYmV6Mik7XG4gICAgICAgIGlmICghaXNCQm94SW50ZXJzZWN0KGJib3gxLCBiYm94MikpIHtcbiAgICAgICAgICAgIHJldHVybiBqdXN0Q291bnQgPyAwIDogW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGwxID0gYmV6bGVuLmFwcGx5KDAsIGJlejEpLFxuICAgICAgICAgICAgbDIgPSBiZXpsZW4uYXBwbHkoMCwgYmV6MiksXG4gICAgICAgICAgICBuMSA9IH5+KGwxIC8gOCksXG4gICAgICAgICAgICBuMiA9IH5+KGwyIC8gOCksXG4gICAgICAgICAgICBkb3RzMSA9IFtdLFxuICAgICAgICAgICAgZG90czIgPSBbXSxcbiAgICAgICAgICAgIHh5ID0ge30sXG4gICAgICAgICAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjEgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoMCwgYmV6MS5jb25jYXQoaSAvIG4xKSk7XG4gICAgICAgICAgICBkb3RzMS5wdXNoKHt4OiBwLngsIHk6IHAueSwgdDogaSAvIG4xfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG4yICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBwID0gZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoMCwgYmV6Mi5jb25jYXQoaSAvIG4yKSk7XG4gICAgICAgICAgICBkb3RzMi5wdXNoKHt4OiBwLngsIHk6IHAueSwgdDogaSAvIG4yfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG4xOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjI7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBkaSA9IGRvdHMxW2ldLFxuICAgICAgICAgICAgICAgICAgICBkaTEgPSBkb3RzMVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGRqID0gZG90czJbal0sXG4gICAgICAgICAgICAgICAgICAgIGRqMSA9IGRvdHMyW2ogKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgY2kgPSBhYnMoZGkxLnggLSBkaS54KSA8IC4wMDEgPyBcInlcIiA6IFwieFwiLFxuICAgICAgICAgICAgICAgICAgICBjaiA9IGFicyhkajEueCAtIGRqLngpIDwgLjAwMSA/IFwieVwiIDogXCJ4XCIsXG4gICAgICAgICAgICAgICAgICAgIGlzID0gaW50ZXJzZWN0KGRpLngsIGRpLnksIGRpMS54LCBkaTEueSwgZGoueCwgZGoueSwgZGoxLngsIGRqMS55KTtcbiAgICAgICAgICAgICAgICBpZiAoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHh5W2lzLngudG9GaXhlZCg0KV0gPT0gaXMueS50b0ZpeGVkKDQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4eVtpcy54LnRvRml4ZWQoNCldID0gaXMueS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDEgPSBkaS50ICsgYWJzKChpc1tjaV0gLSBkaVtjaV0pIC8gKGRpMVtjaV0gLSBkaVtjaV0pKSAqIChkaTEudCAtIGRpLnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBkai50ICsgYWJzKChpc1tjal0gLSBkaltjal0pIC8gKGRqMVtjal0gLSBkaltjal0pKSAqIChkajEudCAtIGRqLnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxICYmIHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGp1c3RDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGlzLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGlzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxOiB0MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDI6IHQyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aEludGVyc2VjdGlvbihwYXRoMSwgcGF0aDIpIHtcbiAgICAgICAgcmV0dXJuIGludGVyUGF0aEhlbHBlcihwYXRoMSwgcGF0aDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXRoSW50ZXJzZWN0aW9uTnVtYmVyKHBhdGgxLCBwYXRoMikge1xuICAgICAgICByZXR1cm4gaW50ZXJQYXRoSGVscGVyKHBhdGgxLCBwYXRoMiwgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyUGF0aEhlbHBlcihwYXRoMSwgcGF0aDIsIGp1c3RDb3VudCkge1xuICAgICAgICBwYXRoMSA9IHBhdGgyY3VydmUocGF0aDEpO1xuICAgICAgICBwYXRoMiA9IHBhdGgyY3VydmUocGF0aDIpO1xuICAgICAgICB2YXIgeDEsIHkxLCB4MiwgeTIsIHgxbSwgeTFtLCB4Mm0sIHkybSwgYmV6MSwgYmV6MixcbiAgICAgICAgICAgIHJlcyA9IGp1c3RDb3VudCA/IDAgOiBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aDEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBpID0gcGF0aDFbaV07XG4gICAgICAgICAgICBpZiAocGlbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICB4MSA9IHgxbSA9IHBpWzFdO1xuICAgICAgICAgICAgICAgIHkxID0geTFtID0gcGlbMl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwaVswXSA9PSBcIkNcIikge1xuICAgICAgICAgICAgICAgICAgICBiZXoxID0gW3gxLCB5MV0uY29uY2F0KHBpLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBiZXoxWzZdO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IGJlejFbN107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmV6MSA9IFt4MSwgeTEsIHgxLCB5MSwgeDFtLCB5MW0sIHgxbSwgeTFtXTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSB4MW07XG4gICAgICAgICAgICAgICAgICAgIHkxID0geTFtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBwYXRoMi5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaiA9IHBhdGgyW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGpbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geDJtID0gcGpbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHkybSA9IHBqWzJdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBqWzBdID09IFwiQ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmV6MiA9IFt4MiwgeTJdLmNvbmNhdChwai5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBiZXoyWzZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gYmV6Mls3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmV6MiA9IFt4MiwgeTIsIHgyLCB5MiwgeDJtLCB5Mm0sIHgybSwgeTJtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgybTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHkybTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRyID0gaW50ZXJIZWxwZXIoYmV6MSwgYmV6MiwganVzdENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqdXN0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gaW50cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gaW50ci5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uc2VnbWVudDEgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQyID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50cltrXS5iZXoxID0gYmV6MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50cltrXS5iZXoyID0gYmV6MjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChpbnRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1BvaW50SW5zaWRlUGF0aChwYXRoLCB4LCB5KSB7XG4gICAgICAgIHZhciBiYm94ID0gcGF0aEJCb3gocGF0aCk7XG4gICAgICAgIHJldHVybiBpc1BvaW50SW5zaWRlQkJveChiYm94LCB4LCB5KSAmJlxuICAgICAgICAgICAgICAgaW50ZXJQYXRoSGVscGVyKHBhdGgsIFtbXCJNXCIsIHgsIHldLCBbXCJIXCIsIGJib3gueDIgKyAxMF1dLCAxKSAlIDIgPT0gMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aEJCb3gocGF0aCkge1xuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aCk7XG4gICAgICAgIGlmIChwdGguYmJveCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lKHB0aC5iYm94KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBib3goKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gcGF0aDJjdXJ2ZShwYXRoKTtcbiAgICAgICAgdmFyIHggPSAwLCBcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgWCA9IFtdLFxuICAgICAgICAgICAgWSA9IFtdLFxuICAgICAgICAgICAgcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBwID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGlmIChwWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBbMV07XG4gICAgICAgICAgICAgICAgeSA9IHBbMl07XG4gICAgICAgICAgICAgICAgWC5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIFkucHVzaCh5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGN1cnZlRGltKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgIFggPSBYLmNvbmNhdChkaW0ubWluLngsIGRpbS5tYXgueCk7XG4gICAgICAgICAgICAgICAgWSA9IFkuY29uY2F0KGRpbS5taW4ueSwgZGltLm1heC55KTtcbiAgICAgICAgICAgICAgICB4ID0gcFs1XTtcbiAgICAgICAgICAgICAgICB5ID0gcFs2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgeG1pbiA9IG1taW4uYXBwbHkoMCwgWCksXG4gICAgICAgICAgICB5bWluID0gbW1pbi5hcHBseSgwLCBZKSxcbiAgICAgICAgICAgIHhtYXggPSBtbWF4LmFwcGx5KDAsIFgpLFxuICAgICAgICAgICAgeW1heCA9IG1tYXguYXBwbHkoMCwgWSksXG4gICAgICAgICAgICBiYiA9IGJveCh4bWluLCB5bWluLCB4bWF4IC0geG1pbiwgeW1heCAtIHltaW4pO1xuICAgICAgICBwdGguYmJveCA9IGNsb25lKGJiKTtcbiAgICAgICAgcmV0dXJuIGJiO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN0UGF0aCh4LCB5LCB3LCBoLCByKSB7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIFtcIk1cIiwgK3ggKyAoK3IpLCB5XSxcbiAgICAgICAgICAgICAgICBbXCJsXCIsIHcgLSByICogMiwgMF0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByLCByLCAwLCAwLCAxLCByLCByXSxcbiAgICAgICAgICAgICAgICBbXCJsXCIsIDAsIGggLSByICogMl0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByLCByLCAwLCAwLCAxLCAtciwgcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCByICogMiAtIHcsIDBdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgLXIsIC1yXSxcbiAgICAgICAgICAgICAgICBbXCJsXCIsIDAsIHIgKiAyIC0gaF0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByLCByLCAwLCAwLCAxLCByLCAtcl0sXG4gICAgICAgICAgICAgICAgW1wielwiXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gW1tcIk1cIiwgeCwgeV0sIFtcImxcIiwgdywgMF0sIFtcImxcIiwgMCwgaF0sIFtcImxcIiwgLXcsIDBdLCBbXCJ6XCJdXTtcbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsbGlwc2VQYXRoKHgsIHksIHJ4LCByeSwgYSkge1xuICAgICAgICBpZiAoYSA9PSBudWxsICYmIHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ5ID0gcng7XG4gICAgICAgIH1cbiAgICAgICAgeCA9ICt4O1xuICAgICAgICB5ID0gK3k7XG4gICAgICAgIHJ4ID0gK3J4O1xuICAgICAgICByeSA9ICtyeTtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG4gICAgICAgICAgICAgICAgeDEgPSB4ICsgcnggKiBNYXRoLmNvcygtcnkgKiByYWQpLFxuICAgICAgICAgICAgICAgIHgyID0geCArIHJ4ICogTWF0aC5jb3MoLWEgKiByYWQpLFxuICAgICAgICAgICAgICAgIHkxID0geSArIHJ4ICogTWF0aC5zaW4oLXJ5ICogcmFkKSxcbiAgICAgICAgICAgICAgICB5MiA9IHkgKyByeCAqIE1hdGguc2luKC1hICogcmFkKSxcbiAgICAgICAgICAgICAgICByZXMgPSBbW1wiTVwiLCB4MSwgeTFdLCBbXCJBXCIsIHJ4LCByeCwgMCwgKyhhIC0gcnkgPiAxODApLCAwLCB4MiwgeTJdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IFtcbiAgICAgICAgICAgICAgICBbXCJNXCIsIHgsIHldLFxuICAgICAgICAgICAgICAgIFtcIm1cIiwgMCwgLXJ5XSxcbiAgICAgICAgICAgICAgICBbXCJhXCIsIHJ4LCByeSwgMCwgMSwgMSwgMCwgMiAqIHJ5XSxcbiAgICAgICAgICAgICAgICBbXCJhXCIsIHJ4LCByeSwgMCwgMSwgMSwgMCwgLTIgKiByeV0sXG4gICAgICAgICAgICAgICAgW1wielwiXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgdmFyIHVuaXQycHggPSBTbmFwLl91bml0MnB4LFxuICAgICAgICBnZXRQYXRoID0ge1xuICAgICAgICBwYXRoOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5hdHRyKFwicGF0aFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2lyY2xlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gdW5pdDJweChlbCk7XG4gICAgICAgICAgICByZXR1cm4gZWxsaXBzZVBhdGgoYXR0ci5jeCwgYXR0ci5jeSwgYXR0ci5yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZWxsaXBzZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHVuaXQycHgoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2VQYXRoKGF0dHIuY3ggfHwgMCwgYXR0ci5jeSB8fCAwLCBhdHRyLnJ4LCBhdHRyLnJ5KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHVuaXQycHgoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGF0dHIueCB8fCAwLCBhdHRyLnkgfHwgMCwgYXR0ci53aWR0aCwgYXR0ci5oZWlnaHQsIGF0dHIucngsIGF0dHIucnkpO1xuICAgICAgICB9LFxuICAgICAgICBpbWFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHVuaXQycHgoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGF0dHIueCB8fCAwLCBhdHRyLnkgfHwgMCwgYXR0ci53aWR0aCwgYXR0ci5oZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk1cIiArIFtlbC5hdHRyKFwieDFcIikgfHwgMCwgZWwuYXR0cihcInkxXCIpIHx8IDAsIGVsLmF0dHIoXCJ4MlwiKSwgZWwuYXR0cihcInkyXCIpXTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWxpbmU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTVwiICsgZWwuYXR0cihcInBvaW50c1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNXCIgKyBlbC5hdHRyKFwicG9pbnRzXCIpICsgXCJ6XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmx0OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBiYm94ID0gZWwubm9kZS5nZXRCQm94KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdFBhdGgoYmJveC54LCBiYm94LnksIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcGF0aFRvUmVsYXRpdmUocGF0aEFycmF5KSB7XG4gICAgICAgIHZhciBwdGggPSBwYXRocyhwYXRoQXJyYXkpLFxuICAgICAgICAgICAgbG93ZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZTtcbiAgICAgICAgaWYgKHB0aC5yZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLnJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFTbmFwLmlzKHBhdGhBcnJheSwgXCJhcnJheVwiKSB8fCAhU25hcC5pcyhwYXRoQXJyYXkgJiYgcGF0aEFycmF5WzBdLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBwYXRoQXJyYXkgPSBTbmFwLnBhcnNlUGF0aFN0cmluZyhwYXRoQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIHggPSAwLFxuICAgICAgICAgICAgeSA9IDAsXG4gICAgICAgICAgICBteCA9IDAsXG4gICAgICAgICAgICBteSA9IDAsXG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGlmIChwYXRoQXJyYXlbMF1bMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgIHggPSBwYXRoQXJyYXlbMF1bMV07XG4gICAgICAgICAgICB5ID0gcGF0aEFycmF5WzBdWzJdO1xuICAgICAgICAgICAgbXggPSB4O1xuICAgICAgICAgICAgbXkgPSB5O1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICAgIHJlcy5wdXNoKFtcIk1cIiwgeCwgeV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSBwYXRoQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIHIgPSByZXNbaV0gPSBbXSxcbiAgICAgICAgICAgICAgICBwYSA9IHBhdGhBcnJheVtpXTtcbiAgICAgICAgICAgIGlmIChwYVswXSAhPSBsb3dlckNhc2UuY2FsbChwYVswXSkpIHtcbiAgICAgICAgICAgICAgICByWzBdID0gbG93ZXJDYXNlLmNhbGwocGFbMF0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgclsyXSA9IHBhWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgclszXSA9IHBhWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls0XSA9IHBhWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls1XSA9IHBhWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls2XSA9ICsocGFbNl0gLSB4KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcls3XSA9ICsocGFbN10gLSB5KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gKyhwYVsxXSAtIHkpLnRvRml4ZWQoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gcGFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBteSA9IHBhWzJdO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDEsIGpqID0gcGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbal0gPSArKHBhW2pdIC0gKChqICUgMikgPyB4IDogeSkpLnRvRml4ZWQoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByID0gcmVzW2ldID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHBhWzBdID09IFwibVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG14ID0gcGFbMV0gKyB4O1xuICAgICAgICAgICAgICAgICAgICBteSA9IHBhWzJdICsgeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gcGEubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICByZXNbaV1ba10gPSBwYVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuID0gcmVzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzW2ldWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgICAgICAgICAgeCA9IG14O1xuICAgICAgICAgICAgICAgICAgICB5ID0gbXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICAgICAgICAgIHggKz0gK3Jlc1tpXVtsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICAgICAgeSArPSArcmVzW2ldW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB4ICs9ICtyZXNbaV1bbGVuIC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gK3Jlc1tpXVtsZW4gLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICAgICAgcHRoLnJlbCA9IHBhdGhDbG9uZShyZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXRoVG9BYnNvbHV0ZShwYXRoQXJyYXkpIHtcbiAgICAgICAgdmFyIHB0aCA9IHBhdGhzKHBhdGhBcnJheSk7XG4gICAgICAgIGlmIChwdGguYWJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5hYnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXMocGF0aEFycmF5LCBcImFycmF5XCIpIHx8ICFpcyhwYXRoQXJyYXkgJiYgcGF0aEFycmF5WzBdLCBcImFycmF5XCIpKSB7IC8vIHJvdWdoIGFzc3VtcHRpb25cbiAgICAgICAgICAgIHBhdGhBcnJheSA9IFNuYXAucGFyc2VQYXRoU3RyaW5nKHBhdGhBcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRoQXJyYXkgfHwgIXBhdGhBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbW1wiTVwiLCAwLCAwXV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgeCA9IDAsXG4gICAgICAgICAgICB5ID0gMCxcbiAgICAgICAgICAgIG14ID0gMCxcbiAgICAgICAgICAgIG15ID0gMCxcbiAgICAgICAgICAgIHN0YXJ0ID0gMCxcbiAgICAgICAgICAgIHBhMDtcbiAgICAgICAgaWYgKHBhdGhBcnJheVswXVswXSA9PSBcIk1cIikge1xuICAgICAgICAgICAgeCA9ICtwYXRoQXJyYXlbMF1bMV07XG4gICAgICAgICAgICB5ID0gK3BhdGhBcnJheVswXVsyXTtcbiAgICAgICAgICAgIG14ID0geDtcbiAgICAgICAgICAgIG15ID0geTtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgICAgICByZXNbMF0gPSBbXCJNXCIsIHgsIHldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcnogPSBwYXRoQXJyYXkubGVuZ3RoID09IDMgJiZcbiAgICAgICAgICAgIHBhdGhBcnJheVswXVswXSA9PSBcIk1cIiAmJlxuICAgICAgICAgICAgcGF0aEFycmF5WzFdWzBdLnRvVXBwZXJDYXNlKCkgPT0gXCJSXCIgJiZcbiAgICAgICAgICAgIHBhdGhBcnJheVsyXVswXS50b1VwcGVyQ2FzZSgpID09IFwiWlwiO1xuICAgICAgICBmb3IgKHZhciByLCBwYSwgaSA9IHN0YXJ0LCBpaSA9IHBhdGhBcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICByZXMucHVzaChyID0gW10pO1xuICAgICAgICAgICAgcGEgPSBwYXRoQXJyYXlbaV07XG4gICAgICAgICAgICBwYTAgPSBwYVswXTtcbiAgICAgICAgICAgIGlmIChwYTAgIT0gcGEwLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByWzBdID0gcGEwLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChyWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gcGFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByWzJdID0gcGFbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByWzNdID0gcGFbM107XG4gICAgICAgICAgICAgICAgICAgICAgICByWzRdID0gcGFbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICByWzVdID0gcGFbNV07XG4gICAgICAgICAgICAgICAgICAgICAgICByWzZdID0gK3BhWzZdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbN10gPSArcGFbN10gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gK3BhWzFdICsgeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICtwYVsxXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RzID0gW3gsIHldLmNvbmNhdChwYS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMiwgamogPSBkb3RzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RzW2pdID0gK2RvdHNbal0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdHNbKytqXSA9ICtkb3RzW2pdICsgeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoY2F0bXVsbFJvbTJiZXppZXIoZG90cywgY3J6KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdHMgPSBlbGxpcHNlUGF0aCh4LCB5LCBwYVsxXSwgcGFbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG90cy5wdXNoKGRvdHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChkb3RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChlbGxpcHNlUGF0aCh4LCB5LCBwYVsxXSwgcGFbMl0sIHBhWzNdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gW1wiVVwiXS5jb25jYXQocmVzW3Jlcy5sZW5ndGggLSAxXS5zbGljZSgtMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9ICtwYVsxXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBteSA9ICtwYVsyXSArIHk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2pdID0gK3BhW2pdICsgKChqICUgMikgPyB4IDogeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYTAgPT0gXCJSXCIpIHtcbiAgICAgICAgICAgICAgICBkb3RzID0gW3gsIHldLmNvbmNhdChwYS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoY2F0bXVsbFJvbTJiZXppZXIoZG90cywgY3J6KSk7XG4gICAgICAgICAgICAgICAgciA9IFtcIlJcIl0uY29uY2F0KHBhLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhMCA9PSBcIk9cIikge1xuICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBkb3RzID0gZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdKTtcbiAgICAgICAgICAgICAgICBkb3RzLnB1c2goZG90c1swXSk7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChkb3RzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGEwID09IFwiVVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdLCBwYVszXSkpO1xuICAgICAgICAgICAgICAgIHIgPSBbXCJVXCJdLmNvbmNhdChyZXNbcmVzLmxlbmd0aCAtIDFdLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBhLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcltrXSA9IHBhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhMCA9IHBhMC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHBhMCAhPSBcIk9cIikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICtteDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArbXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbXggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBteSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICAgICAgcHRoLmFicyA9IHBhdGhDbG9uZShyZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsMmMoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcTJjKHgxLCB5MSwgYXgsIGF5LCB4MiwgeTIpIHtcbiAgICAgICAgdmFyIF8xMyA9IDEgLyAzLFxuICAgICAgICAgICAgXzIzID0gMiAvIDM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgXzEzICogeDEgKyBfMjMgKiBheCxcbiAgICAgICAgICAgICAgICBfMTMgKiB5MSArIF8yMyAqIGF5LFxuICAgICAgICAgICAgICAgIF8xMyAqIHgyICsgXzIzICogYXgsXG4gICAgICAgICAgICAgICAgXzEzICogeTIgKyBfMjMgKiBheSxcbiAgICAgICAgICAgICAgICB4MixcbiAgICAgICAgICAgICAgICB5MlxuICAgICAgICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYTJjKHgxLCB5MSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHgyLCB5MiwgcmVjdXJzaXZlKSB7XG4gICAgICAgIC8vIGZvciBtb3JlIGluZm9ybWF0aW9uIG9mIHdoZXJlIHRoaXMgbWF0aCBjYW1lIGZyb20gdmlzaXQ6XG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICB2YXIgXzEyMCA9IFBJICogMTIwIC8gMTgwLFxuICAgICAgICAgICAgcmFkID0gUEkgLyAxODAgKiAoK2FuZ2xlIHx8IDApLFxuICAgICAgICAgICAgcmVzID0gW10sXG4gICAgICAgICAgICB4eSxcbiAgICAgICAgICAgIHJvdGF0ZSA9IFNuYXAuXy5jYWNoZXIoZnVuY3Rpb24gKHgsIHksIHJhZCkge1xuICAgICAgICAgICAgICAgIHZhciBYID0geCAqIG1hdGguY29zKHJhZCkgLSB5ICogbWF0aC5zaW4ocmFkKSxcbiAgICAgICAgICAgICAgICAgICAgWSA9IHggKiBtYXRoLnNpbihyYWQpICsgeSAqIG1hdGguY29zKHJhZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt4OiBYLCB5OiBZfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgeHkgPSByb3RhdGUoeDEsIHkxLCAtcmFkKTtcbiAgICAgICAgICAgIHgxID0geHkueDtcbiAgICAgICAgICAgIHkxID0geHkueTtcbiAgICAgICAgICAgIHh5ID0gcm90YXRlKHgyLCB5MiwgLXJhZCk7XG4gICAgICAgICAgICB4MiA9IHh5Lng7XG4gICAgICAgICAgICB5MiA9IHh5Lnk7XG4gICAgICAgICAgICB2YXIgY29zID0gbWF0aC5jb3MoUEkgLyAxODAgKiBhbmdsZSksXG4gICAgICAgICAgICAgICAgc2luID0gbWF0aC5zaW4oUEkgLyAxODAgKiBhbmdsZSksXG4gICAgICAgICAgICAgICAgeCA9ICh4MSAtIHgyKSAvIDIsXG4gICAgICAgICAgICAgICAgeSA9ICh5MSAtIHkyKSAvIDI7XG4gICAgICAgICAgICB2YXIgaCA9ICh4ICogeCkgLyAocnggKiByeCkgKyAoeSAqIHkpIC8gKHJ5ICogcnkpO1xuICAgICAgICAgICAgaWYgKGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaCA9IG1hdGguc3FydChoKTtcbiAgICAgICAgICAgICAgICByeCA9IGggKiByeDtcbiAgICAgICAgICAgICAgICByeSA9IGggKiByeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByeDIgPSByeCAqIHJ4LFxuICAgICAgICAgICAgICAgIHJ5MiA9IHJ5ICogcnksXG4gICAgICAgICAgICAgICAgayA9IChsYXJnZV9hcmNfZmxhZyA9PSBzd2VlcF9mbGFnID8gLTEgOiAxKSAqXG4gICAgICAgICAgICAgICAgICAgIG1hdGguc3FydChhYnMoKHJ4MiAqIHJ5MiAtIHJ4MiAqIHkgKiB5IC0gcnkyICogeCAqIHgpIC8gKHJ4MiAqIHkgKiB5ICsgcnkyICogeCAqIHgpKSksXG4gICAgICAgICAgICAgICAgY3ggPSBrICogcnggKiB5IC8gcnkgKyAoeDEgKyB4MikgLyAyLFxuICAgICAgICAgICAgICAgIGN5ID0gayAqIC1yeSAqIHggLyByeCArICh5MSArIHkyKSAvIDIsXG4gICAgICAgICAgICAgICAgZjEgPSBtYXRoLmFzaW4oKCh5MSAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKSxcbiAgICAgICAgICAgICAgICBmMiA9IG1hdGguYXNpbigoKHkyIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpO1xuXG4gICAgICAgICAgICBmMSA9IHgxIDwgY3ggPyBQSSAtIGYxIDogZjE7XG4gICAgICAgICAgICBmMiA9IHgyIDwgY3ggPyBQSSAtIGYyIDogZjI7XG4gICAgICAgICAgICBmMSA8IDAgJiYgKGYxID0gUEkgKiAyICsgZjEpO1xuICAgICAgICAgICAgZjIgPCAwICYmIChmMiA9IFBJICogMiArIGYyKTtcbiAgICAgICAgICAgIGlmIChzd2VlcF9mbGFnICYmIGYxID4gZjIpIHtcbiAgICAgICAgICAgICAgICBmMSA9IGYxIC0gUEkgKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzd2VlcF9mbGFnICYmIGYyID4gZjEpIHtcbiAgICAgICAgICAgICAgICBmMiA9IGYyIC0gUEkgKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZjEgPSByZWN1cnNpdmVbMF07XG4gICAgICAgICAgICBmMiA9IHJlY3Vyc2l2ZVsxXTtcbiAgICAgICAgICAgIGN4ID0gcmVjdXJzaXZlWzJdO1xuICAgICAgICAgICAgY3kgPSByZWN1cnNpdmVbM107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRmID0gZjIgLSBmMTtcbiAgICAgICAgaWYgKGFicyhkZikgPiBfMTIwKSB7XG4gICAgICAgICAgICB2YXIgZjJvbGQgPSBmMixcbiAgICAgICAgICAgICAgICB4Mm9sZCA9IHgyLFxuICAgICAgICAgICAgICAgIHkyb2xkID0geTI7XG4gICAgICAgICAgICBmMiA9IGYxICsgXzEyMCAqIChzd2VlcF9mbGFnICYmIGYyID4gZjEgPyAxIDogLTEpO1xuICAgICAgICAgICAgeDIgPSBjeCArIHJ4ICogbWF0aC5jb3MoZjIpO1xuICAgICAgICAgICAgeTIgPSBjeSArIHJ5ICogbWF0aC5zaW4oZjIpO1xuICAgICAgICAgICAgcmVzID0gYTJjKHgyLCB5MiwgcngsIHJ5LCBhbmdsZSwgMCwgc3dlZXBfZmxhZywgeDJvbGQsIHkyb2xkLCBbZjIsIGYyb2xkLCBjeCwgY3ldKTtcbiAgICAgICAgfVxuICAgICAgICBkZiA9IGYyIC0gZjE7XG4gICAgICAgIHZhciBjMSA9IG1hdGguY29zKGYxKSxcbiAgICAgICAgICAgIHMxID0gbWF0aC5zaW4oZjEpLFxuICAgICAgICAgICAgYzIgPSBtYXRoLmNvcyhmMiksXG4gICAgICAgICAgICBzMiA9IG1hdGguc2luKGYyKSxcbiAgICAgICAgICAgIHQgPSBtYXRoLnRhbihkZiAvIDQpLFxuICAgICAgICAgICAgaHggPSA0IC8gMyAqIHJ4ICogdCxcbiAgICAgICAgICAgIGh5ID0gNCAvIDMgKiByeSAqIHQsXG4gICAgICAgICAgICBtMSA9IFt4MSwgeTFdLFxuICAgICAgICAgICAgbTIgPSBbeDEgKyBoeCAqIHMxLCB5MSAtIGh5ICogYzFdLFxuICAgICAgICAgICAgbTMgPSBbeDIgKyBoeCAqIHMyLCB5MiAtIGh5ICogYzJdLFxuICAgICAgICAgICAgbTQgPSBbeDIsIHkyXTtcbiAgICAgICAgbTJbMF0gPSAyICogbTFbMF0gLSBtMlswXTtcbiAgICAgICAgbTJbMV0gPSAyICogbTFbMV0gLSBtMlsxXTtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFttMiwgbTMsIG00XS5jb25jYXQocmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IFttMiwgbTMsIG00XS5jb25jYXQocmVzKS5qb2luKCkuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgdmFyIG5ld3JlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXdyZXNbaV0gPSBpICUgMiA/IHJvdGF0ZShyZXNbaSAtIDFdLCByZXNbaV0sIHJhZCkueSA6IHJvdGF0ZShyZXNbaV0sIHJlc1tpICsgMV0sIHJhZCkueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdyZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZERvdEF0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgdCkge1xuICAgICAgICB2YXIgdDEgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBvdyh0MSwgMykgKiBwMXggKyBwb3codDEsIDIpICogMyAqIHQgKiBjMXggKyB0MSAqIDMgKiB0ICogdCAqIGMyeCArIHBvdyh0LCAzKSAqIHAyeCxcbiAgICAgICAgICAgIHk6IHBvdyh0MSwgMykgKiBwMXkgKyBwb3codDEsIDIpICogMyAqIHQgKiBjMXkgKyB0MSAqIDMgKiB0ICogdCAqIGMyeSArIHBvdyh0LCAzKSAqIHAyeVxuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXR1cm5zIGJvdW5kaW5nIGJveCBvZiBjdWJpYyBiZXppZXIgY3VydmUuXG4gICAgLy8gU291cmNlOiBodHRwOi8vYmxvZy5oYWNrZXJzLWNhZmUubmV0LzIwMDkvMDYvaG93LXRvLWNhbGN1bGF0ZS1iZXppZXItY3VydmVzLWJvdW5kaW5nLmh0bWxcbiAgICAvLyBPcmlnaW5hbCB2ZXJzaW9uOiBOSVNISU8gSGlyb2thenVcbiAgICAvLyBNb2RpZmljYXRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vdGltbzIyMzQ1XG4gICAgZnVuY3Rpb24gY3VydmVEaW0oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIHZhciB0dmFsdWVzID0gW10sXG4gICAgICAgICAgICBib3VuZHMgPSBbW10sIFtdXSxcbiAgICAgICAgICAgIGEsIGIsIGMsIHQsIHQxLCB0MiwgYjJhYywgc3FydGIyYWM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgICAgICAgICAgICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgICAgICAgICAgICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgICAgICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICAgICAgICAgICAgYyA9IDMgKiB5MSAtIDMgKiB5MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYnMoYSkgPCAxZS0xMikge1xuICAgICAgICAgICAgICAgIGlmIChhYnMoYikgPCAxZS0xMikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdCA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICAgICAgICAgIHNxcnRiMmFjID0gbWF0aC5zcXJ0KGIyYWMpO1xuICAgICAgICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICAgICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICAgICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCwgeSwgaiA9IHR2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICAgamxlbiA9IGosXG4gICAgICAgICAgICBtdDtcbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICAgICAgICBtdCA9IDEgLSB0O1xuICAgICAgICAgICAgYm91bmRzWzBdW2pdID0gKG10ICogbXQgKiBtdCAqIHgwKSArICgzICogbXQgKiBtdCAqIHQgKiB4MSkgKyAoMyAqIG10ICogdCAqIHQgKiB4MikgKyAodCAqIHQgKiB0ICogeDMpO1xuICAgICAgICAgICAgYm91bmRzWzFdW2pdID0gKG10ICogbXQgKiBtdCAqIHkwKSArICgzICogbXQgKiBtdCAqIHQgKiB5MSkgKyAoMyAqIG10ICogdCAqIHQgKiB5MikgKyAodCAqIHQgKiB0ICogeTMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gICAgICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgICAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgICAgICAgYm91bmRzWzBdLmxlbmd0aCA9IGJvdW5kc1sxXS5sZW5ndGggPSBqbGVuICsgMjtcblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluOiB7eDogbW1pbi5hcHBseSgwLCBib3VuZHNbMF0pLCB5OiBtbWluLmFwcGx5KDAsIGJvdW5kc1sxXSl9LFxuICAgICAgICAgIG1heDoge3g6IG1tYXguYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogbW1heC5hcHBseSgwLCBib3VuZHNbMV0pfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGgyY3VydmUocGF0aCwgcGF0aDIpIHtcbiAgICAgICAgdmFyIHB0aCA9ICFwYXRoMiAmJiBwYXRocyhwYXRoKTtcbiAgICAgICAgaWYgKCFwYXRoMiAmJiBwdGguY3VydmUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmN1cnZlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHBhdGhUb0Fic29sdXRlKHBhdGgpLFxuICAgICAgICAgICAgcDIgPSBwYXRoMiAmJiBwYXRoVG9BYnNvbHV0ZShwYXRoMiksXG4gICAgICAgICAgICBhdHRycyA9IHt4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbH0sXG4gICAgICAgICAgICBhdHRyczIgPSB7eDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGx9LFxuICAgICAgICAgICAgcHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgZCwgcGNvbSkge1xuICAgICAgICAgICAgICAgIHZhciBueCwgbnk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJDXCIsIGQueCwgZC55LCBkLngsIGQueSwgZC54LCBkLnldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhKHBhdGhbMF0gaW4ge1Q6IDEsIFE6IDF9KSAmJiAoZC5xeCA9IGQucXkgPSBudWxsKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuWCA9IHBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkLlkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQoYTJjLmFwcGx5KDAsIFtkLngsIGQueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwY29tID09IFwiQ1wiIHx8IHBjb20gPT0gXCJTXCIpIHsgLy8gSW4gXCJTXCIgY2FzZSB3ZSBoYXZlIHRvIHRha2UgaW50byBhY2NvdW50LCBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCBpcyBDL1MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggPSBkLnggKiAyIC0gZC5ieDsgICAgICAgICAgLy8gQW5kIHJlZmxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSBkLnkgKiAyIC0gZC5ieTsgICAgICAgICAgLy8gY29tbWFuZCdzIGNvbnRyb2wgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueSA9IGQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCIsIG54LCBueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJUXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGNvbSA9PSBcIlFcIiB8fCBwY29tID09IFwiVFwiKSB7IC8vIEluIFwiVFwiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgUS9ULlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBkLnggKiAyIC0gZC5xeDsgICAgICAgIC8vIEFuZCBtYWtlIGEgcmVmbGVjdGlvbiBzaW1pbGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IGQueSAqIDIgLSBkLnF5OyAgICAgICAgLy8gdG8gY2FzZSBcIlNcIi5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBzb21ldGhpbmcgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnF5ID0gZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KHEyYyhkLngsIGQueSwgZC5xeCwgZC5xeSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnF4ID0gcGF0aFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KHEyYyhkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSwgcGF0aFszXSwgcGF0aFs0XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChsMmMoZC54LCBkLnksIHBhdGhbMV0sIGQueSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBkLngsIHBhdGhbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGwyYyhkLngsIGQueSwgZC5YLCBkLlkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXhBcmMgPSBmdW5jdGlvbiAocHAsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHBbaV0ubGVuZ3RoID4gNykge1xuICAgICAgICAgICAgICAgICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGNvbXMxW2ldID0gXCJBXCI7IC8vIGlmIGNyZWF0ZWQgbXVsdGlwbGUgQzpzLCB0aGVpciBvcmlnaW5hbCBzZWcgaXMgc2F2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyICYmIChwY29tczJbaV0gPSBcIkFcIik7IC8vIHRoZSBzYW1lIGFzIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcC5zcGxpY2UoaSsrLCAwLCBbXCJDXCJdLmNvbmNhdChwaS5zcGxpY2UoMCwgNikpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlpID0gbW1heChwLmxlbmd0aCwgcDIgJiYgcDIubGVuZ3RoIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXhNID0gZnVuY3Rpb24gKHBhdGgxLCBwYXRoMiwgYTEsIGEyLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgxICYmIHBhdGgyICYmIHBhdGgxW2ldWzBdID09IFwiTVwiICYmIHBhdGgyW2ldWzBdICE9IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgyLnNwbGljZShpLCAwLCBbXCJNXCIsIGEyLngsIGEyLnldKTtcbiAgICAgICAgICAgICAgICAgICAgYTEuYnggPSAwO1xuICAgICAgICAgICAgICAgICAgICBhMS5ieSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGExLnggPSBwYXRoMVtpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYTEueSA9IHBhdGgxW2ldWzJdO1xuICAgICAgICAgICAgICAgICAgICBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGNvbXMxID0gW10sIC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwXG4gICAgICAgICAgICBwY29tczIgPSBbXSwgLy8gcGF0aCBjb21tYW5kcyBvZiBvcmlnaW5hbCBwYXRoIHAyXG4gICAgICAgICAgICBwZmlyc3QgPSBcIlwiLCAvLyB0ZW1wb3JhcnkgaG9sZGVyIGZvciBvcmlnaW5hbCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgIHBjb20gPSBcIlwiOyAvLyBob2xkZXIgZm9yIHByZXZpb3VzIHBhdGggY29tbWFuZCBvZiBvcmlnaW5hbCBwYXRoXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHBbaV0gJiYgKHBmaXJzdCA9IHBbaV1bMF0pOyAvLyBzYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG5cbiAgICAgICAgICAgIGlmIChwZmlyc3QgIT0gXCJDXCIpIC8vIEMgaXMgbm90IHNhdmVkIHlldCwgYmVjYXVzZSBpdCBtYXkgYmUgcmVzdWx0IG9mIGNvbnZlcnNpb25cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwY29tczFbaV0gPSBwZmlyc3Q7IC8vIFNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgICAgICBpICYmICggcGNvbSA9IHBjb21zMVtpIC0gMV0pOyAvLyBHZXQgcHJldmlvdXMgcGF0aCBjb21tYW5kIHBjb21cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBbaV0gPSBwcm9jZXNzUGF0aChwW2ldLCBhdHRycywgcGNvbSk7IC8vIFByZXZpb3VzIHBhdGggY29tbWFuZCBpcyBpbnB1dHRlZCB0byBwcm9jZXNzUGF0aFxuXG4gICAgICAgICAgICBpZiAocGNvbXMxW2ldICE9IFwiQVwiICYmIHBmaXJzdCA9PSBcIkNcIikgcGNvbXMxW2ldID0gXCJDXCI7IC8vIEEgaXMgdGhlIG9ubHkgY29tbWFuZFxuICAgICAgICAgICAgLy8gd2hpY2ggbWF5IHByb2R1Y2UgbXVsdGlwbGUgQzpzXG4gICAgICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IEMgaXMgYWxzbyBDIGluIG9yaWdpbmFsIHBhdGhcblxuICAgICAgICAgICAgZml4QXJjKHAsIGkpOyAvLyBmaXhBcmMgYWRkcyBhbHNvIHRoZSByaWdodCBhbW91bnQgb2YgQTpzIHRvIHBjb21zMVxuXG4gICAgICAgICAgICBpZiAocDIpIHsgLy8gdGhlIHNhbWUgcHJvY2VkdXJlcyBpcyBkb25lIHRvIHAyXG4gICAgICAgICAgICAgICAgcDJbaV0gJiYgKHBmaXJzdCA9IHAyW2ldWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAocGZpcnN0ICE9IFwiQ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBjb21zMltpXSA9IHBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgaSAmJiAocGNvbSA9IHBjb21zMltpIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwMltpXSA9IHByb2Nlc3NQYXRoKHAyW2ldLCBhdHRyczIsIHBjb20pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBjb21zMltpXSAhPSBcIkFcIiAmJiBwZmlyc3QgPT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGNvbXMyW2ldID0gXCJDXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZml4QXJjKHAyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpeE0ocCwgcDIsIGF0dHJzLCBhdHRyczIsIGkpO1xuICAgICAgICAgICAgZml4TShwMiwgcCwgYXR0cnMyLCBhdHRycywgaSk7XG4gICAgICAgICAgICB2YXIgc2VnID0gcFtpXSxcbiAgICAgICAgICAgICAgICBzZWcyID0gcDIgJiYgcDJbaV0sXG4gICAgICAgICAgICAgICAgc2VnbGVuID0gc2VnLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzZWcybGVuID0gcDIgJiYgc2VnMi5sZW5ndGg7XG4gICAgICAgICAgICBhdHRycy54ID0gc2VnW3NlZ2xlbiAtIDJdO1xuICAgICAgICAgICAgYXR0cnMueSA9IHNlZ1tzZWdsZW4gLSAxXTtcbiAgICAgICAgICAgIGF0dHJzLmJ4ID0gdG9GbG9hdChzZWdbc2VnbGVuIC0gNF0pIHx8IGF0dHJzLng7XG4gICAgICAgICAgICBhdHRycy5ieSA9IHRvRmxvYXQoc2VnW3NlZ2xlbiAtIDNdKSB8fCBhdHRycy55O1xuICAgICAgICAgICAgYXR0cnMyLmJ4ID0gcDIgJiYgKHRvRmxvYXQoc2VnMltzZWcybGVuIC0gNF0pIHx8IGF0dHJzMi54KTtcbiAgICAgICAgICAgIGF0dHJzMi5ieSA9IHAyICYmICh0b0Zsb2F0KHNlZzJbc2VnMmxlbiAtIDNdKSB8fCBhdHRyczIueSk7XG4gICAgICAgICAgICBhdHRyczIueCA9IHAyICYmIHNlZzJbc2VnMmxlbiAtIDJdO1xuICAgICAgICAgICAgYXR0cnMyLnkgPSBwMiAmJiBzZWcyW3NlZzJsZW4gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAyKSB7XG4gICAgICAgICAgICBwdGguY3VydmUgPSBwYXRoQ2xvbmUocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAyID8gW3AsIHAyXSA6IHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcFBhdGgocGF0aCwgbWF0cml4KSB7XG4gICAgICAgIGlmICghbWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCwgeSwgaSwgaiwgaWksIGpqLCBwYXRoaTtcbiAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoaSA9IHBhdGhbaV07XG4gICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhdGhpLmxlbmd0aDsgaiA8IGpqOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICB4ID0gbWF0cml4LngocGF0aGlbal0sIHBhdGhpW2ogKyAxXSk7XG4gICAgICAgICAgICAgICAgeSA9IG1hdHJpeC55KHBhdGhpW2pdLCBwYXRoaVtqICsgMV0pO1xuICAgICAgICAgICAgICAgIHBhdGhpW2pdID0geDtcbiAgICAgICAgICAgICAgICBwYXRoaVtqICsgMV0gPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8vIGh0dHA6Ly9zY2hlcGVycy5jYy9nZXR0aW5nLXRvLXRoZS1wb2ludFxuICAgIGZ1bmN0aW9uIGNhdG11bGxSb20yYmV6aWVyKGNycCwgeikge1xuICAgICAgICB2YXIgZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNycC5sZW5ndGg7IGlMZW4gLSAyICogIXogPiBpOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaSAtIDJdLCB5OiArY3JwW2kgLSAxXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogK2NycFtpXSwgICAgIHk6ICtjcnBbaSArIDFdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgKyAyXSwgeTogK2NycFtpICsgM119LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaSArIDRdLCB5OiArY3JwW2kgKyA1XX1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSB7eDogK2NycFtpTGVuIC0gMl0sIHk6ICtjcnBbaUxlbiAtIDFdfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlMZW4gLSA0ID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFszXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlMZW4gLSAyID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFsyXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgICAgICAgICAgICAgcFszXSA9IHt4OiArY3JwWzJdLCB5OiArY3JwWzNdfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpTGVuIC0gNCA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSBwWzJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IHt4OiArY3JwW2ldLCB5OiArY3JwW2kgKyAxXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5wdXNoKFtcIkNcIixcbiAgICAgICAgICAgICAgICAgICgtcFswXS54ICsgNiAqIHBbMV0ueCArIHBbMl0ueCkgLyA2LFxuICAgICAgICAgICAgICAgICAgKC1wWzBdLnkgKyA2ICogcFsxXS55ICsgcFsyXS55KSAvIDYsXG4gICAgICAgICAgICAgICAgICAocFsxXS54ICsgNiAqIHBbMl0ueCAtIHBbM10ueCkgLyA2LFxuICAgICAgICAgICAgICAgICAgKHBbMV0ueSArIDYqcFsyXS55IC0gcFszXS55KSAvIDYsXG4gICAgICAgICAgICAgICAgICBwWzJdLngsXG4gICAgICAgICAgICAgICAgICBwWzJdLnlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0XG4gICAgU25hcC5wYXRoID0gcGF0aHM7XG5cbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmdldFRvdGFsTGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGdpdmVuIHBhdGggaW4gcGl4ZWxzXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgKipcbiAgICAgPSAobnVtYmVyKSBsZW5ndGhcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFRvdGFsTGVuZ3RoID0gZ2V0VG90YWxMZW5ndGg7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5nZXRQb2ludEF0TGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gbGVuZ3RoIGFsb25nIHRoZSBnaXZlbiBwYXRoXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgLSBsZW5ndGggKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoLCBleGNsdWRpbmcgbm9uLXJlbmRlcmluZyBqdW1wc1xuICAgICAqKlxuICAgICA9IChvYmplY3QpIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSxcbiAgICAgbyAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlLFxuICAgICBvICAgICBhbHBoYTogKG51bWJlcikgYW5nbGUgb2YgZGVyaXZhdGl2ZVxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFBvaW50QXRMZW5ndGggPSBnZXRQb2ludEF0TGVuZ3RoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0U3VicGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgc3VicGF0aCBvZiBhIGdpdmVuIHBhdGggYmV0d2VlbiBnaXZlbiBzdGFydCBhbmQgZW5kIGxlbmd0aHNcbiAgICAgKipcbiAgICAgLSBwYXRoIChzdHJpbmcpIFNWRyBwYXRoIHN0cmluZ1xuICAgICAtIGZyb20gKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAtIHRvIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICoqXG4gICAgID0gKHN0cmluZykgcGF0aCBzdHJpbmcgZGVmaW5pdGlvbiBmb3IgdGhlIHNlZ21lbnRcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFN1YnBhdGggPSBmdW5jdGlvbiAocGF0aCwgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VG90YWxMZW5ndGgocGF0aCkgLSB0byA8IDFlLTYpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdWJwYXRoc0F0TGVuZ3RoKHBhdGgsIGZyb20pLmVuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IGdldFN1YnBhdGhzQXRMZW5ndGgocGF0aCwgdG8sIDEpO1xuICAgICAgICByZXR1cm4gZnJvbSA/IGdldFN1YnBhdGhzQXRMZW5ndGgoYSwgZnJvbSkuZW5kIDogYTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFRvdGFsTGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHBhdGggaW4gcGl4ZWxzIChvbmx5IHdvcmtzIGZvciBgcGF0aGAgZWxlbWVudHMpXG4gICAgID0gKG51bWJlcikgbGVuZ3RoXG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0VG90YWxMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aCgpL0VsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKTogSWYgYSA8cGF0aD4gaXMgYnJva2VuIGludG8gZGlmZmVyZW50IHNlZ21lbnRzLCBpcyB0aGUganVtcCBkaXN0YW5jZSB0byB0aGUgbmV3IGNvb3JkaW5hdGVzIHNldCBieSB0aGUgX01fIG9yIF9tXyBjb21tYW5kcyBjYWxjdWxhdGVkIGFzIHBhcnQgb2YgdGhlIHBhdGgncyB0b3RhbCBsZW5ndGg/XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gbGVuZ3RoIG9uIHRoZSBnaXZlbiBwYXRoIChvbmx5IHdvcmtzIGZvciBgcGF0aGAgZWxlbWVudHMpXG4gICAgICoqXG4gICAgIC0gbGVuZ3RoIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCwgZXhjbHVkaW5nIG5vbi1yZW5kZXJpbmcganVtcHNcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSxcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIGRlcml2YXRpdmVcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0UG9pbnRBdExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvaW50QXRMZW5ndGgodGhpcy5hdHRyKFwiZFwiKSwgbGVuZ3RoKTtcbiAgICB9O1xuICAgIC8vIFNJRVJSQSBFbGVtZW50LmdldFN1YnBhdGgoKTogU2ltaWxhciB0byB0aGUgcHJvYmxlbSBmb3IgRWxlbWVudC5nZXRQb2ludEF0TGVuZ3RoKCkuIFVuY2xlYXIgaG93IHRoaXMgd291bGQgd29yayBmb3IgYSBzZWdtZW50ZWQgcGF0aC4gT3ZlcmFsbCwgdGhlIGNvbmNlcHQgb2YgX3N1YnBhdGhfIGFuZCB3aGF0IEknbSBjYWxsaW5nIGEgX3NlZ21lbnRfIChzZXJpZXMgb2Ygbm9uLV9NXyBvciBfWl8gY29tbWFuZHMpIGlzIHVuY2xlYXIuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0U3VicGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBzdWJwYXRoIG9mIGEgZ2l2ZW4gZWxlbWVudCBmcm9tIGdpdmVuIHN0YXJ0IGFuZCBlbmQgbGVuZ3RocyAob25seSB3b3JrcyBmb3IgYHBhdGhgIGVsZW1lbnRzKVxuICAgICAqKlxuICAgICAtIGZyb20gKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAtIHRvIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICoqXG4gICAgID0gKHN0cmluZykgcGF0aCBzdHJpbmcgZGVmaW5pdGlvbiBmb3IgdGhlIHNlZ21lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5nZXRTdWJwYXRoID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBTbmFwLnBhdGguZ2V0U3VicGF0aCh0aGlzLmF0dHIoXCJkXCIpLCBmcm9tLCB0byk7XG4gICAgfTtcbiAgICBTbmFwLl8uYm94ID0gYm94O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZmluZERvdHNBdFNlZ21lbnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogRmluZHMgZG90IGNvb3JkaW5hdGVzIG9uIHRoZSBnaXZlbiBjdWJpYyBiZXppw6lyIGN1cnZlIGF0IHRoZSBnaXZlbiB0XG4gICAgIC0gcDF4IChudW1iZXIpIHggb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBjMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ5IChudW1iZXIpIHkgb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gcDJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHQgKG51bWJlcikgcG9zaXRpb24gb24gdGhlIGN1cnZlICgwLi4xKVxuICAgICA9IChvYmplY3QpIHBvaW50IGluZm9ybWF0aW9uIGluIGZvcm1hdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQsXG4gICAgIG8gICAgIG06IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBhbmNob3IsXG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgYW5jaG9yXG4gICAgIG8gICAgIH0sXG4gICAgIG8gICAgIG46IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYW5jaG9yLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBhbmNob3JcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgc3RhcnQ6IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgZW5kOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUsXG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIHRoZSBjdXJ2ZSBkZXJpdmF0aXZlIGF0IHRoZSBwb2ludFxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmZpbmREb3RzQXRTZWdtZW50ID0gZmluZERvdHNBdFNlZ21lbnQ7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5iZXppZXJCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBvZiBhIGdpdmVuIGN1YmljIGJlemnDqXIgY3VydmVcbiAgICAgLSBwMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gcDF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeCAobnVtYmVyKSB4IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAyeSAobnVtYmVyKSB5IG9mIHRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgICogb3JcbiAgICAgLSBiZXogKGFycmF5KSBhcnJheSBvZiBzaXggcG9pbnRzIGZvciBiZXppw6lyIGN1cnZlXG4gICAgID0gKG9iamVjdCkgYm91bmRpbmcgYm94XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCB0b3AgcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgeDI6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYm90dG9tIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHkyOiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB3aWR0aDogKG51bWJlcikgd2lkdGggb2YgdGhlIGJveCxcbiAgICAgbyAgICAgaGVpZ2h0OiAobnVtYmVyKSBoZWlnaHQgb2YgdGhlIGJveFxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmJlemllckJCb3ggPSBiZXppZXJCQm94O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguaXNQb2ludEluc2lkZUJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIGJvdW5kaW5nIGJveFxuICAgICAtIGJib3ggKHN0cmluZykgYm91bmRpbmcgYm94XG4gICAgIC0geCAoc3RyaW5nKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgIC0geSAoc3RyaW5nKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBwb2ludCBpcyBpbnNpZGVcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmlzUG9pbnRJbnNpZGVCQm94ID0gaXNQb2ludEluc2lkZUJCb3g7XG4gICAgU25hcC5jbG9zZXN0ID0gZnVuY3Rpb24gKHgsIHksIFgsIFkpIHtcbiAgICAgICAgdmFyIHIgPSAxMDAsXG4gICAgICAgICAgICBiID0gYm94KHggLSByIC8gMiwgeSAtIHIgLyAyLCByLCByKSxcbiAgICAgICAgICAgIGluc2lkZSA9IFtdLFxuICAgICAgICAgICAgZ2V0dGVyID0gWFswXS5oYXNPd25Qcm9wZXJ0eShcInhcIikgPyBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IFhbaV0ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogWFtpXS55XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IFhbaV0sXG4gICAgICAgICAgICAgICAgICAgIHk6IFlbaV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvdW5kID0gMDtcbiAgICAgICAgd2hpbGUgKHIgPD0gMWU2ICYmICFmb3VuZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gWC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHh5ID0gZ2V0dGVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpc1BvaW50SW5zaWRlQkJveChiLCB4eS54LCB4eS55KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGUucHVzaCh4eSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICByICo9IDI7XG4gICAgICAgICAgICAgICAgYiA9IGJveCh4IC0gciAvIDIsIHkgLSByIC8gMiwgciwgcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAociA9PSAxZTYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gSW5maW5pdHksXG4gICAgICAgICAgICByZXM7XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gaW5zaWRlLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsID0gU25hcC5sZW4oeCwgeSwgaW5zaWRlW2ldLngsIGluc2lkZVtpXS55KTtcbiAgICAgICAgICAgIGlmIChsZW4gPiBsKSB7XG4gICAgICAgICAgICAgICAgbGVuID0gbDtcbiAgICAgICAgICAgICAgICBpbnNpZGVbaV0ubGVuID0gbDtcbiAgICAgICAgICAgICAgICByZXMgPSBpbnNpZGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguaXNCQm94SW50ZXJzZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHR3byBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICAgLSBiYm94MSAoc3RyaW5nKSBmaXJzdCBib3VuZGluZyBib3hcbiAgICAgLSBiYm94MiAoc3RyaW5nKSBzZWNvbmQgYm91bmRpbmcgYm94XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmlzQkJveEludGVyc2VjdCA9IGlzQkJveEludGVyc2VjdDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmludGVyc2VjdGlvblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBGaW5kcyBpbnRlcnNlY3Rpb25zIG9mIHR3byBwYXRoc1xuICAgICAtIHBhdGgxIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0gcGF0aDIgKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgPSAoYXJyYXkpIGRvdHMgb2YgaW50ZXJzZWN0aW9uXG4gICAgIG8gW1xuICAgICBvICAgICB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCxcbiAgICAgbyAgICAgICAgIHQxOiAobnVtYmVyKSB0IHZhbHVlIGZvciBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgdDI6IChudW1iZXIpIHQgdmFsdWUgZm9yIHNlZ21lbnQgb2YgcGF0aDIsXG4gICAgIG8gICAgICAgICBzZWdtZW50MTogKG51bWJlcikgb3JkZXIgbnVtYmVyIGZvciBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgc2VnbWVudDI6IChudW1iZXIpIG9yZGVyIG51bWJlciBmb3Igc2VnbWVudCBvZiBwYXRoMixcbiAgICAgbyAgICAgICAgIGJlejE6IChhcnJheSkgZWlnaHQgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIGJlemnDqXIgY3VydmUgZm9yIHRoZSBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgYmV6MjogKGFycmF5KSBlaWdodCBjb29yZGluYXRlcyByZXByZXNlbnRpbmcgYmV6acOpciBjdXJ2ZSBmb3IgdGhlIHNlZ21lbnQgb2YgcGF0aDJcbiAgICAgbyAgICAgfVxuICAgICBvIF1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmludGVyc2VjdGlvbiA9IHBhdGhJbnRlcnNlY3Rpb247XG4gICAgU25hcC5wYXRoLmludGVyc2VjdGlvbk51bWJlciA9IHBhdGhJbnRlcnNlY3Rpb25OdW1iZXI7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5pc1BvaW50SW5zaWRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIHBvaW50IGlzIGluc2lkZSBhIGdpdmVuIGNsb3NlZCBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZTogZmlsbCBtb2RlIGRvZXNu4oCZdCBhZmZlY3QgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZC5cbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0geCAobnVtYmVyKSB4IG9mIHRoZSBwb2ludFxuICAgICAtIHkgKG51bWJlcikgeSBvZiB0aGUgcG9pbnRcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgcGF0aFxuICAgIFxcKi9cbiAgICBTbmFwLnBhdGguaXNQb2ludEluc2lkZSA9IGlzUG9pbnRJbnNpZGVQYXRoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0QkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggb2YgYSBnaXZlbiBwYXRoXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveFxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHRvcCBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHgyOiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5MjogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBib3R0b20gcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgd2lkdGg6IChudW1iZXIpIHdpZHRoIG9mIHRoZSBib3gsXG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0IG9mIHRoZSBib3hcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRCQm94ID0gcGF0aEJCb3g7XG4gICAgU25hcC5wYXRoLmdldCA9IGdldFBhdGg7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC50b1JlbGF0aXZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIHBhdGggY29vcmRpbmF0ZXMgaW50byByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgID0gKGFycmF5KSBwYXRoIHN0cmluZ1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgudG9SZWxhdGl2ZSA9IHBhdGhUb1JlbGF0aXZlO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGgudG9BYnNvbHV0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBwYXRoIGNvb3JkaW5hdGVzIGludG8gYWJzb2x1dGUgdmFsdWVzXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChhcnJheSkgcGF0aCBzdHJpbmdcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLnRvQWJzb2x1dGUgPSBwYXRoVG9BYnNvbHV0ZTtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLnRvQ3ViaWNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogQ29udmVydHMgcGF0aCB0byBhIG5ldyBwYXRoIHdoZXJlIGFsbCBzZWdtZW50cyBhcmUgY3ViaWMgYmV6acOpciBjdXJ2ZXNcbiAgICAgLSBwYXRoU3RyaW5nIChzdHJpbmd8YXJyYXkpIHBhdGggc3RyaW5nIG9yIGFycmF5IG9mIHNlZ21lbnRzXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50c1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgudG9DdWJpYyA9IHBhdGgyY3VydmU7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5tYXBcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgcGF0aCBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbWF0cml4XG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICAtIG1hdHJpeCAob2JqZWN0KSBzZWUgQE1hdHJpeFxuICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybWVkIHBhdGggc3RyaW5nXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5tYXAgPSBtYXBQYXRoO1xuICAgIFNuYXAucGF0aC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIFNuYXAucGF0aC5jbG9uZSA9IHBhdGhDbG9uZTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgbW1heCA9IE1hdGgubWF4LFxuICAgICAgICBtbWluID0gTWF0aC5taW47XG5cbiAgICAvLyBTZXRcbiAgICB2YXIgU2V0ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcblx0dGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudHlwZSA9IFwic2V0XCI7XG4gICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3RoaXMuaXRlbXMubGVuZ3RoXSA9IHRoaXMuaXRlbXNbdGhpcy5pdGVtcy5sZW5ndGhdID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXRwcm90byA9IFNldC5wcm90b3R5cGU7XG4gICAgLypcXFxuICAgICAqIFNldC5wdXNoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGVhY2ggYXJndW1lbnQgdG8gdGhlIGN1cnJlbnQgc2V0XG4gICAgID0gKG9iamVjdCkgb3JpZ2luYWwgZWxlbWVudFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbSxcbiAgICAgICAgICAgIGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXNbbGVuXSA9IHRoaXMuaXRlbXNbbGVuXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQucG9wXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGxhc3QgZWxlbWVudCBhbmQgcmV0dXJucyBpdFxuICAgICA9IChvYmplY3QpIGVsZW1lbnRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8ucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxlbmd0aCAmJiBkZWxldGUgdGhpc1t0aGlzLmxlbmd0aC0tXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmZvckVhY2hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEV4ZWN1dGVzIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldFxuICAgICAqXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgdGhlIGxvb3Agc3RvcHMgcnVubmluZy5cbiAgICAgKipcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pIGZ1bmN0aW9uIHRvIHJ1blxuICAgICAtIHRoaXNBcmcgKG9iamVjdCkgY29udGV4dCBvYmplY3QgZm9yIHRoZSBjYWxsYmFja1xuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMuaXRlbXNbaV0sIGkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5hbmltYXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBbmltYXRlcyBlYWNoIGVsZW1lbnQgaW4gc2V0IGluIHN5bmMuXG4gICAgICpcbiAgICAgKipcbiAgICAgLSBhdHRycyAob2JqZWN0KSBrZXktdmFsdWUgcGFpcnMgb2YgZGVzdGluYXRpb24gYXR0cmlidXRlc1xuICAgICAtIGR1cmF0aW9uIChudW1iZXIpIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgIC0gZWFzaW5nIChmdW5jdGlvbikgI29wdGlvbmFsIGVhc2luZyBmdW5jdGlvbiBmcm9tIEBtaW5hIG9yIGN1c3RvbVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHNcbiAgICAgKiBvclxuICAgICAtIGFuaW1hdGlvbiAoYXJyYXkpIGFycmF5IG9mIGFuaW1hdGlvbiBwYXJhbWV0ZXIgZm9yIGVhY2ggZWxlbWVudCBpbiBzZXQgaW4gZm9ybWF0IGBbYXR0cnMsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrXWBcbiAgICAgPiBVc2FnZVxuICAgICB8IC8vIGFuaW1hdGUgYWxsIGVsZW1lbnRzIGluIHNldCB0byByYWRpdXMgMTBcbiAgICAgfCBzZXQuYW5pbWF0ZSh7cjogMTB9LCA1MDAsIG1pbmEuZWFzZWluKTtcbiAgICAgfCAvLyBvclxuICAgICB8IC8vIGFuaW1hdGUgZmlyc3QgZWxlbWVudCB0byByYWRpdXMgMTAsIGJ1dCBzZWNvbmQgdG8gcmFkaXVzIDIwIGFuZCBpbiBkaWZmZXJlbnQgdGltZVxuICAgICB8IHNldC5hbmltYXRlKFt7cjogMTB9LCA1MDAsIG1pbmEuZWFzZWluXSwgW3tyOiAyMH0sIDE1MDAsIG1pbmEuZWFzZWluXSk7XG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChhdHRycywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIFNuYXAuXy5BbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXR0cnMuY2FsbGJhY2s7XG4gICAgICAgICAgICBlYXNpbmcgPSBhdHRycy5lYXNpbmc7XG4gICAgICAgICAgICBtcyA9IGVhc2luZy5kdXI7XG4gICAgICAgICAgICBhdHRycyA9IGF0dHJzLmF0dHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChTbmFwLmlzKGF0dHJzLCBcImFycmF5XCIpICYmIFNuYXAuaXMoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICB2YXIgZWFjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZ2luLFxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gYmVnaW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSB0aGlzLmI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNiID0gMCxcbiAgICAgICAgICAgIHNldCA9IHRoaXMsXG4gICAgICAgICAgICBjYWxsYmFja2VyID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgrK2NiID09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFuaW1jcmVhdGVkLlwiICsgZWwuaWQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBhcmdzW2ldICYmIGVsLmFuaW1hdGUuYXBwbHkoZWwsIGFyZ3NbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5hbmltYXRlKGF0dHJzLCBtcywgZWFzaW5nLCBjYWxsYmFja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBzZXRwcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wb3AoKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuYmluZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU3BlY2lmaWVzIGhvdyB0byBoYW5kbGUgYSBzcGVjaWZpYyBhdHRyaWJ1dGUgd2hlbiBhcHBsaWVkXG4gICAgICogdG8gYSBzZXQuXG4gICAgICpcbiAgICAgKipcbiAgICAgLSBhdHRyIChzdHJpbmcpIGF0dHJpYnV0ZSBuYW1lXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSBmdW5jdGlvbiB0byBydW5cbiAgICAgKiBvclxuICAgICAtIGF0dHIgKHN0cmluZykgYXR0cmlidXRlIG5hbWVcbiAgICAgLSBlbGVtZW50IChFbGVtZW50KSBzcGVjaWZpYyBlbGVtZW50IGluIHRoZSBzZXQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZSB0b1xuICAgICAqIG9yXG4gICAgIC0gYXR0ciAoc3RyaW5nKSBhdHRyaWJ1dGUgbmFtZVxuICAgICAtIGVsZW1lbnQgKEVsZW1lbnQpIHNwZWNpZmljIGVsZW1lbnQgaW4gdGhlIHNldCB0byBhcHBseSB0aGUgYXR0cmlidXRlIHRvXG4gICAgIC0gZWF0dHIgKHN0cmluZykgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50IHRvIGJpbmQgdGhlIGF0dHJpYnV0ZSB0b1xuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uYmluZCA9IGZ1bmN0aW9uIChhdHRyLCBhLCBiKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbYXR0cl0gPSBhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFuYW1lID0gYiB8fCBhdHRyO1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1thdHRyXSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgZGF0YVthbmFtZV0gPSB2O1xuICAgICAgICAgICAgICAgIGEuYXR0cihkYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBzZXRwcm90by5hdHRyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB1bmJvdW5kID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJpbmRpbmdzW2tdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1trXSh2YWx1ZVtrXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuYm91bmRba10gPSB2YWx1ZVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0uYXR0cih1bmJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuY2xlYXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHNldFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LnNwbGljZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyByYW5nZSBvZiBlbGVtZW50cyBmcm9tIHRoZSBzZXRcbiAgICAgKipcbiAgICAgLSBpbmRleCAobnVtYmVyKSBwb3NpdGlvbiBvZiB0aGUgZGVsZXRpb25cbiAgICAgLSBjb3VudCAobnVtYmVyKSBudW1iZXIgb2YgZWxlbWVudCB0byByZW1vdmVcbiAgICAgLSBpbnNlcnRpb27igKYgKG9iamVjdCkgI29wdGlvbmFsIGVsZW1lbnRzIHRvIGluc2VydFxuICAgICA9IChvYmplY3QpIHNldCBlbGVtZW50cyB0aGF0IHdlcmUgZGVsZXRlZFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5zcGxpY2UgPSBmdW5jdGlvbiAoaW5kZXgsIGNvdW50LCBpbnNlcnRpb24pIHtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBtbWF4KHRoaXMubGVuZ3RoICsgaW5kZXgsIDApIDogaW5kZXg7XG4gICAgICAgIGNvdW50ID0gbW1heCgwLCBtbWluKHRoaXMubGVuZ3RoIC0gaW5kZXgsIGNvdW50KSk7XG4gICAgICAgIHZhciB0YWlsID0gW10sXG4gICAgICAgICAgICB0b2RlbCA9IFtdLFxuICAgICAgICAgICAgYXJncyA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRvZGVsLnB1c2godGhpc1tpbmRleCArIGldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgdGFpbC5wdXNoKHRoaXNbaW5kZXggKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ2xlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnbGVuICsgdGFpbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleCArIGldID0gdGhpc1tpbmRleCArIGldID0gaSA8IGFyZ2xlbiA/IGFyZ3NbaV0gOiB0YWlsW2kgLSBhcmdsZW5dO1xuICAgICAgICB9XG4gICAgICAgIGkgPSB0aGlzLml0ZW1zLmxlbmd0aCA9IHRoaXMubGVuZ3RoIC09IGNvdW50IC0gYXJnbGVuO1xuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXNbaSsrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNldCh0b2RlbCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmV4Y2x1ZGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBzZXRcbiAgICAgKipcbiAgICAgLSBlbGVtZW50IChvYmplY3QpIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBvYmplY3Qgd2FzIGZvdW5kIGFuZCByZW1vdmVkIGZyb20gdGhlIHNldFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5leGNsdWRlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKHRoaXNbaV0gPT0gZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgc2V0cHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5pbnNlcnRBZnRlcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBzZXRwcm90by5nZXRCQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeCA9IFtdLFxuICAgICAgICAgICAgeSA9IFtdLFxuICAgICAgICAgICAgeDIgPSBbXSxcbiAgICAgICAgICAgIHkyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaS0tOykgaWYgKCF0aGlzLml0ZW1zW2ldLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLml0ZW1zW2ldLmdldEJCb3goKTtcbiAgICAgICAgICAgIHgucHVzaChib3gueCk7XG4gICAgICAgICAgICB5LnB1c2goYm94LnkpO1xuICAgICAgICAgICAgeDIucHVzaChib3gueCArIGJveC53aWR0aCk7XG4gICAgICAgICAgICB5Mi5wdXNoKGJveC55ICsgYm94LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IG1taW4uYXBwbHkoMCwgeCk7XG4gICAgICAgIHkgPSBtbWluLmFwcGx5KDAsIHkpO1xuICAgICAgICB4MiA9IG1tYXguYXBwbHkoMCwgeDIpO1xuICAgICAgICB5MiA9IG1tYXguYXBwbHkoMCwgeTIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgICB3aWR0aDogeDIgLSB4LFxuICAgICAgICAgICAgaGVpZ2h0OiB5MiAtIHksXG4gICAgICAgICAgICBjeDogeCArICh4MiAtIHgpIC8gMixcbiAgICAgICAgICAgIGN5OiB5ICsgKHkyIC0geSkgLyAyXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBzZXRwcm90by5jbG9uZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHMgPSBuZXcgU2V0O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHMucHVzaCh0aGlzLml0ZW1zW2ldLmNsb25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgc2V0cHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNuYXBcXHUyMDE4cyBzZXRcIjtcbiAgICB9O1xuICAgIHNldHByb3RvLnR5cGUgPSBcInNldFwiO1xuICAgIC8vIGV4cG9ydFxuICAgIFNuYXAuU2V0ID0gU2V0O1xuICAgIFNuYXAuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2V0ID0gbmV3IFNldDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNldC5wdXNoLmFwcGx5KHNldCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9O1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy8gXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vIFxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYikge1xuICAgIHZhciBuYW1lcyA9IHt9LFxuICAgICAgICByZVVuaXQgPSAvW2Etel0rJC9pLFxuICAgICAgICBTdHIgPSBTdHJpbmc7XG4gICAgbmFtZXMuc3Ryb2tlID0gbmFtZXMuZmlsbCA9IFwiY29sb3VyXCI7XG4gICAgZnVuY3Rpb24gZ2V0RW1wdHkoaXRlbSkge1xuICAgICAgICB2YXIgbCA9IGl0ZW1bMF07XG4gICAgICAgIHN3aXRjaCAobC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidFwiOiByZXR1cm4gW2wsIDAsIDBdO1xuICAgICAgICAgICAgY2FzZSBcIm1cIjogcmV0dXJuIFtsLCAxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6IGlmIChpdGVtLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAwLCBpdGVtWzJdLCBpdGVtWzNdXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzXCI6IGlmIChpdGVtLmxlbmd0aCA9PSA1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAxLCAxLCBpdGVtWzNdLCBpdGVtWzRdXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMSwgMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXF1YWxpc2VUcmFuc2Zvcm0odDEsIHQyLCBnZXRCQm94KSB7XG4gICAgICAgIHQyID0gU3RyKHQyKS5yZXBsYWNlKC9cXC57M318XFx1MjAyNi9nLCB0MSk7XG4gICAgICAgIHQxID0gU25hcC5wYXJzZVRyYW5zZm9ybVN0cmluZyh0MSkgfHwgW107XG4gICAgICAgIHQyID0gU25hcC5wYXJzZVRyYW5zZm9ybVN0cmluZyh0MikgfHwgW107XG4gICAgICAgIHZhciBtYXhsZW5ndGggPSBNYXRoLm1heCh0MS5sZW5ndGgsIHQyLmxlbmd0aCksXG4gICAgICAgICAgICBmcm9tID0gW10sXG4gICAgICAgICAgICB0byA9IFtdLFxuICAgICAgICAgICAgaSA9IDAsIGosIGpqLFxuICAgICAgICAgICAgdHQxLCB0dDI7XG4gICAgICAgIGZvciAoOyBpIDwgbWF4bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR0MSA9IHQxW2ldIHx8IGdldEVtcHR5KHQyW2ldKTtcbiAgICAgICAgICAgIHR0MiA9IHQyW2ldIHx8IGdldEVtcHR5KHR0MSk7XG4gICAgICAgICAgICBpZiAoKHR0MVswXSAhPSB0dDJbMF0pIHx8XG4gICAgICAgICAgICAgICAgKHR0MVswXS50b0xvd2VyQ2FzZSgpID09IFwiclwiICYmICh0dDFbMl0gIT0gdHQyWzJdIHx8IHR0MVszXSAhPSB0dDJbM10pKSB8fFxuICAgICAgICAgICAgICAgICh0dDFbMF0udG9Mb3dlckNhc2UoKSA9PSBcInNcIiAmJiAodHQxWzNdICE9IHR0MlszXSB8fCB0dDFbNF0gIT0gdHQyWzRdKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeCh0MSwgZ2V0QkJveCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdDIgPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeCh0MiwgZ2V0QkJveCgpKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IFtbXCJtXCIsIHQxLmEsIHQxLmIsIHQxLmMsIHQxLmQsIHQxLmUsIHQxLmZdXTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBbW1wibVwiLCB0Mi5hLCB0Mi5iLCB0Mi5jLCB0Mi5kLCB0Mi5lLCB0Mi5mXV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbVtpXSA9IFtdO1xuICAgICAgICAgICAgdG9baV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGpqID0gTWF0aC5tYXgodHQxLmxlbmd0aCwgdHQyLmxlbmd0aCk7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgaiBpbiB0dDEgJiYgKGZyb21baV1bal0gPSB0dDFbal0pO1xuICAgICAgICAgICAgICAgIGogaW4gdHQyICYmICh0b1tpXVtqXSA9IHR0MltqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IHBhdGgyYXJyYXkoZnJvbSksXG4gICAgICAgICAgICB0bzogcGF0aDJhcnJheSh0byksXG4gICAgICAgICAgICBmOiBnZXRQYXRoKGZyb20pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE51bWJlcih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VW5pdCh1bml0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gK3ZhbC50b0ZpeGVkKDMpICsgdW5pdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Vmlld0JveCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29sb3VyKGNscikge1xuICAgICAgICByZXR1cm4gU25hcC5yZ2IoY2xyWzBdLCBjbHJbMV0sIGNsclsyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBhdGgocGF0aCkge1xuICAgICAgICB2YXIgayA9IDAsIGksIGlpLCBqLCBqaiwgb3V0LCBhLCBiID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBvdXQgPSBcIltcIjtcbiAgICAgICAgICAgIGEgPSBbJ1wiJyArIHBhdGhbaV1bMF0gKyAnXCInXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDEsIGpqID0gcGF0aFtpXS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgYVtqXSA9IFwidmFsW1wiICsgKGsrKykgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSBhICsgXCJdXCI7XG4gICAgICAgICAgICBiW2ldID0gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihcInZhbFwiLCBcInJldHVybiBTbmFwLnBhdGgudG9TdHJpbmcuY2FsbChbXCIgKyBiICsgXCJdKVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aDJhcnJheShwYXRoKSB7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMSwgamogPSBwYXRoW2ldLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChwYXRoW2ldW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc051bWVyaWMob2JqKSB7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShwYXJzZUZsb2F0KG9iaikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcnJheUVxdWFsKGFycjEsIGFycjIpIHtcbiAgICAgICAgaWYgKCFTbmFwLmlzKGFycjEsIFwiYXJyYXlcIikgfHwgIVNuYXAuaXMoYXJyMiwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnIxLnRvU3RyaW5nKCkgPT0gYXJyMi50b1N0cmluZygpO1xuICAgIH1cbiAgICBFbGVtZW50LnByb3RvdHlwZS5lcXVhbCA9IGZ1bmN0aW9uIChuYW1lLCBiKSB7XG4gICAgICAgIHJldHVybiBldmUoXCJzbmFwLnV0aWwuZXF1YWxcIiwgdGhpcywgbmFtZSwgYikuZmlyc3REZWZpbmVkKCk7XG4gICAgfTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZXF1YWxcIiwgZnVuY3Rpb24gKG5hbWUsIGIpIHtcbiAgICAgICAgdmFyIEEsIEIsIGEgPSBTdHIodGhpcy5hdHRyKG5hbWUpIHx8IFwiXCIpLFxuICAgICAgICAgICAgZWwgPSB0aGlzO1xuICAgICAgICBpZiAoaXNOdW1lcmljKGEpICYmIGlzTnVtZXJpYyhiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBwYXJzZUZsb2F0KGEpLFxuICAgICAgICAgICAgICAgIHRvOiBwYXJzZUZsb2F0KGIpLFxuICAgICAgICAgICAgICAgIGY6IGdldE51bWJlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNbbmFtZV0gPT0gXCJjb2xvdXJcIikge1xuICAgICAgICAgICAgQSA9IFNuYXAuY29sb3IoYSk7XG4gICAgICAgICAgICBCID0gU25hcC5jb2xvcihiKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogW0EuciwgQS5nLCBBLmIsIEEub3BhY2l0eV0sXG4gICAgICAgICAgICAgICAgdG86IFtCLnIsIEIuZywgQi5iLCBCLm9wYWNpdHldLFxuICAgICAgICAgICAgICAgIGY6IGdldENvbG91clxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSBcInZpZXdCb3hcIikge1xuICAgICAgICAgICAgQSA9IHRoaXMuYXR0cihuYW1lKS52Yi5zcGxpdChcIiBcIikubWFwKE51bWJlcik7XG4gICAgICAgICAgICBCID0gYi5zcGxpdChcIiBcIikubWFwKE51bWJlcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IEEsXG4gICAgICAgICAgICAgICAgdG86IEIsXG4gICAgICAgICAgICAgICAgZjogZ2V0Vmlld0JveFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSBcInRyYW5zZm9ybVwiIHx8IG5hbWUgPT0gXCJncmFkaWVudFRyYW5zZm9ybVwiIHx8IG5hbWUgPT0gXCJwYXR0ZXJuVHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIGlmIChiIGluc3RhbmNlb2YgU25hcC5NYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBiID0gYi50b1RyYW5zZm9ybVN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFTbmFwLl8ucmdUcmFuc2Zvcm0udGVzdChiKSkge1xuICAgICAgICAgICAgICAgIGIgPSBTbmFwLl8uc3ZnVHJhbnNmb3JtMnN0cmluZyhiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcXVhbGlzZVRyYW5zZm9ybShhLCBiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEJCb3goMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSBcImRcIiB8fCBuYW1lID09IFwicGF0aFwiKSB7XG4gICAgICAgICAgICBBID0gU25hcC5wYXRoLnRvQ3ViaWMoYSwgYik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IHBhdGgyYXJyYXkoQVswXSksXG4gICAgICAgICAgICAgICAgdG86IHBhdGgyYXJyYXkoQVsxXSksXG4gICAgICAgICAgICAgICAgZjogZ2V0UGF0aChBWzBdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSBcInBvaW50c1wiKSB7XG4gICAgICAgICAgICBBID0gU3RyKGEpLnNwbGl0KFNuYXAuXy5zZXBhcmF0b3IpO1xuICAgICAgICAgICAgQiA9IFN0cihiKS5zcGxpdChTbmFwLl8uc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogQSxcbiAgICAgICAgICAgICAgICB0bzogQixcbiAgICAgICAgICAgICAgICBmOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWw7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFVbml0ID0gYS5tYXRjaChyZVVuaXQpLFxuICAgICAgICAgICAgYlVuaXQgPSBTdHIoYikubWF0Y2gocmVVbml0KTtcbiAgICAgICAgaWYgKGFVbml0ICYmIGFycmF5RXF1YWwoYVVuaXQsIGJVbml0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBwYXJzZUZsb2F0KGEpLFxuICAgICAgICAgICAgICAgIHRvOiBwYXJzZUZsb2F0KGIpLFxuICAgICAgICAgICAgICAgIGY6IGdldFVuaXQoYVVuaXQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLmFzUFgobmFtZSksXG4gICAgICAgICAgICAgICAgdG86IHRoaXMuYXNQWChuYW1lLCBiKSxcbiAgICAgICAgICAgICAgICBmOiBnZXROdW1iZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgZWxwcm90byA9IEVsZW1lbnQucHJvdG90eXBlLFxuICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICBzdXBwb3J0c1RvdWNoID0gXCJjcmVhdGVUb3VjaFwiIGluIGdsb2IuZG9jLFxuICAgIGV2ZW50cyA9IFtcbiAgICAgICAgXCJjbGlja1wiLCBcImRibGNsaWNrXCIsIFwibW91c2Vkb3duXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2VvdXRcIixcbiAgICAgICAgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZXVwXCIsIFwidG91Y2hzdGFydFwiLCBcInRvdWNobW92ZVwiLCBcInRvdWNoZW5kXCIsXG4gICAgICAgIFwidG91Y2hjYW5jZWxcIlxuICAgIF0sXG4gICAgdG91Y2hNYXAgPSB7XG4gICAgICAgIG1vdXNlZG93bjogXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAgIG1vdXNlbW92ZTogXCJ0b3VjaG1vdmVcIixcbiAgICAgICAgbW91c2V1cDogXCJ0b3VjaGVuZFwiXG4gICAgfSxcbiAgICBnZXRTY3JvbGwgPSBmdW5jdGlvbiAoeHksIGVsKSB7XG4gICAgICAgIHZhciBuYW1lID0geHkgPT0gXCJ5XCIgPyBcInNjcm9sbFRvcFwiIDogXCJzY3JvbGxMZWZ0XCIsXG4gICAgICAgICAgICBkb2MgPSBlbCAmJiBlbC5ub2RlID8gZWwubm9kZS5vd25lckRvY3VtZW50IDogZ2xvYi5kb2M7XG4gICAgICAgIHJldHVybiBkb2NbbmFtZSBpbiBkb2MuZG9jdW1lbnRFbGVtZW50ID8gXCJkb2N1bWVudEVsZW1lbnRcIiA6IFwiYm9keVwiXVtuYW1lXTtcbiAgICB9LFxuICAgIHByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfSxcbiAgICBwcmV2ZW50VG91Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH0sXG4gICAgc3RvcFRvdWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG4gICAgYWRkRXZlbnQgPSBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbiwgZWxlbWVudCkge1xuICAgICAgICB2YXIgcmVhbE5hbWUgPSBzdXBwb3J0c1RvdWNoICYmIHRvdWNoTWFwW3R5cGVdID8gdG91Y2hNYXBbdHlwZV0gOiB0eXBlLFxuICAgICAgICAgICAgZiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFkgPSBnZXRTY3JvbGwoXCJ5XCIsIGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxYID0gZ2V0U2Nyb2xsKFwieFwiLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNUb3VjaCAmJiB0b3VjaE1hcFtoYXNdKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0VG91Y2hlc1tpXS50YXJnZXQgPT0gb2JqIHx8IG9iai5jb250YWlucyhlLnRhcmdldFRvdWNoZXNbaV0udGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRlID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gZS50YXJnZXRUb3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUub3JpZ2luYWxFdmVudCA9IG9sZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnRUb3VjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbiA9IHN0b3BUb3VjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUuY2xpZW50WCArIHNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICAgIHkgPSBlLmNsaWVudFkgKyBzY3JvbGxZO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKGVsZW1lbnQsIGUsIHgsIHkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZSAhPT0gcmVhbE5hbWUpIHtcbiAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKHJlYWxOYW1lLCBmLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSByZWFsTmFtZSkge1xuICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIocmVhbE5hbWUsIGYsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgZHJhZyA9IFtdLFxuICAgIGRyYWdNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHggPSBlLmNsaWVudFgsXG4gICAgICAgICAgICB5ID0gZS5jbGllbnRZLFxuICAgICAgICAgICAgc2Nyb2xsWSA9IGdldFNjcm9sbChcInlcIiksXG4gICAgICAgICAgICBzY3JvbGxYID0gZ2V0U2Nyb2xsKFwieFwiKSxcbiAgICAgICAgICAgIGRyYWdpLFxuICAgICAgICAgICAgaiA9IGRyYWcubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICBkcmFnaSA9IGRyYWdbal07XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNUb3VjaCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2ggPSBlLnRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09IGRyYWdpLmVsLl9kcmFnLmlkIHx8IGRyYWdpLmVsLm5vZGUuY29udGFpbnModG91Y2gudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gdG91Y2guY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChlLm9yaWdpbmFsRXZlbnQgPyBlLm9yaWdpbmFsRXZlbnQgOiBlKS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlID0gZHJhZ2kuZWwubm9kZSxcbiAgICAgICAgICAgICAgICBvLFxuICAgICAgICAgICAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5ID0gbm9kZS5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgLy8gZ2xvYi53aW4ub3BlcmEgJiYgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgLy8gbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAvLyBvID0gZHJhZ2kuZWwucGFwZXIuZ2V0RWxlbWVudEJ5UG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAvLyBub2RlLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuICAgICAgICAgICAgLy8gZ2xvYi53aW4ub3BlcmEgJiYgKG5leHQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpIDogcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpKTtcbiAgICAgICAgICAgIC8vIG8gJiYgZXZlKFwic25hcC5kcmFnLm92ZXIuXCIgKyBkcmFnaS5lbC5pZCwgZHJhZ2kuZWwsIG8pO1xuICAgICAgICAgICAgeCArPSBzY3JvbGxYO1xuICAgICAgICAgICAgeSArPSBzY3JvbGxZO1xuICAgICAgICAgICAgZXZlKFwic25hcC5kcmFnLm1vdmUuXCIgKyBkcmFnaS5lbC5pZCwgZHJhZ2kubW92ZV9zY29wZSB8fCBkcmFnaS5lbCwgeCAtIGRyYWdpLmVsLl9kcmFnLngsIHkgLSBkcmFnaS5lbC5fZHJhZy55LCB4LCB5LCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ1VwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgU25hcC51bm1vdXNlbW92ZShkcmFnTW92ZSkudW5tb3VzZXVwKGRyYWdVcCk7XG4gICAgICAgIHZhciBpID0gZHJhZy5sZW5ndGgsXG4gICAgICAgICAgICBkcmFnaTtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgZHJhZ2kgPSBkcmFnW2ldO1xuICAgICAgICAgICAgZHJhZ2kuZWwuX2RyYWcgPSB7fTtcbiAgICAgICAgICAgIGV2ZShcInNuYXAuZHJhZy5lbmQuXCIgKyBkcmFnaS5lbC5pZCwgZHJhZ2kuZW5kX3Njb3BlIHx8IGRyYWdpLnN0YXJ0X3Njb3BlIHx8IGRyYWdpLm1vdmVfc2NvcGUgfHwgZHJhZ2kuZWwsIGUpO1xuICAgICAgICAgICAgZXZlLm9mZihcInNuYXAuZHJhZy4qLlwiICsgZHJhZ2kuZWwuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGRyYWcgPSBbXTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmNsaWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgY2xpY2sgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bmNsaWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgY2xpY2sgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmRibGNsaWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgZG91YmxlIGNsaWNrIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5kYmxjbGlja1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIGRvdWJsZSBjbGljayBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2Vkb3duXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2Vkb3duIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZWRvd25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBtb3VzZWRvd24gZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlbW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIG1vdXNlbW92ZSBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2Vtb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgbW91c2Vtb3ZlIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZW91dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIG1vdXNlb3V0IGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZW91dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNlb3V0IGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZW92ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBtb3VzZW92ZXIgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlb3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNlb3ZlciBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2V1cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIG1vdXNldXAgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNldXBcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBtb3VzZXVwIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b3VjaHN0YXJ0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2hzdGFydCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVudG91Y2hzdGFydFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIHRvdWNoc3RhcnQgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNobW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIHRvdWNobW92ZSBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVudG91Y2htb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2htb3ZlIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b3VjaGVuZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIHRvdWNoZW5kIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW50b3VjaGVuZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIHRvdWNoZW5kIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b3VjaGNhbmNlbFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIHRvdWNoY2FuY2VsIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW50b3VjaGNhbmNlbFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIHRvdWNoY2FuY2VsIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBmb3IgKHZhciBpID0gZXZlbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAoZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgU25hcFtldmVudE5hbWVdID0gZWxwcm90b1tldmVudE5hbWVdID0gZnVuY3Rpb24gKGZuLCBzY29wZSkge1xuICAgICAgICAgICAgICAgIGlmIChTbmFwLmlzKGZuLCBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZjogZm4sXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmQ6IGFkZEV2ZW50KHRoaXMubm9kZSB8fCBkb2N1bWVudCwgZXZlbnROYW1lLCBmbiwgc2NvcGUgfHwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5ldmVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKHRoaXMuZXZlbnRzW2ldLm5hbWUgPT0gZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzW2ldLmYuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU25hcFtcInVuXCIgKyBldmVudE5hbWVdID1cbiAgICAgICAgICAgIGVscHJvdG9bXCJ1blwiICsgZXZlbnROYW1lXSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cyB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgbCA9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGwtLSkgaWYgKGV2ZW50c1tsXS5uYW1lID09IGV2ZW50TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChldmVudHNbbF0uZiA9PSBmbiB8fCAhZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50c1tsXS51bmJpbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnNwbGljZShsLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgIWV2ZW50cy5sZW5ndGggJiYgZGVsZXRlIHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShldmVudHNbaV0pO1xuICAgIH1cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5ob3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBob3ZlciBldmVudCBoYW5kbGVycyB0byB0aGUgZWxlbWVudFxuICAgICAtIGZfaW4gKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBpblxuICAgICAtIGZfb3V0IChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgb3V0XG4gICAgIC0gaWNvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGhvdmVyIGluIGhhbmRsZXJcbiAgICAgLSBvY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgaG92ZXIgb3V0IGhhbmRsZXJcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmhvdmVyID0gZnVuY3Rpb24gKGZfaW4sIGZfb3V0LCBzY29wZV9pbiwgc2NvcGVfb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlb3ZlcihmX2luLCBzY29wZV9pbikubW91c2VvdXQoZl9vdXQsIHNjb3BlX291dCB8fCBzY29wZV9pbik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bmhvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGhvdmVyIGV2ZW50IGhhbmRsZXJzIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBmX2luIChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgaW5cbiAgICAgLSBmX291dCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGhvdmVyIG91dFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udW5ob3ZlciA9IGZ1bmN0aW9uIChmX2luLCBmX291dCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bm1vdXNlb3ZlcihmX2luKS51bm1vdXNlb3V0KGZfb3V0KTtcbiAgICB9O1xuICAgIHZhciBkcmFnZ2FibGUgPSBbXTtcbiAgICAvLyBTSUVSUkEgdW5jbGVhciB3aGF0IF9jb250ZXh0XyByZWZlcnMgdG8gZm9yIHN0YXJ0aW5nLCBlbmRpbmcsIG1vdmluZyB0aGUgZHJhZyBnZXN0dXJlLlxuICAgIC8vIFNJRVJSQSBFbGVtZW50LmRyYWcoKTogX3ggcG9zaXRpb24gb2YgdGhlIG1vdXNlXzogV2hlcmUgYXJlIHRoZSB4L3kgdmFsdWVzIG9mZnNldCBmcm9tP1xuICAgIC8vIFNJRVJSQSBFbGVtZW50LmRyYWcoKTogbXVjaCBvZiB0aGlzIG1lbWJlcidzIGRvYyBhcHBlYXJzIHRvIGJlIGR1cGxpY2F0ZWQgZm9yIHNvbWUgcmVhc29uLlxuICAgIC8vIFNJRVJSQSBVbmNsZWFyIGFib3V0IHRoaXMgc2VudGVuY2U6IF9BZGRpdGlvbmFsbHkgZm9sbG93aW5nIGRyYWcgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkOiBkcmFnLnN0YXJ0LjxpZD4gb24gc3RhcnQsIGRyYWcuZW5kLjxpZD4gb24gZW5kIGFuZCBkcmFnLm1vdmUuPGlkPiBvbiBldmVyeSBtb3ZlLl8gSXMgdGhlcmUgYSBnbG9iYWwgX2RyYWdfIG9iamVjdCB0byB3aGljaCB5b3UgY2FuIGFzc2lnbiBoYW5kbGVycyBrZXllZCBieSBhbiBlbGVtZW50J3MgSUQ/XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZHJhZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgYW4gZWxlbWVudCdzIGRyYWcgZ2VzdHVyZVxuICAgICAqKlxuICAgICAtIG9ubW92ZSAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIG1vdmluZ1xuICAgICAtIG9uc3RhcnQgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBkcmFnIHN0YXJ0XG4gICAgIC0gb25lbmQgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBkcmFnIGVuZFxuICAgICAtIG1jb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBtb3ZpbmcgaGFuZGxlclxuICAgICAtIHNjb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBkcmFnIHN0YXJ0IGhhbmRsZXJcbiAgICAgLSBlY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgZHJhZyBlbmQgaGFuZGxlclxuICAgICAqIEFkZGl0aW9uYWx5IGZvbGxvd2luZyBgZHJhZ2AgZXZlbnRzIGFyZSB0cmlnZ2VyZWQ6IGBkcmFnLnN0YXJ0LjxpZD5gIG9uIHN0YXJ0LCBcbiAgICAgKiBgZHJhZy5lbmQuPGlkPmAgb24gZW5kIGFuZCBgZHJhZy5tb3ZlLjxpZD5gIG9uIGV2ZXJ5IG1vdmUuIFdoZW4gZWxlbWVudCBpcyBkcmFnZ2VkIG92ZXIgYW5vdGhlciBlbGVtZW50IFxuICAgICAqIGBkcmFnLm92ZXIuPGlkPmAgZmlyZXMgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIFN0YXJ0IGV2ZW50IGFuZCBzdGFydCBoYW5kbGVyIGFyZSBjYWxsZWQgaW4gc3BlY2lmaWVkIGNvbnRleHQgb3IgaW4gY29udGV4dCBvZiB0aGUgZWxlbWVudCB3aXRoIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgICBvIHggKG51bWJlcikgeCBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyB5IChudW1iZXIpIHkgcG9zaXRpb24gb2YgdGhlIG1vdXNlXG4gICAgIG8gZXZlbnQgKG9iamVjdCkgRE9NIGV2ZW50IG9iamVjdFxuICAgICAqIE1vdmUgZXZlbnQgYW5kIG1vdmUgaGFuZGxlciBhcmUgY2FsbGVkIGluIHNwZWNpZmllZCBjb250ZXh0IG9yIGluIGNvbnRleHQgb2YgdGhlIGVsZW1lbnQgd2l0aCBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgbyBkeCAobnVtYmVyKSBzaGlmdCBieSB4IGZyb20gdGhlIHN0YXJ0IHBvaW50XG4gICAgIG8gZHkgKG51bWJlcikgc2hpZnQgYnkgeSBmcm9tIHRoZSBzdGFydCBwb2ludFxuICAgICBvIHggKG51bWJlcikgeCBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyB5IChudW1iZXIpIHkgcG9zaXRpb24gb2YgdGhlIG1vdXNlXG4gICAgIG8gZXZlbnQgKG9iamVjdCkgRE9NIGV2ZW50IG9iamVjdFxuICAgICAqIEVuZCBldmVudCBhbmQgZW5kIGhhbmRsZXIgYXJlIGNhbGxlZCBpbiBzcGVjaWZpZWQgY29udGV4dCBvciBpbiBjb250ZXh0IG9mIHRoZSBlbGVtZW50IHdpdGggZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgIG8gZXZlbnQgKG9iamVjdCkgRE9NIGV2ZW50IG9iamVjdFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZHJhZyA9IGZ1bmN0aW9uIChvbm1vdmUsIG9uc3RhcnQsIG9uZW5kLCBtb3ZlX3Njb3BlLCBzdGFydF9zY29wZSwgZW5kX3Njb3BlKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXM7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG9yaWdUcmFuc2Zvcm07XG4gICAgICAgICAgICByZXR1cm4gZWwuZHJhZyhmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBvcmlnVHJhbnNmb3JtICsgKG9yaWdUcmFuc2Zvcm0gPyBcIlRcIiA6IFwidFwiKSArIFtkeCwgZHldXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb3JpZ1RyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtKCkubG9jYWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydChlLCB4LCB5KSB7XG4gICAgICAgICAgICAoZS5vcmlnaW5hbEV2ZW50IHx8IGUpLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlbC5fZHJhZy54ID0geDtcbiAgICAgICAgICAgIGVsLl9kcmFnLnkgPSB5O1xuICAgICAgICAgICAgZWwuX2RyYWcuaWQgPSBlLmlkZW50aWZpZXI7XG4gICAgICAgICAgICAhZHJhZy5sZW5ndGggJiYgU25hcC5tb3VzZW1vdmUoZHJhZ01vdmUpLm1vdXNldXAoZHJhZ1VwKTtcbiAgICAgICAgICAgIGRyYWcucHVzaCh7ZWw6IGVsLCBtb3ZlX3Njb3BlOiBtb3ZlX3Njb3BlLCBzdGFydF9zY29wZTogc3RhcnRfc2NvcGUsIGVuZF9zY29wZTogZW5kX3Njb3BlfSk7XG4gICAgICAgICAgICBvbnN0YXJ0ICYmIGV2ZS5vbihcInNuYXAuZHJhZy5zdGFydC5cIiArIGVsLmlkLCBvbnN0YXJ0KTtcbiAgICAgICAgICAgIG9ubW92ZSAmJiBldmUub24oXCJzbmFwLmRyYWcubW92ZS5cIiArIGVsLmlkLCBvbm1vdmUpO1xuICAgICAgICAgICAgb25lbmQgJiYgZXZlLm9uKFwic25hcC5kcmFnLmVuZC5cIiArIGVsLmlkLCBvbmVuZCk7XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRyYWcuc3RhcnQuXCIgKyBlbC5pZCwgc3RhcnRfc2NvcGUgfHwgbW92ZV9zY29wZSB8fCBlbCwgeCwgeSwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5pdChlLCB4LCB5KSB7XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRyYWdpbml0LlwiICsgZWwuaWQsIGVsLCBlLCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBldmUub24oXCJzbmFwLmRyYWdpbml0LlwiICsgZWwuaWQsIHN0YXJ0KTtcbiAgICAgICAgZWwuX2RyYWcgPSB7fTtcbiAgICAgICAgZHJhZ2dhYmxlLnB1c2goe2VsOiBlbCwgc3RhcnQ6IHN0YXJ0LCBpbml0OiBpbml0fSk7XG4gICAgICAgIGVsLm1vdXNlZG93bihpbml0KTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLypcbiAgICAgKiBFbGVtZW50Lm9uRHJhZ092ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNob3J0Y3V0IHRvIGFzc2lnbiBldmVudCBoYW5kbGVyIGZvciBgZHJhZy5vdmVyLjxpZD5gIGV2ZW50LCB3aGVyZSBgaWRgIGlzIHRoZSBlbGVtZW50J3MgYGlkYCAoc2VlIEBFbGVtZW50LmlkKVxuICAgICAtIGYgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBldmVudCwgZmlyc3QgYXJndW1lbnQgd291bGQgYmUgdGhlIGVsZW1lbnQgeW91IGFyZSBkcmFnZ2luZyBvdmVyXG4gICAgXFwqL1xuICAgIC8vIGVscHJvdG8ub25EcmFnT3ZlciA9IGZ1bmN0aW9uIChmKSB7XG4gICAgLy8gICAgIGYgPyBldmUub24oXCJzbmFwLmRyYWcub3Zlci5cIiArIHRoaXMuaWQsIGYpIDogZXZlLnVuYmluZChcInNuYXAuZHJhZy5vdmVyLlwiICsgdGhpcy5pZCk7XG4gICAgLy8gfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bmRyYWdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYWxsIGRyYWcgZXZlbnQgaGFuZGxlcnMgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnVuZHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSBkcmFnZ2FibGUubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBpZiAoZHJhZ2dhYmxlW2ldLmVsID09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMudW5tb3VzZWRvd24oZHJhZ2dhYmxlW2ldLmluaXQpO1xuICAgICAgICAgICAgZHJhZ2dhYmxlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGV2ZS51bmJpbmQoXCJzbmFwLmRyYWcuKi5cIiArIHRoaXMuaWQpO1xuICAgICAgICAgICAgZXZlLnVuYmluZChcInNuYXAuZHJhZ2luaXQuXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICAhZHJhZ2dhYmxlLmxlbmd0aCAmJiBTbmFwLnVubW91c2Vtb3ZlKGRyYWdNb3ZlKS51bm1vdXNldXAoZHJhZ1VwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyBcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgZWxwcm90byA9IEVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICBwcHJvdG8gPSBQYXBlci5wcm90b3R5cGUsXG4gICAgICAgIHJndXJsID0gL15cXHMqdXJsXFwoKC4rKVxcKS8sXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgJCA9IFNuYXAuXy4kO1xuICAgIFNuYXAuZmlsdGVyID0ge307XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmZpbHRlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGA8ZmlsdGVyPmAgZWxlbWVudFxuICAgICAqKlxuICAgICAtIGZpbHN0ciAoc3RyaW5nKSBTVkcgZnJhZ21lbnQgb2YgZmlsdGVyIHByb3ZpZGVkIGFzIGEgc3RyaW5nXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICAgKiBOb3RlOiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgZmlsdGVycyBlbWJlZGRlZCBpbnRvIHRoZSBwYWdlIGluc2lkZSBhbiBlbXB0eSBTVkcgZWxlbWVudC5cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBmID0gcGFwZXIuZmlsdGVyKCc8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPVwiMlwiLz4nKSxcbiAgICAgfCAgICAgYyA9IHBhcGVyLmNpcmNsZSgxMCwgMTAsIDEwKS5hdHRyKHtcbiAgICAgfCAgICAgICAgIGZpbHRlcjogZlxuICAgICB8ICAgICB9KTtcbiAgICBcXCovXG4gICAgcHByb3RvLmZpbHRlciA9IGZ1bmN0aW9uIChmaWxzdHIpIHtcbiAgICAgICAgdmFyIHBhcGVyID0gdGhpcztcbiAgICAgICAgaWYgKHBhcGVyLnR5cGUgIT0gXCJzdmdcIikge1xuICAgICAgICAgICAgcGFwZXIgPSBwYXBlci5wYXBlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZiA9IFNuYXAucGFyc2UoU3RyKGZpbHN0cikpLFxuICAgICAgICAgICAgaWQgPSBTbmFwLl8uaWQoKSxcbiAgICAgICAgICAgIHdpZHRoID0gcGFwZXIubm9kZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IHBhcGVyLm5vZGUub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgZmlsdGVyID0gJChcImZpbHRlclwiKTtcbiAgICAgICAgJChmaWx0ZXIsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGZpbHRlclVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbHRlci5hcHBlbmRDaGlsZChmLm5vZGUpO1xuICAgICAgICBwYXBlci5kZWZzLmFwcGVuZENoaWxkKGZpbHRlcik7XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudChmaWx0ZXIpO1xuICAgIH07XG4gICAgXG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuZmlsdGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgdmFyIHAgPSAkKHRoaXMubm9kZSwgXCJmaWx0ZXJcIik7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBTdHIocCkubWF0Y2gocmd1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoICYmIFNuYXAuc2VsZWN0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmZpbHRlclwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCAmJiB2YWx1ZS50eXBlID09IFwiZmlsdGVyXCIpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgaWQgPSB2YWx1ZS5ub2RlLmlkO1xuICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgICQodmFsdWUubm9kZSwge2lkOiB2YWx1ZS5pZH0pO1xuICAgICAgICAgICAgICAgIGlkID0gdmFsdWUuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogU25hcC51cmwoaWQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5ibHVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgYmx1ciBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIGFtb3VudCBvZiBob3Jpem9udGFsIGJsdXIsIGluIHBpeGVsc1xuICAgICAtIHkgKG51bWJlcikgI29wdGlvbmFsIGFtb3VudCBvZiB2ZXJ0aWNhbCBibHVyLCBpbiBwaXhlbHNcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBmID0gcGFwZXIuZmlsdGVyKFNuYXAuZmlsdGVyLmJsdXIoNSwgMTApKSxcbiAgICAgfCAgICAgYyA9IHBhcGVyLmNpcmNsZSgxMCwgMTAsIDEwKS5hdHRyKHtcbiAgICAgfCAgICAgICAgIGZpbHRlcjogZlxuICAgICB8ICAgICB9KTtcbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuYmx1ciA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHggPSAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWYgPSB5ID09IG51bGwgPyB4IDogW3gsIHldO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJ1xcPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj1cIntkZWZ9XCIvPicsIHtcbiAgICAgICAgICAgIGRlZjogZGVmXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuYmx1ci50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5zaGFkb3dcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBzaGFkb3cgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gZHggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gZHkgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIGJsdXIgKG51bWJlcikgI29wdGlvbmFsIGFtb3VudCBvZiBibHVyXG4gICAgIC0gY29sb3IgKHN0cmluZykgI29wdGlvbmFsIGNvbG9yIG9mIHRoZSBzaGFkb3dcbiAgICAgLSBvcGFjaXR5IChudW1iZXIpICNvcHRpb25hbCBgMC4uMWAgb3BhY2l0eSBvZiB0aGUgc2hhZG93XG4gICAgICogb3JcbiAgICAgLSBkeCAobnVtYmVyKSAjb3B0aW9uYWwgaG9yaXpvbnRhbCBzaGlmdCBvZiB0aGUgc2hhZG93LCBpbiBwaXhlbHNcbiAgICAgLSBkeSAobnVtYmVyKSAjb3B0aW9uYWwgdmVydGljYWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gY29sb3IgKHN0cmluZykgI29wdGlvbmFsIGNvbG9yIG9mIHRoZSBzaGFkb3dcbiAgICAgLSBvcGFjaXR5IChudW1iZXIpICNvcHRpb25hbCBgMC4uMWAgb3BhY2l0eSBvZiB0aGUgc2hhZG93XG4gICAgICogd2hpY2ggbWFrZXMgYmx1ciBkZWZhdWx0IHRvIGA0YC4gT3JcbiAgICAgLSBkeCAobnVtYmVyKSAjb3B0aW9uYWwgaG9yaXpvbnRhbCBzaGlmdCBvZiB0aGUgc2hhZG93LCBpbiBwaXhlbHNcbiAgICAgLSBkeSAobnVtYmVyKSAjb3B0aW9uYWwgdmVydGljYWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gb3BhY2l0eSAobnVtYmVyKSAjb3B0aW9uYWwgYDAuLjFgIG9wYWNpdHkgb2YgdGhlIHNoYWRvd1xuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGYgPSBwYXBlci5maWx0ZXIoU25hcC5maWx0ZXIuc2hhZG93KDAsIDIsIDMpKSxcbiAgICAgfCAgICAgYyA9IHBhcGVyLmNpcmNsZSgxMCwgMTAsIDEwKS5hdHRyKHtcbiAgICAgfCAgICAgICAgIGZpbHRlcjogZlxuICAgICB8ICAgICB9KTtcbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuc2hhZG93ID0gZnVuY3Rpb24gKGR4LCBkeSwgYmx1ciwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBibHVyID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbG9yID0gYmx1cjtcbiAgICAgICAgICAgIG9wYWNpdHkgPSBjb2xvcjtcbiAgICAgICAgICAgIGJsdXIgPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3IgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgb3BhY2l0eSA9IGNvbG9yO1xuICAgICAgICAgICAgY29sb3IgPSBcIiMwMDBcIjtcbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IGNvbG9yIHx8IFwiIzAwMFwiO1xuICAgICAgICBpZiAoYmx1ciA9PSBudWxsKSB7XG4gICAgICAgICAgICBibHVyID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BhY2l0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcGFjaXR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHggPT0gbnVsbCkge1xuICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICAgICAgZHkgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkeSA9IGR4O1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yID0gU25hcC5jb2xvcihjb2xvcik7XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlR2F1c3NpYW5CbHVyIGluPVwiU291cmNlQWxwaGFcIiBzdGREZXZpYXRpb249XCJ7Ymx1cn1cIi8+PGZlT2Zmc2V0IGR4PVwie2R4fVwiIGR5PVwie2R5fVwiIHJlc3VsdD1cIm9mZnNldGJsdXJcIi8+PGZlRmxvb2QgZmxvb2QtY29sb3I9XCJ7Y29sb3J9XCIvPjxmZUNvbXBvc2l0ZSBpbjI9XCJvZmZzZXRibHVyXCIgb3BlcmF0b3I9XCJpblwiLz48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jQSB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCJ7b3BhY2l0eX1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPjxmZU1lcmdlPjxmZU1lcmdlTm9kZS8+PGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiLz48L2ZlTWVyZ2U+Jywge1xuICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgZHg6IGR4LFxuICAgICAgICAgICAgZHk6IGR5LFxuICAgICAgICAgICAgYmx1cjogYmx1cixcbiAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTbmFwLmZpbHRlci5zaGFkb3cudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuZ3JheXNjYWxlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgZ3JheXNjYWxlIGZpbHRlclxuICAgICAqKlxuICAgICAtIGFtb3VudCAobnVtYmVyKSBhbW91bnQgb2YgZmlsdGVyIChgMC4uMWApXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmdyYXlzY2FsZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29sb3JNYXRyaXggdHlwZT1cIm1hdHJpeFwiIHZhbHVlcz1cInthfSB7Yn0ge2N9IDAgMCB7ZH0ge2V9IHtmfSAwIDAge2d9IHtifSB7aH0gMCAwIDAgMCAwIDEgMFwiLz4nLCB7XG4gICAgICAgICAgICBhOiAwLjIxMjYgKyAwLjc4NzQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBiOiAwLjcxNTIgLSAwLjcxNTIgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBjOiAwLjA3MjIgLSAwLjA3MjIgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBkOiAwLjIxMjYgLSAwLjIxMjYgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBlOiAwLjcxNTIgKyAwLjI4NDggKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBmOiAwLjA3MjIgLSAwLjA3MjIgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBnOiAwLjIxMjYgLSAwLjIxMjYgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBoOiAwLjA3MjIgKyAwLjkyNzggKiAoMSAtIGFtb3VudClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTbmFwLmZpbHRlci5ncmF5c2NhbGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuc2VwaWFcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBzZXBpYSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5zZXBpYSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29sb3JNYXRyaXggdHlwZT1cIm1hdHJpeFwiIHZhbHVlcz1cInthfSB7Yn0ge2N9IDAgMCB7ZH0ge2V9IHtmfSAwIDAge2d9IHtofSB7aX0gMCAwIDAgMCAwIDEgMFwiLz4nLCB7XG4gICAgICAgICAgICBhOiAwLjM5MyArIDAuNjA3ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYjogMC43NjkgLSAwLjc2OSAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGM6IDAuMTg5IC0gMC4xODkgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBkOiAwLjM0OSAtIDAuMzQ5ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZTogMC42ODYgKyAwLjMxNCAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGY6IDAuMTY4IC0gMC4xNjggKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBnOiAwLjI3MiAtIDAuMjcyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgaDogMC41MzQgLSAwLjUzNCAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGk6IDAuMTMxICsgMC44NjkgKiAoMSAtIGFtb3VudClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTbmFwLmZpbHRlci5zZXBpYS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5zYXR1cmF0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIHNhdHVyYXRlIGZpbHRlclxuICAgICAqKlxuICAgICAtIGFtb3VudCAobnVtYmVyKSBhbW91bnQgb2YgZmlsdGVyIChgMC4uMWApXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLnNhdHVyYXRlID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFtb3VudCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCc8ZmVDb2xvck1hdHJpeCB0eXBlPVwic2F0dXJhdGVcIiB2YWx1ZXM9XCJ7YW1vdW50fVwiLz4nLCB7XG4gICAgICAgICAgICBhbW91bnQ6IDEgLSBhbW91bnRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTbmFwLmZpbHRlci5zYXR1cmF0ZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5odWVSb3RhdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBodWUtcm90YXRlIGZpbHRlclxuICAgICAqKlxuICAgICAtIGFuZ2xlIChudW1iZXIpIGFuZ2xlIG9mIHJvdGF0aW9uXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmh1ZVJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICBhbmdsZSA9IGFuZ2xlIHx8IDA7XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29sb3JNYXRyaXggdHlwZT1cImh1ZVJvdGF0ZVwiIHZhbHVlcz1cInthbmdsZX1cIi8+Jywge1xuICAgICAgICAgICAgYW5nbGU6IGFuZ2xlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuaHVlUm90YXRlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmludmVydFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGludmVydCBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5pbnZlcnQgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuLy8gICAgICAgIDxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCItMSAwIDAgMCAxICAwIC0xIDAgMCAxICAwIDAgLTEgMCAxICAwIDAgMCAxIDBcIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9XCJzUkdCXCIvPlxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbXBvbmVudFRyYW5zZmVyPjxmZUZ1bmNSIHR5cGU9XCJ0YWJsZVwiIHRhYmxlVmFsdWVzPVwie2Ftb3VudH0ge2Ftb3VudDJ9XCIvPjxmZUZ1bmNHIHR5cGU9XCJ0YWJsZVwiIHRhYmxlVmFsdWVzPVwie2Ftb3VudH0ge2Ftb3VudDJ9XCIvPjxmZUZ1bmNCIHR5cGU9XCJ0YWJsZVwiIHRhYmxlVmFsdWVzPVwie2Ftb3VudH0ge2Ftb3VudDJ9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj4nLCB7XG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudCxcbiAgICAgICAgICAgIGFtb3VudDI6IDEgLSBhbW91bnRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTbmFwLmZpbHRlci5pbnZlcnQudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuYnJpZ2h0bmVzc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGJyaWdodG5lc3MgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuYnJpZ2h0bmVzcyA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY1IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIi8+PGZlRnVuY0cgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIi8+PGZlRnVuY0IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPicsIHtcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuYnJpZ2h0bmVzcy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5jb250cmFzdFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGNvbnRyYXN0IGZpbHRlclxuICAgICAqKlxuICAgICAtIGFtb3VudCAobnVtYmVyKSBhbW91bnQgb2YgZmlsdGVyIChgMC4uMWApXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmNvbnRyYXN0ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFtb3VudCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCc8ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCJ7YW1vdW50fVwiIGludGVyY2VwdD1cInthbW91bnQyfVwiLz48ZmVGdW5jRyB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCJ7YW1vdW50fVwiIGludGVyY2VwdD1cInthbW91bnQyfVwiLz48ZmVGdW5jQiB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCJ7YW1vdW50fVwiIGludGVyY2VwdD1cInthbW91bnQyfVwiLz48L2ZlQ29tcG9uZW50VHJhbnNmZXI+Jywge1xuICAgICAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICAgICAgICBhbW91bnQyOiAuNSAtIGFtb3VudCAvIDJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTbmFwLmZpbHRlci5jb250cmFzdC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxNCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYiwgRnJhZ21lbnQpIHtcbiAgICB2YXIgYm94ID0gU25hcC5fLmJveCxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBmaXJzdExldHRlciA9IC9eW15hLXpdKihbdGJtbHJjXSkvaSxcbiAgICAgICAgdG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUXCIgKyB0aGlzLmR4ICsgXCIsXCIgKyB0aGlzLmR5O1xuICAgICAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldEFsaWduXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHNoaWZ0IG5lZWRlZCB0byBhbGlnbiB0aGUgZWxlbWVudCByZWxhdGl2ZWx5IHRvIGdpdmVuIGVsZW1lbnQuXG4gICAgICogSWYgbm8gZWxlbWVudHMgc3BlY2lmaWVkLCBwYXJlbnQgYDxzdmc+YCBjb250YWluZXIgd2lsbCBiZSB1c2VkLlxuICAgICAtIGVsIChvYmplY3QpIEBvcHRpb25hbCBhbGlnbm1lbnQgZWxlbWVudFxuICAgICAtIHdheSAoc3RyaW5nKSBvbmUgb2Ygc2l4IHZhbHVlczogYFwidG9wXCJgLCBgXCJtaWRkbGVcImAsIGBcImJvdHRvbVwiYCwgYFwibGVmdFwiYCwgYFwiY2VudGVyXCJgLCBgXCJyaWdodFwiYFxuICAgICA9IChvYmplY3R8c3RyaW5nKSBPYmplY3QgaW4gZm9ybWF0IGB7ZHg6ICwgZHk6IH1gIGFsc28gaGFzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIGEgdHJhbnNmb3JtYXRpb24gc3RyaW5nXG4gICAgID4gVXNhZ2VcbiAgICAgfCBlbC50cmFuc2Zvcm0oZWwuZ2V0QWxpZ24oZWwyLCBcInRvcFwiKSk7XG4gICAgICogb3JcbiAgICAgfCB2YXIgZHkgPSBlbC5nZXRBbGlnbihlbDIsIFwidG9wXCIpLmR5O1xuICAgIFxcKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5nZXRBbGlnbiA9IGZ1bmN0aW9uIChlbCwgd2F5KSB7XG4gICAgICAgIGlmICh3YXkgPT0gbnVsbCAmJiBpcyhlbCwgXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHdheSA9IGVsO1xuICAgICAgICAgICAgZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwgfHwgdGhpcy5wYXBlcjtcbiAgICAgICAgdmFyIGJ4ID0gZWwuZ2V0QkJveCA/IGVsLmdldEJCb3goKSA6IGJveChlbCksXG4gICAgICAgICAgICBiYiA9IHRoaXMuZ2V0QkJveCgpLFxuICAgICAgICAgICAgb3V0ID0ge307XG4gICAgICAgIHdheSA9IHdheSAmJiB3YXkubWF0Y2goZmlyc3RMZXR0ZXIpO1xuICAgICAgICB3YXkgPSB3YXkgPyB3YXlbMV0udG9Mb3dlckNhc2UoKSA6IFwiY1wiO1xuICAgICAgICBzd2l0Y2ggKHdheSkge1xuICAgICAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgICAgICAgICBvdXQuZHggPSAwO1xuICAgICAgICAgICAgICAgIG91dC5keSA9IGJ4LnkgLSBiYi55O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICAgICAgICAgIG91dC5keCA9IDA7XG4gICAgICAgICAgICAgICAgb3V0LmR5ID0gYngueTIgLSBiYi55MjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICBvdXQuZHggPSAwO1xuICAgICAgICAgICAgICAgIG91dC5keSA9IGJ4LmN5IC0gYmIuY3k7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsXCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gYngueCAtIGJiLng7XG4gICAgICAgICAgICAgICAgb3V0LmR5ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJcIjpcbiAgICAgICAgICAgICAgICBvdXQuZHggPSBieC54MiAtIGJiLngyO1xuICAgICAgICAgICAgICAgIG91dC5keSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gYnguY3ggLSBiYi5jeDtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hbGlnblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWxpZ25zIHRoZSBlbGVtZW50IHJlbGF0aXZlbHkgdG8gZ2l2ZW4gb25lIHZpYSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiBJZiBubyBlbGVtZW50cyBzcGVjaWZpZWQsIHBhcmVudCBgPHN2Zz5gIGNvbnRhaW5lciB3aWxsIGJlIHVzZWQuXG4gICAgIC0gZWwgKG9iamVjdCkgQG9wdGlvbmFsIGFsaWdubWVudCBlbGVtZW50XG4gICAgIC0gd2F5IChzdHJpbmcpIG9uZSBvZiBzaXggdmFsdWVzOiBgXCJ0b3BcImAsIGBcIm1pZGRsZVwiYCwgYFwiYm90dG9tXCJgLCBgXCJsZWZ0XCJgLCBgXCJjZW50ZXJcImAsIGBcInJpZ2h0XCJgXG4gICAgID0gKG9iamVjdCkgdGhpcyBlbGVtZW50XG4gICAgID4gVXNhZ2VcbiAgICAgfCBlbC5hbGlnbihlbDIsIFwidG9wXCIpO1xuICAgICAqIG9yXG4gICAgIHwgZWwuYWxpZ24oXCJtaWRkbGVcIik7XG4gICAgXFwqL1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmFsaWduID0gZnVuY3Rpb24gKGVsLCB3YXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKFwiLi4uXCIgKyB0aGlzLmdldEFsaWduKGVsLCB3YXkpKTtcbiAgICB9O1xufSk7XG5cbnJldHVybiBTbmFwO1xufSkpO1xuIiwiLy8vLy8gICAgLy8vLy8gICAgLy8vLy8gICAgLy8vLy9cbi8vLy8vICAgIC8vLy8vICAgIC8vLy8vICAgIC8vLy8vXG4vLy8vLyAgICAvLy8vLyAgICAvLy8vLyAgICAvLy8vL1xuLy8vLy8gICAgLy8vLy8gICAgLy8vLy8gICAgLy8vLy9cbi8vLy8vICAgICAgICAgICAgIC8vLy8vICAgIC8vLy8vXG4vLy8vLyAgICAgICAgICAgICAvLy8vLyAgICAvLy8vL1xuLy8vLy8gICAgLy8vLy8gICAgLy8vLy8gICAgLy8vLy9cbi8vLy8vICAgIC8vLy8vICAgIC8vLy8vICAgIC8vLy8vXG4gICAgICAgICAvLy8vLyAgICAvLy8vL1xuICAgICAgICAgLy8vLy8gICAgLy8vLy9cbi8vLy8vICAgIC8vLy8vICAgIC8vLy8vICAgIC8vLy8vXG4vLy8vLyAgICAvLy8vLyAgICAvLy8vLyAgICAvLy8vL1xuLy8vLy8gICAgLy8vLy8gICAgLy8vLy8gICAgLy8vLy9cbi8vLy8vICAgIC8vLy8vICAgIC8vLy8vICAgIC8vLy8vXG5cbi8qKlxuICogU2Nyb2xsUmV2ZWFsXG4gKiAtLS0tLS0tLS0tLS1cbiAqIFZlcnNpb24gOiAzLjMuMVxuICogV2Vic2l0ZSA6IHNjcm9sbHJldmVhbGpzLm9yZ1xuICogUmVwbyAgICA6IGdpdGh1Yi5jb20vamxtYWtlcy9zY3JvbGxyZXZlYWwuanNcbiAqIEF1dGhvciAgOiBKdWxpYW4gTGxveWQgKEBqbG1ha2VzKVxuICovXG5cbjsoZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCdcblxuICB2YXIgc3JcbiAgdmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblxuICBmdW5jdGlvbiBTY3JvbGxSZXZlYWwgKGNvbmZpZykge1xuICAgIC8vIFN1cHBvcnQgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSBgbmV3YCBrZXl3b3JkLlxuICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBTY3JvbGxSZXZlYWwucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gbmV3IFNjcm9sbFJldmVhbChjb25maWcpXG4gICAgfVxuXG4gICAgc3IgPSB0aGlzIC8vIFNhdmUgcmVmZXJlbmNlIHRvIGluc3RhbmNlLlxuICAgIHNyLnZlcnNpb24gPSAnMy4zLjEnXG4gICAgc3IudG9vbHMgPSBuZXcgVG9vbHMoKSAvLyAqcmVxdWlyZWQgdXRpbGl0aWVzXG5cbiAgICBpZiAoc3IuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgc3IudG9vbHMuZXh0ZW5kKHNyLmRlZmF1bHRzLCBjb25maWcgfHwge30pXG5cbiAgICAgIF9yZXNvbHZlQ29udGFpbmVyKHNyLmRlZmF1bHRzKVxuXG4gICAgICBzci5zdG9yZSA9IHtcbiAgICAgICAgZWxlbWVudHM6IHt9LFxuICAgICAgICBjb250YWluZXJzOiBbXVxuICAgICAgfVxuXG4gICAgICBzci5zZXF1ZW5jZXMgPSB7fVxuICAgICAgc3IuaGlzdG9yeSA9IFtdXG4gICAgICBzci51aWQgPSAwXG4gICAgICBzci5pbml0aWFsaXplZCA9IGZhbHNlXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSAhPT0gbnVsbCkge1xuICAgICAgLy8gTm90ZTogSUU5IG9ubHkgc3VwcG9ydHMgY29uc29sZSBpZiBkZXZ0b29scyBhcmUgb3Blbi5cbiAgICAgIGNvbnNvbGUubG9nKCdTY3JvbGxSZXZlYWwgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuJylcbiAgICB9XG5cbiAgICByZXR1cm4gc3JcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS1cbiAgICogVGhpcyBvYmplY3Qgc2lnbmF0dXJlIGNhbiBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIFNjcm9sbFJldmVhbCBjb25zdHJ1Y3RvcixcbiAgICogb3IgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgYHJldmVhbCgpYCBtZXRob2QuXG4gICAqL1xuXG4gIFNjcm9sbFJldmVhbC5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gICAgLy8gJ2JvdHRvbScsICdsZWZ0JywgJ3RvcCcsICdyaWdodCdcbiAgICBvcmlnaW46ICdib3R0b20nLFxuXG4gICAgLy8gQ2FuIGJlIGFueSB2YWxpZCBDU1MgZGlzdGFuY2UsIGUuZy4gJzVyZW0nLCAnMTAlJywgJzIwdncnLCBldGMuXG4gICAgZGlzdGFuY2U6ICcyMHB4JyxcblxuICAgIC8vIFRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgZGVsYXk6IDAsXG5cbiAgICAvLyBTdGFydGluZyBhbmdsZXMgaW4gZGVncmVlcywgd2lsbCB0cmFuc2l0aW9uIGZyb20gdGhlc2UgdmFsdWVzIHRvIDAgaW4gYWxsIGF4ZXMuXG4gICAgcm90YXRlOiB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcblxuICAgIC8vIFN0YXJ0aW5nIG9wYWNpdHkgdmFsdWUsIGJlZm9yZSB0cmFuc2l0aW9uaW5nIHRvIHRoZSBjb21wdXRlZCBvcGFjaXR5LlxuICAgIG9wYWNpdHk6IDAsXG5cbiAgICAvLyBTdGFydGluZyBzY2FsZSB2YWx1ZSwgd2lsbCB0cmFuc2l0aW9uIGZyb20gdGhpcyB2YWx1ZSB0byAxXG4gICAgc2NhbGU6IDAuOSxcblxuICAgIC8vIEFjY2VwdHMgYW55IHZhbGlkIENTUyBlYXNpbmcsIGUuZy4gJ2Vhc2UnLCAnZWFzZS1pbi1vdXQnLCAnbGluZWFyJywgZXRjLlxuICAgIGVhc2luZzogJ2N1YmljLWJlemllcigwLjYsIDAuMiwgMC4xLCAxKScsXG5cbiAgICAvLyBgPGh0bWw+YCBpcyB0aGUgZGVmYXVsdCByZXZlYWwgY29udGFpbmVyLiBZb3UgY2FuIHBhc3MgZWl0aGVyOlxuICAgIC8vIERPTSBOb2RlLCBlLmcuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb29Db250YWluZXInKVxuICAgIC8vIFNlbGVjdG9yLCBlLmcuICcuZm9vQ29udGFpbmVyJ1xuICAgIGNvbnRhaW5lcjogd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblxuICAgIC8vIHRydWUvZmFsc2UgdG8gY29udHJvbCByZXZlYWwgYW5pbWF0aW9ucyBvbiBtb2JpbGUuXG4gICAgbW9iaWxlOiB0cnVlLFxuXG4gICAgLy8gdHJ1ZTogIHJldmVhbHMgb2NjdXIgZXZlcnkgdGltZSBlbGVtZW50cyBiZWNvbWUgdmlzaWJsZVxuICAgIC8vIGZhbHNlOiByZXZlYWxzIG9jY3VyIG9uY2UgYXMgZWxlbWVudHMgYmVjb21lIHZpc2libGVcbiAgICByZXNldDogZmFsc2UsXG5cbiAgICAvLyAnYWx3YXlzJyDigJQgZGVsYXkgZm9yIGFsbCByZXZlYWwgYW5pbWF0aW9uc1xuICAgIC8vICdvbmNlJyAgIOKAlCBkZWxheSBvbmx5IHRoZSBmaXJzdCB0aW1lIHJldmVhbHMgb2NjdXJcbiAgICAvLyAnb25sb2FkJyAtIGRlbGF5IG9ubHkgZm9yIGFuaW1hdGlvbnMgdHJpZ2dlcmVkIGJ5IGZpcnN0IGxvYWRcbiAgICB1c2VEZWxheTogJ2Fsd2F5cycsXG5cbiAgICAvLyBDaGFuZ2Ugd2hlbiBhbiBlbGVtZW50IGlzIGNvbnNpZGVyZWQgaW4gdGhlIHZpZXdwb3J0LiBUaGUgZGVmYXVsdCB2YWx1ZVxuICAgIC8vIG9mIDAuMjAgbWVhbnMgMjAlIG9mIGFuIGVsZW1lbnQgbXVzdCBiZSB2aXNpYmxlIGZvciBpdHMgcmV2ZWFsIHRvIG9jY3VyLlxuICAgIHZpZXdGYWN0b3I6IDAuMixcblxuICAgIC8vIFBpeGVsIHZhbHVlcyB0aGF0IGFsdGVyIHRoZSBjb250YWluZXIgYm91bmRhcmllcy5cbiAgICAvLyBlLmcuIFNldCBgeyB0b3A6IDQ4IH1gLCBpZiB5b3UgaGF2ZSBhIDQ4cHggdGFsbCBmaXhlZCB0b29sYmFyLlxuICAgIC8vIC0tXG4gICAgLy8gVmlzdWFsIEFpZDogaHR0cHM6Ly9zY3JvbGxyZXZlYWxqcy5vcmcvYXNzZXRzL3ZpZXdvZmZzZXQucG5nXG4gICAgdmlld09mZnNldDogeyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAgfSxcblxuICAgIC8vIENhbGxiYWNrcyB0aGF0IGZpcmUgZm9yIGVhY2ggY29tcGxldGVkIGVsZW1lbnQgcmV2ZWFsLCBhbmQgaWZcbiAgICAvLyBgY29uZmlnLnJlc2V0ID0gdHJ1ZWAsIGZvciBlYWNoIGNvbXBsZXRlZCBlbGVtZW50IHJlc2V0LiBXaGVuIGNyZWF0aW5nIHlvdXJcbiAgICAvLyBjYWxsYmFja3MsIHJlbWVtYmVyIHRoZXkgYXJlIHBhc3NlZCB0aGUgZWxlbWVudOKAmXMgRE9NIG5vZGUgdGhhdCB0cmlnZ2VyZWRcbiAgICAvLyBpdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgYmVmb3JlUmV2ZWFsOiBmdW5jdGlvbiAoZG9tRWwpIHt9LFxuICAgIGFmdGVyUmV2ZWFsOiBmdW5jdGlvbiAoZG9tRWwpIHt9LFxuICAgIGJlZm9yZVJlc2V0OiBmdW5jdGlvbiAoZG9tRWwpIHt9LFxuICAgIGFmdGVyUmVzZXQ6IGZ1bmN0aW9uIChkb21FbCkge31cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBjbGllbnQgc3VwcG9ydHMgQ1NTIFRyYW5zZm9ybSBhbmQgQ1NTIFRyYW5zaXRpb24uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBTY3JvbGxSZXZlYWwucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVxuICAgIHJldHVybiAnV2Via2l0VHJhbnNpdGlvbicgaW4gc3R5bGUgJiYgJ1dlYmtpdFRyYW5zZm9ybScgaW4gc3R5bGUgfHxcbiAgICAgICd0cmFuc2l0aW9uJyBpbiBzdHlsZSAmJiAndHJhbnNmb3JtJyBpbiBzdHlsZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZXZlYWwgc2V0LCBhIGdyb3VwIG9mIGVsZW1lbnRzIHRoYXQgd2lsbCBhbmltYXRlIHdoZW4gdGhleVxuICAgKiBiZWNvbWUgdmlzaWJsZS4gSWYgW2ludGVydmFsXSBpcyBwcm92aWRlZCwgYSBuZXcgc2VxdWVuY2UgaXMgY3JlYXRlZFxuICAgKiB0aGF0IHdpbGwgZW5zdXJlIGVsZW1lbnRzIHJldmVhbCBpbiB0aGUgb3JkZXIgdGhleSBhcHBlYXIgaW4gdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfE5vZGVMaXN0fHN0cmluZ30gW3RhcmdldF0gICBUaGUgbm9kZSwgbm9kZSBsaXN0IG9yIHNlbGVjdG9yIHRvIHVzZSBmb3IgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICBbY29uZmlnXSAgIE92ZXJyaWRlIHRoZSBkZWZhdWx0cyBmb3IgdGhpcyByZXZlYWwgc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICBbaW50ZXJ2YWxdIFRpbWUgYmV0d2VlbiBzZXF1ZW5jZWQgZWxlbWVudCBhbmltYXRpb25zIChtaWxsaXNlY29uZHMpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICBbc3luY10gICAgIFVzZWQgaW50ZXJuYWxseSB3aGVuIHVwZGF0aW5nIHJldmVhbHMgZm9yIGFzeW5jIGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGN1cnJlbnQgU2Nyb2xsUmV2ZWFsIGluc3RhbmNlLlxuICAgKi9cbiAgU2Nyb2xsUmV2ZWFsLnByb3RvdHlwZS5yZXZlYWwgPSBmdW5jdGlvbiAodGFyZ2V0LCBjb25maWcsIGludGVydmFsLCBzeW5jKSB7XG4gICAgdmFyIGNvbnRhaW5lclxuICAgIHZhciBlbGVtZW50c1xuICAgIHZhciBlbGVtXG4gICAgdmFyIGVsZW1JZFxuICAgIHZhciBzZXF1ZW5jZVxuICAgIHZhciBzZXF1ZW5jZUlkXG5cbiAgICAvLyBObyBjdXN0b20gY29uZmlndXJhdGlvbiB3YXMgcGFzc2VkLCBidXQgYSBzZXF1ZW5jZSBpbnRlcnZhbCBpbnN0ZWFkLlxuICAgIC8vIGxldOKAmXMgc2h1ZmZsZSB0aGluZ3MgYXJvdW5kIHRvIG1ha2Ugc3VyZSBldmVyeXRoaW5nIHdvcmtzLlxuICAgIGlmIChjb25maWcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJykge1xuICAgICAgaW50ZXJ2YWwgPSBjb25maWdcbiAgICAgIGNvbmZpZyA9IHt9XG4gICAgfSBlbHNlIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCB8fCBjb25maWcgPT09IG51bGwpIHtcbiAgICAgIGNvbmZpZyA9IHt9XG4gICAgfVxuXG4gICAgY29udGFpbmVyID0gX3Jlc29sdmVDb250YWluZXIoY29uZmlnKVxuICAgIGVsZW1lbnRzID0gX2dldFJldmVhbEVsZW1lbnRzKHRhcmdldCwgY29udGFpbmVyKVxuXG4gICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdTY3JvbGxSZXZlYWw6IHJldmVhbCBvbiBcIicgKyB0YXJnZXQgKyAnXCIgZmFpbGVkLCBubyBlbGVtZW50cyBmb3VuZC4nKVxuICAgICAgcmV0dXJuIHNyXG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSBhIG5ldyBzZXF1ZW5jZSBpZiBhbiBpbnRlcnZhbCBpcyBwYXNzZWQuXG4gICAgaWYgKGludGVydmFsICYmIHR5cGVvZiBpbnRlcnZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHNlcXVlbmNlSWQgPSBfbmV4dFVpZCgpXG5cbiAgICAgIHNlcXVlbmNlID0gc3Iuc2VxdWVuY2VzW3NlcXVlbmNlSWRdID0ge1xuICAgICAgICBpZDogc2VxdWVuY2VJZCxcbiAgICAgICAgaW50ZXJ2YWw6IGludGVydmFsLFxuICAgICAgICBlbGVtSWRzOiBbXSxcbiAgICAgICAgYWN0aXZlOiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJlZ2luIG1haW4gbG9vcCB0byBjb25maWd1cmUgU2Nyb2xsUmV2ZWFsIGVsZW1lbnRzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gY29uZmlndXJlZCBhbmQgZ3JhYiBpdCBmcm9tIHRoZSBzdG9yZS5cbiAgICAgIGVsZW1JZCA9IGVsZW1lbnRzW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1zci1pZCcpXG4gICAgICBpZiAoZWxlbUlkKSB7XG4gICAgICAgIGVsZW0gPSBzci5zdG9yZS5lbGVtZW50c1tlbGVtSWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGxldOKAmXMgZG8gc29tZSBiYXNpYyBzZXR1cC5cbiAgICAgICAgZWxlbSA9IHtcbiAgICAgICAgICBpZDogX25leHRVaWQoKSxcbiAgICAgICAgICBkb21FbDogZWxlbWVudHNbaV0sXG4gICAgICAgICAgc2VlbjogZmFsc2UsXG4gICAgICAgICAgcmV2ZWFsaW5nOiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGVsZW0uZG9tRWwuc2V0QXR0cmlidXRlKCdkYXRhLXNyLWlkJywgZWxlbS5pZClcbiAgICAgIH1cblxuICAgICAgLy8gU2VxdWVuY2Ugb25seSBzZXR1cFxuICAgICAgaWYgKHNlcXVlbmNlKSB7XG4gICAgICAgIGVsZW0uc2VxdWVuY2UgPSB7XG4gICAgICAgICAgaWQ6IHNlcXVlbmNlLmlkLFxuICAgICAgICAgIGluZGV4OiBzZXF1ZW5jZS5lbGVtSWRzLmxlbmd0aFxuICAgICAgICB9XG5cbiAgICAgICAgc2VxdWVuY2UuZWxlbUlkcy5wdXNoKGVsZW0uaWQpXG4gICAgICB9XG5cbiAgICAgIC8vIE5ldyBvciBleGlzdGluZyBlbGVtZW50LCBpdOKAmXMgdGltZSB0byB1cGRhdGUgaXRzIGNvbmZpZ3VyYXRpb24sIHN0eWxlcyxcbiAgICAgIC8vIGFuZCBzZW5kIHRoZSB1cGRhdGVzIHRvIG91ciBzdG9yZS5cbiAgICAgIF9jb25maWd1cmUoZWxlbSwgY29uZmlnLCBjb250YWluZXIpXG4gICAgICBfc3R5bGUoZWxlbSlcbiAgICAgIF91cGRhdGVTdG9yZShlbGVtKVxuXG4gICAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSBlbGVtZW50cyBhcmUgc2V0IHRvIHZpc2liaWxpdHk6IHZpc2libGUsIGV2ZW4gd2hlblxuICAgICAgLy8gb24gbW9iaWxlIGFuZCBgY29uZmlnLm1vYmlsZSA9PT0gZmFsc2VgLCBvciBpZiB1bnN1cHBvcnRlZC5cbiAgICAgIGlmIChzci50b29scy5pc01vYmlsZSgpICYmICFlbGVtLmNvbmZpZy5tb2JpbGUgfHwgIXNyLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgZWxlbS5kb21FbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgZWxlbS5zdHlsZXMuaW5saW5lKVxuICAgICAgICBlbGVtLmRpc2FibGVkID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmICghZWxlbS5yZXZlYWxpbmcpIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBwcm9jZWVkIG5vcm1hbGx5LlxuICAgICAgICBlbGVtLmRvbUVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLFxuICAgICAgICAgIGVsZW0uc3R5bGVzLmlubGluZSArXG4gICAgICAgICAgZWxlbS5zdHlsZXMudHJhbnNmb3JtLmluaXRpYWxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVhY2ggYHJldmVhbCgpYCBpcyByZWNvcmRlZCBzbyB0aGF0IHdoZW4gY2FsbGluZyBgc3luYygpYCB3aGlsZSB3b3JraW5nXG4gICAgLy8gd2l0aCBhc3luY2hyb25vdXNseSBsb2FkZWQgY29udGVudCwgaXQgY2FuIHJlLXRyYWNlIHlvdXIgc3RlcHMgYnV0IHdpdGhcbiAgICAvLyBhbGwgeW91ciBuZXcgZWxlbWVudHMgbm93IGluIHRoZSBET00uXG5cbiAgICAvLyBTaW5jZSBgcmV2ZWFsKClgIGlzIGNhbGxlZCBpbnRlcm5hbGx5IGJ5IGBzeW5jKClgLCB3ZSBkb27igJl0IHdhbnQgdG9cbiAgICAvLyByZWNvcmQgb3IgaW50aWlhbGl6ZSBlYWNoIHJldmVhbCBkdXJpbmcgc3luY2luZy5cbiAgICBpZiAoIXN5bmMgJiYgc3IuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgX3JlY29yZCh0YXJnZXQsIGNvbmZpZywgaW50ZXJ2YWwpXG5cbiAgICAgIC8vIFdlIHB1c2ggaW5pdGlhbGl6YXRpb24gdG8gdGhlIGV2ZW50IHF1ZXVlIHVzaW5nIHNldFRpbWVvdXQsIHNvIHRoYXQgd2UgY2FuXG4gICAgICAvLyBnaXZlIFNjcm9sbFJldmVhbCByb29tIHRvIHByb2Nlc3MgYWxsIHJldmVhbCBjYWxscyBiZWZvcmUgcHV0dGluZyB0aGluZ3MgaW50byBtb3Rpb24uXG4gICAgICAvLyAtLVxuICAgICAgLy8gUGhpbGlwIFJvYmVydHMgLSBXaGF0IHRoZSBoZWNrIGlzIHRoZSBldmVudCBsb29wIGFueXdheT8gKEpTQ29uZiBFVSAyMDE0KVxuICAgICAgLy8gaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj04YUdoWlFrb0ZiUVxuICAgICAgaWYgKHNyLmluaXRUaW1lb3V0KSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc3IuaW5pdFRpbWVvdXQpXG4gICAgICB9XG4gICAgICBzci5pbml0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KF9pbml0LCAwKVxuICAgIH1cblxuICAgIHJldHVybiBzclxuICB9XG5cbiAgLyoqXG4gICAqIFJlLXJ1bnMgYHJldmVhbCgpYCBmb3IgZWFjaCByZWNvcmQgc3RvcmVkIGluIGhpc3RvcnksIGVmZmVjdGl2ZWx5IGNhcHR1cmluZ1xuICAgKiBhbnkgY29udGVudCBsb2FkZWQgYXN5bmNocm9ub3VzbHkgdGhhdCBtYXRjaGVzIGV4aXN0aW5nIHJldmVhbCBzZXQgdGFyZ2V0cy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY3VycmVudCBTY3JvbGxSZXZlYWwgaW5zdGFuY2UuXG4gICAqL1xuICBTY3JvbGxSZXZlYWwucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNyLmhpc3RvcnkubGVuZ3RoICYmIHNyLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3IuaGlzdG9yeS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVjb3JkID0gc3IuaGlzdG9yeVtpXVxuICAgICAgICBzci5yZXZlYWwocmVjb3JkLnRhcmdldCwgcmVjb3JkLmNvbmZpZywgcmVjb3JkLmludGVydmFsLCB0cnVlKVxuICAgICAgfVxuICAgICAgX2luaXQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnU2Nyb2xsUmV2ZWFsOiBzeW5jIGZhaWxlZCwgbm8gcmV2ZWFscyBmb3VuZC4nKVxuICAgIH1cbiAgICByZXR1cm4gc3JcbiAgfVxuXG4gIC8qKlxuICAgKiBQcml2YXRlIE1ldGhvZHNcbiAgICogLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIGZ1bmN0aW9uIF9yZXNvbHZlQ29udGFpbmVyIChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5jb250YWluZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmNvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3Rvcihjb25maWcuY29udGFpbmVyKVxuICAgICAgfSBlbHNlIGlmIChzci50b29scy5pc05vZGUoY29uZmlnLmNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5jb250YWluZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTY3JvbGxSZXZlYWw6IGludmFsaWQgY29udGFpbmVyIFwiJyArIGNvbmZpZy5jb250YWluZXIgKyAnXCIgcHJvdmlkZWQuJylcbiAgICAgICAgY29uc29sZS5sb2coJ1Njcm9sbFJldmVhbDogZmFsbGluZyBiYWNrIHRvIGRlZmF1bHQgY29udGFpbmVyLicpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzci5kZWZhdWx0cy5jb250YWluZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVjayB0byBzZWUgaWYgYSBub2RlIG9yIG5vZGUgbGlzdCB3YXMgcGFzc2VkIGluIGFzIHRoZSB0YXJnZXQsXG4gICAqIG90aGVyd2lzZSBxdWVyeSB0aGUgY29udGFpbmVyIHVzaW5nIHRhcmdldCBhcyBhIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV8Tm9kZUxpc3R8c3RyaW5nfSBbdGFyZ2V0XSAgICBjbGllbnQgaW5wdXQgZm9yIHJldmVhbCB0YXJnZXQuXG4gICAqIEBwYXJhbSB7Tm9kZX0gICAgICAgICAgICAgICAgIFtjb250YWluZXJdIHBhcmVudCBlbGVtZW50IGZvciBzZWxlY3RvciBxdWVyaWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHthcnJheX0gZWxlbWVudHMgdG8gYmUgcmV2ZWFsZWQuXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0UmV2ZWFsRWxlbWVudHMgKHRhcmdldCwgY29udGFpbmVyKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0KSlcbiAgICB9IGVsc2UgaWYgKHNyLnRvb2xzLmlzTm9kZSh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gW3RhcmdldF1cbiAgICB9IGVsc2UgaWYgKHNyLnRvb2xzLmlzTm9kZUxpc3QodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRhcmdldClcbiAgICB9XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQSBjb25zaXN0ZW50IHdheSBvZiBjcmVhdGluZyB1bmlxdWUgSURzLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gX25leHRVaWQgKCkge1xuICAgIHJldHVybiArK3NyLnVpZFxuICB9XG5cbiAgZnVuY3Rpb24gX2NvbmZpZ3VyZSAoZWxlbSwgY29uZmlnLCBjb250YWluZXIpIHtcbiAgICAvLyBJZiBhIGNvbnRhaW5lciB3YXMgcGFzc2VkIGFzIGEgcGFydCBvZiB0aGUgY29uZmlnIG9iamVjdCxcbiAgICAvLyBsZXTigJlzIG92ZXJ3cml0ZSBpdCB3aXRoIHRoZSByZXNvbHZlZCBjb250YWluZXIgcGFzc2VkIGluLlxuICAgIGlmIChjb25maWcuY29udGFpbmVyKSBjb25maWcuY29udGFpbmVyID0gY29udGFpbmVyXG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzbuKAmXQgYWxyZWFkeSBiZWVuIGNvbmZpZ3VyZWQsIGxldOKAmXMgdXNlIGEgY2xvbmUgb2YgdGhlXG4gICAgLy8gZGVmYXVsdHMgZXh0ZW5kZWQgYnkgdGhlIGNvbmZpZ3VyYXRpb24gcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAgaWYgKCFlbGVtLmNvbmZpZykge1xuICAgICAgZWxlbS5jb25maWcgPSBzci50b29scy5leHRlbmRDbG9uZShzci5kZWZhdWx0cywgY29uZmlnKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIGxldOKAmXMgdXNlIGEgY2xvbmUgb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQgY29uZmlndXJhdGlvbiBleHRlbmRlZFxuICAgICAgLy8gYnkgdGhlIGNvbmZpZ3VyYXRpb24gcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAgICBlbGVtLmNvbmZpZyA9IHNyLnRvb2xzLmV4dGVuZENsb25lKGVsZW0uY29uZmlnLCBjb25maWcpXG4gICAgfVxuXG4gICAgLy8gSW5mZXIgQ1NTIFRyYW5zZm9ybSBheGlzIGZyb20gb3JpZ2luIHN0cmluZy5cbiAgICBpZiAoZWxlbS5jb25maWcub3JpZ2luID09PSAndG9wJyB8fCBlbGVtLmNvbmZpZy5vcmlnaW4gPT09ICdib3R0b20nKSB7XG4gICAgICBlbGVtLmNvbmZpZy5heGlzID0gJ1knXG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uY29uZmlnLmF4aXMgPSAnWCdcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfc3R5bGUgKGVsZW0pIHtcbiAgICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLmRvbUVsKVxuXG4gICAgaWYgKCFlbGVtLnN0eWxlcykge1xuICAgICAgZWxlbS5zdHlsZXMgPSB7XG4gICAgICAgIHRyYW5zaXRpb246IHt9LFxuICAgICAgICB0cmFuc2Zvcm06IHt9LFxuICAgICAgICBjb21wdXRlZDoge31cbiAgICAgIH1cblxuICAgICAgLy8gQ2FwdHVyZSBhbnkgZXhpc3RpbmcgaW5saW5lIHN0eWxlcywgYW5kIGFkZCBvdXIgdmlzaWJpbGl0eSBvdmVycmlkZS5cbiAgICAgIC8vIC0tXG4gICAgICAvLyBTZWUgc2VjdGlvbiA0LjIuIGluIHRoZSBEb2N1bWVudGF0aW9uOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2psbWFrZXMvc2Nyb2xscmV2ZWFsLmpzIzQyLWltcHJvdmUtdXNlci1leHBlcmllbmNlXG4gICAgICBlbGVtLnN0eWxlcy5pbmxpbmUgPSBlbGVtLmRvbUVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJ1xuICAgICAgZWxlbS5zdHlsZXMuaW5saW5lICs9ICc7IHZpc2liaWxpdHk6IHZpc2libGU7ICdcblxuICAgICAgLy8gZ3JhYiB0aGUgZWxlbWVudHMgZXhpc3Rpbmcgb3BhY2l0eS5cbiAgICAgIGVsZW0uc3R5bGVzLmNvbXB1dGVkLm9wYWNpdHkgPSBjb21wdXRlZC5vcGFjaXR5XG5cbiAgICAgIC8vIGdyYWIgdGhlIGVsZW1lbnRzIGV4aXN0aW5nIHRyYW5zaXRpb25zLlxuICAgICAgaWYgKCFjb21wdXRlZC50cmFuc2l0aW9uIHx8IGNvbXB1dGVkLnRyYW5zaXRpb24gPT09ICdhbGwgMHMgZWFzZSAwcycpIHtcbiAgICAgICAgZWxlbS5zdHlsZXMuY29tcHV0ZWQudHJhbnNpdGlvbiA9ICcnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLnN0eWxlcy5jb21wdXRlZC50cmFuc2l0aW9uID0gY29tcHV0ZWQudHJhbnNpdGlvbiArICcsICdcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdHJhbnNpdGlvbiBzdHlsZXNcbiAgICBlbGVtLnN0eWxlcy50cmFuc2l0aW9uLmluc3RhbnQgPSBfZ2VuZXJhdGVUcmFuc2l0aW9uKGVsZW0sIDApXG4gICAgZWxlbS5zdHlsZXMudHJhbnNpdGlvbi5kZWxheWVkID0gX2dlbmVyYXRlVHJhbnNpdGlvbihlbGVtLCBlbGVtLmNvbmZpZy5kZWxheSlcblxuICAgIC8vIEdlbmVyYXRlIHRyYW5zZm9ybSBzdHlsZXMsIGZpcnN0IHdpdGggdGhlIHdlYmtpdCBwcmVmaXguXG4gICAgZWxlbS5zdHlsZXMudHJhbnNmb3JtLmluaXRpYWwgPSAnIC13ZWJraXQtdHJhbnNmb3JtOidcbiAgICBlbGVtLnN0eWxlcy50cmFuc2Zvcm0udGFyZ2V0ID0gJyAtd2Via2l0LXRyYW5zZm9ybTonXG4gICAgX2dlbmVyYXRlVHJhbnNmb3JtKGVsZW0pXG5cbiAgICAvLyBBbmQgYWdhaW4gd2l0aG91dCBhbnkgcHJlZml4LlxuICAgIGVsZW0uc3R5bGVzLnRyYW5zZm9ybS5pbml0aWFsICs9ICd0cmFuc2Zvcm06J1xuICAgIGVsZW0uc3R5bGVzLnRyYW5zZm9ybS50YXJnZXQgKz0gJ3RyYW5zZm9ybTonXG4gICAgX2dlbmVyYXRlVHJhbnNmb3JtKGVsZW0pXG4gIH1cblxuICBmdW5jdGlvbiBfZ2VuZXJhdGVUcmFuc2l0aW9uIChlbGVtLCBkZWxheSkge1xuICAgIHZhciBjb25maWcgPSBlbGVtLmNvbmZpZ1xuXG4gICAgcmV0dXJuICctd2Via2l0LXRyYW5zaXRpb246ICcgKyBlbGVtLnN0eWxlcy5jb21wdXRlZC50cmFuc2l0aW9uICtcbiAgICAgICctd2Via2l0LXRyYW5zZm9ybSAnICsgY29uZmlnLmR1cmF0aW9uIC8gMTAwMCArICdzICcgK1xuICAgICAgY29uZmlnLmVhc2luZyArICcgJyArXG4gICAgICBkZWxheSAvIDEwMDAgKyAncywgb3BhY2l0eSAnICtcbiAgICAgIGNvbmZpZy5kdXJhdGlvbiAvIDEwMDAgKyAncyAnICtcbiAgICAgIGNvbmZpZy5lYXNpbmcgKyAnICcgK1xuICAgICAgZGVsYXkgLyAxMDAwICsgJ3M7ICcgK1xuXG4gICAgICAndHJhbnNpdGlvbjogJyArIGVsZW0uc3R5bGVzLmNvbXB1dGVkLnRyYW5zaXRpb24gK1xuICAgICAgJ3RyYW5zZm9ybSAnICsgY29uZmlnLmR1cmF0aW9uIC8gMTAwMCArICdzICcgK1xuICAgICAgY29uZmlnLmVhc2luZyArICcgJyArXG4gICAgICBkZWxheSAvIDEwMDAgKyAncywgb3BhY2l0eSAnICtcbiAgICAgIGNvbmZpZy5kdXJhdGlvbiAvIDEwMDAgKyAncyAnICtcbiAgICAgIGNvbmZpZy5lYXNpbmcgKyAnICcgK1xuICAgICAgZGVsYXkgLyAxMDAwICsgJ3M7ICdcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZW5lcmF0ZVRyYW5zZm9ybSAoZWxlbSkge1xuICAgIHZhciBjb25maWcgPSBlbGVtLmNvbmZpZ1xuICAgIHZhciBjc3NEaXN0YW5jZVxuICAgIHZhciB0cmFuc2Zvcm0gPSBlbGVtLnN0eWxlcy50cmFuc2Zvcm1cblxuICAgIC8vIExldOKAmXMgbWFrZSBzdXJlIG91ciBvdXIgcGl4ZWwgZGlzdGFuY2VzIGFyZSBuZWdhdGl2ZSBmb3IgdG9wIGFuZCBsZWZ0LlxuICAgIC8vIGUuZy4gb3JpZ2luID0gJ3RvcCcgYW5kIGRpc3RhbmNlID0gJzI1cHgnIHN0YXJ0cyBhdCBgdG9wOiAtMjVweGAgaW4gQ1NTLlxuICAgIGlmIChjb25maWcub3JpZ2luID09PSAndG9wJyB8fCBjb25maWcub3JpZ2luID09PSAnbGVmdCcpIHtcbiAgICAgIGNzc0Rpc3RhbmNlID0gL14tLy50ZXN0KGNvbmZpZy5kaXN0YW5jZSlcbiAgICAgICAgPyBjb25maWcuZGlzdGFuY2Uuc3Vic3RyKDEpXG4gICAgICAgIDogJy0nICsgY29uZmlnLmRpc3RhbmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNzc0Rpc3RhbmNlID0gY29uZmlnLmRpc3RhbmNlXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlSW50KGNvbmZpZy5kaXN0YW5jZSkpIHtcbiAgICAgIHRyYW5zZm9ybS5pbml0aWFsICs9ICcgdHJhbnNsYXRlJyArIGNvbmZpZy5heGlzICsgJygnICsgY3NzRGlzdGFuY2UgKyAnKSdcbiAgICAgIHRyYW5zZm9ybS50YXJnZXQgKz0gJyB0cmFuc2xhdGUnICsgY29uZmlnLmF4aXMgKyAnKDApJ1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnNjYWxlKSB7XG4gICAgICB0cmFuc2Zvcm0uaW5pdGlhbCArPSAnIHNjYWxlKCcgKyBjb25maWcuc2NhbGUgKyAnKSdcbiAgICAgIHRyYW5zZm9ybS50YXJnZXQgKz0gJyBzY2FsZSgxKSdcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5yb3RhdGUueCkge1xuICAgICAgdHJhbnNmb3JtLmluaXRpYWwgKz0gJyByb3RhdGVYKCcgKyBjb25maWcucm90YXRlLnggKyAnZGVnKSdcbiAgICAgIHRyYW5zZm9ybS50YXJnZXQgKz0gJyByb3RhdGVYKDApJ1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnJvdGF0ZS55KSB7XG4gICAgICB0cmFuc2Zvcm0uaW5pdGlhbCArPSAnIHJvdGF0ZVkoJyArIGNvbmZpZy5yb3RhdGUueSArICdkZWcpJ1xuICAgICAgdHJhbnNmb3JtLnRhcmdldCArPSAnIHJvdGF0ZVkoMCknXG4gICAgfVxuICAgIGlmIChjb25maWcucm90YXRlLnopIHtcbiAgICAgIHRyYW5zZm9ybS5pbml0aWFsICs9ICcgcm90YXRlWignICsgY29uZmlnLnJvdGF0ZS56ICsgJ2RlZyknXG4gICAgICB0cmFuc2Zvcm0udGFyZ2V0ICs9ICcgcm90YXRlWigwKSdcbiAgICB9XG4gICAgdHJhbnNmb3JtLmluaXRpYWwgKz0gJzsgb3BhY2l0eTogJyArIGNvbmZpZy5vcGFjaXR5ICsgJzsnXG4gICAgdHJhbnNmb3JtLnRhcmdldCArPSAnOyBvcGFjaXR5OiAnICsgZWxlbS5zdHlsZXMuY29tcHV0ZWQub3BhY2l0eSArICc7J1xuICB9XG5cbiAgZnVuY3Rpb24gX3VwZGF0ZVN0b3JlIChlbGVtKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGVsZW0uY29uZmlnLmNvbnRhaW5lclxuXG4gICAgLy8gSWYgdGhpcyBlbGVtZW504oCZcyBjb250YWluZXIgaXNu4oCZdCBhbHJlYWR5IGluIHRoZSBzdG9yZSwgbGV04oCZcyBhZGQgaXQuXG4gICAgaWYgKGNvbnRhaW5lciAmJiBzci5zdG9yZS5jb250YWluZXJzLmluZGV4T2YoY29udGFpbmVyKSA9PT0gLTEpIHtcbiAgICAgIHNyLnN0b3JlLmNvbnRhaW5lcnMucHVzaChlbGVtLmNvbmZpZy5jb250YWluZXIpXG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBlbGVtZW50IHN0b3JlZCB3aXRoIG91ciBuZXcgZWxlbWVudC5cbiAgICBzci5zdG9yZS5lbGVtZW50c1tlbGVtLmlkXSA9IGVsZW1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZWNvcmQgKHRhcmdldCwgY29uZmlnLCBpbnRlcnZhbCkge1xuICAgIC8vIFNhdmUgdGhlIGByZXZlYWwoKWAgYXJndW1lbnRzIHRoYXQgdHJpZ2dlcmVkIHRoaXMgYF9yZWNvcmQoKWAgY2FsbCwgc28gd2VcbiAgICAvLyBjYW4gcmUtdHJhY2Ugb3VyIHN0ZXBzIHdoZW4gY2FsbGluZyB0aGUgYHN5bmMoKWAgbWV0aG9kLlxuICAgIHZhciByZWNvcmQgPSB7XG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgaW50ZXJ2YWw6IGludGVydmFsXG4gICAgfVxuICAgIHNyLmhpc3RvcnkucHVzaChyZWNvcmQpXG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdCAoKSB7XG4gICAgaWYgKHNyLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIC8vIEluaXRpYWwgYW5pbWF0ZSBjYWxsIHRyaWdnZXJzIHZhbGlkIHJldmVhbCBhbmltYXRpb25zIG9uIGZpcnN0IGxvYWQuXG4gICAgICAvLyBTdWJzZXF1ZW50IGFuaW1hdGUgY2FsbHMgYXJlIG1hZGUgaW5zaWRlIHRoZSBldmVudCBoYW5kbGVyLlxuICAgICAgX2FuaW1hdGUoKVxuXG4gICAgICAvLyBUaGVuIHdlIGxvb3AgdGhyb3VnaCBhbGwgY29udGFpbmVyIG5vZGVzIGluIHRoZSBzdG9yZSBhbmQgYmluZCBldmVudFxuICAgICAgLy8gbGlzdGVuZXJzIHRvIGVhY2guXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyLnN0b3JlLmNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3Iuc3RvcmUuY29udGFpbmVyc1tpXS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBfaGFuZGxlcilcbiAgICAgICAgc3Iuc3RvcmUuY29udGFpbmVyc1tpXS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgLy8gTGV04oCZcyBhbHNvIGRvIGEgb25lLXRpbWUgYmluZGluZyBvZiB3aW5kb3cgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgaWYgKCFzci5pbml0aWFsaXplZCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX2hhbmRsZXIpXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfaGFuZGxlcilcbiAgICAgICAgc3IuaW5pdGlhbGl6ZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzclxuICB9XG5cbiAgZnVuY3Rpb24gX2hhbmRsZXIgKCkge1xuICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX2FuaW1hdGUpXG4gIH1cblxuICBmdW5jdGlvbiBfc2V0QWN0aXZlU2VxdWVuY2VzICgpIHtcbiAgICB2YXIgYWN0aXZlXG4gICAgdmFyIGVsZW1cbiAgICB2YXIgZWxlbUlkXG4gICAgdmFyIHNlcXVlbmNlXG5cbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIHNlcXVlbmNlc1xuICAgIHNyLnRvb2xzLmZvck93bihzci5zZXF1ZW5jZXMsIGZ1bmN0aW9uIChzZXF1ZW5jZUlkKSB7XG4gICAgICBzZXF1ZW5jZSA9IHNyLnNlcXVlbmNlc1tzZXF1ZW5jZUlkXVxuICAgICAgYWN0aXZlID0gZmFsc2VcblxuICAgICAgLy8gRm9yIGVhY2ggc2VxdWVuY2VkIGVsZW1lbmV0LCBsZXTigJlzIGNoZWNrIHZpc2liaWxpdHkgYW5kIGlmXG4gICAgICAvLyBhbnkgYXJlIHZpc2libGUsIHNldCBpdOKAmXMgc2VxdWVuY2UgdG8gYWN0aXZlLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXF1ZW5jZS5lbGVtSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1JZCA9IHNlcXVlbmNlLmVsZW1JZHNbaV1cbiAgICAgICAgZWxlbSA9IHNyLnN0b3JlLmVsZW1lbnRzW2VsZW1JZF1cbiAgICAgICAgaWYgKF9pc0VsZW1WaXNpYmxlKGVsZW0pICYmICFhY3RpdmUpIHtcbiAgICAgICAgICBhY3RpdmUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VxdWVuY2UuYWN0aXZlID0gYWN0aXZlXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hbmltYXRlICgpIHtcbiAgICB2YXIgZGVsYXllZFxuICAgIHZhciBlbGVtXG5cbiAgICBfc2V0QWN0aXZlU2VxdWVuY2VzKClcblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgZWxlbWVudHMgaW4gdGhlIHN0b3JlXG4gICAgc3IudG9vbHMuZm9yT3duKHNyLnN0b3JlLmVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbUlkKSB7XG4gICAgICBlbGVtID0gc3Iuc3RvcmUuZWxlbWVudHNbZWxlbUlkXVxuICAgICAgZGVsYXllZCA9IF9zaG91bGRVc2VEZWxheShlbGVtKVxuXG4gICAgICAvLyBMZXTigJlzIHNlZSBpZiB3ZSBzaG91bGQgcmV2ZWFsYW5kIGlmIHNvLFxuICAgICAgLy8gdHJpZ2dlciB0aGUgYGJlZm9yZVJldmVhbGAgY2FsbGJhY2sgYW5kXG4gICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gdXNlIGRlbGF5LlxuICAgICAgaWYgKF9zaG91bGRSZXZlYWwoZWxlbSkpIHtcbiAgICAgICAgZWxlbS5jb25maWcuYmVmb3JlUmV2ZWFsKGVsZW0uZG9tRWwpXG4gICAgICAgIGlmIChkZWxheWVkKSB7XG4gICAgICAgICAgZWxlbS5kb21FbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJyxcbiAgICAgICAgICAgIGVsZW0uc3R5bGVzLmlubGluZSArXG4gICAgICAgICAgICBlbGVtLnN0eWxlcy50cmFuc2Zvcm0udGFyZ2V0ICtcbiAgICAgICAgICAgIGVsZW0uc3R5bGVzLnRyYW5zaXRpb24uZGVsYXllZFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLmRvbUVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLFxuICAgICAgICAgICAgZWxlbS5zdHlsZXMuaW5saW5lICtcbiAgICAgICAgICAgIGVsZW0uc3R5bGVzLnRyYW5zZm9ybS50YXJnZXQgK1xuICAgICAgICAgICAgZWxlbS5zdHlsZXMudHJhbnNpdGlvbi5pbnN0YW50XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGV04oCZcyBxdWV1ZSB0aGUgYGFmdGVyUmV2ZWFsYCBjYWxsYmFja1xuICAgICAgICAvLyBhbmQgbWFyayB0aGUgZWxlbWVudCBhcyBzZWVuIGFuZCByZXZlYWxpbmcuXG4gICAgICAgIF9xdWV1ZUNhbGxiYWNrKCdyZXZlYWwnLCBlbGVtLCBkZWxheWVkKVxuICAgICAgICBlbGVtLnJldmVhbGluZyA9IHRydWVcbiAgICAgICAgZWxlbS5zZWVuID0gdHJ1ZVxuXG4gICAgICAgIGlmIChlbGVtLnNlcXVlbmNlKSB7XG4gICAgICAgICAgX3F1ZXVlTmV4dEluU2VxdWVuY2UoZWxlbSwgZGVsYXllZClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfc2hvdWxkUmVzZXQoZWxlbSkpIHtcbiAgICAgICAgLy9PdGhlcndpc2UgcmVzZXQgb3VyIGVsZW1lbnQgYW5kXG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIGBiZWZvcmVSZXNldGAgY2FsbGJhY2suXG4gICAgICAgIGVsZW0uY29uZmlnLmJlZm9yZVJlc2V0KGVsZW0uZG9tRWwpXG4gICAgICAgIGVsZW0uZG9tRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsXG4gICAgICAgICAgZWxlbS5zdHlsZXMuaW5saW5lICtcbiAgICAgICAgICBlbGVtLnN0eWxlcy50cmFuc2Zvcm0uaW5pdGlhbCArXG4gICAgICAgICAgZWxlbS5zdHlsZXMudHJhbnNpdGlvbi5pbnN0YW50XG4gICAgICAgIClcbiAgICAgICAgLy8gQW5kIHF1ZXVlIHRoZSBgYWZ0ZXJSZXNldGAgY2FsbGJhY2suXG4gICAgICAgIF9xdWV1ZUNhbGxiYWNrKCdyZXNldCcsIGVsZW0pXG4gICAgICAgIGVsZW0ucmV2ZWFsaW5nID0gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gX3F1ZXVlTmV4dEluU2VxdWVuY2UgKGVsZW0sIGRlbGF5ZWQpIHtcbiAgICB2YXIgZWxhcHNlZCA9IDBcbiAgICB2YXIgZGVsYXkgPSAwXG4gICAgdmFyIHNlcXVlbmNlID0gc3Iuc2VxdWVuY2VzW2VsZW0uc2VxdWVuY2UuaWRdXG5cbiAgICAvLyBXZeKAmXJlIHByb2Nlc3NpbmcgYSBzZXF1ZW5jZWQgZWxlbWVudCwgc28gbGV0J3MgYmxvY2sgb3RoZXIgZWxlbWVudHMgaW4gdGhpcyBzZXF1ZW5jZS5cbiAgICBzZXF1ZW5jZS5ibG9ja2VkID0gdHJ1ZVxuXG4gICAgLy8gU2luY2Ugd2XigJlyZSB0cmlnZ2VyaW5nIGFuaW1hdGlvbnMgYSBwYXJ0IG9mIGEgc2VxdWVuY2UgYWZ0ZXIgYW5pbWF0aW9ucyBvbiBmaXJzdCBsb2FkLFxuICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHRoYXQgY29uZGl0aW9uIGFuZCBleHBsaWNpdGx5IGFkZCB0aGUgZGVsYXkgdG8gb3VyIHRpbWVyLlxuICAgIGlmIChkZWxheWVkICYmIGVsZW0uY29uZmlnLnVzZURlbGF5ID09PSAnb25sb2FkJykge1xuICAgICAgZGVsYXkgPSBlbGVtLmNvbmZpZy5kZWxheVxuICAgIH1cblxuICAgIC8vIElmIGEgc2VxdWVuY2UgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nLCBjYXB0dXJlIHRoZSBlbGFwc2VkIHRpbWUgYW5kIGNsZWFyIGl0LlxuICAgIGlmIChlbGVtLnNlcXVlbmNlLnRpbWVyKSB7XG4gICAgICBlbGFwc2VkID0gTWF0aC5hYnMoZWxlbS5zZXF1ZW5jZS50aW1lci5zdGFydGVkIC0gbmV3IERhdGUoKSlcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZWxlbS5zZXF1ZW5jZS50aW1lcilcbiAgICB9XG5cbiAgICAvLyBTdGFydCBhIG5ldyB0aW1lci5cbiAgICBlbGVtLnNlcXVlbmNlLnRpbWVyID0geyBzdGFydGVkOiBuZXcgRGF0ZSgpIH1cbiAgICBlbGVtLnNlcXVlbmNlLnRpbWVyLmNsb2NrID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gU2VxdWVuY2UgaW50ZXJ2YWwgaGFzIHBhc3NlZCwgc28gdW5ibG9jayB0aGUgc2VxdWVuY2UgYW5kIHJlLXJ1biB0aGUgaGFuZGxlci5cbiAgICAgIHNlcXVlbmNlLmJsb2NrZWQgPSBmYWxzZVxuICAgICAgZWxlbS5zZXF1ZW5jZS50aW1lciA9IG51bGxcbiAgICAgIF9oYW5kbGVyKClcbiAgICB9LCBNYXRoLmFicyhzZXF1ZW5jZS5pbnRlcnZhbCkgKyBkZWxheSAtIGVsYXBzZWQpXG4gIH1cblxuICBmdW5jdGlvbiBfcXVldWVDYWxsYmFjayAodHlwZSwgZWxlbSwgZGVsYXllZCkge1xuICAgIHZhciBlbGFwc2VkID0gMFxuICAgIHZhciBkdXJhdGlvbiA9IDBcbiAgICB2YXIgY2FsbGJhY2sgPSAnYWZ0ZXInXG5cbiAgICAvLyBDaGVjayB3aGljaCBjYWxsYmFjayB3ZeKAmXJlIHdvcmtpbmcgd2l0aC5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3JldmVhbCc6XG4gICAgICAgIGR1cmF0aW9uID0gZWxlbS5jb25maWcuZHVyYXRpb25cbiAgICAgICAgaWYgKGRlbGF5ZWQpIHtcbiAgICAgICAgICBkdXJhdGlvbiArPSBlbGVtLmNvbmZpZy5kZWxheVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrICs9ICdSZXZlYWwnXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgZHVyYXRpb24gPSBlbGVtLmNvbmZpZy5kdXJhdGlvblxuICAgICAgICBjYWxsYmFjayArPSAnUmVzZXQnXG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gSWYgYSB0aW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcsIGNhcHR1cmUgdGhlIGVsYXBzZWQgdGltZSBhbmQgY2xlYXIgaXQuXG4gICAgaWYgKGVsZW0udGltZXIpIHtcbiAgICAgIGVsYXBzZWQgPSBNYXRoLmFicyhlbGVtLnRpbWVyLnN0YXJ0ZWQgLSBuZXcgRGF0ZSgpKVxuICAgICAgd2luZG93LmNsZWFyVGltZW91dChlbGVtLnRpbWVyLmNsb2NrKVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IGEgbmV3IHRpbWVyLlxuICAgIGVsZW0udGltZXIgPSB7IHN0YXJ0ZWQ6IG5ldyBEYXRlKCkgfVxuICAgIGVsZW0udGltZXIuY2xvY2sgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUaGUgdGltZXIgY29tcGxldGVkLCBzbyBsZXTigJlzIGZpcmUgdGhlIGNhbGxiYWNrIGFuZCBudWxsIHRoZSB0aW1lci5cbiAgICAgIGVsZW0uY29uZmlnW2NhbGxiYWNrXShlbGVtLmRvbUVsKVxuICAgICAgZWxlbS50aW1lciA9IG51bGxcbiAgICB9LCBkdXJhdGlvbiAtIGVsYXBzZWQpXG4gIH1cblxuICBmdW5jdGlvbiBfc2hvdWxkUmV2ZWFsIChlbGVtKSB7XG4gICAgaWYgKGVsZW0uc2VxdWVuY2UpIHtcbiAgICAgIHZhciBzZXF1ZW5jZSA9IHNyLnNlcXVlbmNlc1tlbGVtLnNlcXVlbmNlLmlkXVxuICAgICAgcmV0dXJuIHNlcXVlbmNlLmFjdGl2ZSAmJlxuICAgICAgICAhc2VxdWVuY2UuYmxvY2tlZCAmJlxuICAgICAgICAhZWxlbS5yZXZlYWxpbmcgJiZcbiAgICAgICAgIWVsZW0uZGlzYWJsZWRcbiAgICB9XG4gICAgcmV0dXJuIF9pc0VsZW1WaXNpYmxlKGVsZW0pICYmXG4gICAgICAhZWxlbS5yZXZlYWxpbmcgJiZcbiAgICAgICFlbGVtLmRpc2FibGVkXG4gIH1cblxuICBmdW5jdGlvbiBfc2hvdWxkVXNlRGVsYXkgKGVsZW0pIHtcbiAgICB2YXIgY29uZmlnID0gZWxlbS5jb25maWcudXNlRGVsYXlcbiAgICByZXR1cm4gY29uZmlnID09PSAnYWx3YXlzJyB8fFxuICAgICAgKGNvbmZpZyA9PT0gJ29ubG9hZCcgJiYgIXNyLmluaXRpYWxpemVkKSB8fFxuICAgICAgKGNvbmZpZyA9PT0gJ29uY2UnICYmICFlbGVtLnNlZW4pXG4gIH1cblxuICBmdW5jdGlvbiBfc2hvdWxkUmVzZXQgKGVsZW0pIHtcbiAgICBpZiAoZWxlbS5zZXF1ZW5jZSkge1xuICAgICAgdmFyIHNlcXVlbmNlID0gc3Iuc2VxdWVuY2VzW2VsZW0uc2VxdWVuY2UuaWRdXG4gICAgICByZXR1cm4gIXNlcXVlbmNlLmFjdGl2ZSAmJlxuICAgICAgICBlbGVtLmNvbmZpZy5yZXNldCAmJlxuICAgICAgICBlbGVtLnJldmVhbGluZyAmJlxuICAgICAgICAhZWxlbS5kaXNhYmxlZFxuICAgIH1cbiAgICByZXR1cm4gIV9pc0VsZW1WaXNpYmxlKGVsZW0pICYmXG4gICAgICBlbGVtLmNvbmZpZy5yZXNldCAmJlxuICAgICAgZWxlbS5yZXZlYWxpbmcgJiZcbiAgICAgICFlbGVtLmRpc2FibGVkXG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0Q29udGFpbmVyIChjb250YWluZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGNvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICAgIGhlaWdodDogY29udGFpbmVyLmNsaWVudEhlaWdodFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXRTY3JvbGxlZCAoY29udGFpbmVyKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBjb250YWluZXIgc2Nyb2xsIHZhbHVlcywgcGx1cyB0aGUgaXRzIG9mZnNldC5cbiAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lciAhPT0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgdmFyIG9mZnNldCA9IF9nZXRPZmZzZXQoY29udGFpbmVyKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogY29udGFpbmVyLnNjcm9sbExlZnQgKyBvZmZzZXQubGVmdCxcbiAgICAgICAgeTogY29udGFpbmVyLnNjcm9sbFRvcCArIG9mZnNldC50b3BcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCBkZWZhdWx0IHRvIHRoZSB3aW5kb3cgb2JqZWN04oCZcyBzY3JvbGwgdmFsdWVzLlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0T2Zmc2V0IChkb21FbCkge1xuICAgIHZhciBvZmZzZXRUb3AgPSAwXG4gICAgdmFyIG9mZnNldExlZnQgPSAwXG5cbiAgICAgIC8vIEdyYWIgdGhlIGVsZW1lbnTigJlzIGRpbWVuc2lvbnMuXG4gICAgdmFyIG9mZnNldEhlaWdodCA9IGRvbUVsLm9mZnNldEhlaWdodFxuICAgIHZhciBvZmZzZXRXaWR0aCA9IGRvbUVsLm9mZnNldFdpZHRoXG5cbiAgICAvLyBOb3cgY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbGVtZW50IGFuZCBpdHMgcGFyZW50LCB0aGVuXG4gICAgLy8gYWdhaW4gZm9yIHRoZSBwYXJlbnQgdG8gaXRzIHBhcmVudCwgYW5kIGFnYWluIGV0Yy4uLiB1bnRpbCB3ZSBoYXZlIHRoZVxuICAgIC8vIHRvdGFsIGRpc3RhbmNlIG9mIHRoZSBlbGVtZW50IHRvIHRoZSBkb2N1bWVudOKAmXMgdG9wIGFuZCBsZWZ0IG9yaWdpbi5cbiAgICBkbyB7XG4gICAgICBpZiAoIWlzTmFOKGRvbUVsLm9mZnNldFRvcCkpIHtcbiAgICAgICAgb2Zmc2V0VG9wICs9IGRvbUVsLm9mZnNldFRvcFxuICAgICAgfVxuICAgICAgaWYgKCFpc05hTihkb21FbC5vZmZzZXRMZWZ0KSkge1xuICAgICAgICBvZmZzZXRMZWZ0ICs9IGRvbUVsLm9mZnNldExlZnRcbiAgICAgIH1cbiAgICAgIGRvbUVsID0gZG9tRWwub2Zmc2V0UGFyZW50XG4gICAgfSB3aGlsZSAoZG9tRWwpXG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICBsZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgaGVpZ2h0OiBvZmZzZXRIZWlnaHQsXG4gICAgICB3aWR0aDogb2Zmc2V0V2lkdGhcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaXNFbGVtVmlzaWJsZSAoZWxlbSkge1xuICAgIHZhciBvZmZzZXQgPSBfZ2V0T2Zmc2V0KGVsZW0uZG9tRWwpXG4gICAgdmFyIGNvbnRhaW5lciA9IF9nZXRDb250YWluZXIoZWxlbS5jb25maWcuY29udGFpbmVyKVxuICAgIHZhciBzY3JvbGxlZCA9IF9nZXRTY3JvbGxlZChlbGVtLmNvbmZpZy5jb250YWluZXIpXG4gICAgdmFyIHZGID0gZWxlbS5jb25maWcudmlld0ZhY3RvclxuXG4gICAgICAvLyBEZWZpbmUgdGhlIGVsZW1lbnQgZ2VvbWV0cnkuXG4gICAgdmFyIGVsZW1IZWlnaHQgPSBvZmZzZXQuaGVpZ2h0XG4gICAgdmFyIGVsZW1XaWR0aCA9IG9mZnNldC53aWR0aFxuICAgIHZhciBlbGVtVG9wID0gb2Zmc2V0LnRvcFxuICAgIHZhciBlbGVtTGVmdCA9IG9mZnNldC5sZWZ0XG4gICAgdmFyIGVsZW1Cb3R0b20gPSBlbGVtVG9wICsgZWxlbUhlaWdodFxuICAgIHZhciBlbGVtUmlnaHQgPSBlbGVtTGVmdCArIGVsZW1XaWR0aFxuXG4gICAgcmV0dXJuIGNvbmZpcm1Cb3VuZHMoKSB8fCBpc1Bvc2l0aW9uRml4ZWQoKVxuXG4gICAgZnVuY3Rpb24gY29uZmlybUJvdW5kcyAoKSB7XG4gICAgICAvLyBEZWZpbmUgdGhlIGVsZW1lbnTigJlzIGZ1bmN0aW9uYWwgYm91bmRhcmllcyB1c2luZyBpdHMgdmlldyBmYWN0b3IuXG4gICAgICB2YXIgdG9wID0gZWxlbVRvcCArIGVsZW1IZWlnaHQgKiB2RlxuICAgICAgdmFyIGxlZnQgPSBlbGVtTGVmdCArIGVsZW1XaWR0aCAqIHZGXG4gICAgICB2YXIgYm90dG9tID0gZWxlbUJvdHRvbSAtIGVsZW1IZWlnaHQgKiB2RlxuICAgICAgdmFyIHJpZ2h0ID0gZWxlbVJpZ2h0IC0gZWxlbVdpZHRoICogdkZcblxuICAgICAgLy8gRGVmaW5lIHRoZSBjb250YWluZXIgZnVuY3Rpb25hbCBib3VuZGFyaWVzIHVzaW5nIGl0cyB2aWV3IG9mZnNldC5cbiAgICAgIHZhciB2aWV3VG9wID0gc2Nyb2xsZWQueSArIGVsZW0uY29uZmlnLnZpZXdPZmZzZXQudG9wXG4gICAgICB2YXIgdmlld0xlZnQgPSBzY3JvbGxlZC54ICsgZWxlbS5jb25maWcudmlld09mZnNldC5sZWZ0XG4gICAgICB2YXIgdmlld0JvdHRvbSA9IHNjcm9sbGVkLnkgLSBlbGVtLmNvbmZpZy52aWV3T2Zmc2V0LmJvdHRvbSArIGNvbnRhaW5lci5oZWlnaHRcbiAgICAgIHZhciB2aWV3UmlnaHQgPSBzY3JvbGxlZC54IC0gZWxlbS5jb25maWcudmlld09mZnNldC5yaWdodCArIGNvbnRhaW5lci53aWR0aFxuXG4gICAgICByZXR1cm4gdG9wIDwgdmlld0JvdHRvbSAmJlxuICAgICAgICBib3R0b20gPiB2aWV3VG9wICYmXG4gICAgICAgIGxlZnQgPiB2aWV3TGVmdCAmJlxuICAgICAgICByaWdodCA8IHZpZXdSaWdodFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUG9zaXRpb25GaXhlZCAoKSB7XG4gICAgICByZXR1cm4gKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0uZG9tRWwpLnBvc2l0aW9uID09PSAnZml4ZWQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXRpZXNcbiAgICogLS0tLS0tLS0tXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFRvb2xzICgpIHt9XG5cbiAgVG9vbHMucHJvdG90eXBlLmlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBPYmplY3RcbiAgfVxuXG4gIFRvb2xzLnByb3RvdHlwZS5pc05vZGUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuTm9kZSA9PT0gJ29iamVjdCdcbiAgICAgID8gb2JqZWN0IGluc3RhbmNlb2Ygd2luZG93Lk5vZGVcbiAgICAgIDogb2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnXG4gIH1cblxuICBUb29scy5wcm90b3R5cGUuaXNOb2RlTGlzdCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgcHJvdG90eXBlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KVxuICAgIHZhciByZWdleCA9IC9eXFxbb2JqZWN0IChIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdHxPYmplY3QpXFxdJC9cblxuICAgIHJldHVybiB0eXBlb2Ygd2luZG93Lk5vZGVMaXN0ID09PSAnb2JqZWN0J1xuICAgICAgPyBvYmplY3QgaW5zdGFuY2VvZiB3aW5kb3cuTm9kZUxpc3RcbiAgICAgIDogb2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHJlZ2V4LnRlc3QocHJvdG90eXBlVG9TdHJpbmcpICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAob2JqZWN0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmlzTm9kZShvYmplY3RbMF0pKVxuICB9XG5cbiAgVG9vbHMucHJvdG90eXBlLmZvck93biA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwib2JqZWN0XCIsIGJ1dCByZWNlaXZlZCBcIicgKyB0eXBlb2Ygb2JqZWN0ICsgJ1wiLicpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgVG9vbHMucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHRoaXMuZm9yT3duKHNvdXJjZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBpZiAodGhpcy5pc09iamVjdChzb3VyY2VbcHJvcGVydHldKSkge1xuICAgICAgICBpZiAoIXRhcmdldFtwcm9wZXJ0eV0gfHwgIXRoaXMuaXNPYmplY3QodGFyZ2V0W3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0ge31cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4dGVuZCh0YXJnZXRbcHJvcGVydHldLCBzb3VyY2VbcHJvcGVydHldKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV1cbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpXG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgVG9vbHMucHJvdG90eXBlLmV4dGVuZENsb25lID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHRoaXMuZXh0ZW5kKHt9LCB0YXJnZXQpLCBzb3VyY2UpXG4gIH1cblxuICBUb29scy5wcm90b3R5cGUuaXNNb2JpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlmaWxsc1xuICAgKiAtLS0tLS0tLVxuICAgKi9cblxuICBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKVxuICAgIH1cblxuICAvKipcbiAgICogTW9kdWxlIFdyYXBwZXJcbiAgICogLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBTY3JvbGxSZXZlYWxcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxSZXZlYWxcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuU2Nyb2xsUmV2ZWFsID0gU2Nyb2xsUmV2ZWFsXG4gIH1cbn0oKSlcbiIsInZhciBCUiA9IHtcblx0YWRkTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcblx0XHQvLyAkKCdhLmxpbmsnKS5ob3ZlciggXG5cdFx0Ly8gXHRmdW5jdGlvbigpe1xuXHRcdC8vIFx0XHR2YXIgcmVkSG92ZXIgPSAkKHRoaXMpLmZpbmQoJ3NwYW4nKTtcblx0XHQvLyBcdFx0JChyZWRIb3ZlcikuYW5pbWF0ZSh7XCJtYXJnaW5Cb3R0b21cIjpcIjEwcHhcIn0sIDMwMCk7XG5cdFx0Ly8gXHRcdCQocmVkSG92ZXIpLmFuaW1hdGUoe1wib3BhY2l0eVwiOlwiMVwifSwgMzAwKTtcblxuXHRcdC8vIFx0fSxcblx0XHQvLyBcdGZ1bmN0aW9uKCl7XG5cdFx0Ly8gXHRcdHZhciByZWRIb3ZlciA9ICQodGhpcykuZmluZCgnc3BhbicpO1xuXHRcdC8vIFx0XHQkKHJlZEhvdmVyKS5hbmltYXRlKHtcIm1hcmdpbkJvdHRvbVwiOlwiMFwifSwgMzAwKTtcblx0XHQvLyBcdFx0JChyZWRIb3ZlcikuYW5pbWF0ZSh7XCJvcGFjaXR5XCI6XCIwXCJ9LCAzMDApO1xuXHRcdC8vIFx0fVxuXHRcdC8vIClcblx0XHQkKCcuY2xvc2VfX21vZGFsJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdCQodGhpcykuY2xvc2VzdCgnLm1vZGFsX19iYWNrZ3JvdW5kJykuZmFkZU91dCgnMzAwJykuYWRkQ2xhc3MoJ2hpZGRlbicpO1xuXHRcdH0pO1xuXHRcdCQoJy5hY2NvcmRpb25fX3RyaWdnZXInKS5jbGljayggZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgdHJpZ2dlcklkID0gJCh0aGlzKS5kYXRhKCd0cmlnZ2VyLXRhcmdldCcpO1xuXHRcdFx0dmFyIGFjY29yZGlvbiA9ICQoJyMnK3RyaWdnZXJJZCk7XG5cdFx0XHQkKGFjY29yZGlvbikuc2xpZGVUb2dnbGUoNDAwKTtcblx0XHRcdC8vICQoYWNjb3JkaW9uKS5zbGlkZVRvZ2dsZSgzMDAsIGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBcdCQodGhpcykudG9nZ2xlQ2xhc3MoJ2hpZGRlbicpO1xuXHRcdFx0Ly8gfSlcblx0XHR9KVxuXG5cdFx0JCgnI2RpdmVyc2l0eU1vZGFsVHJpZ2dlcicpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRCUl9DT09LSUVTLnZpc2l0RGl2ZXJzaXR5KCk7XG5cdFx0XHRCUl9DT09LSUVTLnNob3dEaXZlcnNpdHlNb2RhbCgpO1xuXHRcdH0pO1xuXHR9XG59XG5cblxuXG4kKGZ1bmN0aW9uKCl7XG5cdEJSLmFkZExpc3RlbmVycygpO1xufSk7IiwidmFyIEJSX0NPT0tJRVMgPSB7XG5cdG9uTG9hZDogZnVuY3Rpb24oKXtcblx0XHRjb25zb2xlLmxvZyhcIkJSIENvb2tpZSBTY3JpcHRzIGxvYWRlZCFcIik7XG5cdH0sXG4gICAgY3JlYXRlQ29va2llOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgZGF5cykge1xuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKGRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgICB2YXIgZXhwaXJlcyA9IFwiOyBleHBpcmVzPVwiICsgZGF0ZS50b0dNVFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdmFyIGV4cGlyZXMgPSBcIlwiOyAgICAgICAgICAgICAgIFxuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IG5hbWUgKyBcIj1cIiArIHZhbHVlICsgZXhwaXJlcyArIFwiOyBwYXRoPS9cIjtcbiAgICB9LFxuXHRyZWFkQ29va2llOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBuYW1lRVEgPSBuYW1lICsgXCI9XCI7XG4gICAgICAgIHZhciBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIGMgPSBjLnN1YnN0cmluZygxLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGVyYXNlQ29va2llOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIEJSX0NPT0tJRVMuY3JlYXRlQ29va2llKG5hbWUsIFwiXCIsIC0xKTtcbiAgICB9LFxuXHR2aXNpdERpdmVyc2l0eTogZnVuY3Rpb24oKXtcblx0XHRCUl9DT09LSUVTLmNyZWF0ZUNvb2tpZShcInZpc2l0ZWREaXZlcnNpdHlcIiwgXCJ0cnVlXCIpO1xuXHRcdHZhciB2aXNpdGVkRGl2ZXJzaXR5ID0gQlJfQ09PS0lFUy5yZWFkQ29va2llKFwidmlzaXRlZERpdmVyc2l0eVwiKTtcblx0XHRjb25zb2xlLmxvZyh2aXNpdGVkRGl2ZXJzaXR5KTtcblx0fSxcblx0c2hvd0RpdmVyc2l0eU1vZGFsOiBmdW5jdGlvbigpIHtcblx0XHRjb25zb2xlLmxvZyhcIlNob3dpbmcgRU9FIE1vZGFsIVwiKTtcblx0XHR2YXIgZGl2ZXJzaXR5TW9kYWwgPSAkKCcubW9kYWxfX2JhY2tncm91bmQuZGl2ZXJzaXR5Jyk7XG5cdFx0ZGl2ZXJzaXR5TW9kYWwucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpLmZhZGVJbignc2xvdycpO1xuXHR9XG59XG5cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG5cdEJSX0NPT0tJRVMub25Mb2FkKCk7XG59KSIsInZhciBFWFBBTkRFUiA9IHtcblx0YWRkTGlzdGVuZXJzOiBmdW5jdGlvbigpe1xuXHRcdCQoJyNzaG93TW9yZVJlbGF0ZWRFeHBlcmllbmNlcywgLmV4cGVyaWVuY2VfZXhwYW5kZXInKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuXHRcdFx0JChkb2N1bWVudC5ib2R5KS50cmlnZ2VyKFwic3RpY2t5X2tpdDpyZWNhbGNcIik7XG5cdFx0XHR2YXIgaGlkZGVuRXhwZXJpZW5jZXMgPSAkKCcuc2lkZWJhcl9fY29sb3ItYmxvY2stLW91dGVyLXdyYXBwZXIuaGlkZGVuX19leHAnKTtcblx0XHRcdCQoaGlkZGVuRXhwZXJpZW5jZXMpLnRvZ2dsZUNsYXNzKCdoaWRkZW4nKTtcblx0XHRcdHZhciBoaWRkZW5NZW51SXRlbXMgPSAkKCcuc2lkZWJhci1pdGVtc19fd3JhcHBlcicpO1xuXHRcdFx0JChoaWRkZW5NZW51SXRlbXMpLnNsaWRlVG9nZ2xlKCczMDAnKTtcblx0XHRcdHZhciBleHBhbmRlciA9ICQoJy5leHBlcmllbmNlX2V4cGFuZGVyJyk7XG5cdFx0XHQkKGV4cGFuZGVyKS50b2dnbGVDbGFzcygnZXhwYW5kZWQnKTtcblx0XHRcdGlmICgkKCcjc2hvd01vcmVSZWxhdGVkRXhwZXJpZW5jZXMnKS5oYXNDbGFzcygnbW9yZScpKXtcblx0XHRcdFx0JCgnI3Nob3dNb3JlUmVsYXRlZEV4cGVyaWVuY2VzJykucmVtb3ZlQ2xhc3MoJ21vcmUnKS5hZGRDbGFzcygnbGVzcycpLnRleHQoXCJTSE9XIExFU1NcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCcjc2hvd01vcmVSZWxhdGVkRXhwZXJpZW5jZXMnKS5yZW1vdmVDbGFzcygnbGVzcycpLmFkZENsYXNzKCdtb3JlJykudGV4dChcIlNIT1cgTU9SRVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHQkKCcuam9iX2V4cGFuZGVyJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBleHBhbmRlciA9ICQodGhpcyk7XG5cdFx0XHR2YXIgaGlkZGVuSm9iRGVzY3JpcHRvbiA9ICQoZXhwYW5kZXIpLnBhcmVudCgpLnBhcmVudCgpLm5leHQoJ3RyJykuZmluZCgndGQnKTtcblx0XHRcdCQoaGlkZGVuSm9iRGVzY3JpcHRvbikuc2xpZGVUb2dnbGUoNDAwKTtcblx0XHRcdCQoZXhwYW5kZXIpLnRvZ2dsZUNsYXNzKCdleHBhbmRlZCcpO1xuXHRcdH0pO1xuXHRcdCQoJy5tb2JpbGVfX3NpZGViYXItLWV4cGFuZGVyJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBleHBhbmRlciA9ICQodGhpcyk7XG5cdFx0XHR2YXIgdHJpZ2dlcklkID0gJChleHBhbmRlcikuZGF0YSgnc2hvdy10YXJnZXQnKTtcblx0XHRcdHZhciBoaWRkZW5NZW51SXRlbXMgPSAkKCcjJyt0cmlnZ2VySWQpO1xuXHRcdFx0JChoaWRkZW5NZW51SXRlbXMpLnNsaWRlVG9nZ2xlKDQwMCk7XG5cdFx0XHRjb25zb2xlLmxvZygnZXhwYW5kZWQnKTtcblx0XHRcdCQoZXhwYW5kZXIpLnRvZ2dsZUNsYXNzKCdleHBhbmRlZCcpO1xuXHRcdH0pO1xuXG5cdH1cbn1cblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcblx0RVhQQU5ERVIuYWRkTGlzdGVuZXJzKCk7XG59KTtcblxuICIsImpRdWVyeSggJ2lmcmFtZVtzcmMqPVwieW91dHViZS5jb21cIl0nKS53cmFwKFwiPGRpdiBjbGFzcz0nZmxleC12aWRlbyB3aWRlc2NyZWVuJy8+XCIpO1xualF1ZXJ5KCAnaWZyYW1lW3NyYyo9XCJ2aW1lby5jb21cIl0nKS53cmFwKFwiPGRpdiBjbGFzcz0nZmxleC12aWRlbyB3aWRlc2NyZWVuIHZpbWVvJy8+XCIpO1xuIiwiLy8gJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcbi8vIFx0aWYgKCAkKFwiYm9keVwiKS5oYXNDbGFzcyhcInBhZ2UtdGVtcGxhdGUtaG9tZXBhZ2VcIikgKXtcbi8vIFx0XHQvLyBhbmltYXRlIGdyaWQgZWxlbWVudHMgb24gaG9tZXBhZ2Vcbi8vIFx0XHR3aW5kb3cuc3IgPSBTY3JvbGxSZXZlYWwoe2Rpc3RhbmNlOicxMCUnLCBkdXJhdGlvbjogOTAwLCBkZWxheTogMSwgcmVzZXQ6ZmFsc2UsIHNjYWxlOjAuOTksIGVhc2luZzogJ2xpbmVhcid9KTtcbi8vIFx0XHRzci5yZXZlYWwoJy5ob21lcGFnZS1ncmlkLWVsZW1lbnQnKTtcbi8vIFx0fVxuLy8gfSk7XG4iLCJqUXVlcnkoZG9jdW1lbnQpLmZvdW5kYXRpb24oKTtcbiIsInZhciBJTlNJR0hUUyA9IHtcblx0bGlzdGVuZXJzOiBmdW5jdGlvbigpe1xuXHRcdGNvbnNvbGUubG9nKCdJbnNpZ2h0cyBsaXN0ZW5lcnMganMgbG9hZGVkJyk7XG5cdFx0JCgnc2VsZWN0Lmluc2lnaHQnKS5jaGFuZ2UoZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBzZWxlY3RzID0gJCgnc2VsZWN0Jyk7XG5cdFx0XHR2YXIgcXVlcnlTdHJpbmdCYXNlID0gbG9jYXRpb24ub3JpZ2luICsgbG9jYXRpb24ucGF0aG5hbWU7XG5cdFx0XHR2YXIgcXVlcnlTdHJpbmcgPSBcIlwiO1xuXHRcdFx0dmFyIGZpbHRlcnMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSBzZWxlY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBzZWxlY3QgPSBzZWxlY3RzW2ldO1xuXHRcdFx0XHRpZiAoICQoc2VsZWN0KS52YWwoKS5sZW5ndGggPiAwICYmICAkKHNlbGVjdCkudmFsKCkgIT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0ZmlsdGVycy5wdXNoKCQoc2VsZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKFwiZmlsdGVyc1wiICsgZmlsdGVycyk7XG5cdFx0XHRmb3IodmFyIGkgPSBmaWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBwYXJhbU5hbWUgPSAkKGZpbHRlcnNbaV0pLmF0dHIoJ25hbWUnKTtcblx0XHRcdFx0dmFyIHBhcmFtVmFsdWUgPSAkKGZpbHRlcnNbaV0pLnZhbCgpO1xuXHRcdFx0XHRpZiAoIHBhcmFtVmFsdWUubGVuZ3RoID4gMCAmJiBpID09PSBmaWx0ZXJzLmxlbmd0aCAtIDEgKSB7XG5cdFx0XHRcdFx0cXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZ0Jhc2UgKyBcIj9cIiArIHBhcmFtTmFtZSArIFwiPVwiICsgcGFyYW1WYWx1ZTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhxdWVyeVN0cmluZyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcmFtVmFsdWUubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0XHRxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nICsgXCImXCIgKyBwYXJhbU5hbWUgKyBcIj1cIiArIHBhcmFtVmFsdWU7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cocXVlcnlTdHJpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBzZXQgYmFjayB0aGUgdXJsIHRvIHRoZSBiYXNlIGlmIHRoZXJlIGFyZSBubyBxdWVyaWVzIGxlZnRcblx0XHRcdGlmKCBxdWVyeVN0cmluZy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHF1ZXJ5U3RyaW5nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHF1ZXJ5U3RyaW5nQmFzZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdG9uTG9hZDogZnVuY3Rpb24oKXtcblx0XHQvLyBHZXQgc2VhcmNoIHBhcmFtIHZhbHVlcyBmcm9tIHVybFxuXHRcdHZhciBzZWxlY3RlZERhdGUgPSAkLnVybCgpLnBhcmFtKCdkYXRlX3F1ZXJ5JywgJ3N0cmljdCcpIHx8IFwiXCI7XG5cdFx0dmFyIHNlbGVjdGVkR2VvZ3JhcGh5ID0gJC51cmwoKS5wYXJhbSgnZ2VvZ3JhcGh5X3F1ZXJ5JywgJ3N0cmljdCcpIHx8IFwiXCI7XG5cdFx0dmFyIHNlbGVjdGVkSW5kdXN0cnkgPSAkLnVybCgpLnBhcmFtKCdpbmR1c3RyeV9xdWVyeScsICdzdHJpY3QnKSB8fCBcIlwiO1xuXHRcdHZhciBzZWxlY3RlZFByYWN0aWNlID0gJC51cmwoKS5wYXJhbSgncHJhY3RpY2VfcXVlcnknLCAnc3RyaWN0JykgfHwgXCJcIjtcblx0XHR2YXIgc2VsZWN0ZWRMYW5ndWFnZSA9ICQudXJsKCkucGFyYW0oJ2xhbmd1YWdlX3F1ZXJ5JywgJ3N0cmljdCcpIHx8IFwiXCI7XG5cdFx0dmFyIHNlbGVjdGVkTG9jYXRpb25zID0gJC51cmwoKS5wYXJhbSgnbG9jYXRpb25fcXVlcnknLCAnc3RyaWN0JykgfHwgXCJcIjtcblx0XHR2YXIgc2VsZWN0ZWRBZG1pc3Npb24gPSAkLnVybCgpLnBhcmFtKCdhZG1pc3Npb25fcXVlcnknLCAnc3RyaWN0JykgfHwgXCJcIjtcblx0XHR2YXIgc2VsZWN0ZWRFZHVjYXRpb24gPSAkLnVybCgpLnBhcmFtKCdlZHVjYXRpb25fcXVlcnknLCAnc3RyaWN0JykgfHwgXCJcIjtcblx0XHR2YXIgc2VsZWN0ZWRLZXl3b3JkID0gJC51cmwoKS5wYXJhbSgna2V5d29yZCcsICdzdHJpY3QnKSB8fCBcIlwiO1xuXG5cdFx0Ly8gU2V0IHZhcnMgZm9yIHNlbGVjdHMgZm9yIGFsbCBzZWFyY2ggcGFyYW1zXG5cdFx0dmFyIGRhdGVTZWxlY3QgPSAkKCdzZWxlY3QjZGF0ZVNlbGVjdCcpO1xuXHRcdHZhciBnZW9ncmFwaHlTZWxlY3QgPSAkKCdzZWxlY3QjZ2VvZ3JhcGh5U2VsZWN0Jyk7XG5cdFx0dmFyIGluZHVzdHJ5U2VsZWN0ID0gJCgnc2VsZWN0I2luZHVzdHJ5U2VsZWN0Jyk7XG5cdFx0dmFyIHByYWN0aWNlU2VsZWN0ID0gJCgnc2VsZWN0I3ByYWN0aWNlU2VsZWN0Jyk7XG5cdFx0dmFyIGxhbmd1YWdlU2VsZWN0ID0gJCgnc2VsZWN0I2xhbmd1YWdlU2VsZWN0Jyk7XG5cdFx0dmFyIGxvY2F0aW9uU2VsZWN0ID0gJCgnc2VsZWN0I2xvY2F0aW9uU2VsZWN0Jyk7XG5cdFx0dmFyIGFkbWlzc2lvblNlbGVjdCA9ICQoJ3NlbGVjdCNhZG1pc3Npb25TZWxlY3QnKTtcblx0XHR2YXIgZWR1Y2F0aW9uU2VsZWN0ID0gJCgnc2VsZWN0I2VkdWNhdGlvblNlbGVjdCcpO1xuXHRcdHZhciBrZXl3b3JkSW5wdXQgPSAkKCdpbnB1dCNrZXl3b3JkSW5wdXQnKTtcblxuXHRcdC8vIENoYW5nZSB2YWx1ZSBvZiBzZWxlY3RzIGJhc2VkIG9uIHVybCBwYXJhbXNcblx0XHRkYXRlU2VsZWN0LnZhbChkZWNvZGVVUklDb21wb25lbnQoc2VsZWN0ZWREYXRlKSk7XG5cdFx0Z2VvZ3JhcGh5U2VsZWN0LnZhbChkZWNvZGVVUklDb21wb25lbnQoc2VsZWN0ZWRHZW9ncmFwaHkpKTtcblx0XHRpbmR1c3RyeVNlbGVjdC52YWwoZGVjb2RlVVJJQ29tcG9uZW50KHNlbGVjdGVkSW5kdXN0cnkpKTtcblx0XHRwcmFjdGljZVNlbGVjdC52YWwoZGVjb2RlVVJJQ29tcG9uZW50KHNlbGVjdGVkUHJhY3RpY2UpKTtcblx0XHRsYW5ndWFnZVNlbGVjdC52YWwoZGVjb2RlVVJJQ29tcG9uZW50KHNlbGVjdGVkTGFuZ3VhZ2UpKTtcblx0XHRsb2NhdGlvblNlbGVjdC52YWwoZGVjb2RlVVJJQ29tcG9uZW50KHNlbGVjdGVkTG9jYXRpb25zKSk7XG5cdFx0YWRtaXNzaW9uU2VsZWN0LnZhbChkZWNvZGVVUklDb21wb25lbnQoc2VsZWN0ZWRBZG1pc3Npb24pKTtcblx0XHRlZHVjYXRpb25TZWxlY3QudmFsKGRlY29kZVVSSUNvbXBvbmVudChzZWxlY3RlZEVkdWNhdGlvbikpO1xuXHRcdGtleXdvcmRJbnB1dC52YWwoZGVjb2RlVVJJQ29tcG9uZW50KHNlbGVjdGVkS2V5d29yZCkpO1xuXHR9XG59XG5cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG5cdElOU0lHSFRTLmxpc3RlbmVycygpO1xuXHRJTlNJR0hUUy5vbkxvYWQoKTtcbn0pXG4iLCIvLyBKb3lyaWRlIGRlbW9cbiQoJyNzdGFydC1qcicpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAkKGRvY3VtZW50KS5mb3VuZGF0aW9uKCdqb3lyaWRlJywnc3RhcnQnKTtcbn0pOyIsInZhciBMT0NBVElPTlNFQVJDSEVSID0ge1xuXHRkZXRlY3RDaGFuZ2U6IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gbGlzdGVuIGZvciBjaGFuZ2VzIGluIHNlbGVjdCBvcHRpb25zIGVsZW1lbnRcblx0XHQkKCcjbG9jYXRpb25TZWxlY3QnKS5jaGFuZ2UoZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0Ly8gYnVpbGQgcXVlcnkgc3RyaW5nXG5cdFx0XHR2YXIga2V5d29yZCA9ICQoJyNsb2NhdGlvblNlbGVjdCcpLnZhbCgpIHx8IFwiXCI7XHRcdFx0XG5cdFx0XHR2YXIgcXVlcnlTdHJpbmdCYXNlID0gbG9jYXRpb24ub3JpZ2luICsgbG9jYXRpb24ucGF0aG5hbWU7XG5cdFx0XHR2YXIgcXVlcnlTdHJpbmcgPSBcIlwiICsgXCI/am9iX2xvY2F0aW9uX3F1ZXJ5PVwiK2tleXdvcmQ7XG5cdFx0XHQvLyByZWxvYWQgdGhlIHBhZ2Ugd2l0aCB0aGUga2V5d29yZCBhcyB0aGUgdXJsXG5cdFx0XHR3aW5kb3cubG9jYXRpb24ucmVwbGFjZShxdWVyeVN0cmluZyk7XHRcdFxuXHRcdH0pO1xuXHR9LFxuXHQvLyBtYWtlIHNlbGVjdCB2YWx1ZSByZWZsZWN0IHlvdXIgbW9zdCByZWNlbnQgc2VhcmNoIHBhcmFtXG5cdG9uTG9hZDogZnVuY3Rpb24oKXtcblx0XHR2YXIgam9iS2V5d29yZCA9ICQudXJsKCkucGFyYW0oJ2pvYl9sb2NhdGlvbl9xdWVyeScsICdzdHJpY3QnKTtcblx0XHR2YXIgbG9jYXRpb25TZWxlY3QgPSAkKCcjbG9jYXRpb25TZWxlY3QnKTtcblx0XHRpZiAoam9iS2V5d29yZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRsb2NhdGlvblNlbGVjdC52YWwoZGVjb2RlVVJJQ29tcG9uZW50KGpvYktleXdvcmQpKTtcblx0XHR9XG5cdFx0XG5cdH1cbn1cblxuJCgnZG9jdW1lbnQnKS5yZWFkeShmdW5jdGlvbigpe1xuXHRMT0NBVElPTlNFQVJDSEVSLmRldGVjdENoYW5nZSgpOyBcblx0TE9DQVRJT05TRUFSQ0hFUi5vbkxvYWQoKTtcbn0pOyIsInZhciBtb2JpbGVNZW51ID0ge1xuXHRcdG9wZW5Ecm9wZG93bjogZnVuY3Rpb24oKXtcblx0XHRcdC8vIGVuYWJsZSBvciBkaXNhYmxlIHNjcm9sbCBmb3IgbW9iaWxlIGRyb3Bkb3duIGZ1bmN0aW9uXG5cdFx0XHR2YXIgY2hlY2tTY3JvbGwgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCQoJ2JvZHknKS5oYXNDbGFzcygnbm8tc2Nyb2xsJykpIHtcblx0XHRcdFx0XHRkaXNhYmxlU2Nyb2xsLm9uKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGlzYWJsZVNjcm9sbC5vZmYoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0JCgnI29wZW4tbW9iaWxlLW1lbnUnKS5jbGljayhmdW5jdGlvbigpe1xuXHRcdFx0XHQkKCcjbWVudS1tb2JpbGUtbWVudScpLnNsaWRlVG9nZ2xlKCk7XG5cdFx0XHRcdCQoJyNzZWFyY2hfX2ljb25fX21vYmlsZScpLnNsaWRlVG9nZ2xlKCk7XG5cdFx0XHRcdCQoJyNtb2JpbGVfX2xvZ29fX2NvbnRhaW5lcicpLnNsaWRlVG9nZ2xlKCk7XG5cdFx0XHRcdCQoJyNvcGVuLW1vYmlsZS1tZW51JykudG9nZ2xlQ2xhc3MoJ21vYmlsZS1hY3RpdmUnKTtcblx0XHRcdFx0JCgnI29wZW4tbW9iaWxlLW1lbnUnKS50b2dnbGVDbGFzcygnY2xvc2VfX21vZGFsJyk7XG5cdFx0XHRcdCQoJyNvcGVuLW1vYmlsZS1tZW51JykuY3NzKHsndG9wJzonNXB4JywgJ2xlZnQnOiAnMCd9KTtcblx0XHRcdFx0JCgnLm1vYmlsZV9fbWVudV9fYm90dG9tJykudG9nZ2xlKCk7XG5cdFx0XHRcdCQoJ2JvZHknKS50b2dnbGVDbGFzcygnbm8tc2Nyb2xsJyk7XG5cdFx0XHRcdCQoJy5odW1hbi1pY29uJykuc2xpZGVUb2dnbGUoKTtcdFx0XHRcblx0XHRcdFx0Ly8gY2FsbCBjaGVjayBzY3JvbGwgZnVuY3Rpb24gZGVmaW5lZCBhYm92ZVxuXHRcdFx0XHRjaGVja1Njcm9sbCgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcbn1cblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcblx0bW9iaWxlTWVudS5vcGVuRHJvcGRvd24oKTtcbn0pO1xuXG4iLCIvLyBkZXNrdG9wIG5hdmlnYXRpb24gaG92ZXIgaW50ZXJhY3Rpb25zXG5cbi8vIGVkaXRlZCBmb3VuZGF0aW9uLmRyb3Bkb3duTWVudS5qcyBsaW5lIDM2OCB0byBtYWtlIGRlbGF5IG9uIGNsb3NpbmcgdGltZSBhZnRlciBtb3VzZW91dCBldmVudCBzaG9ydGVyIFxuLy8gdG8gcmVzdG9yZSB0byBkZWZhdWx0LCBzZXQgdGhpcyBudW1iZXIgdG8gJzUwMCdcblxudmFyIE5BViA9IHtcblx0Ly8gbGlzdGVuZXJzOiBmdW5jdGlvbigpe1xuXHQvLyBcdFx0Ly8gbWVkaXVtIGJyZWFrcG9pbnQgaG92ZXIgaW50ZXJhY3Rpb24gZm9yIG5hdmlnYXRpb25cblx0Ly8gXHQvLyBpZiAoJCh3aW5kb3cpLmlubmVyV2lkdGgoKSA+IDcwMCApIHtcblx0Ly8gXHQvLyBcdFx0JCgnLm1lbnUtaXRlbS1oYXMtY2hpbGRyZW4nKS5vbih7XG5cdC8vIFx0Ly8gXHRcdFx0bW91c2VvdmVyOiBmdW5jdGlvbigpe1x0XHRcdFx0XHRcblx0Ly8gXHQvLyBcdFx0XHRcdCQoJy5zdWJuYXZfX2NvbG9yLWJsb2NrJykuc3RvcCgpLnNob3coMzEwKTtcblx0Ly8gXHQvLyBcdFx0XHR9LFxuXHQvLyBcdC8vIFx0XHRcdG1vdXNlb3V0OiBmdW5jdGlvbigpe1x0XHRcdFx0XHRcdFxuXHQvLyBcdC8vIFx0XHRcdFx0JCgnLnN1Ym5hdl9fY29sb3ItYmxvY2snKS5zdG9wKCkuaGlkZSgzMTApO1xuXHQvLyBcdC8vIFx0XHRcdH1cblx0Ly8gXHQvLyBcdFx0fSk7XHRcblx0Ly8gXHQvLyBcdH1cblxuXHQvLyBcdFx0aWYgKCQod2luZG93KS5pbm5lcldpZHRoKCkgPiA3NjggKSB7XG5cdC8vIFx0XHRcdCQoJy5tZW51LWl0ZW0taGFzLWNoaWxkcmVuJykub24oe1xuXHQvLyBcdFx0XHRcdG1vdXNlb3ZlcjogZnVuY3Rpb24oKXtcdFx0XHRcdFx0XG5cdC8vIFx0XHRcdFx0XHQvLyQoJy5zdWJuYXZfX2NvbG9yLWJsb2NrJykuc3RvcCgpLnNob3coMzEwKTtcblx0Ly8gXHRcdFx0XHR9LFxuXHQvLyBcdFx0XHRcdG1vdXNlb3V0OiBmdW5jdGlvbigpe1x0XHRcdFx0XHRcdFxuXHQvLyBcdFx0XHRcdFx0Ly8kKCcuc3VibmF2X19jb2xvci1ibG9jaycpLnN0b3AoKS5oaWRlKDMxMCk7XG5cdC8vIFx0XHRcdFx0fVxuXHQvLyBcdFx0XHR9KTtcdFxuXHQvLyBcdFx0fVxuXG5cdC8vIH0sXG5cdGRlc2t0b3BNZW51OiAkKCcjbWFzdGhlYWQnKSxcblx0Ly8gaGlkZSBvciBzaG93IHNjcm9sbCBuYXYgYmFyXG5cdHNjcm9sbEV2ZW50czogZnVuY3Rpb24oKXtcblx0XHQvLyBkaWZmZXJlbnRpYXRlIGJ0dyBtb2JpbGUgYW5kIGFsbCBlbHNlXG5cdFx0dmFyIGRlc2t0b3BDaGVjayA9ICQod2luZG93KS5zY3JvbGxUb3AoKSA+PSBOQVYuZGVza3RvcE1lbnUuaGVpZ2h0KCk7XG5cdFx0dmFyIG1vYmlsZUNoZWNrID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpID4gMjUwO1xuXHRcdHZhciBjaGVjaztcblx0XHRpZiAoJChkb2N1bWVudCkud2lkdGgoKSA+PSA2NDApIHtcblx0XHRcdGNoZWNrID0gZGVza3RvcENoZWNrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGVjayA9IG1vYmlsZUNoZWNrO1xuXHRcdH1cblx0XHRpZiAoIGNoZWNrICApIHtcblx0XHRcdCQoTkFWLmRlc2t0b3BNZW51KS5jc3MoJ29wYWNpdHknLCAnMCcpO1xuXHRcdFx0JCgnLm1lbnVfX291dGVyLXdyYXBwZXItLWRlc2t0b3Atb24tc2Nyb2xsJykuc2xpZGVEb3duKCdmYXN0Jyk7XG5cdFx0XHQkKCcjbWVudS1uZXN0ZWQtcGFnZXMtMScpLmFkZENsYXNzKCdzY3JvbGxlZCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkKE5BVi5kZXNrdG9wTWVudSkuY3NzKCdvcGFjaXR5JywgJzEnKTtcblx0XHRcdCQoJy5tZW51X19vdXRlci13cmFwcGVyLS1kZXNrdG9wLW9uLXNjcm9sbCcpLnNsaWRlVXAoJ2Zhc3QnKTtcblx0XHRcdCQoJyNtZW51LW5lc3RlZC1wYWdlcy0xJykucmVtb3ZlQ2xhc3MoJ3Njcm9sbGVkJyk7XG5cdFx0fVxuXHR9LFx0XG5cdC8vIGNvcnJlY3RzIHNwYWNpbmcgb2YgbGFzdCBhbmQgZmlyc3Qgc3VibWVudSBpdGVtXG5cdHN1Ym1lbnVDb3JyZWN0aW9uOiBmdW5jdGlvbigpe1xuXHRcdC8vIGZvciByZWd1bGFyIG1lbnVcblx0XHQkKCcuaXMtZHJvcGRvd24tc3VibWVudTplcSgwKScgKS5hZGRDbGFzcygnZmlyc3Qtc3VibWVudS1pdGVtJyk7XG5cdFx0JCgnLmlzLWRyb3Bkb3duLXN1Ym1lbnU6ZXEoMiknICkuYWRkQ2xhc3MoJ2JlZm9yZS1sYXN0LXN1Ym1lbnUtaXRlbScpO1xuXHRcdCQoJy5pcy1kcm9wZG93bi1zdWJtZW51OmVxKDMpJyApLmFkZENsYXNzKCdsYXN0LXN1Ym1lbnUtaXRlbScpO1xuXHRcdC8vIGZvciBzY3JvbGwgbWVudVxuXHRcdCQoJy5pcy1kcm9wZG93bi1zdWJtZW51OmVxKDQpJyApLmFkZENsYXNzKCdmaXJzdC1zdWJtZW51LWl0ZW0tc2Nyb2xsJyk7XG5cdFx0JCgnLmlzLWRyb3Bkb3duLXN1Ym1lbnU6ZXEoNiknICkuYWRkQ2xhc3MoJ2JlZm9yZS1sYXN0LXN1Ym1lbnUtaXRlbS1zY3JvbGwnKTtcblx0XHQkKCcuaXMtZHJvcGRvd24tc3VibWVudTplcSg3KScgKS5hZGRDbGFzcygnbGFzdC1zdWJtZW51LWl0ZW0tc2Nyb2xsJyk7XG5cdH1cblxufVxuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuXHQvL05BVi5saXN0ZW5lcnMoKTtcblx0TkFWLnN1Ym1lbnVDb3JyZWN0aW9uKCk7XG5cdFx0JChkb2N1bWVudCkuc2Nyb2xsKCBmdW5jdGlvbigpe1xuXHRcdFx0TkFWLnNjcm9sbEV2ZW50cygpO1xuXHRcdH0pXG5cblx0aWYgKCAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgPj0gTkFWLmRlc2t0b3BNZW51LmhlaWdodCgpICYmICQoZG9jdW1lbnQpLndpZHRoKCkgPj0gNzY4KSB7XG5cdFx0Ly8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHBhZ2UgbG9hZCBhbmQgdXNlciBzY3JvbGxcblx0XHQvLyBvdGhlcndpc2UgcmVndWxhciBtZW51IGlzIGFsd2F5cyBoaWRkZW4gb24gcGFnZSBsb2FkIGF0IHNjcm9sbCBsb2NhdGlvbiA6UFxuXHRcdHZhciB1c2VyU2Nyb2xsID0gZmFsc2U7ICAgICBcblx0XHRmdW5jdGlvbiBtb3VzZUV2ZW50KGUpIHsgXG5cdFx0XHR1c2VyU2Nyb2xsID0gdHJ1ZTsgXG5cdFx0fSBcblx0XHQvLyBvbmx5IGhpZGUgaWYgdXNlciBoYXMgc2Nyb2xsZWRcblx0XHRpZiAodXNlclNjcm9sbCkge1xuXHRcdFx0JChOQVYuZGVza3RvcE1lbnUpLmhpZGUoKTtcblx0XHR9XG5cdH1cbn0pXG5cblxuXG5cblxuXG5cbi8vIHZhciBuYXZiYXIgPSB7XG4vLyBcdG9uSG92ZXI6IGZ1bmN0aW9uKCl7XG4vLyBcdFx0Ly8gbWVkaXVtIGJyZWFrcG9pbnRcbi8vIFx0XHRpZiAoJCh3aW5kb3cpLmlubmVyV2lkdGgoKSA+IDcwMCApIHtcbi8vIFx0XHRcdFx0JCgnLm1lbnUtaXRlbS1oYXMtY2hpbGRyZW4nKS5vbih7XG4vLyBcdFx0XHRcdFx0bW91c2VvdmVyOiBmdW5jdGlvbigpe1xuLy8gXHRcdFx0XHRcdFx0JCgnLnN1Ym5hdl9fY29sb3ItYmxvY2snKS5zdG9wKCkuc2hvdyg0MTApO1xuLy8gXHRcdFx0XHRcdH0sXG4vLyBcdFx0XHRcdFx0bW91c2VvdXQ6IGZ1bmN0aW9uKCl7XG4vLyBcdFx0XHRcdFx0XHQkKCcuc3VibmF2X19jb2xvci1ibG9jaycpLnN0b3AoKS5oaWRlKDQxMCk7XG4vLyBcdFx0XHRcdFx0fVxuLy8gXHRcdFx0XHR9KTtcdFxuLy8gXHRcdFx0fVxuLy8gXHRcdH0sXG4vLyBcdFx0ZGVza3RvcE1lbnU6ICQoJyNtYXN0aGVhZCcpXG5cdFxuLy8gXHR9XG5cbi8vICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG5cbi8vIFx0XHRuYXZiYXIub25Ib3ZlcigpO1xuXG5cbi8vIFx0XHRcdGlmICggJCh3aW5kb3cpLnNjcm9sbFRvcCgpID49IG5hdmJhci5kZXNrdG9wTWVudS5oZWlnaHQoKSApIHtcbi8vIFx0XHRcdFx0bmF2YmFyLmRlc2t0b3BNZW51LmhpZGUoKTtcbi8vIFx0XHRcdFx0JCgnLm1lbnVfX291dGVyLXdyYXBwZXItLWRlc2t0b3Atb24tc2Nyb2xsJykuZmFkZUluKCk7XG4vLyBcdFx0XHRcdGNvbnNvbGUubG9nKCduYXYgaXMgaGlkZGVuJylcbi8vIFx0XHRcdH0gZWxzZSB7XG4vLyBcdFx0XHRcdG5hdmJhci5kZXNrdG9wTWVudS5zaG93KCk7XG4vLyBcdFx0XHRcdCQoJy5tZW51X19vdXRlci13cmFwcGVyLS1kZXNrdG9wLW9uLXNjcm9sbCcpLmhpZGUoKTtcbi8vIFx0XHRcdH1cblx0XHRcdFx0XG5cbi8vIFx0Ly8gaWYgKCAkKGRvY3VtZW50KS53aWR0aCgpID4gNjQwKSB7XG4vLyBcdC8vIFx0XHQkKGRvY3VtZW50KS5zY3JvbGwoIGZ1bmN0aW9uKCl7XG4vLyBcdC8vIFx0XHRcdG5hdmJhci5vblNjcm9sbCgpO1xuLy8gXHQvLyBcdFx0fSlcbi8vIFx0Ly8gXHR9XG4vLyBcdGlmICggJCh3aW5kb3cpLnNjcm9sbFRvcCgpID49IG5hdmJhci5kZXNrdG9wTWVudS5oZWlnaHQoKSAmJiAkKGRvY3VtZW50KS53aWR0aCgpID4gNjQwKSB7XG4vLyBcdFx0bmF2YmFyLmRlc2t0b3BNZW51LmhpZGUoKTtcbi8vIFx0fVxuLy8gXHQvLyB9XG4vLyB9KTsiLCIiLCJ2YXIgUEVPUExFID0ge1xuXHRsaXN0ZW5lcnM6IGZ1bmN0aW9uKCl7XG5cdFx0Y29uc29sZS5sb2coJ1Blb3BsZSBqcyBsb2FkZWQnKTtcblxuXHRcdC8vIG5hdmlnYXRlIHRvIGxldHRlciBhbmNob3Jcblx0XHQkKCcubGV0dGVyX19saW5rJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFxuXHRcdFx0dmFyIGxldHRlcmxMaW5rSW5uZXJXcmFwcGVycyA9ICQoJy5sZXR0ZXJfX2xpbmstLWlubmVyLXdyYXBwZXInKTtcblx0XHRcdHZhciBsZXR0ZXIgPSAkKHRoaXMpLmRhdGEoJ2xldHRlcicpO1xuXHRcdFx0dmFyIGxldHRlckFuY2hvciA9ICQoXCJkaXZbZGF0YS1sZXR0ZXItYW5jaG9yPVwiKyBsZXR0ZXIgK1wiXVwiKTtcblx0XHRcdGlmIChsZXR0ZXJBbmNob3Iub2Zmc2V0KCkgIT09IHVuZGVmaW5lZCkgeyBcblx0XHRcdFx0bGV0dGVybExpbmtJbm5lcldyYXBwZXJzLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcblx0XHRcdFx0dmFyIHNlbGVjdGVkbGV0dGVybExpbmtJbm5lcldyYXBwZXIgPSAkKHRoaXMpLnBhcmVudCgpO1xuXHRcdFx0XHRzZWxlY3RlZGxldHRlcmxMaW5rSW5uZXJXcmFwcGVyLmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XHRcdFx0JCgnaHRtbCxib2R5JykuYW5pbWF0ZSh7XG5cdFx0ICAgICAgICAgIHNjcm9sbFRvcDogbGV0dGVyQW5jaG9yLm9mZnNldCgpLnRvcCAtIDIwMFxuXHRcdCAgICAgICAgfSwgMTAwMCk7XG5cdFx0ICAgICAgICBjb25zb2xlLmxvZyhcIlNjcm9sbGluZyB0byBcIiArIGxldHRlciApOyAgXG5cdFx0ICAgICAgICAkKCcuYmFja19fdG9fX3RvcCcpLnNsaWRlVG9nZ2xlKCk7XG5cdFx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBubyBlbGVtZW50IHdpdGggdGhhdCBsZXR0ZXIgXG5cdFx0XHRcdC8vIGxldHRlciBpcyBub3QgY2xpY2thYmxlXG5cdFx0XHRcdGxldHRlckFuY2hvci5jbGljayhmdW5jdGlvbihldmVudCl7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdFxuXHRcdH0pO1xuXHRcdC8vICQoZG9jdW1lbnQpLnJlc2l6ZShmdW5jdGlvbihldmVudCkge1xuXHRcdC8vIFx0aWYgKCAkKGRvY3VtZW50KS53aWR0aCgpID4gNjQwKSB7XG5cdFx0Ly8gXHRcdFBFT1BMRS5zY3JvbGxFdmVudHMoKTtcblx0XHQvLyBcdFx0JChkb2N1bWVudCkuc2Nyb2xsKCBmdW5jdGlvbigpe1xuXHRcdC8vIFx0XHRcdFBFT1BMRS5zY3JvbGxFdmVudHMoKTtcblx0XHQvLyBcdFx0fSk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfSk7XG5cdFx0JCgnI2FkdmFuY2VkUGVvcGxlU2VhcmNoJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFBFT1BMRS5yZXZlYWxBZHZhbmNlZFNlYXJjaCgpO1xuXHRcdH0pO1xuXHRcdCQoJyNwZW9wbGVBZHZhbmNlZFNlYXJjaEJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Y29uc29sZS5sb2coXCJwcmV2ZW50ZWQhXCIpO1xuXHRcdFx0dmFyIHNlbGVjdHMgPSAkKCdzZWxlY3QnKTtcblx0XHRcdHZhciBrZXl3b3JkID0gJChcIiNrZXl3b3JkSW5wdXRcIikudmFsKCkgfHwgXCJcIjtcblx0XHRcdHZhciBxdWVyeVN0cmluZ0Jhc2UgPSBsb2NhdGlvbi5vcmlnaW4gKyBsb2NhdGlvbi5wYXRobmFtZTtcblx0XHRcdHZhciBxdWVyeVN0cmluZyA9IFwiXCI7XG5cdFx0XHR2YXIgZmlsdGVycyA9IFtdO1xuXHRcdFx0Ly8gc2VsZWN0cyB2YWx1ZXMgZnJvbSBkcm9wZG93biBvcHRpb25zIGFuZCBkZXRlcm1pbmVzIG51bWJlciBvZiBmaWx0ZXJzIGZyb20gdGhlc2Vcblx0XHRcdGZvciAodmFyIGkgPSBzZWxlY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBzZWxlY3QgPSBzZWxlY3RzW2ldO1xuXHRcdFx0XHRpZiAoICQoc2VsZWN0KS52YWwoKS5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRcdGZpbHRlcnMucHVzaCgkKHNlbGVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZyhmaWx0ZXJzKTtcblx0XHRcdC8vIHBhc3NlcyB0aGUgcGFyYW1ldGVycyBmcm9tIGVhY2ggb2YgdGhlIHNlbGVjdGVkIGZpbHRlcnNcblx0XHRcdGZvcih2YXIgaSA9IGZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIHBhcmFtTmFtZSA9ICQoZmlsdGVyc1tpXSkuYXR0cignbmFtZScpO1xuXHRcdFx0XHR2YXIgcGFyYW1WYWx1ZSA9ICQoZmlsdGVyc1tpXSkudmFsKCk7XG5cdFx0XHRcdGlmICggcGFyYW1WYWx1ZS5sZW5ndGggPiAwICYmIGkgPT09IGZpbHRlcnMubGVuZ3RoIC0gMSApIHtcblx0XHRcdFx0XHRxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nQmFzZSArIFwiP1wiICsgcGFyYW1OYW1lICsgXCI9XCIgKyBwYXJhbVZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJhbVZhbHVlLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0cXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZyArIFwiJlwiICsgcGFyYW1OYW1lICsgXCI9XCIgKyBwYXJhbVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHF1ZXJ5U3RyaW5nLmxlbmd0aCA+IDAgKXtcblx0XHRcdFx0aWYgKCBrZXl3b3JkLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0cXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZyArIFwiJmtleXdvcmQ9XCIgKyBrZXl3b3JkO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGtleXdvcmQubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0XHRxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nICsgXCI/a2V5d29yZD1cIiArIGtleXdvcmQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGRlYnVnZ2VyO1xuXHRcdFx0d2luZG93LmxvY2F0aW9uLnJlcGxhY2UocXVlcnlTdHJpbmcpO1xuXHRcdH0pO1xuXHR9LFxuXHRzdGlja3lTaWRlQmFyOiAkKCcuc2lkZWJhcl9fb24tc2Nyb2xsLS1maXhlZCcpLFxuXHQvLyBzY3JvbGxFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdC8vIFx0dmFyIGhlaWdodEFkanVzdG1lbnQ7XG5cdC8vIFx0aWYgKCAkKCcucGFnZS10ZW1wbGF0ZS1wZW9wbGUnKS5sZW5ndGggPiAwICYmICAkKCcucGVvcGxlX19kZXRhaWxzLS1jb250YWluZXInKS5oZWlnaHQoKSA+ICQoJy5zaWRlYmFyX19vbi1zY3JvbGwtLWZpeGVkJykuaGVpZ2h0KCkgKXtcblx0Ly8gXHRcdGhlaWdodEFkanVzdG1lbnQgPSA4MDA7XG5cdC8vIFx0fSBlbHNlIHtcblx0Ly8gXHRcdGhlaWdodEFkanVzdG1lbnQgPSAyNjM7XG5cdC8vIFx0fVxuXHQvLyBcdHZhciBzY3JvbGxTdG9wcGVyT2Zmc2V0ID0gJCgnI21hc3RoZWFkJykuaGVpZ2h0KCkgKyAkKCcuYm9keV9fd3JhcHBlcicpLmhlaWdodCgpIC0gaGVpZ2h0QWRqdXN0bWVudDtcblx0Ly8gXHRpZiAoICQod2luZG93KS5zY3JvbGxUb3AoKSA+PSAoJCgnI2ZlYXR1cmVkSW1hZ2UnKS5oZWlnaHQoKSkgJiYgJCh3aW5kb3cpLnNjcm9sbFRvcCgpIDw9IHNjcm9sbFN0b3BwZXJPZmZzZXQgKSB7XG5cdC8vIFx0XHRQRU9QTEUuc3RpY2tTaWRlQmFyKCd0b3AnKTtcblx0Ly8gXHR9IGVsc2UgaWYgKCAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgPj0gc2Nyb2xsU3RvcHBlck9mZnNldCApIHtcblx0Ly8gXHRcdFBFT1BMRS5zdGlja1NpZGVCYXIoJ2JvdHRvbScpO1xuXHQvLyBcdFx0Y29uc29sZS5sb2coJ2JvdHRvbSBzdGlja2VyJyk7XG5cdC8vIFx0fSBlbHNlIHtcblx0Ly8gXHRcdFBFT1BMRS51bnN0aWNrU2lkZUJhcigpO1xuXHQvLyBcdH1cblx0Ly8gfSxcblx0Ly8gc3RpY2tTaWRlQmFyOiBmdW5jdGlvbihsb2NhdGlvbikge1xuXHQvLyBcdHZhciBzaWRlQmFyV2lkdGg7XG5cdC8vIFx0aWYgKCBsb2NhdGlvbiA9PT0gJ3RvcCcgKSB7XHRcblx0Ly8gXHRcdGlmICggJCh3aW5kb3cpLndpZHRoKCkgPCAxMDAwICkge1xuXHQvLyBcdFx0XHRzaWRlQmFyV2lkdGggPSAnY2FsYyg3NWVtIC8gNCknO1xuXHQvLyBcdFx0fSBlbHNlIHtcblx0Ly8gXHRcdFx0c2lkZUJhcldpZHRoID0gJ2NhbGMoNzVlbSAvIDYpJztcblx0Ly8gXHRcdH1cblx0Ly8gXHRcdFBFT1BMRS5zdGlja3lTaWRlQmFyLmNzcyh7XG5cdC8vIFx0XHRcdHBvc2l0aW9uOiAnZml4ZWQnLFxuXHQvLyBcdFx0XHR3aWR0aDogc2lkZUJhcldpZHRoLFxuXHQvLyBcdFx0XHR0b3A6ICcxNjBweCdcblx0Ly8gXHRcdH0pO1xuXHQvLyBcdH0gZWxzZSB7XG5cdC8vIFx0XHRpZiAoICQod2luZG93KS53aWR0aCgpIDwgMTAwMCApIHtcblx0Ly8gXHRcdFx0c2lkZUJhcldpZHRoID0gJzI1JSc7XG5cdC8vIFx0XHR9IGVsc2Uge1xuXHQvLyBcdFx0XHRzaWRlQmFyV2lkdGggPSAnMTYuNjY2NjclJztcblx0Ly8gXHRcdH1cblx0Ly8gXHRcdFBFT1BMRS5zdGlja3lTaWRlQmFyLmNzcyh7XG5cdC8vIFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHQvLyBcdFx0XHR3aWR0aDogc2lkZUJhcldpZHRoLFxuXHQvLyBcdFx0XHR0b3A6ICdpbml0aWFsJyxcblx0Ly8gXHRcdFx0Ym90dG9tOiAnNjBweCdcblx0Ly8gXHRcdH0pO1xuXHQvLyBcdH1cdFxuXHQvLyB9LFxuXHQvLyB1bnN0aWNrU2lkZUJhcjogZnVuY3Rpb24oKSB7XG5cdC8vIFx0dmFyIHNpZGVCYXJXaWR0aDtcblx0Ly8gXHRpZiAoICQod2luZG93KS53aWR0aCgpIDwgMTAwMCApIHtcblx0Ly8gXHRcdHNpZGVCYXJXaWR0aCA9ICcyNSUnO1xuXHQvLyBcdH0gZWxzZSB7XG5cdC8vIFx0XHRzaWRlQmFyV2lkdGggPSAnMTYuNjY2NjclJztcblx0Ly8gXHR9XG5cdC8vIFx0UEVPUExFLnN0aWNreVNpZGVCYXIuY3NzKHtcblx0Ly8gXHRcdHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuXHQvLyBcdFx0d2lkdGg6IHNpZGVCYXJXaWR0aCxcblx0Ly8gXHRcdHRvcDogJ2luaXRpYWwnXHRcdFx0XG5cdC8vIFx0fSk7XG5cdC8vIH0sXG5cdHJldmVhbEFkdmFuY2VkU2VhcmNoOiBmdW5jdGlvbigpe1xuXHRcdCQoJyNhZHZhbmNlZFNlYXJjaE1vZGFsJykucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpLmZhZGVJbignc2xvdycpO1xuXHRcdGNvbnNvbGUubG9nKFwiYWR2YW5jZWQgc2VhcmNoIHJldmVhbGVkIVwiKVxuXHR9LFxuXHRoaWRlQWR2YW5jZWRTZWFyY2g6IGZ1bmN0aW9uKCl7XG5cdFx0JCgnI2FkdmFuY2VkU2VhcmNoTW9kYWwnKS5hZGRDbGFzcygnaGlkZGVuJykuZmFkZU91dCgnc2xvdycpO1xuXHRcdGNvbnNvbGUubG9nKFwiYWR2YW5jZWQgc2VhcmNoIGhpZGRlbiFcIilcblx0fSxcblxuXHRzY3JvbGxCYWNrVG9Ub3A6IGZ1bmN0aW9uKCl7XG5cdFx0JCgnLmJhY2tfX3RvX190b3AnKS5jbGljayhmdW5jdGlvbihldmVudCl7XG5cdFx0XHQkKCdodG1sLGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgc2Nyb2xsVG9wOiAkKCcubGV0dGVyX19saW5rc193cmFwcGVyJykub2Zmc2V0KCkudG9wIC0gMjAwXG4gICAgICB9LCAxMDAwKTtcbiAgICAgIGlmICgkKHRoaXMpLmlzKFwiOnZpc2libGVcIikpIHtcblx0XHRcdFx0JCh0aGlzKS5zbGlkZVRvZ2dsZSgpO1xuICAgICAgfVxuXHRcdH0pO1xuXHR9XG59O1xuXG5cblx0JCh3aW5kb3cpLm9uKCdyZXNpemUnLCBmdW5jdGlvbihldmVudCkge1x0XHRcblx0XHRcdHZhciBoZWFkZXJIZWlnaHQgPSAkKCcjbWFzdGhlYWRPblNjcm9sbCcpLmhlaWdodCgpICsgMTYwO1xuXHRcdFx0dmFyIGVsZW1lbnRUb1N0aWNrID0gJCgnLnNpZGViYXJfX29uLXNjcm9sbC0tZml4ZWQnKTtcblx0XHRcdGlmICggJCgnLnNpZGViYXJfX29uLXNjcm9sbC0tZml4ZWQnKS5sZW5ndGggPiAwICYmICQoZG9jdW1lbnQpLndpZHRoKCkgPj0gNzY4ICl7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiU1RJQ0tZXCIpO1xuXHRcdFx0XHRcdGVsZW1lbnRUb1N0aWNrLmNzcygnd2lkdGgnLCAnMTc1cHggIWltcG9ydGFudCcpO1xuXHRcdFx0XHRcdGVsZW1lbnRUb1N0aWNrLnN0aWNrX2luX3BhcmVudCh7IG9mZnNldF90b3A6IGhlYWRlckhlaWdodCB9KTtcblx0XHRcdH1cdGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50VG9TdGljay50cmlnZ2VyKFwic3RpY2t5X2tpdDpkZXRhY2hcIik7XG5cdFx0XHR9XHRcblxuXHR9KTtcblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcblx0UEVPUExFLmxpc3RlbmVycygpO1xuXHRQRU9QTEUuc2Nyb2xsQmFja1RvVG9wKCk7XG5cdC8vIGlmICggJChkb2N1bWVudCkud2lkdGgoKSA+IDY0MCkge1xuXHQvLyBcdFBFT1BMRS5zY3JvbGxFdmVudHMoKTtcblx0Ly8gXHQkKGRvY3VtZW50KS5zY3JvbGwoIGZ1bmN0aW9uKCl7XG5cdC8vIFx0XHRQRU9QTEUuc2Nyb2xsRXZlbnRzKCk7XG5cdC8vIFx0fSk7XG5cdC8vIH1cblx0dmFyIGhlYWRlckhlaWdodCA9ICQoJyNtYXN0aGVhZE9uU2Nyb2xsJykuaGVpZ2h0KCkgKyAxNjA7XG5cdHZhciBlbGVtZW50VG9TdGljayA9ICQoJy5zaWRlYmFyX19vbi1zY3JvbGwtLWZpeGVkJyk7XG5cdFx0aWYgKCAkKCcuc2lkZWJhcl9fb24tc2Nyb2xsLS1maXhlZCcpLmxlbmd0aCA+IDApe1xuXHRcdFx0Y29uc29sZS5sb2coXCJTVElDS1lcIik7XG5cdFx0XHRpZiAoJChkb2N1bWVudCkud2lkdGgoKSA+PSA3NjgpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coaGVhZGVySGVpZ2h0KTtcblx0XHRcdFx0ZWxlbWVudFRvU3RpY2suc3RpY2tfaW5fcGFyZW50KHsgb2Zmc2V0X3RvcDogaGVhZGVySGVpZ2h0IH0pO1xuXHRcdFx0fSBcdFxuXHR9XHRcblx0JCh3aW5kb3cpLnRyaWdnZXIoJ3Jlc2l6ZScpO1xufSk7IiwidmFyIGhvbWVwYWdlID0geyBcblx0aW5pdGlhbGl6ZVNsaWRlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gY3JlYXRlIFNWR1xuXHRcdHZhciBzID0gU25hcChcIiNzbGlkZXItc3ZnXCIpO1xuXHRcdHZhciBsaW5lID0gcy5wYXBlci5saW5lKDAsIDAsIDI1MDAsIDApO1xuXG5cdFx0Ly8gc2V0IFNWRyBhdHRyaWJ1dGVzXG5cdFx0dmFyIGFuaW1hdGVTdmcgPSBmdW5jdGlvbigpIHtcblx0XHRcdGxpbmUuYXR0cih7XG5cdFx0XHRcdHN0cm9rZTogJ3RyYW5zcGFyZW50Jyxcblx0XHRcdFx0ZmlsbDogJ25vbmUnLFxuXHRcdFx0XHRzdHJva2VXaWR0aDogNSxcblx0XHRcdFx0XCJmaWxsLW9wYWNpdHlcIiA6IDBcblx0XHRcdH0pO1xuXHRcdFx0Ly8gYW5pbWF0ZSBTVkcgbGluZVx0XG5cdFx0XHRsaW5lLmFuaW1hdGUoe3N0cm9rZTogJyNjMTA4MTknLCBmaWxsOidub25lJ30sIDM5MDAgLCBtaW5hLmxpbmVhcik7XG5cdFx0XG5cdFx0fTtcblx0XHRhbmltYXRlU3ZnKCk7XG5cdFx0Ly8gYW5pbWF0ZSBTVkcgb24gc2xpZGUgY2hhbmdlXG5cdFx0JCgnLnNsaWRlci1jb250YWluZXInKS5vbignYmVmb3JlQ2hhbmdlJywgZnVuY3Rpb24oc2xpY2ssIGN1cnJlbnRTbGlkZSwgbmV4dFNsaWRlKXtcblx0XHRcdGFuaW1hdGVTdmcoKTtcblx0XHR9KTtcblxuXHRcdGlmICggJChcImJvZHlcIikuaGFzQ2xhc3MoXCJwYWdlLXRlbXBsYXRlLWhvbWVwYWdlXCIpICl7XG5cdFx0XHQvLyBzdGFydCBTbGljayBzbGlkZXJcblx0XHRcdCQoJy5zbGlkZXItY29udGFpbmVyJykuc2xpY2soe1xuXHRcdFx0XHRzbGlkZTogJy5zbGlkZScsXG5cdFx0XHRcdHNsaWRlc1RvU2hvdzogMSxcblx0XHRcdFx0c2xpZGVzVG9TY3JvbGw6IDEsXG5cdFx0XHRcdGF1dG9wbGF5OiB0cnVlLFxuXHRcdFx0XHRhdXRvcGxheVNwZWVkOiA0MDAwLFxuXHRcdFx0XHRhcnJvd3M6IHRydWUsXG5cdFx0XHRcdGZhZGU6IHRydWUsXG5cdFx0XHRcdGluZmluaXRlOiB0cnVlLFxuXHRcdFx0XHRwcmV2QXJyb3c6ICQoJy5wcmV2LXNsaWRlci1ob21lJyksXG5cdFx0XHRcdG5leHRBcnJvdzogJCgnLm5leHQtc2xpZGVyLWhvbWUnKVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59XG5cblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcblx0aWYoICQoJyNzbGlkZXItc3ZnJykubGVuZ3RoICl7XG5cdFx0aG9tZXBhZ2UuaW5pdGlhbGl6ZVNsaWRlcigpO1xuXHR9XHRcbn0pO1xuXHQiLCIkKHdpbmRvdykuYmluZCgnIGxvYWQgcmVzaXplIG9yaWVudGF0aW9uQ2hhbmdlICcsIGZ1bmN0aW9uICgpIHtcbiAgIHZhciBmb290ZXIgPSAkKFwiI2Zvb3Rlci1jb250YWluZXJcIik7XG4gICB2YXIgcG9zID0gZm9vdGVyLnBvc2l0aW9uKCk7XG4gICB2YXIgaGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcG9zLnRvcDtcbiAgIGhlaWdodCA9IGhlaWdodCAtIGZvb3Rlci5oZWlnaHQoKSAtMTtcblxuICAgZnVuY3Rpb24gc3RpY2t5Rm9vdGVyKCkge1xuICAgICBmb290ZXIuY3NzKHtcbiAgICAgICAgICdtYXJnaW4tdG9wJzogaGVpZ2h0ICsgJ3B4J1xuICAgICB9KTtcbiAgIH1cbiAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgIHN0aWNreUZvb3RlcigpO1xuICAgfVxufSk7XG4iLCJ2YXIgU1VNTUVSID0ge1xuXHRleHBhbmRTY2hlZHVsZTogZnVuY3Rpb24oKXtcblx0XHQkKCcjcmVjcnVpdGluZ01vZGFsJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0Y29uc29sZS5sb2coJ3JlY3J1dGluZycpO1xuXHRcdFx0dmFyIHN1bW1lck1vZGFsID0gJCgnLm1vZGFsX19iYWNrZ3JvdW5kLmRpdmVyc2l0eScpO1xuXHRcdFx0c3VtbWVyTW9kYWwucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpLmZhZGVJbignc2xvdycpO1xuXHRcdH0pO1xuXHR9XG59XG5cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XG5cdFNVTU1FUi5leHBhbmRTY2hlZHVsZSgpO1xufSkiLCIvKlxuIFN0aWNreS1raXQgdjEuMS4yIHwgV1RGUEwgfCBMZWFmIENvcmNvcmFuIDIwMTUgfCBodHRwOi8vbGVhZm8ubmV0XG4qL1xuKGZ1bmN0aW9uKCl7dmFyIGIsZjtiPXRoaXMualF1ZXJ5fHx3aW5kb3cualF1ZXJ5O2Y9Yih3aW5kb3cpO2IuZm4uc3RpY2tfaW5fcGFyZW50PWZ1bmN0aW9uKGQpe3ZhciBBLHcsSixuLEIsSyxwLHEsayxFLHQ7bnVsbD09ZCYmKGQ9e30pO3Q9ZC5zdGlja3lfY2xhc3M7Qj1kLmlubmVyX3Njcm9sbGluZztFPWQucmVjYWxjX2V2ZXJ5O2s9ZC5wYXJlbnQ7cT1kLm9mZnNldF90b3A7cD1kLnNwYWNlcjt3PWQuYm90dG9taW5nO251bGw9PXEmJihxPTApO251bGw9PWsmJihrPXZvaWQgMCk7bnVsbD09QiYmKEI9ITApO251bGw9PXQmJih0PVwiaXNfc3R1Y2tcIik7QT1iKGRvY3VtZW50KTtudWxsPT13JiYodz0hMCk7Sj1mdW5jdGlvbihhLGQsbixDLEYsdSxyLEcpe3ZhciB2LEgsbSxELEksYyxnLHgseSx6LGgsbDtpZighYS5kYXRhKFwic3RpY2t5X2tpdFwiKSl7YS5kYXRhKFwic3RpY2t5X2tpdFwiLCEwKTtJPUEuaGVpZ2h0KCk7Zz1hLnBhcmVudCgpO251bGwhPWsmJihnPWcuY2xvc2VzdChrKSk7XG5pZighZy5sZW5ndGgpdGhyb3dcImZhaWxlZCB0byBmaW5kIHN0aWNrIHBhcmVudFwiO3Y9bT0hMTsoaD1udWxsIT1wP3AmJmEuY2xvc2VzdChwKTpiKFwiPGRpdiAvPlwiKSkmJmguY3NzKFwicG9zaXRpb25cIixhLmNzcyhcInBvc2l0aW9uXCIpKTt4PWZ1bmN0aW9uKCl7dmFyIGMsZixlO2lmKCFHJiYoST1BLmhlaWdodCgpLGM9cGFyc2VJbnQoZy5jc3MoXCJib3JkZXItdG9wLXdpZHRoXCIpLDEwKSxmPXBhcnNlSW50KGcuY3NzKFwicGFkZGluZy10b3BcIiksMTApLGQ9cGFyc2VJbnQoZy5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiKSwxMCksbj1nLm9mZnNldCgpLnRvcCtjK2YsQz1nLmhlaWdodCgpLG0mJih2PW09ITEsbnVsbD09cCYmKGEuaW5zZXJ0QWZ0ZXIoaCksaC5kZXRhY2goKSksYS5jc3Moe3Bvc2l0aW9uOlwiXCIsdG9wOlwiXCIsd2lkdGg6XCJcIixib3R0b206XCJcIn0pLnJlbW92ZUNsYXNzKHQpLGU9ITApLEY9YS5vZmZzZXQoKS50b3AtKHBhcnNlSW50KGEuY3NzKFwibWFyZ2luLXRvcFwiKSwxMCl8fDApLXEsXG51PWEub3V0ZXJIZWlnaHQoITApLHI9YS5jc3MoXCJmbG9hdFwiKSxoJiZoLmNzcyh7d2lkdGg6YS5vdXRlcldpZHRoKCEwKSxoZWlnaHQ6dSxkaXNwbGF5OmEuY3NzKFwiZGlzcGxheVwiKSxcInZlcnRpY2FsLWFsaWduXCI6YS5jc3MoXCJ2ZXJ0aWNhbC1hbGlnblwiKSxcImZsb2F0XCI6cn0pLGUpKXJldHVybiBsKCl9O3goKTtpZih1IT09QylyZXR1cm4gRD12b2lkIDAsYz1xLHo9RSxsPWZ1bmN0aW9uKCl7dmFyIGIsbCxlLGs7aWYoIUcmJihlPSExLG51bGwhPXomJigtLXosMD49eiYmKHo9RSx4KCksZT0hMCkpLGV8fEEuaGVpZ2h0KCk9PT1JfHx4KCksZT1mLnNjcm9sbFRvcCgpLG51bGwhPUQmJihsPWUtRCksRD1lLG0/KHcmJihrPWUrdStjPkMrbix2JiYhayYmKHY9ITEsYS5jc3Moe3Bvc2l0aW9uOlwiZml4ZWRcIixib3R0b206XCJcIix0b3A6Y30pLnRyaWdnZXIoXCJzdGlja3lfa2l0OnVuYm90dG9tXCIpKSksZTxGJiYobT0hMSxjPXEsbnVsbD09cCYmKFwibGVmdFwiIT09ciYmXCJyaWdodFwiIT09cnx8YS5pbnNlcnRBZnRlcihoKSxcbmguZGV0YWNoKCkpLGI9e3Bvc2l0aW9uOlwiXCIsd2lkdGg6XCJcIix0b3A6XCJcIn0sYS5jc3MoYikucmVtb3ZlQ2xhc3ModCkudHJpZ2dlcihcInN0aWNreV9raXQ6dW5zdGlja1wiKSksQiYmKGI9Zi5oZWlnaHQoKSx1K3E+YiYmIXYmJihjLT1sLGM9TWF0aC5tYXgoYi11LGMpLGM9TWF0aC5taW4ocSxjKSxtJiZhLmNzcyh7dG9wOmMrXCJweFwifSkpKSk6ZT5GJiYobT0hMCxiPXtwb3NpdGlvbjpcImZpeGVkXCIsdG9wOmN9LGIud2lkdGg9XCJib3JkZXItYm94XCI9PT1hLmNzcyhcImJveC1zaXppbmdcIik/YS5vdXRlcldpZHRoKCkrXCJweFwiOmEud2lkdGgoKStcInB4XCIsYS5jc3MoYikuYWRkQ2xhc3ModCksbnVsbD09cCYmKGEuYWZ0ZXIoaCksXCJsZWZ0XCIhPT1yJiZcInJpZ2h0XCIhPT1yfHxoLmFwcGVuZChhKSksYS50cmlnZ2VyKFwic3RpY2t5X2tpdDpzdGlja1wiKSksbSYmdyYmKG51bGw9PWsmJihrPWUrdStjPkMrbiksIXYmJmspKSlyZXR1cm4gdj0hMCxcInN0YXRpY1wiPT09Zy5jc3MoXCJwb3NpdGlvblwiKSYmZy5jc3Moe3Bvc2l0aW9uOlwicmVsYXRpdmVcIn0pLFxuYS5jc3Moe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixib3R0b206ZCx0b3A6XCJhdXRvXCJ9KS50cmlnZ2VyKFwic3RpY2t5X2tpdDpib3R0b21cIil9LHk9ZnVuY3Rpb24oKXt4KCk7cmV0dXJuIGwoKX0sSD1mdW5jdGlvbigpe0c9ITA7Zi5vZmYoXCJ0b3VjaG1vdmVcIixsKTtmLm9mZihcInNjcm9sbFwiLGwpO2Yub2ZmKFwicmVzaXplXCIseSk7Yihkb2N1bWVudC5ib2R5KS5vZmYoXCJzdGlja3lfa2l0OnJlY2FsY1wiLHkpO2Eub2ZmKFwic3RpY2t5X2tpdDpkZXRhY2hcIixIKTthLnJlbW92ZURhdGEoXCJzdGlja3lfa2l0XCIpO2EuY3NzKHtwb3NpdGlvbjpcIlwiLGJvdHRvbTpcIlwiLHRvcDpcIlwiLHdpZHRoOlwiXCJ9KTtnLnBvc2l0aW9uKFwicG9zaXRpb25cIixcIlwiKTtpZihtKXJldHVybiBudWxsPT1wJiYoXCJsZWZ0XCIhPT1yJiZcInJpZ2h0XCIhPT1yfHxhLmluc2VydEFmdGVyKGgpLGgucmVtb3ZlKCkpLGEucmVtb3ZlQ2xhc3ModCl9LGYub24oXCJ0b3VjaG1vdmVcIixsKSxmLm9uKFwic2Nyb2xsXCIsbCksZi5vbihcInJlc2l6ZVwiLFxueSksYihkb2N1bWVudC5ib2R5KS5vbihcInN0aWNreV9raXQ6cmVjYWxjXCIseSksYS5vbihcInN0aWNreV9raXQ6ZGV0YWNoXCIsSCksc2V0VGltZW91dChsLDApfX07bj0wO2ZvcihLPXRoaXMubGVuZ3RoO248SztuKyspZD10aGlzW25dLEooYihkKSk7cmV0dXJuIHRoaXN9fSkuY2FsbCh0aGlzKTsiLCIhZnVuY3Rpb24oZSx0KXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP21vZHVsZS5leHBvcnRzPXQoKTplLmRpc2FibGVTY3JvbGw9dCgpfSh0aGlzLGZ1bmN0aW9uKCl7dmFyIGU9e29wdGlvbnM6e2Rpc2FibGVXaGVlbDohMCxkaXNhYmxlU2Nyb2xsYmFyOiEwLGRpc2FibGVLZXlzOiEwLHNjcm9sbEV2ZW50S2V5czpbMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDBdfSxlbGVtZW50OmRvY3VtZW50LmJvZHksbG9ja1RvU2Nyb2xsUG9zOlswLDBdLG9uOmZ1bmN0aW9uKGUsdCl7dGhpcy5lbGVtZW50PWV8fGRvY3VtZW50LmJvZHksdGhpcy5vcHRpb25zPXRoaXMuX2V4dGVuZCh0aGlzLm9wdGlvbnMsdCksdGhpcy5vcHRpb25zLmRpc2FibGVXaGVlbCYmKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsdGhpcy5faGFuZGxlV2hlZWwpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Nb3VzZVNjcm9sbFwiLHRoaXMuX2hhbmRsZVdoZWVsKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5faGFuZGxlV2hlZWwpKSx0aGlzLm9wdGlvbnMuZGlzYWJsZVNjcm9sbGJhciYmKHRoaXMubG9ja1RvU2Nyb2xsUG9zPVt0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCx0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wXSx0aGlzLl9kaXNhYmxlU2Nyb2xsYmFyRm49dGhpcy5faGFuZGxlU2Nyb2xsYmFyLmJpbmQodGhpcyksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMuX2Rpc2FibGVTY3JvbGxiYXJGbikpLHRoaXMub3B0aW9ucy5kaXNhYmxlS2V5cyYmKHRoaXMuX2Rpc2FibGVLZXlzRm49dGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5fZGlzYWJsZUtleXNGbikpfSxvZmY6ZnVuY3Rpb24oKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLHRoaXMuX2hhbmRsZVdoZWVsKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTW91c2VTY3JvbGxcIix0aGlzLl9oYW5kbGVXaGVlbCksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMuX2hhbmRsZVdoZWVsKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5fZGlzYWJsZVNjcm9sbGJhckZuKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuX2Rpc2FibGVLZXlzRm4pfSxfaGFuZGxlV2hlZWw6ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpfSxfaGFuZGxlU2Nyb2xsYmFyOmZ1bmN0aW9uKCl7d2luZG93LnNjcm9sbFRvKHRoaXMubG9ja1RvU2Nyb2xsUG9zWzBdLHRoaXMubG9ja1RvU2Nyb2xsUG9zWzFdKX0sX2hhbmRsZUtleWRvd246ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDx0aGlzLm9wdGlvbnMuc2Nyb2xsRXZlbnRLZXlzLmxlbmd0aDt0KyspaWYoZS5rZXlDb2RlPT09dGhpcy5vcHRpb25zLnNjcm9sbEV2ZW50S2V5c1t0XSlyZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpLCExfSxfZXh0ZW5kOmZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3Qua2V5cyhBcnJheS5wcm90b3R5cGUuc2xpY2UoYXJndW1lbnRzLDEpKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2Zvcih2YXIgbyBpbiB0KXQuaGFzT3duUHJvcGVydHkobykmJihlW29dPXRbb10pfSksZX19O3JldHVybiBlfSk7IiwiLyohIEJhY2tzdHJldGNoIC0gdjIuMC40IC0gMjAxMy0wNi0xOVxuKiBodHRwOi8vc3JvYmJpbi5jb20vanF1ZXJ5LXBsdWdpbnMvYmFja3N0cmV0Y2gvXG4qIENvcHlyaWdodCAoYykgMjAxMyBTY290dCBSb2JiaW47IExpY2Vuc2VkIE1JVCAqL1xuKGZ1bmN0aW9uKGEsZCxwKXthLmZuLmJhY2tzdHJldGNoPWZ1bmN0aW9uKGMsYil7KGM9PT1wfHwwPT09Yy5sZW5ndGgpJiZhLmVycm9yKFwiTm8gaW1hZ2VzIHdlcmUgc3VwcGxpZWQgZm9yIEJhY2tzdHJldGNoXCIpOzA9PT1hKGQpLnNjcm9sbFRvcCgpJiZkLnNjcm9sbFRvKDAsMCk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZz1kLmRhdGEoXCJiYWNrc3RyZXRjaFwiKTtpZihnKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYyYmXCJmdW5jdGlvblwiPT10eXBlb2YgZ1tjXSl7Z1tjXShiKTtyZXR1cm59Yj1hLmV4dGVuZChnLm9wdGlvbnMsYik7Zy5kZXN0cm95KCEwKX1nPW5ldyBxKHRoaXMsYyxiKTtkLmRhdGEoXCJiYWNrc3RyZXRjaFwiLGcpfSl9O2EuYmFja3N0cmV0Y2g9ZnVuY3Rpb24oYyxiKXtyZXR1cm4gYShcImJvZHlcIikuYmFja3N0cmV0Y2goYyxiKS5kYXRhKFwiYmFja3N0cmV0Y2hcIil9O2EuZXhwcltcIjpcIl0uYmFja3N0cmV0Y2g9ZnVuY3Rpb24oYyl7cmV0dXJuIGEoYykuZGF0YShcImJhY2tzdHJldGNoXCIpIT09cH07YS5mbi5iYWNrc3RyZXRjaC5kZWZhdWx0cz17Y2VudGVyZWRYOiEwLGNlbnRlcmVkWTohMCxkdXJhdGlvbjo1RTMsZmFkZTowfTt2YXIgcj17bGVmdDowLHRvcDowLG92ZXJmbG93OlwiaGlkZGVuXCIsbWFyZ2luOjAscGFkZGluZzowLGhlaWdodDpcIjEwMCVcIix3aWR0aDpcIjEwMCVcIix6SW5kZXg6LTk5OTk5OX0scz17cG9zaXRpb246XCJhYnNvbHV0ZVwiLGRpc3BsYXk6XCJub25lXCIsbWFyZ2luOjAscGFkZGluZzowLGJvcmRlcjpcIm5vbmVcIix3aWR0aDpcImF1dG9cIixoZWlnaHQ6XCJhdXRvXCIsbWF4SGVpZ2h0Olwibm9uZVwiLG1heFdpZHRoOlwibm9uZVwiLHpJbmRleDotOTk5OTk5fSxxPWZ1bmN0aW9uKGMsYixlKXt0aGlzLm9wdGlvbnM9YS5leHRlbmQoe30sYS5mbi5iYWNrc3RyZXRjaC5kZWZhdWx0cyxlfHx7fSk7dGhpcy5pbWFnZXM9YS5pc0FycmF5KGIpP2I6W2JdO2EuZWFjaCh0aGlzLmltYWdlcyxmdW5jdGlvbigpe2EoXCI8aW1nIC8+XCIpWzBdLnNyYz10aGlzfSk7dGhpcy5pc0JvZHk9Yz09PWRvY3VtZW50LmJvZHk7dGhpcy4kY29udGFpbmVyPWEoYyk7dGhpcy4kcm9vdD10aGlzLmlzQm9keT9sP2EoZCk6YShkb2N1bWVudCk6dGhpcy4kY29udGFpbmVyO2M9dGhpcy4kY29udGFpbmVyLmNoaWxkcmVuKFwiLmJhY2tzdHJldGNoXCIpLmZpcnN0KCk7dGhpcy4kd3JhcD1jLmxlbmd0aD9jOmEoJzxkaXYgY2xhc3M9XCJiYWNrc3RyZXRjaFwiPjwvZGl2PicpLmNzcyhyKS5hcHBlbmRUbyh0aGlzLiRjb250YWluZXIpO3RoaXMuaXNCb2R5fHwoYz10aGlzLiRjb250YWluZXIuY3NzKFwicG9zaXRpb25cIiksYj10aGlzLiRjb250YWluZXIuY3NzKFwiekluZGV4XCIpLHRoaXMuJGNvbnRhaW5lci5jc3Moe3Bvc2l0aW9uOlwic3RhdGljXCI9PT1jP1wicmVsYXRpdmVcIjpjLHpJbmRleDpcImF1dG9cIj09PWI/MDpiLGJhY2tncm91bmQ6XCJub25lXCJ9KSx0aGlzLiR3cmFwLmNzcyh7ekluZGV4Oi05OTk5OTh9KSk7dGhpcy4kd3JhcC5jc3Moe3Bvc2l0aW9uOnRoaXMuaXNCb2R5JiZsP1wiZml4ZWRcIjpcImFic29sdXRlXCJ9KTt0aGlzLmluZGV4PTA7dGhpcy5zaG93KHRoaXMuaW5kZXgpO2EoZCkub24oXCJyZXNpemUuYmFja3N0cmV0Y2hcIixhLnByb3h5KHRoaXMucmVzaXplLHRoaXMpKS5vbihcIm9yaWVudGF0aW9uY2hhbmdlLmJhY2tzdHJldGNoXCIsYS5wcm94eShmdW5jdGlvbigpe3RoaXMuaXNCb2R5JiYwPT09ZC5wYWdlWU9mZnNldCYmKGQuc2Nyb2xsVG8oMCwxKSx0aGlzLnJlc2l6ZSgpKX0sdGhpcykpfTtxLnByb3RvdHlwZT17cmVzaXplOmZ1bmN0aW9uKCl7dHJ5e3ZhciBhPXtsZWZ0OjAsdG9wOjB9LGI9dGhpcy5pc0JvZHk/dGhpcy4kcm9vdC53aWR0aCgpOnRoaXMuJHJvb3QuaW5uZXJXaWR0aCgpLGU9YixnPXRoaXMuaXNCb2R5P2QuaW5uZXJIZWlnaHQ/ZC5pbm5lckhlaWdodDp0aGlzLiRyb290LmhlaWdodCgpOnRoaXMuJHJvb3QuaW5uZXJIZWlnaHQoKSxqPWUvdGhpcy4kaW1nLmRhdGEoXCJyYXRpb1wiKSxmO2o+PWc/KGY9KGotZykvMix0aGlzLm9wdGlvbnMuY2VudGVyZWRZJiYoYS50b3A9XCItXCIrZitcInB4XCIpKTooaj1nLGU9aip0aGlzLiRpbWcuZGF0YShcInJhdGlvXCIpLGY9KGUtYikvMix0aGlzLm9wdGlvbnMuY2VudGVyZWRYJiYoYS5sZWZ0PVwiLVwiK2YrXCJweFwiKSk7dGhpcy4kd3JhcC5jc3Moe3dpZHRoOmIsaGVpZ2h0Omd9KS5maW5kKFwiaW1nOm5vdCguZGVsZXRlYWJsZSlcIikuY3NzKHt3aWR0aDplLGhlaWdodDpqfSkuY3NzKGEpfWNhdGNoKGgpe31yZXR1cm4gdGhpc30sc2hvdzpmdW5jdGlvbihjKXtpZighKE1hdGguYWJzKGMpPnRoaXMuaW1hZ2VzLmxlbmd0aC0xKSl7dmFyIGI9dGhpcyxlPWIuJHdyYXAuZmluZChcImltZ1wiKS5hZGRDbGFzcyhcImRlbGV0ZWFibGVcIiksZD17cmVsYXRlZFRhcmdldDpiLiRjb250YWluZXJbMF19O2IuJGNvbnRhaW5lci50cmlnZ2VyKGEuRXZlbnQoXCJiYWNrc3RyZXRjaC5iZWZvcmVcIixkKSxbYixjXSk7dGhpcy5pbmRleD1jO2NsZWFySW50ZXJ2YWwoYi5pbnRlcnZhbCk7Yi4kaW1nPWEoXCI8aW1nIC8+XCIpLmNzcyhzKS5iaW5kKFwibG9hZFwiLGZ1bmN0aW9uKGYpe3ZhciBoPXRoaXMud2lkdGh8fGEoZi50YXJnZXQpLndpZHRoKCk7Zj10aGlzLmhlaWdodHx8YShmLnRhcmdldCkuaGVpZ2h0KCk7YSh0aGlzKS5kYXRhKFwicmF0aW9cIixoL2YpO2EodGhpcykuZmFkZUluKGIub3B0aW9ucy5zcGVlZHx8Yi5vcHRpb25zLmZhZGUsZnVuY3Rpb24oKXtlLnJlbW92ZSgpO2IucGF1c2VkfHxiLmN5Y2xlKCk7YShbXCJhZnRlclwiLFwic2hvd1wiXSkuZWFjaChmdW5jdGlvbigpe2IuJGNvbnRhaW5lci50cmlnZ2VyKGEuRXZlbnQoXCJiYWNrc3RyZXRjaC5cIit0aGlzLGQpLFtiLGNdKX0pfSk7Yi5yZXNpemUoKX0pLmFwcGVuZFRvKGIuJHdyYXApO2IuJGltZy5hdHRyKFwic3JjXCIsYi5pbWFnZXNbY10pO3JldHVybiBifX0sbmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNob3codGhpcy5pbmRleDx0aGlzLmltYWdlcy5sZW5ndGgtMT90aGlzLmluZGV4KzE6MCl9LHByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaG93KDA9PT10aGlzLmluZGV4P3RoaXMuaW1hZ2VzLmxlbmd0aC0xOnRoaXMuaW5kZXgtMSl9LHBhdXNlOmZ1bmN0aW9uKCl7dGhpcy5wYXVzZWQ9ITA7cmV0dXJuIHRoaXN9LHJlc3VtZTpmdW5jdGlvbigpe3RoaXMucGF1c2VkPSExO3RoaXMubmV4dCgpO3JldHVybiB0aGlzfSxjeWNsZTpmdW5jdGlvbigpezE8dGhpcy5pbWFnZXMubGVuZ3RoJiYoY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKSx0aGlzLmludGVydmFsPXNldEludGVydmFsKGEucHJveHkoZnVuY3Rpb24oKXt0aGlzLnBhdXNlZHx8dGhpcy5uZXh0KCl9LHRoaXMpLHRoaXMub3B0aW9ucy5kdXJhdGlvbikpO3JldHVybiB0aGlzfSxkZXN0cm95OmZ1bmN0aW9uKGMpe2EoZCkub2ZmKFwicmVzaXplLmJhY2tzdHJldGNoIG9yaWVudGF0aW9uY2hhbmdlLmJhY2tzdHJldGNoXCIpO2NsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7Y3x8dGhpcy4kd3JhcC5yZW1vdmUoKTt0aGlzLiRjb250YWluZXIucmVtb3ZlRGF0YShcImJhY2tzdHJldGNoXCIpfX07dmFyIGwsZj1uYXZpZ2F0b3IudXNlckFnZW50LG09bmF2aWdhdG9yLnBsYXRmb3JtLGU9Zi5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oWzAtOV0rKS8pLGU9ISFlJiZlWzFdLGg9Zi5tYXRjaCgvRmVubmVjXFwvKFswLTldKykvKSxoPSEhaCYmaFsxXSxuPWYubWF0Y2goL09wZXJhIE1vYmlcXC8oWzAtOV0rKS8pLHQ9ISFuJiZuWzFdLGs9Zi5tYXRjaCgvTVNJRSAoWzAtOV0rKS8pLGs9ISFrJiZrWzFdO2w9ISgoLTE8bS5pbmRleE9mKFwiaVBob25lXCIpfHwtMTxtLmluZGV4T2YoXCJpUGFkXCIpfHwtMTxtLmluZGV4T2YoXCJpUG9kXCIpKSYmZSYmNTM0PmV8fGQub3BlcmFtaW5pJiZcIltvYmplY3QgT3BlcmFNaW5pXVwiPT09e30udG9TdHJpbmcuY2FsbChkLm9wZXJhbWluaSl8fG4mJjc0NTg+dHx8LTE8Zi5pbmRleE9mKFwiQW5kcm9pZFwiKSYmZSYmNTMzPmV8fGgmJjY+aHx8XCJwYWxtR2V0UmVzb3VyY2VcImluIGQmJmUmJjUzND5lfHwtMTxmLmluZGV4T2YoXCJNZWVHb1wiKSYmLTE8Zi5pbmRleE9mKFwiTm9raWFCcm93c2VyLzguNS4wXCIpfHxrJiY2Pj1rKX0pKGpRdWVyeSx3aW5kb3cpOyIsIi8qXG4gICAgIF8gXyAgICAgIF8gICAgICAgX1xuIF9fX3wgKF8pIF9fX3wgfCBfXyAgKF8pX19fXG4vIF9ffCB8IHwvIF9ffCB8LyAvICB8IC8gX198XG5cXF9fIFxcIHwgfCAoX198ICAgPCBfIHwgXFxfXyBcXFxufF9fXy9ffF98XFxfX198X3xcXF8oXykvIHxfX18vXG4gICAgICAgICAgICAgICAgICAgfF9fL1xuXG4gVmVyc2lvbjogMS42LjBcbiAgQXV0aG9yOiBLZW4gV2hlZWxlclxuIFdlYnNpdGU6IGh0dHA6Ly9rZW53aGVlbGVyLmdpdGh1Yi5pb1xuICAgIERvY3M6IGh0dHA6Ly9rZW53aGVlbGVyLmdpdGh1Yi5pby9zbGlja1xuICAgIFJlcG86IGh0dHA6Ly9naXRodWIuY29tL2tlbndoZWVsZXIvc2xpY2tcbiAgSXNzdWVzOiBodHRwOi8vZ2l0aHViLmNvbS9rZW53aGVlbGVyL3NsaWNrL2lzc3Vlc1xuXG4gKi9cbi8qIGdsb2JhbCB3aW5kb3csIGRvY3VtZW50LCBkZWZpbmUsIGpRdWVyeSwgc2V0SW50ZXJ2YWwsIGNsZWFySW50ZXJ2YWwgKi9cbihmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeShqUXVlcnkpO1xuICAgIH1cblxufShmdW5jdGlvbigkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBTbGljayA9IHdpbmRvdy5TbGljayB8fCB7fTtcblxuICAgIFNsaWNrID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBpbnN0YW5jZVVpZCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gU2xpY2soZWxlbWVudCwgc2V0dGluZ3MpIHtcblxuICAgICAgICAgICAgdmFyIF8gPSB0aGlzLCBkYXRhU2V0dGluZ3M7XG5cbiAgICAgICAgICAgIF8uZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhZGFwdGl2ZUhlaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXBwZW5kQXJyb3dzOiAkKGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGFwcGVuZERvdHM6ICQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgYXJyb3dzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFzTmF2Rm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXZBcnJvdzogJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtcm9sZT1cIm5vbmVcIiBjbGFzcz1cInNsaWNrLXByZXZcIiBhcmlhLWxhYmVsPVwiUHJldmlvdXNcIiB0YWJpbmRleD1cIjBcIiByb2xlPVwiYnV0dG9uXCI+UHJldmlvdXM8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgIG5leHRBcnJvdzogJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtcm9sZT1cIm5vbmVcIiBjbGFzcz1cInNsaWNrLW5leHRcIiBhcmlhLWxhYmVsPVwiTmV4dFwiIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJidXR0b25cIj5OZXh0PC9idXR0b24+JyxcbiAgICAgICAgICAgICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXV0b3BsYXlTcGVlZDogMzAwMCxcbiAgICAgICAgICAgICAgICBjZW50ZXJNb2RlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjZW50ZXJQYWRkaW5nOiAnNTBweCcsXG4gICAgICAgICAgICAgICAgY3NzRWFzZTogJ2Vhc2UnLFxuICAgICAgICAgICAgICAgIGN1c3RvbVBhZ2luZzogZnVuY3Rpb24oc2xpZGVyLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLXJvbGU9XCJub25lXCIgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIC8+JykudGV4dChpICsgMSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkb3RzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkb3RzQ2xhc3M6ICdzbGljay1kb3RzJyxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgICAgICAgICBlZGdlRnJpY3Rpb246IDAuMzUsXG4gICAgICAgICAgICAgICAgZmFkZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZm9jdXNPblNlbGVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5maW5pdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFNsaWRlOiAwLFxuICAgICAgICAgICAgICAgIGxhenlMb2FkOiAnb25kZW1hbmQnLFxuICAgICAgICAgICAgICAgIG1vYmlsZUZpcnN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXVzZU9uSG92ZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgcGF1c2VPbkZvY3VzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhdXNlT25Eb3RzSG92ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc3BvbmRUbzogJ3dpbmRvdycsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2l2ZTogbnVsbCxcbiAgICAgICAgICAgICAgICByb3dzOiAxLFxuICAgICAgICAgICAgICAgIHJ0bDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2xpZGU6ICcnLFxuICAgICAgICAgICAgICAgIHNsaWRlc1BlclJvdzogMSxcbiAgICAgICAgICAgICAgICBzbGlkZXNUb1Nob3c6IDEsXG4gICAgICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gICAgICAgICAgICAgICAgc3BlZWQ6IDUwMCxcbiAgICAgICAgICAgICAgICBzd2lwZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzd2lwZVRvU2xpZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRvdWNoTW92ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0b3VjaFRocmVzaG9sZDogNSxcbiAgICAgICAgICAgICAgICB1c2VDU1M6IHRydWUsXG4gICAgICAgICAgICAgICAgdXNlVHJhbnNmb3JtOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlV2lkdGg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFN3aXBpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhaXRGb3JBbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHpJbmRleDogMTAwMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgXy5pbml0aWFscyA9IHtcbiAgICAgICAgICAgICAgICBhbmltYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdXRvUGxheVRpbWVyOiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnREaXJlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgY3VycmVudExlZnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudFNsaWRlOiAwLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogMSxcbiAgICAgICAgICAgICAgICAkZG90czogbnVsbCxcbiAgICAgICAgICAgICAgICBsaXN0V2lkdGg6IG51bGwsXG4gICAgICAgICAgICAgICAgbGlzdEhlaWdodDogbnVsbCxcbiAgICAgICAgICAgICAgICBsb2FkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgJG5leHRBcnJvdzogbnVsbCxcbiAgICAgICAgICAgICAgICAkcHJldkFycm93OiBudWxsLFxuICAgICAgICAgICAgICAgIHNsaWRlQ291bnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgc2xpZGVXaWR0aDogbnVsbCxcbiAgICAgICAgICAgICAgICAkc2xpZGVUcmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICAkc2xpZGVzOiBudWxsLFxuICAgICAgICAgICAgICAgIHNsaWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNsaWRlT2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIHN3aXBlTGVmdDogbnVsbCxcbiAgICAgICAgICAgICAgICAkbGlzdDogbnVsbCxcbiAgICAgICAgICAgICAgICB0b3VjaE9iamVjdDoge30sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3Jtc0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVuc2xpY2tlZDogZmFsc2VcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICQuZXh0ZW5kKF8sIF8uaW5pdGlhbHMpO1xuXG4gICAgICAgICAgICBfLmFjdGl2ZUJyZWFrcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9IG51bGw7XG4gICAgICAgICAgICBfLmFuaW1Qcm9wID0gbnVsbDtcbiAgICAgICAgICAgIF8uYnJlYWtwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIF8uYnJlYWtwb2ludFNldHRpbmdzID0gW107XG4gICAgICAgICAgICBfLmNzc1RyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICAgICAgICBfLmZvY3Vzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBfLmludGVycnVwdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBfLmhpZGRlbiA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgXy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgXy5wb3NpdGlvblByb3AgPSBudWxsO1xuICAgICAgICAgICAgXy5yZXNwb25kVG8gPSBudWxsO1xuICAgICAgICAgICAgXy5yb3dDb3VudCA9IDE7XG4gICAgICAgICAgICBfLnNob3VsZENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIF8uJHNsaWRlciA9ICQoZWxlbWVudCk7XG4gICAgICAgICAgICBfLiRzbGlkZXNDYWNoZSA9IG51bGw7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgXy50cmFuc2l0aW9uVHlwZSA9IG51bGw7XG4gICAgICAgICAgICBfLnZpc2liaWxpdHlDaGFuZ2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICBfLndpbmRvd1dpZHRoID0gMDtcbiAgICAgICAgICAgIF8ud2luZG93VGltZXIgPSBudWxsO1xuXG4gICAgICAgICAgICBkYXRhU2V0dGluZ3MgPSAkKGVsZW1lbnQpLmRhdGEoJ3NsaWNrJykgfHwge307XG5cbiAgICAgICAgICAgIF8ub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBfLmRlZmF1bHRzLCBzZXR0aW5ncywgZGF0YVNldHRpbmdzKTtcblxuICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBfLm9wdGlvbnMuaW5pdGlhbFNsaWRlO1xuXG4gICAgICAgICAgICBfLm9yaWdpbmFsU2V0dGluZ3MgPSBfLm9wdGlvbnM7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIF8uaGlkZGVuID0gJ21vekhpZGRlbic7XG4gICAgICAgICAgICAgICAgXy52aXNpYmlsaXR5Q2hhbmdlID0gJ21venZpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQud2Via2l0SGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIF8uaGlkZGVuID0gJ3dlYmtpdEhpZGRlbic7XG4gICAgICAgICAgICAgICAgXy52aXNpYmlsaXR5Q2hhbmdlID0gJ3dlYmtpdHZpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLmF1dG9QbGF5ID0gJC5wcm94eShfLmF1dG9QbGF5LCBfKTtcbiAgICAgICAgICAgIF8uYXV0b1BsYXlDbGVhciA9ICQucHJveHkoXy5hdXRvUGxheUNsZWFyLCBfKTtcbiAgICAgICAgICAgIF8uYXV0b1BsYXlJdGVyYXRvciA9ICQucHJveHkoXy5hdXRvUGxheUl0ZXJhdG9yLCBfKTtcbiAgICAgICAgICAgIF8uY2hhbmdlU2xpZGUgPSAkLnByb3h5KF8uY2hhbmdlU2xpZGUsIF8pO1xuICAgICAgICAgICAgXy5jbGlja0hhbmRsZXIgPSAkLnByb3h5KF8uY2xpY2tIYW5kbGVyLCBfKTtcbiAgICAgICAgICAgIF8uc2VsZWN0SGFuZGxlciA9ICQucHJveHkoXy5zZWxlY3RIYW5kbGVyLCBfKTtcbiAgICAgICAgICAgIF8uc2V0UG9zaXRpb24gPSAkLnByb3h5KF8uc2V0UG9zaXRpb24sIF8pO1xuICAgICAgICAgICAgXy5zd2lwZUhhbmRsZXIgPSAkLnByb3h5KF8uc3dpcGVIYW5kbGVyLCBfKTtcbiAgICAgICAgICAgIF8uZHJhZ0hhbmRsZXIgPSAkLnByb3h5KF8uZHJhZ0hhbmRsZXIsIF8pO1xuICAgICAgICAgICAgXy5rZXlIYW5kbGVyID0gJC5wcm94eShfLmtleUhhbmRsZXIsIF8pO1xuXG4gICAgICAgICAgICBfLmluc3RhbmNlVWlkID0gaW5zdGFuY2VVaWQrKztcblxuICAgICAgICAgICAgLy8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3NcbiAgICAgICAgICAgIC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uIChtdXN0IHN0YXJ0IHdpdGggPClcbiAgICAgICAgICAgIC8vIEV4dHJhY3RlZCBmcm9tIGpRdWVyeSB2MS4xMSBzb3VyY2VcbiAgICAgICAgICAgIF8uaHRtbEV4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSopJC87XG5cblxuICAgICAgICAgICAgXy5yZWdpc3RlckJyZWFrcG9pbnRzKCk7XG4gICAgICAgICAgICBfLmluaXQodHJ1ZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTbGljaztcblxuICAgIH0oKSk7XG5cbiAgICBTbGljay5wcm90b3R5cGUuYWN0aXZhdGVBREEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suZmluZCgnLnNsaWNrLWFjdGl2ZScpLmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ2ZhbHNlJ1xuICAgICAgICB9KS5maW5kKCdhLCBpbnB1dCwgYnV0dG9uLCBzZWxlY3QnKS5hdHRyKHtcbiAgICAgICAgICAgICd0YWJpbmRleCc6ICcwJ1xuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYWRkU2xpZGUgPSBTbGljay5wcm90b3R5cGUuc2xpY2tBZGQgPSBmdW5jdGlvbihtYXJrdXAsIGluZGV4LCBhZGRCZWZvcmUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZihpbmRleCkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgYWRkQmVmb3JlID0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCAwIHx8IChpbmRleCA+PSBfLnNsaWRlQ291bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBfLnVubG9hZCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YoaW5kZXgpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIF8uJHNsaWRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAkKG1hcmt1cCkuYXBwZW5kVG8oXy4kc2xpZGVUcmFjayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFkZEJlZm9yZSkge1xuICAgICAgICAgICAgICAgICQobWFya3VwKS5pbnNlcnRCZWZvcmUoXy4kc2xpZGVzLmVxKGluZGV4KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQobWFya3VwKS5pbnNlcnRBZnRlcihfLiRzbGlkZXMuZXEoaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhZGRCZWZvcmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAkKG1hcmt1cCkucHJlcGVuZFRvKF8uJHNsaWRlVHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKG1hcmt1cCkuYXBwZW5kVG8oXy4kc2xpZGVUcmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfLiRzbGlkZXMgPSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suYXBwZW5kKF8uJHNsaWRlcyk7XG5cbiAgICAgICAgXy4kc2xpZGVzLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICQoZWxlbWVudCkuYXR0cignZGF0YS1zbGljay1pbmRleCcsIGluZGV4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy4kc2xpZGVzQ2FjaGUgPSBfLiRzbGlkZXM7XG5cbiAgICAgICAgXy5yZWluaXQoKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYW5pbWF0ZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXM7XG4gICAgICAgIGlmIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID09PSAxICYmIF8ub3B0aW9ucy5hZGFwdGl2ZUhlaWdodCA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gXy4kc2xpZGVzLmVxKF8uY3VycmVudFNsaWRlKS5vdXRlckhlaWdodCh0cnVlKTtcbiAgICAgICAgICAgIF8uJGxpc3QuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0YXJnZXRIZWlnaHRcbiAgICAgICAgICAgIH0sIF8ub3B0aW9ucy5zcGVlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmFuaW1hdGVTbGlkZSA9IGZ1bmN0aW9uKHRhcmdldExlZnQsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgdmFyIGFuaW1Qcm9wcyA9IHt9LFxuICAgICAgICAgICAgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5hbmltYXRlSGVpZ2h0KCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5ydGwgPT09IHRydWUgJiYgXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IC10YXJnZXRMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLnRyYW5zZm9ybXNFbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRMZWZ0XG4gICAgICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkLCBfLm9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogdGFyZ2V0TGVmdFxuICAgICAgICAgICAgICAgIH0sIF8ub3B0aW9ucy5zcGVlZCwgXy5vcHRpb25zLmVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChfLmNzc1RyYW5zaXRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMucnRsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uY3VycmVudExlZnQgPSAtKF8uY3VycmVudExlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbVN0YXJ0OiBfLmN1cnJlbnRMZWZ0XG4gICAgICAgICAgICAgICAgfSkuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1TdGFydDogdGFyZ2V0TGVmdFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IF8ub3B0aW9ucy5zcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBfLm9wdGlvbnMuZWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICBzdGVwOiBmdW5jdGlvbihub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9IE1hdGguY2VpbChub3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltUHJvcHNbXy5hbmltVHlwZV0gPSAndHJhbnNsYXRlKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgKyAncHgsIDBweCknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKGFuaW1Qcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUoMHB4LCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgKyAncHgpJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyhhbmltUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIF8uYXBwbHlUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IE1hdGguY2VpbCh0YXJnZXRMZWZ0KTtcblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUzZCgnICsgdGFyZ2V0TGVmdCArICdweCwgMHB4LCAwcHgpJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbmltUHJvcHNbXy5hbmltVHlwZV0gPSAndHJhbnNsYXRlM2QoMHB4LCcgKyB0YXJnZXRMZWZ0ICsgJ3B4LCAwcHgpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MoYW5pbVByb3BzKTtcblxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmRpc2FibGVUcmFuc2l0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldE5hdlRhcmdldCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGFzTmF2Rm9yID0gXy5vcHRpb25zLmFzTmF2Rm9yO1xuXG4gICAgICAgIGlmICggYXNOYXZGb3IgJiYgYXNOYXZGb3IgIT09IG51bGwgKSB7XG4gICAgICAgICAgICBhc05hdkZvciA9ICQoYXNOYXZGb3IpLm5vdChfLiRzbGlkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzTmF2Rm9yO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hc05hdkZvciA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgYXNOYXZGb3IgPSBfLmdldE5hdlRhcmdldCgpO1xuXG4gICAgICAgIGlmICggYXNOYXZGb3IgIT09IG51bGwgJiYgdHlwZW9mIGFzTmF2Rm9yID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgIGFzTmF2Rm9yLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9ICQodGhpcykuc2xpY2soJ2dldFNsaWNrJyk7XG4gICAgICAgICAgICAgICAgaWYoIXRhcmdldC51bnNsaWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNsaWRlSGFuZGxlcihpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYXBwbHlUcmFuc2l0aW9uID0gZnVuY3Rpb24oc2xpZGUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICB0cmFuc2l0aW9uID0ge307XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbltfLnRyYW5zaXRpb25UeXBlXSA9IF8udHJhbnNmb3JtVHlwZSArICcgJyArIF8ub3B0aW9ucy5zcGVlZCArICdtcyAnICsgXy5vcHRpb25zLmNzc0Vhc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uW18udHJhbnNpdGlvblR5cGVdID0gJ29wYWNpdHkgJyArIF8ub3B0aW9ucy5zcGVlZCArICdtcyAnICsgXy5vcHRpb25zLmNzc0Vhc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyh0cmFuc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZSkuY3NzKHRyYW5zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmF1dG9QbGF5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uYXV0b1BsYXlDbGVhcigpO1xuXG4gICAgICAgIGlmICggXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyApIHtcbiAgICAgICAgICAgIF8uYXV0b1BsYXlUaW1lciA9IHNldEludGVydmFsKCBfLmF1dG9QbGF5SXRlcmF0b3IsIF8ub3B0aW9ucy5hdXRvcGxheVNwZWVkICk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYXV0b1BsYXlDbGVhciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5hdXRvUGxheVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKF8uYXV0b1BsYXlUaW1lcik7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYXV0b1BsYXlJdGVyYXRvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHNsaWRlVG8gPSBfLmN1cnJlbnRTbGlkZSArIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcblxuICAgICAgICBpZiAoICFfLnBhdXNlZCAmJiAhXy5pbnRlcnJ1cHRlZCAmJiAhXy5mb2N1c3NlZCApIHtcblxuICAgICAgICAgICAgaWYgKCBfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBfLmRpcmVjdGlvbiA9PT0gMSAmJiAoIF8uY3VycmVudFNsaWRlICsgMSApID09PSAoIF8uc2xpZGVDb3VudCAtIDEgKSkge1xuICAgICAgICAgICAgICAgICAgICBfLmRpcmVjdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIF8uZGlyZWN0aW9uID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNsaWRlVG8gPSBfLmN1cnJlbnRTbGlkZSAtIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIF8uY3VycmVudFNsaWRlIC0gMSA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKCBzbGlkZVRvICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5idWlsZEFycm93cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgXy4kcHJldkFycm93ID0gJChfLm9wdGlvbnMucHJldkFycm93KS5hZGRDbGFzcygnc2xpY2stYXJyb3cnKTtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvdyA9ICQoXy5vcHRpb25zLm5leHRBcnJvdykuYWRkQ2xhc3MoJ3NsaWNrLWFycm93Jyk7XG5cbiAgICAgICAgICAgIGlmKCBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICkge1xuXG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93LnJlbW92ZUNsYXNzKCdzbGljay1oaWRkZW4nKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiB0YWJpbmRleCcpO1xuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2staGlkZGVuJykucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4gdGFiaW5kZXgnKTtcblxuICAgICAgICAgICAgICAgIGlmIChfLmh0bWxFeHByLnRlc3QoXy5vcHRpb25zLnByZXZBcnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgXy4kcHJldkFycm93LnByZXBlbmRUbyhfLm9wdGlvbnMuYXBwZW5kQXJyb3dzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5odG1sRXhwci50ZXN0KF8ub3B0aW9ucy5uZXh0QXJyb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5hcHBlbmRUbyhfLm9wdGlvbnMuYXBwZW5kQXJyb3dzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1kaXNhYmxlZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93LmFkZCggXy4kbmV4dEFycm93IClcblxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWhpZGRlbicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RhYmluZGV4JzogJy0xJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYnVpbGREb3RzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgaSwgZG90O1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZG90cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlci5hZGRDbGFzcygnc2xpY2stZG90dGVkJyk7XG5cbiAgICAgICAgICAgIGRvdCA9ICQoJzx1bCAvPicpLmFkZENsYXNzKF8ub3B0aW9ucy5kb3RzQ2xhc3MpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IF8uZ2V0RG90Q291bnQoKTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgZG90LmFwcGVuZCgkKCc8bGkgLz4nKS5hcHBlbmQoXy5vcHRpb25zLmN1c3RvbVBhZ2luZy5jYWxsKHRoaXMsIF8sIGkpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uJGRvdHMgPSBkb3QuYXBwZW5kVG8oXy5vcHRpb25zLmFwcGVuZERvdHMpO1xuXG4gICAgICAgICAgICBfLiRkb3RzLmZpbmQoJ2xpJykuZmlyc3QoKS5hZGRDbGFzcygnc2xpY2stYWN0aXZlJykuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmJ1aWxkT3V0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uJHNsaWRlcyA9XG4gICAgICAgICAgICBfLiRzbGlkZXJcbiAgICAgICAgICAgICAgICAuY2hpbGRyZW4oIF8ub3B0aW9ucy5zbGlkZSArICc6bm90KC5zbGljay1jbG9uZWQpJylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLXNsaWRlJyk7XG5cbiAgICAgICAgXy5zbGlkZUNvdW50ID0gXy4kc2xpZGVzLmxlbmd0aDtcblxuICAgICAgICBfLiRzbGlkZXMuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkYXRhLXNsaWNrLWluZGV4JywgaW5kZXgpXG4gICAgICAgICAgICAgICAgLmRhdGEoJ29yaWdpbmFsU3R5bGluZycsICQoZWxlbWVudCkuYXR0cignc3R5bGUnKSB8fCAnJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uJHNsaWRlci5hZGRDbGFzcygnc2xpY2stc2xpZGVyJyk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjayA9IChfLnNsaWRlQ291bnQgPT09IDApID9cbiAgICAgICAgICAgICQoJzxkaXYgY2xhc3M9XCJzbGljay10cmFja1wiLz4nKS5hcHBlbmRUbyhfLiRzbGlkZXIpIDpcbiAgICAgICAgICAgIF8uJHNsaWRlcy53cmFwQWxsKCc8ZGl2IGNsYXNzPVwic2xpY2stdHJhY2tcIi8+JykucGFyZW50KCk7XG5cbiAgICAgICAgXy4kbGlzdCA9IF8uJHNsaWRlVHJhY2sud3JhcChcbiAgICAgICAgICAgICc8ZGl2IGFyaWEtbGl2ZT1cInBvbGl0ZVwiIGNsYXNzPVwic2xpY2stbGlzdFwiLz4nKS5wYXJlbnQoKTtcbiAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MoJ29wYWNpdHknLCAwKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUgfHwgXy5vcHRpb25zLnN3aXBlVG9TbGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgICQoJ2ltZ1tkYXRhLWxhenldJywgXy4kc2xpZGVyKS5ub3QoJ1tzcmNdJykuYWRkQ2xhc3MoJ3NsaWNrLWxvYWRpbmcnKTtcblxuICAgICAgICBfLnNldHVwSW5maW5pdGUoKTtcblxuICAgICAgICBfLmJ1aWxkQXJyb3dzKCk7XG5cbiAgICAgICAgXy5idWlsZERvdHMoKTtcblxuICAgICAgICBfLnVwZGF0ZURvdHMoKTtcblxuXG4gICAgICAgIF8uc2V0U2xpZGVDbGFzc2VzKHR5cGVvZiBfLmN1cnJlbnRTbGlkZSA9PT0gJ251bWJlcicgPyBfLmN1cnJlbnRTbGlkZSA6IDApO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZHJhZ2dhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRsaXN0LmFkZENsYXNzKCdkcmFnZ2FibGUnKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5idWlsZFJvd3MgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsIGEsIGIsIGMsIG5ld1NsaWRlcywgbnVtT2ZTbGlkZXMsIG9yaWdpbmFsU2xpZGVzLHNsaWRlc1BlclNlY3Rpb247XG5cbiAgICAgICAgbmV3U2xpZGVzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBvcmlnaW5hbFNsaWRlcyA9IF8uJHNsaWRlci5jaGlsZHJlbigpO1xuXG4gICAgICAgIGlmKF8ub3B0aW9ucy5yb3dzID4gMSkge1xuXG4gICAgICAgICAgICBzbGlkZXNQZXJTZWN0aW9uID0gXy5vcHRpb25zLnNsaWRlc1BlclJvdyAqIF8ub3B0aW9ucy5yb3dzO1xuICAgICAgICAgICAgbnVtT2ZTbGlkZXMgPSBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTbGlkZXMubGVuZ3RoIC8gc2xpZGVzUGVyU2VjdGlvblxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yKGEgPSAwOyBhIDwgbnVtT2ZTbGlkZXM7IGErKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNsaWRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZm9yKGIgPSAwOyBiIDwgXy5vcHRpb25zLnJvd3M7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIGZvcihjID0gMDsgYyA8IF8ub3B0aW9ucy5zbGlkZXNQZXJSb3c7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IChhICogc2xpZGVzUGVyU2VjdGlvbiArICgoYiAqIF8ub3B0aW9ucy5zbGlkZXNQZXJSb3cpICsgYykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsU2xpZGVzLmdldCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKG9yaWdpbmFsU2xpZGVzLmdldCh0YXJnZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzbGlkZS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTbGlkZXMuYXBwZW5kQ2hpbGQoc2xpZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLiRzbGlkZXIuZW1wdHkoKS5hcHBlbmQobmV3U2xpZGVzKTtcbiAgICAgICAgICAgIF8uJHNsaWRlci5jaGlsZHJlbigpLmNoaWxkcmVuKCkuY2hpbGRyZW4oKVxuICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOigxMDAgLyBfLm9wdGlvbnMuc2xpZGVzUGVyUm93KSArICclJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Rpc3BsYXknOiAnaW5saW5lLWJsb2NrJ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2hlY2tSZXNwb25zaXZlID0gZnVuY3Rpb24oaW5pdGlhbCwgZm9yY2VVcGRhdGUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBicmVha3BvaW50LCB0YXJnZXRCcmVha3BvaW50LCByZXNwb25kVG9XaWR0aCwgdHJpZ2dlckJyZWFrcG9pbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNsaWRlcldpZHRoID0gXy4kc2xpZGVyLndpZHRoKCk7XG4gICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8ICQod2luZG93KS53aWR0aCgpO1xuXG4gICAgICAgIGlmIChfLnJlc3BvbmRUbyA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICAgIHJlc3BvbmRUb1dpZHRoID0gd2luZG93V2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5yZXNwb25kVG8gPT09ICdzbGlkZXInKSB7XG4gICAgICAgICAgICByZXNwb25kVG9XaWR0aCA9IHNsaWRlcldpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKF8ucmVzcG9uZFRvID09PSAnbWluJykge1xuICAgICAgICAgICAgcmVzcG9uZFRvV2lkdGggPSBNYXRoLm1pbih3aW5kb3dXaWR0aCwgc2xpZGVyV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMucmVzcG9uc2l2ZSAmJlxuICAgICAgICAgICAgXy5vcHRpb25zLnJlc3BvbnNpdmUubGVuZ3RoICYmXG4gICAgICAgICAgICBfLm9wdGlvbnMucmVzcG9uc2l2ZSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICB0YXJnZXRCcmVha3BvaW50ID0gbnVsbDtcblxuICAgICAgICAgICAgZm9yIChicmVha3BvaW50IGluIF8uYnJlYWtwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5icmVha3BvaW50cy5oYXNPd25Qcm9wZXJ0eShicmVha3BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5vcmlnaW5hbFNldHRpbmdzLm1vYmlsZUZpcnN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbmRUb1dpZHRoIDwgXy5icmVha3BvaW50c1ticmVha3BvaW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnQgPSBfLmJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbmRUb1dpZHRoID4gXy5icmVha3BvaW50c1ticmVha3BvaW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnQgPSBfLmJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0QnJlYWtwb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChfLmFjdGl2ZUJyZWFrcG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEJyZWFrcG9pbnQgIT09IF8uYWN0aXZlQnJlYWtwb2ludCB8fCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5hY3RpdmVCcmVha3BvaW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uYnJlYWtwb2ludFNldHRpbmdzW3RhcmdldEJyZWFrcG9pbnRdID09PSAndW5zbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLnVuc2xpY2sodGFyZ2V0QnJlYWtwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBfLm9yaWdpbmFsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uYnJlYWtwb2ludFNldHRpbmdzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnJlYWtwb2ludF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gXy5vcHRpb25zLmluaXRpYWxTbGlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5yZWZyZXNoKGluaXRpYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckJyZWFrcG9pbnQgPSB0YXJnZXRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgXy5hY3RpdmVCcmVha3BvaW50ID0gdGFyZ2V0QnJlYWtwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uYnJlYWtwb2ludFNldHRpbmdzW3RhcmdldEJyZWFrcG9pbnRdID09PSAndW5zbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udW5zbGljayh0YXJnZXRCcmVha3BvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBfLm9yaWdpbmFsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5icmVha3BvaW50U2V0dGluZ3NbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBfLm9wdGlvbnMuaW5pdGlhbFNsaWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXy5yZWZyZXNoKGluaXRpYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJCcmVha3BvaW50ID0gdGFyZ2V0QnJlYWtwb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChfLmFjdGl2ZUJyZWFrcG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5hY3RpdmVCcmVha3BvaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zID0gXy5vcmlnaW5hbFNldHRpbmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBfLm9wdGlvbnMuaW5pdGlhbFNsaWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF8ucmVmcmVzaChpbml0aWFsKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckJyZWFrcG9pbnQgPSB0YXJnZXRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb25seSB0cmlnZ2VyIGJyZWFrcG9pbnRzIGR1cmluZyBhbiBhY3R1YWwgYnJlYWsuIG5vdCBvbiBpbml0aWFsaXplLlxuICAgICAgICAgICAgaWYoICFpbml0aWFsICYmIHRyaWdnZXJCcmVha3BvaW50ICE9PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignYnJlYWtwb2ludCcsIFtfLCB0cmlnZ2VyQnJlYWtwb2ludF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNoYW5nZVNsaWRlID0gZnVuY3Rpb24oZXZlbnQsIGRvbnRBbmltYXRlKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCksXG4gICAgICAgICAgICBpbmRleE9mZnNldCwgc2xpZGVPZmZzZXQsIHVuZXZlbk9mZnNldDtcblxuICAgICAgICAvLyBJZiB0YXJnZXQgaXMgYSBsaW5rLCBwcmV2ZW50IGRlZmF1bHQgYWN0aW9uLlxuICAgICAgICBpZigkdGFyZ2V0LmlzKCdhJykpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0YXJnZXQgaXMgbm90IHRoZSA8bGk+IGVsZW1lbnQgKGllOiBhIGNoaWxkKSwgZmluZCB0aGUgPGxpPi5cbiAgICAgICAgaWYoISR0YXJnZXQuaXMoJ2xpJykpIHtcbiAgICAgICAgICAgICR0YXJnZXQgPSAkdGFyZ2V0LmNsb3Nlc3QoJ2xpJyk7XG4gICAgICAgIH1cblxuICAgICAgICB1bmV2ZW5PZmZzZXQgPSAoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICE9PSAwKTtcbiAgICAgICAgaW5kZXhPZmZzZXQgPSB1bmV2ZW5PZmZzZXQgPyAwIDogKF8uc2xpZGVDb3VudCAtIF8uY3VycmVudFNsaWRlKSAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmRhdGEubWVzc2FnZSkge1xuXG4gICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XG4gICAgICAgICAgICAgICAgc2xpZGVPZmZzZXQgPSBpbmRleE9mZnNldCA9PT0gMCA/IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA6IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLSBpbmRleE9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgICAgICBfLnNsaWRlSGFuZGxlcihfLmN1cnJlbnRTbGlkZSAtIHNsaWRlT2Zmc2V0LCBmYWxzZSwgZG9udEFuaW1hdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICAgICAgc2xpZGVPZmZzZXQgPSBpbmRleE9mZnNldCA9PT0gMCA/IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA6IGluZGV4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKF8uY3VycmVudFNsaWRlICsgc2xpZGVPZmZzZXQsIGZhbHNlLCBkb250QW5pbWF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdpbmRleCc6XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZXZlbnQuZGF0YS5pbmRleCA9PT0gMCA/IDAgOlxuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4IHx8ICR0YXJnZXQuaW5kZXgoKSAqIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcblxuICAgICAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKF8uY2hlY2tOYXZpZ2FibGUoaW5kZXgpLCBmYWxzZSwgZG9udEFuaW1hdGUpO1xuICAgICAgICAgICAgICAgICR0YXJnZXQuY2hpbGRyZW4oKS50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jaGVja05hdmlnYWJsZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgbmF2aWdhYmxlcywgcHJldk5hdmlnYWJsZTtcblxuICAgICAgICBuYXZpZ2FibGVzID0gXy5nZXROYXZpZ2FibGVJbmRleGVzKCk7XG4gICAgICAgIHByZXZOYXZpZ2FibGUgPSAwO1xuICAgICAgICBpZiAoaW5kZXggPiBuYXZpZ2FibGVzW25hdmlnYWJsZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIGluZGV4ID0gbmF2aWdhYmxlc1tuYXZpZ2FibGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBuYXZpZ2FibGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbmF2aWdhYmxlc1tuXSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHByZXZOYXZpZ2FibGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2TmF2aWdhYmxlID0gbmF2aWdhYmxlc1tuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNsZWFuVXBFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzICYmIF8uJGRvdHMgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgJCgnbGknLCBfLiRkb3RzKVxuICAgICAgICAgICAgICAgIC5vZmYoJ2NsaWNrLnNsaWNrJywgXy5jaGFuZ2VTbGlkZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdtb3VzZWVudGVyLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgLm9mZignbW91c2VsZWF2ZS5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIGZhbHNlKSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlci5vZmYoJ2ZvY3VzLnNsaWNrIGJsdXIuc2xpY2snKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cgJiYgXy4kcHJldkFycm93Lm9mZignY2xpY2suc2xpY2snLCBfLmNoYW5nZVNsaWRlKTtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvdyAmJiBfLiRuZXh0QXJyb3cub2ZmKCdjbGljay5zbGljaycsIF8uY2hhbmdlU2xpZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy4kbGlzdC5vZmYoJ3RvdWNoc3RhcnQuc2xpY2sgbW91c2Vkb3duLnNsaWNrJywgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9mZigndG91Y2htb3ZlLnNsaWNrIG1vdXNlbW92ZS5zbGljaycsIF8uc3dpcGVIYW5kbGVyKTtcbiAgICAgICAgXy4kbGlzdC5vZmYoJ3RvdWNoZW5kLnNsaWNrIG1vdXNldXAuc2xpY2snLCBfLnN3aXBlSGFuZGxlcik7XG4gICAgICAgIF8uJGxpc3Qub2ZmKCd0b3VjaGNhbmNlbC5zbGljayBtb3VzZWxlYXZlLnNsaWNrJywgXy5zd2lwZUhhbmRsZXIpO1xuXG4gICAgICAgIF8uJGxpc3Qub2ZmKCdjbGljay5zbGljaycsIF8uY2xpY2tIYW5kbGVyKTtcblxuICAgICAgICAkKGRvY3VtZW50KS5vZmYoXy52aXNpYmlsaXR5Q2hhbmdlLCBfLnZpc2liaWxpdHkpO1xuXG4gICAgICAgIF8uY2xlYW5VcFNsaWRlRXZlbnRzKCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRsaXN0Lm9mZigna2V5ZG93bi5zbGljaycsIF8ua2V5SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZvY3VzT25TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICQoXy4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vZmYoJ2NsaWNrLnNsaWNrJywgXy5zZWxlY3RIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQod2luZG93KS5vZmYoJ29yaWVudGF0aW9uY2hhbmdlLnNsaWNrLnNsaWNrLScgKyBfLmluc3RhbmNlVWlkLCBfLm9yaWVudGF0aW9uQ2hhbmdlKTtcblxuICAgICAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsIF8ucmVzaXplKTtcblxuICAgICAgICAkKCdbZHJhZ2dhYmxlIT10cnVlXScsIF8uJHNsaWRlVHJhY2spLm9mZignZHJhZ3N0YXJ0JywgXy5wcmV2ZW50RGVmYXVsdCk7XG5cbiAgICAgICAgJCh3aW5kb3cpLm9mZignbG9hZC5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgXy5zZXRQb3NpdGlvbik7XG4gICAgICAgICQoZG9jdW1lbnQpLm9mZigncmVhZHkuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsIF8uc2V0UG9zaXRpb24pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jbGVhblVwU2xpZGVFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy4kbGlzdC5vZmYoJ21vdXNlZW50ZXIuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCB0cnVlKSk7XG4gICAgICAgIF8uJGxpc3Qub2ZmKCdtb3VzZWxlYXZlLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgZmFsc2UpKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2xlYW5VcFJvd3MgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsIG9yaWdpbmFsU2xpZGVzO1xuXG4gICAgICAgIGlmKF8ub3B0aW9ucy5yb3dzID4gMSkge1xuICAgICAgICAgICAgb3JpZ2luYWxTbGlkZXMgPSBfLiRzbGlkZXMuY2hpbGRyZW4oKS5jaGlsZHJlbigpO1xuICAgICAgICAgICAgb3JpZ2luYWxTbGlkZXMucmVtb3ZlQXR0cignc3R5bGUnKTtcbiAgICAgICAgICAgIF8uJHNsaWRlci5lbXB0eSgpLmFwcGVuZChvcmlnaW5hbFNsaWRlcyk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8uc2hvdWxkQ2xpY2sgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24ocmVmcmVzaCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmF1dG9QbGF5Q2xlYXIoKTtcblxuICAgICAgICBfLnRvdWNoT2JqZWN0ID0ge307XG5cbiAgICAgICAgXy5jbGVhblVwRXZlbnRzKCk7XG5cbiAgICAgICAgJCgnLnNsaWNrLWNsb25lZCcsIF8uJHNsaWRlcikuZGV0YWNoKCk7XG5cbiAgICAgICAgaWYgKF8uJGRvdHMpIHtcbiAgICAgICAgICAgIF8uJGRvdHMucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICggXy4kcHJldkFycm93ICYmIF8uJHByZXZBcnJvdy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIF8uJHByZXZBcnJvd1xuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuJylcbiAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4gYXJpYS1kaXNhYmxlZCB0YWJpbmRleCcpXG4gICAgICAgICAgICAgICAgLmNzcygnZGlzcGxheScsJycpO1xuXG4gICAgICAgICAgICBpZiAoIF8uaHRtbEV4cHIudGVzdCggXy5vcHRpb25zLnByZXZBcnJvdyApKSB7XG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLiRuZXh0QXJyb3cgJiYgXy4kbmV4dEFycm93Lmxlbmd0aCApIHtcblxuICAgICAgICAgICAgXy4kbmV4dEFycm93XG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCBzbGljay1hcnJvdyBzbGljay1oaWRkZW4nKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4JylcbiAgICAgICAgICAgICAgICAuY3NzKCdkaXNwbGF5JywnJyk7XG5cbiAgICAgICAgICAgIGlmICggXy5odG1sRXhwci50ZXN0KCBfLm9wdGlvbnMubmV4dEFycm93ICkpIHtcbiAgICAgICAgICAgICAgICBfLiRuZXh0QXJyb3cucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKF8uJHNsaWRlcykge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLXNsaWRlIHNsaWNrLWFjdGl2ZSBzbGljay1jZW50ZXIgc2xpY2stdmlzaWJsZSBzbGljay1jdXJyZW50JylcbiAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4nKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXNsaWNrLWluZGV4JylcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmF0dHIoJ3N0eWxlJywgJCh0aGlzKS5kYXRhKCdvcmlnaW5hbFN0eWxpbmcnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKTtcblxuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5kZXRhY2goKTtcblxuICAgICAgICAgICAgXy4kbGlzdC5kZXRhY2goKTtcblxuICAgICAgICAgICAgXy4kc2xpZGVyLmFwcGVuZChfLiRzbGlkZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5jbGVhblVwUm93cygpO1xuXG4gICAgICAgIF8uJHNsaWRlci5yZW1vdmVDbGFzcygnc2xpY2stc2xpZGVyJyk7XG4gICAgICAgIF8uJHNsaWRlci5yZW1vdmVDbGFzcygnc2xpY2staW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgXy4kc2xpZGVyLnJlbW92ZUNsYXNzKCdzbGljay1kb3R0ZWQnKTtcblxuICAgICAgICBfLnVuc2xpY2tlZCA9IHRydWU7XG5cbiAgICAgICAgaWYoIXJlZnJlc2gpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdkZXN0cm95JywgW19dKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5kaXNhYmxlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHNsaWRlKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgdHJhbnNpdGlvbiA9IHt9O1xuXG4gICAgICAgIHRyYW5zaXRpb25bXy50cmFuc2l0aW9uVHlwZV0gPSAnJztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyh0cmFuc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZSkuY3NzKHRyYW5zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmZhZGVTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlSW5kZXgsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLmNzc1RyYW5zaXRpb25zID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGVJbmRleCkuY3NzKHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGVJbmRleCkuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkLCBfLm9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgXy5hcHBseVRyYW5zaXRpb24oc2xpZGVJbmRleCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZUluZGV4KS5jc3Moe1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBfLmRpc2FibGVUcmFuc2l0aW9uKHNsaWRlSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoKTtcbiAgICAgICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZmFkZVNsaWRlT3V0ID0gZnVuY3Rpb24oc2xpZGVJbmRleCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5jc3NUcmFuc2l0aW9ucyA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlSW5kZXgpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4IC0gMlxuICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkLCBfLm9wdGlvbnMuZWFzaW5nKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBfLmFwcGx5VHJhbnNpdGlvbihzbGlkZUluZGV4KTtcblxuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlSW5kZXgpLmNzcyh7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXggLSAyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmZpbHRlclNsaWRlcyA9IFNsaWNrLnByb3RvdHlwZS5zbGlja0ZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcikge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoZmlsdGVyICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlc0NhY2hlID0gXy4kc2xpZGVzO1xuXG4gICAgICAgICAgICBfLnVubG9hZCgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlc0NhY2hlLmZpbHRlcihmaWx0ZXIpLmFwcGVuZFRvKF8uJHNsaWRlVHJhY2spO1xuXG4gICAgICAgICAgICBfLnJlaW5pdCgpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZm9jdXNIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uJHNsaWRlclxuICAgICAgICAgICAgLm9mZignZm9jdXMuc2xpY2sgYmx1ci5zbGljaycpXG4gICAgICAgICAgICAub24oJ2ZvY3VzLnNsaWNrIGJsdXIuc2xpY2snLFxuICAgICAgICAgICAgICAgICcqOm5vdCguc2xpY2stYXJyb3cpJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB2YXIgJHNmID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGlmKCBfLm9wdGlvbnMucGF1c2VPbkZvY3VzICkge1xuICAgICAgICAgICAgICAgICAgICBfLmZvY3Vzc2VkID0gJHNmLmlzKCc6Zm9jdXMnKTtcbiAgICAgICAgICAgICAgICAgICAgXy5hdXRvUGxheSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXRDdXJyZW50ID0gU2xpY2sucHJvdG90eXBlLnNsaWNrQ3VycmVudFNsaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuICAgICAgICByZXR1cm4gXy5jdXJyZW50U2xpZGU7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldERvdENvdW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIHZhciBicmVha1BvaW50ID0gMDtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgcGFnZXJRdHkgPSAwO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdoaWxlIChicmVha1BvaW50IDwgXy5zbGlkZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgKytwYWdlclF0eTtcbiAgICAgICAgICAgICAgICBicmVha1BvaW50ID0gY291bnRlciArIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgICAgICAgICBjb3VudGVyICs9IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogXy5vcHRpb25zLnNsaWRlc1RvU2hvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcGFnZXJRdHkgPSBfLnNsaWRlQ291bnQ7XG4gICAgICAgIH0gZWxzZSBpZighXy5vcHRpb25zLmFzTmF2Rm9yKSB7XG4gICAgICAgICAgICBwYWdlclF0eSA9IDEgKyBNYXRoLmNlaWwoKF8uc2xpZGVDb3VudCAtIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIC8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKTtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGJyZWFrUG9pbnQgPCBfLnNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICArK3BhZ2VyUXR5O1xuICAgICAgICAgICAgICAgIGJyZWFrUG9pbnQgPSBjb3VudGVyICsgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICAgICAgICAgICAgICAgIGNvdW50ZXIgKz0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgOiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhZ2VyUXR5IC0gMTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uKHNsaWRlSW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICB0YXJnZXRMZWZ0LFxuICAgICAgICAgICAgdmVydGljYWxIZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9IDAsXG4gICAgICAgICAgICB0YXJnZXRTbGlkZTtcblxuICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gMDtcbiAgICAgICAgdmVydGljYWxIZWlnaHQgPSBfLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCh0cnVlKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAoXy5zbGlkZVdpZHRoICogXy5vcHRpb25zLnNsaWRlc1RvU2hvdykgKiAtMTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9ICh2ZXJ0aWNhbEhlaWdodCAqIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpICogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlSW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgPiBfLnNsaWRlQ291bnQgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xpZGVJbmRleCA+IF8uc2xpZGVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9ICgoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAtIChzbGlkZUluZGV4IC0gXy5zbGlkZUNvdW50KSkgKiBfLnNsaWRlV2lkdGgpICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9ICgoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAtIChzbGlkZUluZGV4IC0gXy5zbGlkZUNvdW50KSkgKiB2ZXJ0aWNhbEhlaWdodCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAoKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCkgKiBfLnNsaWRlV2lkdGgpICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9ICgoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSAqIHZlcnRpY2FsSGVpZ2h0KSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNsaWRlSW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID4gXy5zbGlkZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9ICgoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIC0gXy5zbGlkZUNvdW50KSAqIF8uc2xpZGVXaWR0aDtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9ICgoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIC0gXy5zbGlkZUNvdW50KSAqIHZlcnRpY2FsSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgKz0gXy5zbGlkZVdpZHRoICogTWF0aC5mbG9vcihfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMikgLSBfLnNsaWRlV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgXy5zbGlkZU9mZnNldCArPSBfLnNsaWRlV2lkdGggKiBNYXRoLmZsb29yKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0YXJnZXRMZWZ0ID0gKChzbGlkZUluZGV4ICogXy5zbGlkZVdpZHRoKSAqIC0xKSArIF8uc2xpZGVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRMZWZ0ID0gKChzbGlkZUluZGV4ICogdmVydGljYWxIZWlnaHQpICogLTEpICsgdmVydGljYWxPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZhcmlhYmxlV2lkdGggPT09IHRydWUpIHtcblxuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93IHx8IF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTbGlkZSA9IF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLmVxKHNsaWRlSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTbGlkZSA9IF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLmVxKHNsaWRlSW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5ydGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U2xpZGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IChfLiRzbGlkZVRyYWNrLndpZHRoKCkgLSB0YXJnZXRTbGlkZVswXS5vZmZzZXRMZWZ0IC0gdGFyZ2V0U2xpZGUud2lkdGgoKSkgKiAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gdGFyZ2V0U2xpZGVbMF0gPyB0YXJnZXRTbGlkZVswXS5vZmZzZXRMZWZ0ICogLTEgOiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgfHwgXy5vcHRpb25zLmluZmluaXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTbGlkZSA9IF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLmVxKHNsaWRlSW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykuZXEoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U2xpZGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAoXy4kc2xpZGVUcmFjay53aWR0aCgpIC0gdGFyZ2V0U2xpZGVbMF0ub2Zmc2V0TGVmdCAtIHRhcmdldFNsaWRlLndpZHRoKCkpICogLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gdGFyZ2V0U2xpZGVbMF0gPyB0YXJnZXRTbGlkZVswXS5vZmZzZXRMZWZ0ICogLTEgOiAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgKz0gKF8uJGxpc3Qud2lkdGgoKSAtIHRhcmdldFNsaWRlLm91dGVyV2lkdGgoKSkgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldExlZnQ7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldE9wdGlvbiA9IFNsaWNrLnByb3RvdHlwZS5zbGlja0dldE9wdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbikge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICByZXR1cm4gXy5vcHRpb25zW29wdGlvbl07XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldE5hdmlnYWJsZUluZGV4ZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBicmVha1BvaW50ID0gMCxcbiAgICAgICAgICAgIGNvdW50ZXIgPSAwLFxuICAgICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgICAgbWF4O1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtYXggPSBfLnNsaWRlQ291bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1BvaW50ID0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICogLTE7XG4gICAgICAgICAgICBjb3VudGVyID0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICogLTE7XG4gICAgICAgICAgICBtYXggPSBfLnNsaWRlQ291bnQgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGJyZWFrUG9pbnQgPCBtYXgpIHtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaChicmVha1BvaW50KTtcbiAgICAgICAgICAgIGJyZWFrUG9pbnQgPSBjb3VudGVyICsgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICAgICAgICAgICAgY291bnRlciArPSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA6IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXhlcztcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0U2xpY2sgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0U2xpZGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHNsaWRlc1RyYXZlcnNlZCwgc3dpcGVkU2xpZGUsIGNlbnRlck9mZnNldDtcblxuICAgICAgICBjZW50ZXJPZmZzZXQgPSBfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSA/IF8uc2xpZGVXaWR0aCAqIE1hdGguZmxvb3IoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIpIDogMDtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnN3aXBlVG9TbGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5maW5kKCcuc2xpY2stc2xpZGUnKS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBzbGlkZSkge1xuICAgICAgICAgICAgICAgIGlmIChzbGlkZS5vZmZzZXRMZWZ0IC0gY2VudGVyT2Zmc2V0ICsgKCQoc2xpZGUpLm91dGVyV2lkdGgoKSAvIDIpID4gKF8uc3dpcGVMZWZ0ICogLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXBlZFNsaWRlID0gc2xpZGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2xpZGVzVHJhdmVyc2VkID0gTWF0aC5hYnMoJChzd2lwZWRTbGlkZSkuYXR0cignZGF0YS1zbGljay1pbmRleCcpIC0gXy5jdXJyZW50U2xpZGUpIHx8IDE7XG5cbiAgICAgICAgICAgIHJldHVybiBzbGlkZXNUcmF2ZXJzZWQ7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ29UbyA9IFNsaWNrLnByb3RvdHlwZS5zbGlja0dvVG8gPSBmdW5jdGlvbihzbGlkZSwgZG9udEFuaW1hdGUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2luZGV4JyxcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyc2VJbnQoc2xpZGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGRvbnRBbmltYXRlKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGNyZWF0aW9uKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICghJChfLiRzbGlkZXIpLmhhc0NsYXNzKCdzbGljay1pbml0aWFsaXplZCcpKSB7XG5cbiAgICAgICAgICAgICQoXy4kc2xpZGVyKS5hZGRDbGFzcygnc2xpY2staW5pdGlhbGl6ZWQnKTtcblxuICAgICAgICAgICAgXy5idWlsZFJvd3MoKTtcbiAgICAgICAgICAgIF8uYnVpbGRPdXQoKTtcbiAgICAgICAgICAgIF8uc2V0UHJvcHMoKTtcbiAgICAgICAgICAgIF8uc3RhcnRMb2FkKCk7XG4gICAgICAgICAgICBfLmxvYWRTbGlkZXIoKTtcbiAgICAgICAgICAgIF8uaW5pdGlhbGl6ZUV2ZW50cygpO1xuICAgICAgICAgICAgXy51cGRhdGVBcnJvd3MoKTtcbiAgICAgICAgICAgIF8udXBkYXRlRG90cygpO1xuICAgICAgICAgICAgXy5jaGVja1Jlc3BvbnNpdmUodHJ1ZSk7XG4gICAgICAgICAgICBfLmZvY3VzSGFuZGxlcigpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3JlYXRpb24pIHtcbiAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdpbml0JywgW19dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5pbml0QURBKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5hdXRvcGxheSApIHtcblxuICAgICAgICAgICAgXy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIF8uYXV0b1BsYXkoKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXRBREEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuICAgICAgICBfLiRzbGlkZXMuYWRkKF8uJHNsaWRlVHJhY2suZmluZCgnLnNsaWNrLWNsb25lZCcpKS5hdHRyKHtcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcbiAgICAgICAgICAgICd0YWJpbmRleCc6ICctMSdcbiAgICAgICAgfSkuZmluZCgnYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0JykuYXR0cih7XG4gICAgICAgICAgICAndGFiaW5kZXgnOiAnLTEnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suYXR0cigncm9sZScsICdsaXN0Ym94Jyk7XG5cbiAgICAgICAgXy4kc2xpZGVzLm5vdChfLiRzbGlkZVRyYWNrLmZpbmQoJy5zbGljay1jbG9uZWQnKSkuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmF0dHIoe1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ29wdGlvbicsXG4gICAgICAgICAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiAnc2xpY2stc2xpZGUnICsgXy5pbnN0YW5jZVVpZCArIGkgKyAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfLiRkb3RzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfLiRkb3RzLmF0dHIoJ3JvbGUnLCAndGFibGlzdCcpLmZpbmQoJ2xpJykuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiAnZmFsc2UnLFxuICAgICAgICAgICAgICAgICAgICAnYXJpYS1jb250cm9scyc6ICduYXZpZ2F0aW9uJyArIF8uaW5zdGFuY2VVaWQgKyBpICsgJycsXG4gICAgICAgICAgICAgICAgICAgICdpZCc6ICdzbGljay1zbGlkZScgKyBfLmluc3RhbmNlVWlkICsgaSArICcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maXJzdCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpLmVuZCgpXG4gICAgICAgICAgICAgICAgLmZpbmQoJ2J1dHRvbicpLmF0dHIoJ3JvbGUnLCAnYnV0dG9uJykuZW5kKClcbiAgICAgICAgICAgICAgICAuY2xvc2VzdCgnZGl2JykuYXR0cigncm9sZScsICd0b29sYmFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgXy5hY3RpdmF0ZUFEQSgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0QXJyb3dFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hcnJvd3MgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgXy4kcHJldkFycm93XG4gICAgICAgICAgICAgICAub2ZmKCdjbGljay5zbGljaycpXG4gICAgICAgICAgICAgICAub24oJ2NsaWNrLnNsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAncHJldmlvdXMnXG4gICAgICAgICAgICAgICB9LCBfLmNoYW5nZVNsaWRlKTtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvd1xuICAgICAgICAgICAgICAgLm9mZignY2xpY2suc2xpY2snKVxuICAgICAgICAgICAgICAgLm9uKCdjbGljay5zbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ25leHQnXG4gICAgICAgICAgICAgICB9LCBfLmNoYW5nZVNsaWRlKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0RG90RXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZG90cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAkKCdsaScsIF8uJGRvdHMpLm9uKCdjbGljay5zbGljaycsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW5kZXgnXG4gICAgICAgICAgICB9LCBfLmNoYW5nZVNsaWRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmRvdHMgPT09IHRydWUgJiYgXy5vcHRpb25zLnBhdXNlT25Eb3RzSG92ZXIgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICQoJ2xpJywgXy4kZG90cylcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlZW50ZXIuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCB0cnVlKSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbGVhdmUuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCBmYWxzZSkpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdFNsaWRlRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICggXy5vcHRpb25zLnBhdXNlT25Ib3ZlciApIHtcblxuICAgICAgICAgICAgXy4kbGlzdC5vbignbW91c2VlbnRlci5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIHRydWUpKTtcbiAgICAgICAgICAgIF8uJGxpc3Qub24oJ21vdXNlbGVhdmUuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCBmYWxzZSkpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdGlhbGl6ZUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmluaXRBcnJvd0V2ZW50cygpO1xuXG4gICAgICAgIF8uaW5pdERvdEV2ZW50cygpO1xuICAgICAgICBfLmluaXRTbGlkZUV2ZW50cygpO1xuXG4gICAgICAgIF8uJGxpc3Qub24oJ3RvdWNoc3RhcnQuc2xpY2sgbW91c2Vkb3duLnNsaWNrJywge1xuICAgICAgICAgICAgYWN0aW9uOiAnc3RhcnQnXG4gICAgICAgIH0sIF8uc3dpcGVIYW5kbGVyKTtcbiAgICAgICAgXy4kbGlzdC5vbigndG91Y2htb3ZlLnNsaWNrIG1vdXNlbW92ZS5zbGljaycsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ21vdmUnXG4gICAgICAgIH0sIF8uc3dpcGVIYW5kbGVyKTtcbiAgICAgICAgXy4kbGlzdC5vbigndG91Y2hlbmQuc2xpY2sgbW91c2V1cC5zbGljaycsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2VuZCdcbiAgICAgICAgfSwgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9uKCd0b3VjaGNhbmNlbC5zbGljayBtb3VzZWxlYXZlLnNsaWNrJywge1xuICAgICAgICAgICAgYWN0aW9uOiAnZW5kJ1xuICAgICAgICB9LCBfLnN3aXBlSGFuZGxlcik7XG5cbiAgICAgICAgXy4kbGlzdC5vbignY2xpY2suc2xpY2snLCBfLmNsaWNrSGFuZGxlcik7XG5cbiAgICAgICAgJChkb2N1bWVudCkub24oXy52aXNpYmlsaXR5Q2hhbmdlLCAkLnByb3h5KF8udmlzaWJpbGl0eSwgXykpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy4kbGlzdC5vbigna2V5ZG93bi5zbGljaycsIF8ua2V5SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZvY3VzT25TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICQoXy4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vbignY2xpY2suc2xpY2snLCBfLnNlbGVjdEhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh3aW5kb3cpLm9uKCdvcmllbnRhdGlvbmNoYW5nZS5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgJC5wcm94eShfLm9yaWVudGF0aW9uQ2hhbmdlLCBfKSk7XG5cbiAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsICQucHJveHkoXy5yZXNpemUsIF8pKTtcblxuICAgICAgICAkKCdbZHJhZ2dhYmxlIT10cnVlXScsIF8uJHNsaWRlVHJhY2spLm9uKCdkcmFnc3RhcnQnLCBfLnByZXZlbnREZWZhdWx0KTtcblxuICAgICAgICAkKHdpbmRvdykub24oJ2xvYWQuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsIF8uc2V0UG9zaXRpb24pO1xuICAgICAgICAkKGRvY3VtZW50KS5vbigncmVhZHkuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsIF8uc2V0UG9zaXRpb24pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0VUkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hcnJvd3MgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cuc2hvdygpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93LnNob3coKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgXy4kZG90cy5zaG93KCk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5rZXlIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG4gICAgICAgICAvL0RvbnQgc2xpZGUgaWYgdGhlIGN1cnNvciBpcyBpbnNpZGUgdGhlIGZvcm0gZmllbGRzIGFuZCBhcnJvdyBrZXlzIGFyZSBwcmVzc2VkXG4gICAgICAgIGlmKCFldmVudC50YXJnZXQudGFnTmFtZS5tYXRjaCgnVEVYVEFSRUF8SU5QVVR8U0VMRUNUJykpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAzNyAmJiBfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uY2hhbmdlU2xpZGUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBfLm9wdGlvbnMucnRsID09PSB0cnVlID8gJ25leHQnIDogICdwcmV2aW91cydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAzOSAmJiBfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uY2hhbmdlU2xpZGUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBfLm9wdGlvbnMucnRsID09PSB0cnVlID8gJ3ByZXZpb3VzJyA6ICduZXh0J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUubGF6eUxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBsb2FkUmFuZ2UsIGNsb25lUmFuZ2UsIHJhbmdlU3RhcnQsIHJhbmdlRW5kO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoaW1hZ2VzU2NvcGUpIHtcblxuICAgICAgICAgICAgJCgnaW1nW2RhdGEtbGF6eV0nLCBpbWFnZXNTY29wZSkuZWFjaChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU291cmNlID0gJCh0aGlzKS5hdHRyKCdkYXRhLWxhenknKSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VUb0xvYWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgICAgICAgICAgICAgIGltYWdlVG9Mb2FkLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAuYW5pbWF0ZSh7IG9wYWNpdHk6IDAgfSwgMTAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3JjJywgaW1hZ2VTb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hbmltYXRlKHsgb3BhY2l0eTogMSB9LCAyMDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1sYXp5JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLWxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2xhenlMb2FkZWQnLCBbXywgaW1hZ2UsIGltYWdlU291cmNlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpbWFnZVRvTG9hZC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCAnZGF0YS1sYXp5JyApXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoICdzbGljay1sb2FkaW5nJyApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoICdzbGljay1sYXp5bG9hZC1lcnJvcicgKTtcblxuICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignbGF6eUxvYWRFcnJvcicsIFsgXywgaW1hZ2UsIGltYWdlU291cmNlIF0pO1xuXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGltYWdlVG9Mb2FkLnNyYyA9IGltYWdlU291cmNlO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VTdGFydCA9IF8uY3VycmVudFNsaWRlICsgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyICsgMSk7XG4gICAgICAgICAgICAgICAgcmFuZ2VFbmQgPSByYW5nZVN0YXJ0ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBNYXRoLm1heCgwLCBfLmN1cnJlbnRTbGlkZSAtIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMiArIDEpKTtcbiAgICAgICAgICAgICAgICByYW5nZUVuZCA9IDIgKyAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIgKyAxKSArIF8uY3VycmVudFNsaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2VTdGFydCA9IF8ub3B0aW9ucy5pbmZpbml0ZSA/IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyBfLmN1cnJlbnRTbGlkZSA6IF8uY3VycmVudFNsaWRlO1xuICAgICAgICAgICAgcmFuZ2VFbmQgPSBNYXRoLmNlaWwocmFuZ2VTdGFydCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpO1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlU3RhcnQgPiAwKSByYW5nZVN0YXJ0LS07XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlRW5kIDw9IF8uc2xpZGVDb3VudCkgcmFuZ2VFbmQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWRSYW5nZSA9IF8uJHNsaWRlci5maW5kKCcuc2xpY2stc2xpZGUnKS5zbGljZShyYW5nZVN0YXJ0LCByYW5nZUVuZCk7XG4gICAgICAgIGxvYWRJbWFnZXMobG9hZFJhbmdlKTtcblxuICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIGNsb25lUmFuZ2UgPSBfLiRzbGlkZXIuZmluZCgnLnNsaWNrLXNsaWRlJyk7XG4gICAgICAgICAgICBsb2FkSW1hZ2VzKGNsb25lUmFuZ2UpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgaWYgKF8uY3VycmVudFNsaWRlID49IF8uc2xpZGVDb3VudCAtIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIGNsb25lUmFuZ2UgPSBfLiRzbGlkZXIuZmluZCgnLnNsaWNrLWNsb25lZCcpLnNsaWNlKDAsIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpO1xuICAgICAgICAgICAgbG9hZEltYWdlcyhjbG9uZVJhbmdlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmN1cnJlbnRTbGlkZSA9PT0gMCkge1xuICAgICAgICAgICAgY2xvbmVSYW5nZSA9IF8uJHNsaWRlci5maW5kKCcuc2xpY2stY2xvbmVkJykuc2xpY2UoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAqIC0xKTtcbiAgICAgICAgICAgIGxvYWRJbWFnZXMoY2xvbmVSYW5nZSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUubG9hZFNsaWRlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLnNldFBvc2l0aW9uKCk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5jc3Moe1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9KTtcblxuICAgICAgICBfLiRzbGlkZXIucmVtb3ZlQ2xhc3MoJ3NsaWNrLWxvYWRpbmcnKTtcblxuICAgICAgICBfLmluaXRVSSgpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMubGF6eUxvYWQgPT09ICdwcm9ncmVzc2l2ZScpIHtcbiAgICAgICAgICAgIF8ucHJvZ3Jlc3NpdmVMYXp5TG9hZCgpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLm5leHQgPSBTbGljay5wcm90b3R5cGUuc2xpY2tOZXh0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uY2hhbmdlU2xpZGUoe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICduZXh0J1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUub3JpZW50YXRpb25DaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5jaGVja1Jlc3BvbnNpdmUoKTtcbiAgICAgICAgXy5zZXRQb3NpdGlvbigpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5wYXVzZSA9IFNsaWNrLnByb3RvdHlwZS5zbGlja1BhdXNlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uYXV0b1BsYXlDbGVhcigpO1xuICAgICAgICBfLnBhdXNlZCA9IHRydWU7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnBsYXkgPSBTbGljay5wcm90b3R5cGUuc2xpY2tQbGF5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uYXV0b1BsYXkoKTtcbiAgICAgICAgXy5vcHRpb25zLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgXy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgXy5mb2N1c3NlZCA9IGZhbHNlO1xuICAgICAgICBfLmludGVycnVwdGVkID0gZmFsc2U7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnBvc3RTbGlkZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmKCAhXy51bnNsaWNrZWQgKSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdhZnRlckNoYW5nZScsIFtfLCBpbmRleF0pO1xuXG4gICAgICAgICAgICBfLmFuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBfLnNldFBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgIF8uc3dpcGVMZWZ0ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCBfLm9wdGlvbnMuYXV0b3BsYXkgKSB7XG4gICAgICAgICAgICAgICAgXy5hdXRvUGxheSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLmluaXRBREEoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnByZXYgPSBTbGljay5wcm90b3R5cGUuc2xpY2tQcmV2ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uY2hhbmdlU2xpZGUoe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdwcmV2aW91cydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5wcm9ncmVzc2l2ZUxhenlMb2FkID0gZnVuY3Rpb24oIHRyeUNvdW50ICkge1xuXG4gICAgICAgIHRyeUNvdW50ID0gdHJ5Q291bnQgfHwgMTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICAkaW1nc1RvTG9hZCA9ICQoICdpbWdbZGF0YS1sYXp5XScsIF8uJHNsaWRlciApLFxuICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICBpbWFnZVNvdXJjZSxcbiAgICAgICAgICAgIGltYWdlVG9Mb2FkO1xuXG4gICAgICAgIGlmICggJGltZ3NUb0xvYWQubGVuZ3RoICkge1xuXG4gICAgICAgICAgICBpbWFnZSA9ICRpbWdzVG9Mb2FkLmZpcnN0KCk7XG4gICAgICAgICAgICBpbWFnZVNvdXJjZSA9IGltYWdlLmF0dHIoJ2RhdGEtbGF6eScpO1xuICAgICAgICAgICAgaW1hZ2VUb0xvYWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgICAgICAgICAgaW1hZ2VUb0xvYWQub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAuYXR0ciggJ3NyYycsIGltYWdlU291cmNlIClcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtbGF6eScpXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stbG9hZGluZycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBfLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQgPT09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uc2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignbGF6eUxvYWRlZCcsIFsgXywgaW1hZ2UsIGltYWdlU291cmNlIF0pO1xuICAgICAgICAgICAgICAgIF8ucHJvZ3Jlc3NpdmVMYXp5TG9hZCgpO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpbWFnZVRvTG9hZC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRyeUNvdW50IDwgMyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogdHJ5IHRvIGxvYWQgdGhlIGltYWdlIDMgdGltZXMsXG4gICAgICAgICAgICAgICAgICAgICAqIGxlYXZlIGEgc2xpZ2h0IGRlbGF5IHNvIHdlIGRvbid0IGdldFxuICAgICAgICAgICAgICAgICAgICAgKiBzZXJ2ZXJzIGJsb2NraW5nIHRoZSByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnByb2dyZXNzaXZlTGF6eUxvYWQoIHRyeUNvdW50ICsgMSApO1xuICAgICAgICAgICAgICAgICAgICB9LCA1MDAgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCAnZGF0YS1sYXp5JyApXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoICdzbGljay1sb2FkaW5nJyApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoICdzbGljay1sYXp5bG9hZC1lcnJvcicgKTtcblxuICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignbGF6eUxvYWRFcnJvcicsIFsgXywgaW1hZ2UsIGltYWdlU291cmNlIF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIF8ucHJvZ3Jlc3NpdmVMYXp5TG9hZCgpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpbWFnZVRvTG9hZC5zcmMgPSBpbWFnZVNvdXJjZTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignYWxsSW1hZ2VzTG9hZGVkJywgWyBfIF0pO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCBpbml0aWFsaXppbmcgKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLCBjdXJyZW50U2xpZGUsIGxhc3RWaXNpYmxlSW5kZXg7XG5cbiAgICAgICAgbGFzdFZpc2libGVJbmRleCA9IF8uc2xpZGVDb3VudCAtIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG5cbiAgICAgICAgLy8gaW4gbm9uLWluZmluaXRlIHNsaWRlcnMsIHdlIGRvbid0IHdhbnQgdG8gZ28gcGFzdCB0aGVcbiAgICAgICAgLy8gbGFzdCB2aXNpYmxlIGluZGV4LlxuICAgICAgICBpZiggIV8ub3B0aW9ucy5pbmZpbml0ZSAmJiAoIF8uY3VycmVudFNsaWRlID4gbGFzdFZpc2libGVJbmRleCApKSB7XG4gICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IGxhc3RWaXNpYmxlSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBsZXNzIHNsaWRlcyB0aGFuIHRvIHNob3csIGdvIHRvIHN0YXJ0LlxuICAgICAgICBpZiAoIF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICkge1xuICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSAwO1xuXG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50U2xpZGUgPSBfLmN1cnJlbnRTbGlkZTtcblxuICAgICAgICBfLmRlc3Ryb3kodHJ1ZSk7XG5cbiAgICAgICAgJC5leHRlbmQoXywgXy5pbml0aWFscywgeyBjdXJyZW50U2xpZGU6IGN1cnJlbnRTbGlkZSB9KTtcblxuICAgICAgICBfLmluaXQoKTtcblxuICAgICAgICBpZiggIWluaXRpYWxpemluZyApIHtcblxuICAgICAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogY3VycmVudFNsaWRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucmVnaXN0ZXJCcmVha3BvaW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcywgYnJlYWtwb2ludCwgY3VycmVudEJyZWFrcG9pbnQsIGwsXG4gICAgICAgICAgICByZXNwb25zaXZlU2V0dGluZ3MgPSBfLm9wdGlvbnMucmVzcG9uc2l2ZSB8fCBudWxsO1xuXG4gICAgICAgIGlmICggJC50eXBlKHJlc3BvbnNpdmVTZXR0aW5ncykgPT09ICdhcnJheScgJiYgcmVzcG9uc2l2ZVNldHRpbmdzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgXy5yZXNwb25kVG8gPSBfLm9wdGlvbnMucmVzcG9uZFRvIHx8ICd3aW5kb3cnO1xuXG4gICAgICAgICAgICBmb3IgKCBicmVha3BvaW50IGluIHJlc3BvbnNpdmVTZXR0aW5ncyApIHtcblxuICAgICAgICAgICAgICAgIGwgPSBfLmJyZWFrcG9pbnRzLmxlbmd0aC0xO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCcmVha3BvaW50ID0gcmVzcG9uc2l2ZVNldHRpbmdzW2JyZWFrcG9pbnRdLmJyZWFrcG9pbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2l2ZVNldHRpbmdzLmhhc093blByb3BlcnR5KGJyZWFrcG9pbnQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBicmVha3BvaW50cyBhbmQgY3V0IG91dCBhbnkgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gb25lcyB3aXRoIHRoZSBzYW1lIGJyZWFrcG9pbnQgbnVtYmVyLCB3ZSBkb24ndCB3YW50IGR1cGVzLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSggbCA+PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF8uYnJlYWtwb2ludHNbbF0gJiYgXy5icmVha3BvaW50c1tsXSA9PT0gY3VycmVudEJyZWFrcG9pbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5icmVha3BvaW50cy5zcGxpY2UobCwxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGwtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF8uYnJlYWtwb2ludHMucHVzaChjdXJyZW50QnJlYWtwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIF8uYnJlYWtwb2ludFNldHRpbmdzW2N1cnJlbnRCcmVha3BvaW50XSA9IHJlc3BvbnNpdmVTZXR0aW5nc1ticmVha3BvaW50XS5zZXR0aW5ncztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLmJyZWFrcG9pbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIF8ub3B0aW9ucy5tb2JpbGVGaXJzdCApID8gYS1iIDogYi1hO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5yZWluaXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy4kc2xpZGVzID1cbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2tcbiAgICAgICAgICAgICAgICAuY2hpbGRyZW4oXy5vcHRpb25zLnNsaWRlKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stc2xpZGUnKTtcblxuICAgICAgICBfLnNsaWRlQ291bnQgPSBfLiRzbGlkZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChfLmN1cnJlbnRTbGlkZSA+PSBfLnNsaWRlQ291bnQgJiYgXy5jdXJyZW50U2xpZGUgIT09IDApIHtcbiAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gXy5jdXJyZW50U2xpZGUgLSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIF8ucmVnaXN0ZXJCcmVha3BvaW50cygpO1xuXG4gICAgICAgIF8uc2V0UHJvcHMoKTtcbiAgICAgICAgXy5zZXR1cEluZmluaXRlKCk7XG4gICAgICAgIF8uYnVpbGRBcnJvd3MoKTtcbiAgICAgICAgXy51cGRhdGVBcnJvd3MoKTtcbiAgICAgICAgXy5pbml0QXJyb3dFdmVudHMoKTtcbiAgICAgICAgXy5idWlsZERvdHMoKTtcbiAgICAgICAgXy51cGRhdGVEb3RzKCk7XG4gICAgICAgIF8uaW5pdERvdEV2ZW50cygpO1xuICAgICAgICBfLmNsZWFuVXBTbGlkZUV2ZW50cygpO1xuICAgICAgICBfLmluaXRTbGlkZUV2ZW50cygpO1xuXG4gICAgICAgIF8uY2hlY2tSZXNwb25zaXZlKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZvY3VzT25TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICQoXy4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vbignY2xpY2suc2xpY2snLCBfLnNlbGVjdEhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5zZXRTbGlkZUNsYXNzZXModHlwZW9mIF8uY3VycmVudFNsaWRlID09PSAnbnVtYmVyJyA/IF8uY3VycmVudFNsaWRlIDogMCk7XG5cbiAgICAgICAgXy5zZXRQb3NpdGlvbigpO1xuICAgICAgICBfLmZvY3VzSGFuZGxlcigpO1xuXG4gICAgICAgIF8ucGF1c2VkID0gIV8ub3B0aW9ucy5hdXRvcGxheTtcbiAgICAgICAgXy5hdXRvUGxheSgpO1xuXG4gICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdyZUluaXQnLCBbX10pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCQod2luZG93KS53aWR0aCgpICE9PSBfLndpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoXy53aW5kb3dEZWxheSk7XG4gICAgICAgICAgICBfLndpbmRvd0RlbGF5ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgXy53aW5kb3dXaWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xuICAgICAgICAgICAgICAgIF8uY2hlY2tSZXNwb25zaXZlKCk7XG4gICAgICAgICAgICAgICAgaWYoICFfLnVuc2xpY2tlZCApIHsgXy5zZXRQb3NpdGlvbigpOyB9XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnJlbW92ZVNsaWRlID0gU2xpY2sucHJvdG90eXBlLnNsaWNrUmVtb3ZlID0gZnVuY3Rpb24oaW5kZXgsIHJlbW92ZUJlZm9yZSwgcmVtb3ZlQWxsKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICh0eXBlb2YoaW5kZXgpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJlbW92ZUJlZm9yZSA9IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSByZW1vdmVCZWZvcmUgPT09IHRydWUgPyAwIDogXy5zbGlkZUNvdW50IC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gcmVtb3ZlQmVmb3JlID09PSB0cnVlID8gLS1pbmRleCA6IGluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8IDEgfHwgaW5kZXggPCAwIHx8IGluZGV4ID4gXy5zbGlkZUNvdW50IC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgXy51bmxvYWQoKTtcblxuICAgICAgICBpZiAocmVtb3ZlQWxsID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCkucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZXEoaW5kZXgpLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy4kc2xpZGVzID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKTtcblxuICAgICAgICBfLiRzbGlkZVRyYWNrLmFwcGVuZChfLiRzbGlkZXMpO1xuXG4gICAgICAgIF8uJHNsaWRlc0NhY2hlID0gXy4kc2xpZGVzO1xuXG4gICAgICAgIF8ucmVpbml0KCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldENTUyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgcG9zaXRpb25Qcm9wcyA9IHt9LFxuICAgICAgICAgICAgeCwgeTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSAtcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgeCA9IF8ucG9zaXRpb25Qcm9wID09ICdsZWZ0JyA/IE1hdGguY2VpbChwb3NpdGlvbikgKyAncHgnIDogJzBweCc7XG4gICAgICAgIHkgPSBfLnBvc2l0aW9uUHJvcCA9PSAndG9wJyA/IE1hdGguY2VpbChwb3NpdGlvbikgKyAncHgnIDogJzBweCc7XG5cbiAgICAgICAgcG9zaXRpb25Qcm9wc1tfLnBvc2l0aW9uUHJvcF0gPSBwb3NpdGlvbjtcblxuICAgICAgICBpZiAoXy50cmFuc2Zvcm1zRW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKHBvc2l0aW9uUHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb25Qcm9wcyA9IHt9O1xuICAgICAgICAgICAgaWYgKF8uY3NzVHJhbnNpdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUoJyArIHggKyAnLCAnICsgeSArICcpJztcbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyhwb3NpdGlvblByb3BzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUzZCgnICsgeCArICcsICcgKyB5ICsgJywgMHB4KSc7XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MocG9zaXRpb25Qcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy4kbGlzdC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAoJzBweCAnICsgXy5vcHRpb25zLmNlbnRlclBhZGRpbmcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLiRsaXN0LmhlaWdodChfLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCh0cnVlKSAqIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpO1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy4kbGlzdC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAoXy5vcHRpb25zLmNlbnRlclBhZGRpbmcgKyAnIDBweCcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfLmxpc3RXaWR0aCA9IF8uJGxpc3Qud2lkdGgoKTtcbiAgICAgICAgXy5saXN0SGVpZ2h0ID0gXy4kbGlzdC5oZWlnaHQoKTtcblxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlICYmIF8ub3B0aW9ucy52YXJpYWJsZVdpZHRoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy5zbGlkZVdpZHRoID0gTWF0aC5jZWlsKF8ubGlzdFdpZHRoIC8gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyk7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLndpZHRoKE1hdGguY2VpbCgoXy5zbGlkZVdpZHRoICogXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykubGVuZ3RoKSkpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoXy5vcHRpb25zLnZhcmlhYmxlV2lkdGggPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2sud2lkdGgoNTAwMCAqIF8uc2xpZGVDb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLnNsaWRlV2lkdGggPSBNYXRoLmNlaWwoXy5saXN0V2lkdGgpO1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5oZWlnaHQoTWF0aC5jZWlsKChfLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCh0cnVlKSAqIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLmxlbmd0aCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXQgPSBfLiRzbGlkZXMuZmlyc3QoKS5vdXRlcldpZHRoKHRydWUpIC0gXy4kc2xpZGVzLmZpcnN0KCkud2lkdGgoKTtcbiAgICAgICAgaWYgKF8ub3B0aW9ucy52YXJpYWJsZVdpZHRoID09PSBmYWxzZSkgXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykud2lkdGgoXy5zbGlkZVdpZHRoIC0gb2Zmc2V0KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0RmFkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHRhcmdldExlZnQ7XG5cbiAgICAgICAgXy4kc2xpZGVzLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRhcmdldExlZnQgPSAoXy5zbGlkZVdpZHRoICogaW5kZXgpICogLTE7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICQoZWxlbWVudCkuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0YXJnZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleCAtIDIsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdGFyZ2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXggLSAyLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uJHNsaWRlcy5lcShfLmN1cnJlbnRTbGlkZSkuY3NzKHtcbiAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleCAtIDEsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPT09IDEgJiYgXy5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0ID09PSB0cnVlICYmIF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRIZWlnaHQgPSBfLiRzbGlkZXMuZXEoXy5jdXJyZW50U2xpZGUpLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgICAgXy4kbGlzdC5jc3MoJ2hlaWdodCcsIHRhcmdldEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0T3B0aW9uID1cbiAgICBTbGljay5wcm90b3R5cGUuc2xpY2tTZXRPcHRpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWNjZXB0cyBhcmd1bWVudHMgaW4gZm9ybWF0IG9mOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBmb3IgY2hhbmdpbmcgYSBzaW5nbGUgb3B0aW9uJ3MgdmFsdWU6XG4gICAgICAgICAqICAgICAuc2xpY2soXCJzZXRPcHRpb25cIiwgb3B0aW9uLCB2YWx1ZSwgcmVmcmVzaCApXG4gICAgICAgICAqXG4gICAgICAgICAqICAtIGZvciBjaGFuZ2luZyBhIHNldCBvZiByZXNwb25zaXZlIG9wdGlvbnM6XG4gICAgICAgICAqICAgICAuc2xpY2soXCJzZXRPcHRpb25cIiwgJ3Jlc3BvbnNpdmUnLCBbe30sIC4uLl0sIHJlZnJlc2ggKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBmb3IgdXBkYXRpbmcgbXVsdGlwbGUgdmFsdWVzIGF0IG9uY2UgKG5vdCByZXNwb25zaXZlKVxuICAgICAgICAgKiAgICAgLnNsaWNrKFwic2V0T3B0aW9uXCIsIHsgJ29wdGlvbic6IHZhbHVlLCAuLi4gfSwgcmVmcmVzaCApXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBfID0gdGhpcywgbCwgaXRlbSwgb3B0aW9uLCB2YWx1ZSwgcmVmcmVzaCA9IGZhbHNlLCB0eXBlO1xuXG4gICAgICAgIGlmKCAkLnR5cGUoIGFyZ3VtZW50c1swXSApID09PSAnb2JqZWN0JyApIHtcblxuICAgICAgICAgICAgb3B0aW9uID0gIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHJlZnJlc2ggPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0eXBlID0gJ211bHRpcGxlJztcblxuICAgICAgICB9IGVsc2UgaWYgKCAkLnR5cGUoIGFyZ3VtZW50c1swXSApID09PSAnc3RyaW5nJyApIHtcblxuICAgICAgICAgICAgb3B0aW9uID0gIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgcmVmcmVzaCA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgICAgICAgaWYgKCBhcmd1bWVudHNbMF0gPT09ICdyZXNwb25zaXZlJyAmJiAkLnR5cGUoIGFyZ3VtZW50c1sxXSApID09PSAnYXJyYXknICkge1xuXG4gICAgICAgICAgICAgICAgdHlwZSA9ICdyZXNwb25zaXZlJztcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cbiAgICAgICAgICAgICAgICB0eXBlID0gJ3NpbmdsZSc7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0eXBlID09PSAnc2luZ2xlJyApIHtcblxuICAgICAgICAgICAgXy5vcHRpb25zW29wdGlvbl0gPSB2YWx1ZTtcblxuXG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09ICdtdWx0aXBsZScgKSB7XG5cbiAgICAgICAgICAgICQuZWFjaCggb3B0aW9uICwgZnVuY3Rpb24oIG9wdCwgdmFsICkge1xuXG4gICAgICAgICAgICAgICAgXy5vcHRpb25zW29wdF0gPSB2YWw7XG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gJ3Jlc3BvbnNpdmUnICkge1xuXG4gICAgICAgICAgICBmb3IgKCBpdGVtIGluIHZhbHVlICkge1xuXG4gICAgICAgICAgICAgICAgaWYoICQudHlwZSggXy5vcHRpb25zLnJlc3BvbnNpdmUgKSAhPT0gJ2FycmF5JyApIHtcblxuICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMucmVzcG9uc2l2ZSA9IFsgdmFsdWVbaXRlbV0gXTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbCA9IF8ub3B0aW9ucy5yZXNwb25zaXZlLmxlbmd0aC0xO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgcmVzcG9uc2l2ZSBvYmplY3QgYW5kIHNwbGljZSBvdXQgZHVwbGljYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoIGwgPj0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF8ub3B0aW9ucy5yZXNwb25zaXZlW2xdLmJyZWFrcG9pbnQgPT09IHZhbHVlW2l0ZW1dLmJyZWFrcG9pbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMucmVzcG9uc2l2ZS5zcGxpY2UobCwxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsLS07XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy5yZXNwb25zaXZlLnB1c2goIHZhbHVlW2l0ZW1dICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByZWZyZXNoICkge1xuXG4gICAgICAgICAgICBfLnVubG9hZCgpO1xuICAgICAgICAgICAgXy5yZWluaXQoKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uc2V0RGltZW5zaW9ucygpO1xuXG4gICAgICAgIF8uc2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy5zZXRDU1MoXy5nZXRMZWZ0KF8uY3VycmVudFNsaWRlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLnNldEZhZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdzZXRQb3NpdGlvbicsIFtfXSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldFByb3BzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgYm9keVN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcblxuICAgICAgICBfLnBvc2l0aW9uUHJvcCA9IF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gdHJ1ZSA/ICd0b3AnIDogJ2xlZnQnO1xuXG4gICAgICAgIGlmIChfLnBvc2l0aW9uUHJvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlci5hZGRDbGFzcygnc2xpY2stdmVydGljYWwnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJHNsaWRlci5yZW1vdmVDbGFzcygnc2xpY2stdmVydGljYWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2R5U3R5bGUuV2Via2l0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBib2R5U3R5bGUuTW96VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBib2R5U3R5bGUubXNUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMudXNlQ1NTID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy5jc3NUcmFuc2l0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5mYWRlICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlb2YgXy5vcHRpb25zLnpJbmRleCA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgICAgaWYoIF8ub3B0aW9ucy56SW5kZXggPCAzICkge1xuICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMuekluZGV4ID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8ub3B0aW9ucy56SW5kZXggPSBfLmRlZmF1bHRzLnpJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2R5U3R5bGUuT1RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfLmFuaW1UeXBlID0gJ09UcmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gJy1vLXRyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gJ09UcmFuc2l0aW9uJztcbiAgICAgICAgICAgIGlmIChib2R5U3R5bGUucGVyc3BlY3RpdmVQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkICYmIGJvZHlTdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9PT0gdW5kZWZpbmVkKSBfLmFuaW1UeXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHlTdHlsZS5Nb3pUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9ICdNb3pUcmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gJy1tb3otdHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNpdGlvblR5cGUgPSAnTW96VHJhbnNpdGlvbic7XG4gICAgICAgICAgICBpZiAoYm9keVN0eWxlLnBlcnNwZWN0aXZlUHJvcGVydHkgPT09IHVuZGVmaW5lZCAmJiBib2R5U3R5bGUuTW96UGVyc3BlY3RpdmUgPT09IHVuZGVmaW5lZCkgXy5hbmltVHlwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5U3R5bGUud2Via2l0VHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF8uYW5pbVR5cGUgPSAnd2Via2l0VHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNmb3JtVHlwZSA9ICctd2Via2l0LXRyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gJ3dlYmtpdFRyYW5zaXRpb24nO1xuICAgICAgICAgICAgaWYgKGJvZHlTdHlsZS5wZXJzcGVjdGl2ZVByb3BlcnR5ID09PSB1bmRlZmluZWQgJiYgYm9keVN0eWxlLndlYmtpdFBlcnNwZWN0aXZlID09PSB1bmRlZmluZWQpIF8uYW5pbVR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keVN0eWxlLm1zVHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF8uYW5pbVR5cGUgPSAnbXNUcmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gJy1tcy10cmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2l0aW9uVHlwZSA9ICdtc1RyYW5zaXRpb24nO1xuICAgICAgICAgICAgaWYgKGJvZHlTdHlsZS5tc1RyYW5zZm9ybSA9PT0gdW5kZWZpbmVkKSBfLmFuaW1UeXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHlTdHlsZS50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCAmJiBfLmFuaW1UeXBlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9ICd0cmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gJ3RyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gJ3RyYW5zaXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIF8udHJhbnNmb3Jtc0VuYWJsZWQgPSBfLm9wdGlvbnMudXNlVHJhbnNmb3JtICYmIChfLmFuaW1UeXBlICE9PSBudWxsICYmIF8uYW5pbVR5cGUgIT09IGZhbHNlKTtcbiAgICB9O1xuXG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0U2xpZGVDbGFzc2VzID0gZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBjZW50ZXJPZmZzZXQsIGFsbFNsaWRlcywgaW5kZXhPZmZzZXQsIHJlbWFpbmRlcjtcblxuICAgICAgICBhbGxTbGlkZXMgPSBfLiRzbGlkZXJcbiAgICAgICAgICAgIC5maW5kKCcuc2xpY2stc2xpZGUnKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1hY3RpdmUgc2xpY2stY2VudGVyIHNsaWNrLWN1cnJlbnQnKVxuICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgIC5lcShpbmRleClcbiAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stY3VycmVudCcpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBjZW50ZXJPZmZzZXQgPSBNYXRoLmZsb29yKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyKTtcblxuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGNlbnRlck9mZnNldCAmJiBpbmRleCA8PSAoXy5zbGlkZUNvdW50IC0gMSkgLSBjZW50ZXJPZmZzZXQpIHtcblxuICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleCAtIGNlbnRlck9mZnNldCwgaW5kZXggKyBjZW50ZXJPZmZzZXQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4T2Zmc2V0ID0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleE9mZnNldCAtIGNlbnRlck9mZnNldCArIDEsIGluZGV4T2Zmc2V0ICsgY2VudGVyT2Zmc2V0ICsgMilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXEoYWxsU2xpZGVzLmxlbmd0aCAtIDEgLSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1jZW50ZXInKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IF8uc2xpZGVDb3VudCAtIDEpIHtcblxuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcShfLm9wdGlvbnMuc2xpZGVzVG9TaG93KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1jZW50ZXInKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgICAgICAuZXEoaW5kZXgpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1jZW50ZXInKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8PSAoXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykpIHtcblxuICAgICAgICAgICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaW5kZXgsIGluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGxTbGlkZXMubGVuZ3RoIDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgICAgIGFsbFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmVtYWluZGVyID0gXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2hvdztcbiAgICAgICAgICAgICAgICBpbmRleE9mZnNldCA9IF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSA/IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyBpbmRleCA6IGluZGV4O1xuXG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPT0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICYmIChfLnNsaWRlQ291bnQgLSBpbmRleCkgPCBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaW5kZXhPZmZzZXQgLSAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAtIHJlbWFpbmRlciksIGluZGV4T2Zmc2V0ICsgcmVtYWluZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGFsbFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGluZGV4T2Zmc2V0LCBpbmRleE9mZnNldCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmxhenlMb2FkID09PSAnb25kZW1hbmQnKSB7XG4gICAgICAgICAgICBfLmxhenlMb2FkKCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0dXBJbmZpbml0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGksIHNsaWRlSW5kZXgsIGluZmluaXRlQ291bnQ7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLm9wdGlvbnMuY2VudGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgc2xpZGVJbmRleCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5maW5pdGVDb3VudCA9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZmluaXRlQ291bnQgPSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IF8uc2xpZGVDb3VudDsgaSA+IChfLnNsaWRlQ291bnQgLVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5maW5pdGVDb3VudCk7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzbGlkZUluZGV4ID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICQoXy4kc2xpZGVzW3NsaWRlSW5kZXhdKS5jbG9uZSh0cnVlKS5hdHRyKCdpZCcsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2RhdGEtc2xpY2staW5kZXgnLCBzbGlkZUluZGV4IC0gXy5zbGlkZUNvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnByZXBlbmRUbyhfLiRzbGlkZVRyYWNrKS5hZGRDbGFzcygnc2xpY2stY2xvbmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmZpbml0ZUNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICQoXy4kc2xpZGVzW3NsaWRlSW5kZXhdKS5jbG9uZSh0cnVlKS5hdHRyKCdpZCcsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2RhdGEtc2xpY2staW5kZXgnLCBzbGlkZUluZGV4ICsgXy5zbGlkZUNvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKF8uJHNsaWRlVHJhY2spLmFkZENsYXNzKCdzbGljay1jbG9uZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5maW5kKCcuc2xpY2stY2xvbmVkJykuZmluZCgnW2lkXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYXR0cignaWQnLCAnJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmludGVycnVwdCA9IGZ1bmN0aW9uKCB0b2dnbGUgKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmKCAhdG9nZ2xlICkge1xuICAgICAgICAgICAgXy5hdXRvUGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIF8uaW50ZXJydXB0ZWQgPSB0b2dnbGU7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNlbGVjdEhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9XG4gICAgICAgICAgICAkKGV2ZW50LnRhcmdldCkuaXMoJy5zbGljay1zbGlkZScpID9cbiAgICAgICAgICAgICAgICAkKGV2ZW50LnRhcmdldCkgOlxuICAgICAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCcuc2xpY2stc2xpZGUnKTtcblxuICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludCh0YXJnZXRFbGVtZW50LmF0dHIoJ2RhdGEtc2xpY2staW5kZXgnKSk7XG5cbiAgICAgICAgaWYgKCFpbmRleCkgaW5kZXggPSAwO1xuXG4gICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLnNldFNsaWRlQ2xhc3NlcyhpbmRleCk7XG4gICAgICAgICAgICBfLmFzTmF2Rm9yKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgXy5zbGlkZUhhbmRsZXIoaW5kZXgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zbGlkZUhhbmRsZXIgPSBmdW5jdGlvbihpbmRleCwgc3luYywgZG9udEFuaW1hdGUpIHtcblxuICAgICAgICB2YXIgdGFyZ2V0U2xpZGUsIGFuaW1TbGlkZSwgb2xkU2xpZGUsIHNsaWRlTGVmdCwgdGFyZ2V0TGVmdCA9IG51bGwsXG4gICAgICAgICAgICBfID0gdGhpcywgbmF2VGFyZ2V0O1xuXG4gICAgICAgIHN5bmMgPSBzeW5jIHx8IGZhbHNlO1xuXG4gICAgICAgIGlmIChfLmFuaW1hdGluZyA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMud2FpdEZvckFuaW1hdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gdHJ1ZSAmJiBfLmN1cnJlbnRTbGlkZSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLmFzTmF2Rm9yKGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFNsaWRlID0gaW5kZXg7XG4gICAgICAgIHRhcmdldExlZnQgPSBfLmdldExlZnQodGFyZ2V0U2xpZGUpO1xuICAgICAgICBzbGlkZUxlZnQgPSBfLmdldExlZnQoXy5jdXJyZW50U2xpZGUpO1xuXG4gICAgICAgIF8uY3VycmVudExlZnQgPSBfLnN3aXBlTGVmdCA9PT0gbnVsbCA/IHNsaWRlTGVmdCA6IF8uc3dpcGVMZWZ0O1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlICYmIF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSBmYWxzZSAmJiAoaW5kZXggPCAwIHx8IGluZGV4ID4gXy5nZXREb3RDb3VudCgpICogXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSkge1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy5jdXJyZW50U2xpZGU7XG4gICAgICAgICAgICAgICAgaWYgKGRvbnRBbmltYXRlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uYW5pbWF0ZVNsaWRlKHNsaWRlTGVmdCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZSh0YXJnZXRTbGlkZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKHRhcmdldFNsaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSBmYWxzZSAmJiBfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSAmJiAoaW5kZXggPCAwIHx8IGluZGV4ID4gKF8uc2xpZGVDb3VudCAtIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCkpKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2xpZGUgPSBfLmN1cnJlbnRTbGlkZTtcbiAgICAgICAgICAgICAgICBpZiAoZG9udEFuaW1hdGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5hbmltYXRlU2xpZGUoc2xpZGVMZWZ0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKHRhcmdldFNsaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUodGFyZ2V0U2xpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmF1dG9wbGF5ICkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfLmF1dG9QbGF5VGltZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldFNsaWRlIDwgMCkge1xuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGFuaW1TbGlkZSA9IF8uc2xpZGVDb3VudCAtIChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltU2xpZGUgPSBfLnNsaWRlQ291bnQgKyB0YXJnZXRTbGlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRTbGlkZSA+PSBfLnNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgIT09IDApIHtcbiAgICAgICAgICAgICAgICBhbmltU2xpZGUgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltU2xpZGUgPSB0YXJnZXRTbGlkZSAtIF8uc2xpZGVDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuaW1TbGlkZSA9IHRhcmdldFNsaWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5hbmltYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdiZWZvcmVDaGFuZ2UnLCBbXywgXy5jdXJyZW50U2xpZGUsIGFuaW1TbGlkZV0pO1xuXG4gICAgICAgIG9sZFNsaWRlID0gXy5jdXJyZW50U2xpZGU7XG4gICAgICAgIF8uY3VycmVudFNsaWRlID0gYW5pbVNsaWRlO1xuXG4gICAgICAgIF8uc2V0U2xpZGVDbGFzc2VzKF8uY3VycmVudFNsaWRlKTtcblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5hc05hdkZvciApIHtcblxuICAgICAgICAgICAgbmF2VGFyZ2V0ID0gXy5nZXROYXZUYXJnZXQoKTtcbiAgICAgICAgICAgIG5hdlRhcmdldCA9IG5hdlRhcmdldC5zbGljaygnZ2V0U2xpY2snKTtcblxuICAgICAgICAgICAgaWYgKCBuYXZUYXJnZXQuc2xpZGVDb3VudCA8PSBuYXZUYXJnZXQub3B0aW9ucy5zbGlkZXNUb1Nob3cgKSB7XG4gICAgICAgICAgICAgICAgbmF2VGFyZ2V0LnNldFNsaWRlQ2xhc3NlcyhfLmN1cnJlbnRTbGlkZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF8udXBkYXRlRG90cygpO1xuICAgICAgICBfLnVwZGF0ZUFycm93cygpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbnRBbmltYXRlICE9PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBfLmZhZGVTbGlkZU91dChvbGRTbGlkZSk7XG5cbiAgICAgICAgICAgICAgICBfLmZhZGVTbGlkZShhbmltU2xpZGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZShhbmltU2xpZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKGFuaW1TbGlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmFuaW1hdGVIZWlnaHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb250QW5pbWF0ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5hbmltYXRlU2xpZGUodGFyZ2V0TGVmdCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUoYW5pbVNsaWRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy5wb3N0U2xpZGUoYW5pbVNsaWRlKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zdGFydExvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hcnJvd3MgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cuaGlkZSgpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93LmhpZGUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgXy4kZG90cy5oaWRlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlci5hZGRDbGFzcygnc2xpY2stbG9hZGluZycpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zd2lwZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB4RGlzdCwgeURpc3QsIHIsIHN3aXBlQW5nbGUsIF8gPSB0aGlzO1xuXG4gICAgICAgIHhEaXN0ID0gXy50b3VjaE9iamVjdC5zdGFydFggLSBfLnRvdWNoT2JqZWN0LmN1clg7XG4gICAgICAgIHlEaXN0ID0gXy50b3VjaE9iamVjdC5zdGFydFkgLSBfLnRvdWNoT2JqZWN0LmN1clk7XG4gICAgICAgIHIgPSBNYXRoLmF0YW4yKHlEaXN0LCB4RGlzdCk7XG5cbiAgICAgICAgc3dpcGVBbmdsZSA9IE1hdGgucm91bmQociAqIDE4MCAvIE1hdGguUEkpO1xuICAgICAgICBpZiAoc3dpcGVBbmdsZSA8IDApIHtcbiAgICAgICAgICAgIHN3aXBlQW5nbGUgPSAzNjAgLSBNYXRoLmFicyhzd2lwZUFuZ2xlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoc3dpcGVBbmdsZSA8PSA0NSkgJiYgKHN3aXBlQW5nbGUgPj0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoXy5vcHRpb25zLnJ0bCA9PT0gZmFsc2UgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN3aXBlQW5nbGUgPD0gMzYwKSAmJiAoc3dpcGVBbmdsZSA+PSAzMTUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKF8ub3B0aW9ucy5ydGwgPT09IGZhbHNlID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzd2lwZUFuZ2xlID49IDEzNSkgJiYgKHN3aXBlQW5nbGUgPD0gMjI1KSkge1xuICAgICAgICAgICAgcmV0dXJuIChfLm9wdGlvbnMucnRsID09PSBmYWxzZSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoKHN3aXBlQW5nbGUgPj0gMzUpICYmIChzd2lwZUFuZ2xlIDw9IDEzNSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3VwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAndmVydGljYWwnO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zd2lwZUVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgc2xpZGVDb3VudCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjtcblxuICAgICAgICBfLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIF8uaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgXy5zaG91bGRDbGljayA9ICggXy50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA+IDEwICkgPyBmYWxzZSA6IHRydWU7XG5cbiAgICAgICAgaWYgKCBfLnRvdWNoT2JqZWN0LmN1clggPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy50b3VjaE9iamVjdC5lZGdlSGl0ID09PSB0cnVlICkge1xuICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2VkZ2UnLCBbXywgXy5zd2lwZURpcmVjdGlvbigpIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID49IF8udG91Y2hPYmplY3QubWluU3dpcGUgKSB7XG5cbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IF8uc3dpcGVEaXJlY3Rpb24oKTtcblxuICAgICAgICAgICAgc3dpdGNoICggZGlyZWN0aW9uICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZG93bic6XG5cbiAgICAgICAgICAgICAgICAgICAgc2xpZGVDb3VudCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMuc3dpcGVUb1NsaWRlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmNoZWNrTmF2aWdhYmxlKCBfLmN1cnJlbnRTbGlkZSArIF8uZ2V0U2xpZGVDb3VudCgpICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY3VycmVudFNsaWRlICsgXy5nZXRTbGlkZUNvdW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50RGlyZWN0aW9uID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBjYXNlICd1cCc6XG5cbiAgICAgICAgICAgICAgICAgICAgc2xpZGVDb3VudCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMuc3dpcGVUb1NsaWRlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmNoZWNrTmF2aWdhYmxlKCBfLmN1cnJlbnRTbGlkZSAtIF8uZ2V0U2xpZGVDb3VudCgpICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY3VycmVudFNsaWRlIC0gXy5nZXRTbGlkZUNvdW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50RGlyZWN0aW9uID0gMTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggZGlyZWN0aW9uICE9ICd2ZXJ0aWNhbCcgKSB7XG5cbiAgICAgICAgICAgICAgICBfLnNsaWRlSGFuZGxlciggc2xpZGVDb3VudCApO1xuICAgICAgICAgICAgICAgIF8udG91Y2hPYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignc3dpcGUnLCBbXywgZGlyZWN0aW9uIF0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKCBfLnRvdWNoT2JqZWN0LnN0YXJ0WCAhPT0gXy50b3VjaE9iamVjdC5jdXJYICkge1xuXG4gICAgICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoIF8uY3VycmVudFNsaWRlICk7XG4gICAgICAgICAgICAgICAgXy50b3VjaE9iamVjdCA9IHt9O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zd2lwZUhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoKF8ub3B0aW9ucy5zd2lwZSA9PT0gZmFsc2UpIHx8ICgnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQgJiYgXy5vcHRpb25zLnN3aXBlID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMuZHJhZ2dhYmxlID09PSBmYWxzZSAmJiBldmVudC50eXBlLmluZGV4T2YoJ21vdXNlJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfLnRvdWNoT2JqZWN0LmZpbmdlckNvdW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoIDogMTtcblxuICAgICAgICBfLnRvdWNoT2JqZWN0Lm1pblN3aXBlID0gXy5saXN0V2lkdGggLyBfLm9wdGlvbnNcbiAgICAgICAgICAgIC50b3VjaFRocmVzaG9sZDtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy50b3VjaE9iamVjdC5taW5Td2lwZSA9IF8ubGlzdEhlaWdodCAvIF8ub3B0aW9uc1xuICAgICAgICAgICAgICAgIC50b3VjaFRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGF0YS5hY3Rpb24pIHtcblxuICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgIF8uc3dpcGVTdGFydChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxuICAgICAgICAgICAgICAgIF8uc3dpcGVNb3ZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICBfLnN3aXBlRW5kKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN3aXBlTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgZWRnZVdhc0hpdCA9IGZhbHNlLFxuICAgICAgICAgICAgY3VyTGVmdCwgc3dpcGVEaXJlY3Rpb24sIHN3aXBlTGVuZ3RoLCBwb3NpdGlvbk9mZnNldCwgdG91Y2hlcztcblxuICAgICAgICB0b3VjaGVzID0gZXZlbnQub3JpZ2luYWxFdmVudCAhPT0gdW5kZWZpbmVkID8gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzIDogbnVsbDtcblxuICAgICAgICBpZiAoIV8uZHJhZ2dpbmcgfHwgdG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyTGVmdCA9IF8uZ2V0TGVmdChfLmN1cnJlbnRTbGlkZSk7XG5cbiAgICAgICAgXy50b3VjaE9iamVjdC5jdXJYID0gdG91Y2hlcyAhPT0gdW5kZWZpbmVkID8gdG91Y2hlc1swXS5wYWdlWCA6IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIF8udG91Y2hPYmplY3QuY3VyWSA9IHRvdWNoZXMgIT09IHVuZGVmaW5lZCA/IHRvdWNoZXNbMF0ucGFnZVkgOiBldmVudC5jbGllbnRZO1xuXG4gICAgICAgIF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPSBNYXRoLnJvdW5kKE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KF8udG91Y2hPYmplY3QuY3VyWCAtIF8udG91Y2hPYmplY3Quc3RhcnRYLCAyKSkpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgTWF0aC5wb3coXy50b3VjaE9iamVjdC5jdXJZIC0gXy50b3VjaE9iamVjdC5zdGFydFksIDIpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZURpcmVjdGlvbiA9IF8uc3dpcGVEaXJlY3Rpb24oKTtcblxuICAgICAgICBpZiAoc3dpcGVEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50ICE9PSB1bmRlZmluZWQgJiYgXy50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBwb3NpdGlvbk9mZnNldCA9IChfLm9wdGlvbnMucnRsID09PSBmYWxzZSA/IDEgOiAtMSkgKiAoXy50b3VjaE9iamVjdC5jdXJYID4gXy50b3VjaE9iamVjdC5zdGFydFggPyAxIDogLTEpO1xuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcG9zaXRpb25PZmZzZXQgPSBfLnRvdWNoT2JqZWN0LmN1clkgPiBfLnRvdWNoT2JqZWN0LnN0YXJ0WSA/IDEgOiAtMTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgc3dpcGVMZW5ndGggPSBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoO1xuXG4gICAgICAgIF8udG91Y2hPYmplY3QuZWRnZUhpdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoKF8uY3VycmVudFNsaWRlID09PSAwICYmIHN3aXBlRGlyZWN0aW9uID09PSAncmlnaHQnKSB8fCAoXy5jdXJyZW50U2xpZGUgPj0gXy5nZXREb3RDb3VudCgpICYmIHN3aXBlRGlyZWN0aW9uID09PSAnbGVmdCcpKSB7XG4gICAgICAgICAgICAgICAgc3dpcGVMZW5ndGggPSBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoICogXy5vcHRpb25zLmVkZ2VGcmljdGlvbjtcbiAgICAgICAgICAgICAgICBfLnRvdWNoT2JqZWN0LmVkZ2VIaXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uc3dpcGVMZWZ0ID0gY3VyTGVmdCArIHN3aXBlTGVuZ3RoICogcG9zaXRpb25PZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLnN3aXBlTGVmdCA9IGN1ckxlZnQgKyAoc3dpcGVMZW5ndGggKiAoXy4kbGlzdC5oZWlnaHQoKSAvIF8ubGlzdFdpZHRoKSkgKiBwb3NpdGlvbk9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5zd2lwZUxlZnQgPSBjdXJMZWZ0ICsgc3dpcGVMZW5ndGggKiBwb3NpdGlvbk9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gdHJ1ZSB8fCBfLm9wdGlvbnMudG91Y2hNb3ZlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uYW5pbWF0aW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLnN3aXBlTGVmdCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBfLnNldENTUyhfLnN3aXBlTGVmdCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN3aXBlU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHRvdWNoZXM7XG5cbiAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKF8udG91Y2hPYmplY3QuZmluZ2VyQ291bnQgIT09IDEgfHwgXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8udG91Y2hPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvdWNoZXMgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF07XG4gICAgICAgIH1cblxuICAgICAgICBfLnRvdWNoT2JqZWN0LnN0YXJ0WCA9IF8udG91Y2hPYmplY3QuY3VyWCA9IHRvdWNoZXMgIT09IHVuZGVmaW5lZCA/IHRvdWNoZXMucGFnZVggOiBldmVudC5jbGllbnRYO1xuICAgICAgICBfLnRvdWNoT2JqZWN0LnN0YXJ0WSA9IF8udG91Y2hPYmplY3QuY3VyWSA9IHRvdWNoZXMgIT09IHVuZGVmaW5lZCA/IHRvdWNoZXMucGFnZVkgOiBldmVudC5jbGllbnRZO1xuXG4gICAgICAgIF8uZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS51bmZpbHRlclNsaWRlcyA9IFNsaWNrLnByb3RvdHlwZS5zbGlja1VuZmlsdGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLiRzbGlkZXNDYWNoZSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICBfLnVubG9hZCgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlc0NhY2hlLmFwcGVuZFRvKF8uJHNsaWRlVHJhY2spO1xuXG4gICAgICAgICAgICBfLnJlaW5pdCgpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUudW5sb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgICQoJy5zbGljay1jbG9uZWQnLCBfLiRzbGlkZXIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmIChfLiRkb3RzKSB7XG4gICAgICAgICAgICBfLiRkb3RzLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uJHByZXZBcnJvdyAmJiBfLmh0bWxFeHByLnRlc3QoXy5vcHRpb25zLnByZXZBcnJvdykpIHtcbiAgICAgICAgICAgIF8uJHByZXZBcnJvdy5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLiRuZXh0QXJyb3cgJiYgXy5odG1sRXhwci50ZXN0KF8ub3B0aW9ucy5uZXh0QXJyb3cpKSB7XG4gICAgICAgICAgICBfLiRuZXh0QXJyb3cucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stc2xpZGUgc2xpY2stYWN0aXZlIHNsaWNrLXZpc2libGUgc2xpY2stY3VycmVudCcpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpXG4gICAgICAgICAgICAuY3NzKCd3aWR0aCcsICcnKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUudW5zbGljayA9IGZ1bmN0aW9uKGZyb21CcmVha3BvaW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcigndW5zbGljaycsIFtfLCBmcm9tQnJlYWtwb2ludF0pO1xuICAgICAgICBfLmRlc3Ryb3koKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUudXBkYXRlQXJyb3dzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgY2VudGVyT2Zmc2V0O1xuXG4gICAgICAgIGNlbnRlck9mZnNldCA9IE1hdGguZmxvb3IoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIpO1xuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAmJlxuICAgICAgICAgICAgIV8ub3B0aW9ucy5pbmZpbml0ZSApIHtcblxuICAgICAgICAgICAgXy4kcHJldkFycm93LnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIGlmIChfLmN1cnJlbnRTbGlkZSA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93LmFkZENsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5jdXJyZW50U2xpZGUgPj0gXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAmJiBfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5hZGRDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uY3VycmVudFNsaWRlID49IF8uc2xpZGVDb3VudCAtIDEgJiYgXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5hZGRDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS51cGRhdGVEb3RzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLiRkb3RzICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIF8uJGRvdHNcbiAgICAgICAgICAgICAgICAuZmluZCgnbGknKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgICAgICBfLiRkb3RzXG4gICAgICAgICAgICAgICAgLmZpbmQoJ2xpJylcbiAgICAgICAgICAgICAgICAuZXEoTWF0aC5mbG9vcihfLmN1cnJlbnRTbGlkZSAvIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCkpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUudmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5hdXRvcGxheSApIHtcblxuICAgICAgICAgICAgaWYgKCBkb2N1bWVudFtfLmhpZGRlbl0gKSB7XG5cbiAgICAgICAgICAgICAgICBfLmludGVycnVwdGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIF8uaW50ZXJydXB0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAkLmZuLnNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgbCA9IF8ubGVuZ3RoLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHJldDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQgPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9wdCA9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBfW2ldLnNsaWNrID0gbmV3IFNsaWNrKF9baV0sIG9wdCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0ID0gX1tpXS5zbGlja1tvcHRdLmFwcGx5KF9baV0uc2xpY2ssIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXQgIT0gJ3VuZGVmaW5lZCcpIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF87XG4gICAgfTtcblxufSkpO1xuIiwiLypcbiAgICAgXyBfICAgICAgXyAgICAgICBfXG4gX19ffCAoXykgX19ffCB8IF9fICAoXylfX19cbi8gX198IHwgfC8gX198IHwvIC8gIHwgLyBfX3xcblxcX18gXFwgfCB8IChfX3wgICA8IF8gfCBcXF9fIFxcXG58X19fL198X3xcXF9fX3xffFxcXyhfKS8gfF9fXy9cbiAgICAgICAgICAgICAgICAgICB8X18vXG5cbiBWZXJzaW9uOiAxLjYuMFxuICBBdXRob3I6IEtlbiBXaGVlbGVyXG4gV2Vic2l0ZTogaHR0cDovL2tlbndoZWVsZXIuZ2l0aHViLmlvXG4gICAgRG9jczogaHR0cDovL2tlbndoZWVsZXIuZ2l0aHViLmlvL3NsaWNrXG4gICAgUmVwbzogaHR0cDovL2dpdGh1Yi5jb20va2Vud2hlZWxlci9zbGlja1xuICBJc3N1ZXM6IGh0dHA6Ly9naXRodWIuY29tL2tlbndoZWVsZXIvc2xpY2svaXNzdWVzXG5cbiAqL1xuIWZ1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wianF1ZXJ5XCJdLGEpOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzP21vZHVsZS5leHBvcnRzPWEocmVxdWlyZShcImpxdWVyeVwiKSk6YShqUXVlcnkpfShmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjt2YXIgYj13aW5kb3cuU2xpY2t8fHt9O2I9ZnVuY3Rpb24oKXtmdW5jdGlvbiBjKGMsZCl7dmFyIGYsZT10aGlzO2UuZGVmYXVsdHM9e2FjY2Vzc2liaWxpdHk6ITAsYWRhcHRpdmVIZWlnaHQ6ITEsYXBwZW5kQXJyb3dzOmEoYyksYXBwZW5kRG90czphKGMpLGFycm93czohMCxhc05hdkZvcjpudWxsLHByZXZBcnJvdzonPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1yb2xlPVwibm9uZVwiIGNsYXNzPVwic2xpY2stcHJldlwiIGFyaWEtbGFiZWw9XCJQcmV2aW91c1wiIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJidXR0b25cIj5QcmV2aW91czwvYnV0dG9uPicsbmV4dEFycm93Oic8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLXJvbGU9XCJub25lXCIgY2xhc3M9XCJzbGljay1uZXh0XCIgYXJpYS1sYWJlbD1cIk5leHRcIiB0YWJpbmRleD1cIjBcIiByb2xlPVwiYnV0dG9uXCI+TmV4dDwvYnV0dG9uPicsYXV0b3BsYXk6ITEsYXV0b3BsYXlTcGVlZDozZTMsY2VudGVyTW9kZTohMSxjZW50ZXJQYWRkaW5nOlwiNTBweFwiLGNzc0Vhc2U6XCJlYXNlXCIsY3VzdG9tUGFnaW5nOmZ1bmN0aW9uKGIsYyl7cmV0dXJuIGEoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtcm9sZT1cIm5vbmVcIiByb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgLz4nKS50ZXh0KGMrMSl9LGRvdHM6ITEsZG90c0NsYXNzOlwic2xpY2stZG90c1wiLGRyYWdnYWJsZTohMCxlYXNpbmc6XCJsaW5lYXJcIixlZGdlRnJpY3Rpb246LjM1LGZhZGU6ITEsZm9jdXNPblNlbGVjdDohMSxpbmZpbml0ZTohMCxpbml0aWFsU2xpZGU6MCxsYXp5TG9hZDpcIm9uZGVtYW5kXCIsbW9iaWxlRmlyc3Q6ITEscGF1c2VPbkhvdmVyOiEwLHBhdXNlT25Gb2N1czohMCxwYXVzZU9uRG90c0hvdmVyOiExLHJlc3BvbmRUbzpcIndpbmRvd1wiLHJlc3BvbnNpdmU6bnVsbCxyb3dzOjEscnRsOiExLHNsaWRlOlwiXCIsc2xpZGVzUGVyUm93OjEsc2xpZGVzVG9TaG93OjEsc2xpZGVzVG9TY3JvbGw6MSxzcGVlZDo1MDAsc3dpcGU6ITAsc3dpcGVUb1NsaWRlOiExLHRvdWNoTW92ZTohMCx0b3VjaFRocmVzaG9sZDo1LHVzZUNTUzohMCx1c2VUcmFuc2Zvcm06ITAsdmFyaWFibGVXaWR0aDohMSx2ZXJ0aWNhbDohMSx2ZXJ0aWNhbFN3aXBpbmc6ITEsd2FpdEZvckFuaW1hdGU6ITAsekluZGV4OjFlM30sZS5pbml0aWFscz17YW5pbWF0aW5nOiExLGRyYWdnaW5nOiExLGF1dG9QbGF5VGltZXI6bnVsbCxjdXJyZW50RGlyZWN0aW9uOjAsY3VycmVudExlZnQ6bnVsbCxjdXJyZW50U2xpZGU6MCxkaXJlY3Rpb246MSwkZG90czpudWxsLGxpc3RXaWR0aDpudWxsLGxpc3RIZWlnaHQ6bnVsbCxsb2FkSW5kZXg6MCwkbmV4dEFycm93Om51bGwsJHByZXZBcnJvdzpudWxsLHNsaWRlQ291bnQ6bnVsbCxzbGlkZVdpZHRoOm51bGwsJHNsaWRlVHJhY2s6bnVsbCwkc2xpZGVzOm51bGwsc2xpZGluZzohMSxzbGlkZU9mZnNldDowLHN3aXBlTGVmdDpudWxsLCRsaXN0Om51bGwsdG91Y2hPYmplY3Q6e30sdHJhbnNmb3Jtc0VuYWJsZWQ6ITEsdW5zbGlja2VkOiExfSxhLmV4dGVuZChlLGUuaW5pdGlhbHMpLGUuYWN0aXZlQnJlYWtwb2ludD1udWxsLGUuYW5pbVR5cGU9bnVsbCxlLmFuaW1Qcm9wPW51bGwsZS5icmVha3BvaW50cz1bXSxlLmJyZWFrcG9pbnRTZXR0aW5ncz1bXSxlLmNzc1RyYW5zaXRpb25zPSExLGUuZm9jdXNzZWQ9ITEsZS5pbnRlcnJ1cHRlZD0hMSxlLmhpZGRlbj1cImhpZGRlblwiLGUucGF1c2VkPSEwLGUucG9zaXRpb25Qcm9wPW51bGwsZS5yZXNwb25kVG89bnVsbCxlLnJvd0NvdW50PTEsZS5zaG91bGRDbGljaz0hMCxlLiRzbGlkZXI9YShjKSxlLiRzbGlkZXNDYWNoZT1udWxsLGUudHJhbnNmb3JtVHlwZT1udWxsLGUudHJhbnNpdGlvblR5cGU9bnVsbCxlLnZpc2liaWxpdHlDaGFuZ2U9XCJ2aXNpYmlsaXR5Y2hhbmdlXCIsZS53aW5kb3dXaWR0aD0wLGUud2luZG93VGltZXI9bnVsbCxmPWEoYykuZGF0YShcInNsaWNrXCIpfHx7fSxlLm9wdGlvbnM9YS5leHRlbmQoe30sZS5kZWZhdWx0cyxkLGYpLGUuY3VycmVudFNsaWRlPWUub3B0aW9ucy5pbml0aWFsU2xpZGUsZS5vcmlnaW5hbFNldHRpbmdzPWUub3B0aW9ucyxcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuPyhlLmhpZGRlbj1cIm1vekhpZGRlblwiLGUudmlzaWJpbGl0eUNoYW5nZT1cIm1venZpc2liaWxpdHljaGFuZ2VcIik6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiYmKGUuaGlkZGVuPVwid2Via2l0SGlkZGVuXCIsZS52aXNpYmlsaXR5Q2hhbmdlPVwid2Via2l0dmlzaWJpbGl0eWNoYW5nZVwiKSxlLmF1dG9QbGF5PWEucHJveHkoZS5hdXRvUGxheSxlKSxlLmF1dG9QbGF5Q2xlYXI9YS5wcm94eShlLmF1dG9QbGF5Q2xlYXIsZSksZS5hdXRvUGxheUl0ZXJhdG9yPWEucHJveHkoZS5hdXRvUGxheUl0ZXJhdG9yLGUpLGUuY2hhbmdlU2xpZGU9YS5wcm94eShlLmNoYW5nZVNsaWRlLGUpLGUuY2xpY2tIYW5kbGVyPWEucHJveHkoZS5jbGlja0hhbmRsZXIsZSksZS5zZWxlY3RIYW5kbGVyPWEucHJveHkoZS5zZWxlY3RIYW5kbGVyLGUpLGUuc2V0UG9zaXRpb249YS5wcm94eShlLnNldFBvc2l0aW9uLGUpLGUuc3dpcGVIYW5kbGVyPWEucHJveHkoZS5zd2lwZUhhbmRsZXIsZSksZS5kcmFnSGFuZGxlcj1hLnByb3h5KGUuZHJhZ0hhbmRsZXIsZSksZS5rZXlIYW5kbGVyPWEucHJveHkoZS5rZXlIYW5kbGVyLGUpLGUuaW5zdGFuY2VVaWQ9YisrLGUuaHRtbEV4cHI9L14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qKSQvLGUucmVnaXN0ZXJCcmVha3BvaW50cygpLGUuaW5pdCghMCl9dmFyIGI9MDtyZXR1cm4gY30oKSxiLnByb3RvdHlwZS5hY3RpdmF0ZUFEQT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS4kc2xpZGVUcmFjay5maW5kKFwiLnNsaWNrLWFjdGl2ZVwiKS5hdHRyKHtcImFyaWEtaGlkZGVuXCI6XCJmYWxzZVwifSkuZmluZChcImEsIGlucHV0LCBidXR0b24sIHNlbGVjdFwiKS5hdHRyKHt0YWJpbmRleDpcIjBcIn0pfSxiLnByb3RvdHlwZS5hZGRTbGlkZT1iLnByb3RvdHlwZS5zbGlja0FkZD1mdW5jdGlvbihiLGMsZCl7dmFyIGU9dGhpcztpZihcImJvb2xlYW5cIj09dHlwZW9mIGMpZD1jLGM9bnVsbDtlbHNlIGlmKDA+Y3x8Yz49ZS5zbGlkZUNvdW50KXJldHVybiExO2UudW5sb2FkKCksXCJudW1iZXJcIj09dHlwZW9mIGM/MD09PWMmJjA9PT1lLiRzbGlkZXMubGVuZ3RoP2EoYikuYXBwZW5kVG8oZS4kc2xpZGVUcmFjayk6ZD9hKGIpLmluc2VydEJlZm9yZShlLiRzbGlkZXMuZXEoYykpOmEoYikuaW5zZXJ0QWZ0ZXIoZS4kc2xpZGVzLmVxKGMpKTpkPT09ITA/YShiKS5wcmVwZW5kVG8oZS4kc2xpZGVUcmFjayk6YShiKS5hcHBlbmRUbyhlLiRzbGlkZVRyYWNrKSxlLiRzbGlkZXM9ZS4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLGUuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKSxlLiRzbGlkZVRyYWNrLmFwcGVuZChlLiRzbGlkZXMpLGUuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKGIsYyl7YShjKS5hdHRyKFwiZGF0YS1zbGljay1pbmRleFwiLGIpfSksZS4kc2xpZGVzQ2FjaGU9ZS4kc2xpZGVzLGUucmVpbml0KCl9LGIucHJvdG90eXBlLmFuaW1hdGVIZWlnaHQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2lmKDE9PT1hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZhLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQ9PT0hMCYmYS5vcHRpb25zLnZlcnRpY2FsPT09ITEpe3ZhciBiPWEuJHNsaWRlcy5lcShhLmN1cnJlbnRTbGlkZSkub3V0ZXJIZWlnaHQoITApO2EuJGxpc3QuYW5pbWF0ZSh7aGVpZ2h0OmJ9LGEub3B0aW9ucy5zcGVlZCl9fSxiLnByb3RvdHlwZS5hbmltYXRlU2xpZGU9ZnVuY3Rpb24oYixjKXt2YXIgZD17fSxlPXRoaXM7ZS5hbmltYXRlSGVpZ2h0KCksZS5vcHRpb25zLnJ0bD09PSEwJiZlLm9wdGlvbnMudmVydGljYWw9PT0hMSYmKGI9LWIpLGUudHJhbnNmb3Jtc0VuYWJsZWQ9PT0hMT9lLm9wdGlvbnMudmVydGljYWw9PT0hMT9lLiRzbGlkZVRyYWNrLmFuaW1hdGUoe2xlZnQ6Yn0sZS5vcHRpb25zLnNwZWVkLGUub3B0aW9ucy5lYXNpbmcsYyk6ZS4kc2xpZGVUcmFjay5hbmltYXRlKHt0b3A6Yn0sZS5vcHRpb25zLnNwZWVkLGUub3B0aW9ucy5lYXNpbmcsYyk6ZS5jc3NUcmFuc2l0aW9ucz09PSExPyhlLm9wdGlvbnMucnRsPT09ITAmJihlLmN1cnJlbnRMZWZ0PS1lLmN1cnJlbnRMZWZ0KSxhKHthbmltU3RhcnQ6ZS5jdXJyZW50TGVmdH0pLmFuaW1hdGUoe2FuaW1TdGFydDpifSx7ZHVyYXRpb246ZS5vcHRpb25zLnNwZWVkLGVhc2luZzplLm9wdGlvbnMuZWFzaW5nLHN0ZXA6ZnVuY3Rpb24oYSl7YT1NYXRoLmNlaWwoYSksZS5vcHRpb25zLnZlcnRpY2FsPT09ITE/KGRbZS5hbmltVHlwZV09XCJ0cmFuc2xhdGUoXCIrYStcInB4LCAwcHgpXCIsZS4kc2xpZGVUcmFjay5jc3MoZCkpOihkW2UuYW5pbVR5cGVdPVwidHJhbnNsYXRlKDBweCxcIithK1wicHgpXCIsZS4kc2xpZGVUcmFjay5jc3MoZCkpfSxjb21wbGV0ZTpmdW5jdGlvbigpe2MmJmMuY2FsbCgpfX0pKTooZS5hcHBseVRyYW5zaXRpb24oKSxiPU1hdGguY2VpbChiKSxlLm9wdGlvbnMudmVydGljYWw9PT0hMT9kW2UuYW5pbVR5cGVdPVwidHJhbnNsYXRlM2QoXCIrYitcInB4LCAwcHgsIDBweClcIjpkW2UuYW5pbVR5cGVdPVwidHJhbnNsYXRlM2QoMHB4LFwiK2IrXCJweCwgMHB4KVwiLGUuJHNsaWRlVHJhY2suY3NzKGQpLGMmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmRpc2FibGVUcmFuc2l0aW9uKCksYy5jYWxsKCl9LGUub3B0aW9ucy5zcGVlZCkpfSxiLnByb3RvdHlwZS5nZXROYXZUYXJnZXQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9Yi5vcHRpb25zLmFzTmF2Rm9yO3JldHVybiBjJiZudWxsIT09YyYmKGM9YShjKS5ub3QoYi4kc2xpZGVyKSksY30sYi5wcm90b3R5cGUuYXNOYXZGb3I9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcyxkPWMuZ2V0TmF2VGFyZ2V0KCk7bnVsbCE9PWQmJlwib2JqZWN0XCI9PXR5cGVvZiBkJiZkLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpLnNsaWNrKFwiZ2V0U2xpY2tcIik7Yy51bnNsaWNrZWR8fGMuc2xpZGVIYW5kbGVyKGIsITApfSl9LGIucHJvdG90eXBlLmFwcGx5VHJhbnNpdGlvbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9e307Yi5vcHRpb25zLmZhZGU9PT0hMT9jW2IudHJhbnNpdGlvblR5cGVdPWIudHJhbnNmb3JtVHlwZStcIiBcIitiLm9wdGlvbnMuc3BlZWQrXCJtcyBcIitiLm9wdGlvbnMuY3NzRWFzZTpjW2IudHJhbnNpdGlvblR5cGVdPVwib3BhY2l0eSBcIitiLm9wdGlvbnMuc3BlZWQrXCJtcyBcIitiLm9wdGlvbnMuY3NzRWFzZSxiLm9wdGlvbnMuZmFkZT09PSExP2IuJHNsaWRlVHJhY2suY3NzKGMpOmIuJHNsaWRlcy5lcShhKS5jc3MoYyl9LGIucHJvdG90eXBlLmF1dG9QbGF5PWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLmF1dG9QbGF5Q2xlYXIoKSxhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGEuYXV0b1BsYXlUaW1lcj1zZXRJbnRlcnZhbChhLmF1dG9QbGF5SXRlcmF0b3IsYS5vcHRpb25zLmF1dG9wbGF5U3BlZWQpKX0sYi5wcm90b3R5cGUuYXV0b1BsYXlDbGVhcj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5hdXRvUGxheVRpbWVyJiZjbGVhckludGVydmFsKGEuYXV0b1BsYXlUaW1lcil9LGIucHJvdG90eXBlLmF1dG9QbGF5SXRlcmF0b3I9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jdXJyZW50U2xpZGUrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO2EucGF1c2VkfHxhLmludGVycnVwdGVkfHxhLmZvY3Vzc2VkfHwoYS5vcHRpb25zLmluZmluaXRlPT09ITEmJigxPT09YS5kaXJlY3Rpb24mJmEuY3VycmVudFNsaWRlKzE9PT1hLnNsaWRlQ291bnQtMT9hLmRpcmVjdGlvbj0wOjA9PT1hLmRpcmVjdGlvbiYmKGI9YS5jdXJyZW50U2xpZGUtYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLGEuY3VycmVudFNsaWRlLTE9PT0wJiYoYS5kaXJlY3Rpb249MSkpKSxhLnNsaWRlSGFuZGxlcihiKSl9LGIucHJvdG90eXBlLmJ1aWxkQXJyb3dzPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcztiLm9wdGlvbnMuYXJyb3dzPT09ITAmJihiLiRwcmV2QXJyb3c9YShiLm9wdGlvbnMucHJldkFycm93KS5hZGRDbGFzcyhcInNsaWNrLWFycm93XCIpLGIuJG5leHRBcnJvdz1hKGIub3B0aW9ucy5uZXh0QXJyb3cpLmFkZENsYXNzKFwic2xpY2stYXJyb3dcIiksYi5zbGlkZUNvdW50PmIub3B0aW9ucy5zbGlkZXNUb1Nob3c/KGIuJHByZXZBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWhpZGRlblwiKS5yZW1vdmVBdHRyKFwiYXJpYS1oaWRkZW4gdGFiaW5kZXhcIiksYi4kbmV4dEFycm93LnJlbW92ZUNsYXNzKFwic2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiB0YWJpbmRleFwiKSxiLmh0bWxFeHByLnRlc3QoYi5vcHRpb25zLnByZXZBcnJvdykmJmIuJHByZXZBcnJvdy5wcmVwZW5kVG8oYi5vcHRpb25zLmFwcGVuZEFycm93cyksYi5odG1sRXhwci50ZXN0KGIub3B0aW9ucy5uZXh0QXJyb3cpJiZiLiRuZXh0QXJyb3cuYXBwZW5kVG8oYi5vcHRpb25zLmFwcGVuZEFycm93cyksYi5vcHRpb25zLmluZmluaXRlIT09ITAmJmIuJHByZXZBcnJvdy5hZGRDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsXCJ0cnVlXCIpKTpiLiRwcmV2QXJyb3cuYWRkKGIuJG5leHRBcnJvdykuYWRkQ2xhc3MoXCJzbGljay1oaWRkZW5cIikuYXR0cih7XCJhcmlhLWRpc2FibGVkXCI6XCJ0cnVlXCIsdGFiaW5kZXg6XCItMVwifSkpfSxiLnByb3RvdHlwZS5idWlsZERvdHM9ZnVuY3Rpb24oKXt2YXIgYyxkLGI9dGhpcztpZihiLm9wdGlvbnMuZG90cz09PSEwJiZiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdyl7Zm9yKGIuJHNsaWRlci5hZGRDbGFzcyhcInNsaWNrLWRvdHRlZFwiKSxkPWEoXCI8dWwgLz5cIikuYWRkQ2xhc3MoYi5vcHRpb25zLmRvdHNDbGFzcyksYz0wO2M8PWIuZ2V0RG90Q291bnQoKTtjKz0xKWQuYXBwZW5kKGEoXCI8bGkgLz5cIikuYXBwZW5kKGIub3B0aW9ucy5jdXN0b21QYWdpbmcuY2FsbCh0aGlzLGIsYykpKTtiLiRkb3RzPWQuYXBwZW5kVG8oYi5vcHRpb25zLmFwcGVuZERvdHMpLGIuJGRvdHMuZmluZChcImxpXCIpLmZpcnN0KCkuYWRkQ2xhc3MoXCJzbGljay1hY3RpdmVcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJmYWxzZVwiKX19LGIucHJvdG90eXBlLmJ1aWxkT3V0PWZ1bmN0aW9uKCl7dmFyIGI9dGhpcztiLiRzbGlkZXM9Yi4kc2xpZGVyLmNoaWxkcmVuKGIub3B0aW9ucy5zbGlkZStcIjpub3QoLnNsaWNrLWNsb25lZClcIikuYWRkQ2xhc3MoXCJzbGljay1zbGlkZVwiKSxiLnNsaWRlQ291bnQ9Yi4kc2xpZGVzLmxlbmd0aCxiLiRzbGlkZXMuZWFjaChmdW5jdGlvbihiLGMpe2EoYykuYXR0cihcImRhdGEtc2xpY2staW5kZXhcIixiKS5kYXRhKFwib3JpZ2luYWxTdHlsaW5nXCIsYShjKS5hdHRyKFwic3R5bGVcIil8fFwiXCIpfSksYi4kc2xpZGVyLmFkZENsYXNzKFwic2xpY2stc2xpZGVyXCIpLGIuJHNsaWRlVHJhY2s9MD09PWIuc2xpZGVDb3VudD9hKCc8ZGl2IGNsYXNzPVwic2xpY2stdHJhY2tcIi8+JykuYXBwZW5kVG8oYi4kc2xpZGVyKTpiLiRzbGlkZXMud3JhcEFsbCgnPGRpdiBjbGFzcz1cInNsaWNrLXRyYWNrXCIvPicpLnBhcmVudCgpLGIuJGxpc3Q9Yi4kc2xpZGVUcmFjay53cmFwKCc8ZGl2IGFyaWEtbGl2ZT1cInBvbGl0ZVwiIGNsYXNzPVwic2xpY2stbGlzdFwiLz4nKS5wYXJlbnQoKSxiLiRzbGlkZVRyYWNrLmNzcyhcIm9wYWNpdHlcIiwwKSwoYi5vcHRpb25zLmNlbnRlck1vZGU9PT0hMHx8Yi5vcHRpb25zLnN3aXBlVG9TbGlkZT09PSEwKSYmKGIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbD0xKSxhKFwiaW1nW2RhdGEtbGF6eV1cIixiLiRzbGlkZXIpLm5vdChcIltzcmNdXCIpLmFkZENsYXNzKFwic2xpY2stbG9hZGluZ1wiKSxiLnNldHVwSW5maW5pdGUoKSxiLmJ1aWxkQXJyb3dzKCksYi5idWlsZERvdHMoKSxiLnVwZGF0ZURvdHMoKSxiLnNldFNsaWRlQ2xhc3NlcyhcIm51bWJlclwiPT10eXBlb2YgYi5jdXJyZW50U2xpZGU/Yi5jdXJyZW50U2xpZGU6MCksYi5vcHRpb25zLmRyYWdnYWJsZT09PSEwJiZiLiRsaXN0LmFkZENsYXNzKFwiZHJhZ2dhYmxlXCIpfSxiLnByb3RvdHlwZS5idWlsZFJvd3M9ZnVuY3Rpb24oKXt2YXIgYixjLGQsZSxmLGcsaCxhPXRoaXM7aWYoZT1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksZz1hLiRzbGlkZXIuY2hpbGRyZW4oKSxhLm9wdGlvbnMucm93cz4xKXtmb3IoaD1hLm9wdGlvbnMuc2xpZGVzUGVyUm93KmEub3B0aW9ucy5yb3dzLGY9TWF0aC5jZWlsKGcubGVuZ3RoL2gpLGI9MDtmPmI7YisrKXt2YXIgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2ZvcihjPTA7YzxhLm9wdGlvbnMucm93cztjKyspe3ZhciBqPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Zm9yKGQ9MDtkPGEub3B0aW9ucy5zbGlkZXNQZXJSb3c7ZCsrKXt2YXIgaz1iKmgrKGMqYS5vcHRpb25zLnNsaWRlc1BlclJvdytkKTtnLmdldChrKSYmai5hcHBlbmRDaGlsZChnLmdldChrKSl9aS5hcHBlbmRDaGlsZChqKX1lLmFwcGVuZENoaWxkKGkpfWEuJHNsaWRlci5lbXB0eSgpLmFwcGVuZChlKSxhLiRzbGlkZXIuY2hpbGRyZW4oKS5jaGlsZHJlbigpLmNoaWxkcmVuKCkuY3NzKHt3aWR0aDoxMDAvYS5vcHRpb25zLnNsaWRlc1BlclJvdytcIiVcIixkaXNwbGF5OlwiaW5saW5lLWJsb2NrXCJ9KX19LGIucHJvdG90eXBlLmNoZWNrUmVzcG9uc2l2ZT1mdW5jdGlvbihiLGMpe3ZhciBlLGYsZyxkPXRoaXMsaD0hMSxpPWQuJHNsaWRlci53aWR0aCgpLGo9d2luZG93LmlubmVyV2lkdGh8fGEod2luZG93KS53aWR0aCgpO2lmKFwid2luZG93XCI9PT1kLnJlc3BvbmRUbz9nPWo6XCJzbGlkZXJcIj09PWQucmVzcG9uZFRvP2c9aTpcIm1pblwiPT09ZC5yZXNwb25kVG8mJihnPU1hdGgubWluKGosaSkpLGQub3B0aW9ucy5yZXNwb25zaXZlJiZkLm9wdGlvbnMucmVzcG9uc2l2ZS5sZW5ndGgmJm51bGwhPT1kLm9wdGlvbnMucmVzcG9uc2l2ZSl7Zj1udWxsO2ZvcihlIGluIGQuYnJlYWtwb2ludHMpZC5icmVha3BvaW50cy5oYXNPd25Qcm9wZXJ0eShlKSYmKGQub3JpZ2luYWxTZXR0aW5ncy5tb2JpbGVGaXJzdD09PSExP2c8ZC5icmVha3BvaW50c1tlXSYmKGY9ZC5icmVha3BvaW50c1tlXSk6Zz5kLmJyZWFrcG9pbnRzW2VdJiYoZj1kLmJyZWFrcG9pbnRzW2VdKSk7bnVsbCE9PWY/bnVsbCE9PWQuYWN0aXZlQnJlYWtwb2ludD8oZiE9PWQuYWN0aXZlQnJlYWtwb2ludHx8YykmJihkLmFjdGl2ZUJyZWFrcG9pbnQ9ZixcInVuc2xpY2tcIj09PWQuYnJlYWtwb2ludFNldHRpbmdzW2ZdP2QudW5zbGljayhmKTooZC5vcHRpb25zPWEuZXh0ZW5kKHt9LGQub3JpZ2luYWxTZXR0aW5ncyxkLmJyZWFrcG9pbnRTZXR0aW5nc1tmXSksYj09PSEwJiYoZC5jdXJyZW50U2xpZGU9ZC5vcHRpb25zLmluaXRpYWxTbGlkZSksZC5yZWZyZXNoKGIpKSxoPWYpOihkLmFjdGl2ZUJyZWFrcG9pbnQ9ZixcInVuc2xpY2tcIj09PWQuYnJlYWtwb2ludFNldHRpbmdzW2ZdP2QudW5zbGljayhmKTooZC5vcHRpb25zPWEuZXh0ZW5kKHt9LGQub3JpZ2luYWxTZXR0aW5ncyxkLmJyZWFrcG9pbnRTZXR0aW5nc1tmXSksYj09PSEwJiYoZC5jdXJyZW50U2xpZGU9ZC5vcHRpb25zLmluaXRpYWxTbGlkZSksZC5yZWZyZXNoKGIpKSxoPWYpOm51bGwhPT1kLmFjdGl2ZUJyZWFrcG9pbnQmJihkLmFjdGl2ZUJyZWFrcG9pbnQ9bnVsbCxkLm9wdGlvbnM9ZC5vcmlnaW5hbFNldHRpbmdzLGI9PT0hMCYmKGQuY3VycmVudFNsaWRlPWQub3B0aW9ucy5pbml0aWFsU2xpZGUpLGQucmVmcmVzaChiKSxoPWYpLGJ8fGg9PT0hMXx8ZC4kc2xpZGVyLnRyaWdnZXIoXCJicmVha3BvaW50XCIsW2QsaF0pfX0sYi5wcm90b3R5cGUuY2hhbmdlU2xpZGU9ZnVuY3Rpb24oYixjKXt2YXIgZixnLGgsZD10aGlzLGU9YShiLmN1cnJlbnRUYXJnZXQpO3N3aXRjaChlLmlzKFwiYVwiKSYmYi5wcmV2ZW50RGVmYXVsdCgpLGUuaXMoXCJsaVwiKXx8KGU9ZS5jbG9zZXN0KFwibGlcIikpLGg9ZC5zbGlkZUNvdW50JWQub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCE9PTAsZj1oPzA6KGQuc2xpZGVDb3VudC1kLmN1cnJlbnRTbGlkZSklZC5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLGIuZGF0YS5tZXNzYWdlKXtjYXNlXCJwcmV2aW91c1wiOmc9MD09PWY/ZC5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsOmQub3B0aW9ucy5zbGlkZXNUb1Nob3ctZixkLnNsaWRlQ291bnQ+ZC5vcHRpb25zLnNsaWRlc1RvU2hvdyYmZC5zbGlkZUhhbmRsZXIoZC5jdXJyZW50U2xpZGUtZywhMSxjKTticmVhaztjYXNlXCJuZXh0XCI6Zz0wPT09Zj9kLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6ZixkLnNsaWRlQ291bnQ+ZC5vcHRpb25zLnNsaWRlc1RvU2hvdyYmZC5zbGlkZUhhbmRsZXIoZC5jdXJyZW50U2xpZGUrZywhMSxjKTticmVhaztjYXNlXCJpbmRleFwiOnZhciBpPTA9PT1iLmRhdGEuaW5kZXg/MDpiLmRhdGEuaW5kZXh8fGUuaW5kZXgoKSpkLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7ZC5zbGlkZUhhbmRsZXIoZC5jaGVja05hdmlnYWJsZShpKSwhMSxjKSxlLmNoaWxkcmVuKCkudHJpZ2dlcihcImZvY3VzXCIpO2JyZWFrO2RlZmF1bHQ6cmV0dXJufX0sYi5wcm90b3R5cGUuY2hlY2tOYXZpZ2FibGU9ZnVuY3Rpb24oYSl7dmFyIGMsZCxiPXRoaXM7aWYoYz1iLmdldE5hdmlnYWJsZUluZGV4ZXMoKSxkPTAsYT5jW2MubGVuZ3RoLTFdKWE9Y1tjLmxlbmd0aC0xXTtlbHNlIGZvcih2YXIgZSBpbiBjKXtpZihhPGNbZV0pe2E9ZDticmVha31kPWNbZV19cmV0dXJuIGF9LGIucHJvdG90eXBlLmNsZWFuVXBFdmVudHM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2Iub3B0aW9ucy5kb3RzJiZudWxsIT09Yi4kZG90cyYmYShcImxpXCIsYi4kZG90cykub2ZmKFwiY2xpY2suc2xpY2tcIixiLmNoYW5nZVNsaWRlKS5vZmYoXCJtb3VzZWVudGVyLnNsaWNrXCIsYS5wcm94eShiLmludGVycnVwdCxiLCEwKSkub2ZmKFwibW91c2VsZWF2ZS5zbGlja1wiLGEucHJveHkoYi5pbnRlcnJ1cHQsYiwhMSkpLGIuJHNsaWRlci5vZmYoXCJmb2N1cy5zbGljayBibHVyLnNsaWNrXCIpLGIub3B0aW9ucy5hcnJvd3M9PT0hMCYmYi5zbGlkZUNvdW50PmIub3B0aW9ucy5zbGlkZXNUb1Nob3cmJihiLiRwcmV2QXJyb3cmJmIuJHByZXZBcnJvdy5vZmYoXCJjbGljay5zbGlja1wiLGIuY2hhbmdlU2xpZGUpLGIuJG5leHRBcnJvdyYmYi4kbmV4dEFycm93Lm9mZihcImNsaWNrLnNsaWNrXCIsYi5jaGFuZ2VTbGlkZSkpLGIuJGxpc3Qub2ZmKFwidG91Y2hzdGFydC5zbGljayBtb3VzZWRvd24uc2xpY2tcIixiLnN3aXBlSGFuZGxlciksYi4kbGlzdC5vZmYoXCJ0b3VjaG1vdmUuc2xpY2sgbW91c2Vtb3ZlLnNsaWNrXCIsYi5zd2lwZUhhbmRsZXIpLGIuJGxpc3Qub2ZmKFwidG91Y2hlbmQuc2xpY2sgbW91c2V1cC5zbGlja1wiLGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9mZihcInRvdWNoY2FuY2VsLnNsaWNrIG1vdXNlbGVhdmUuc2xpY2tcIixiLnN3aXBlSGFuZGxlciksYi4kbGlzdC5vZmYoXCJjbGljay5zbGlja1wiLGIuY2xpY2tIYW5kbGVyKSxhKGRvY3VtZW50KS5vZmYoYi52aXNpYmlsaXR5Q2hhbmdlLGIudmlzaWJpbGl0eSksYi5jbGVhblVwU2xpZGVFdmVudHMoKSxiLm9wdGlvbnMuYWNjZXNzaWJpbGl0eT09PSEwJiZiLiRsaXN0Lm9mZihcImtleWRvd24uc2xpY2tcIixiLmtleUhhbmRsZXIpLGIub3B0aW9ucy5mb2N1c09uU2VsZWN0PT09ITAmJmEoYi4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vZmYoXCJjbGljay5zbGlja1wiLGIuc2VsZWN0SGFuZGxlciksYSh3aW5kb3cpLm9mZihcIm9yaWVudGF0aW9uY2hhbmdlLnNsaWNrLnNsaWNrLVwiK2IuaW5zdGFuY2VVaWQsYi5vcmllbnRhdGlvbkNoYW5nZSksYSh3aW5kb3cpLm9mZihcInJlc2l6ZS5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGIucmVzaXplKSxhKFwiW2RyYWdnYWJsZSE9dHJ1ZV1cIixiLiRzbGlkZVRyYWNrKS5vZmYoXCJkcmFnc3RhcnRcIixiLnByZXZlbnREZWZhdWx0KSxhKHdpbmRvdykub2ZmKFwibG9hZC5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGIuc2V0UG9zaXRpb24pLGEoZG9jdW1lbnQpLm9mZihcInJlYWR5LnNsaWNrLnNsaWNrLVwiK2IuaW5zdGFuY2VVaWQsYi5zZXRQb3NpdGlvbil9LGIucHJvdG90eXBlLmNsZWFuVXBTbGlkZUV2ZW50cz1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi4kbGlzdC5vZmYoXCJtb3VzZWVudGVyLnNsaWNrXCIsYS5wcm94eShiLmludGVycnVwdCxiLCEwKSksYi4kbGlzdC5vZmYoXCJtb3VzZWxlYXZlLnNsaWNrXCIsYS5wcm94eShiLmludGVycnVwdCxiLCExKSl9LGIucHJvdG90eXBlLmNsZWFuVXBSb3dzPWZ1bmN0aW9uKCl7dmFyIGIsYT10aGlzO2Eub3B0aW9ucy5yb3dzPjEmJihiPWEuJHNsaWRlcy5jaGlsZHJlbigpLmNoaWxkcmVuKCksYi5yZW1vdmVBdHRyKFwic3R5bGVcIiksYS4kc2xpZGVyLmVtcHR5KCkuYXBwZW5kKGIpKX0sYi5wcm90b3R5cGUuY2xpY2tIYW5kbGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7Yi5zaG91bGRDbGljaz09PSExJiYoYS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxhLnN0b3BQcm9wYWdhdGlvbigpLGEucHJldmVudERlZmF1bHQoKSl9LGIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcztjLmF1dG9QbGF5Q2xlYXIoKSxjLnRvdWNoT2JqZWN0PXt9LGMuY2xlYW5VcEV2ZW50cygpLGEoXCIuc2xpY2stY2xvbmVkXCIsYy4kc2xpZGVyKS5kZXRhY2goKSxjLiRkb3RzJiZjLiRkb3RzLnJlbW92ZSgpLGMuJHByZXZBcnJvdyYmYy4kcHJldkFycm93Lmxlbmd0aCYmKGMuJHByZXZBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkIHNsaWNrLWFycm93IHNsaWNrLWhpZGRlblwiKS5yZW1vdmVBdHRyKFwiYXJpYS1oaWRkZW4gYXJpYS1kaXNhYmxlZCB0YWJpbmRleFwiKS5jc3MoXCJkaXNwbGF5XCIsXCJcIiksYy5odG1sRXhwci50ZXN0KGMub3B0aW9ucy5wcmV2QXJyb3cpJiZjLiRwcmV2QXJyb3cucmVtb3ZlKCkpLGMuJG5leHRBcnJvdyYmYy4kbmV4dEFycm93Lmxlbmd0aCYmKGMuJG5leHRBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkIHNsaWNrLWFycm93IHNsaWNrLWhpZGRlblwiKS5yZW1vdmVBdHRyKFwiYXJpYS1oaWRkZW4gYXJpYS1kaXNhYmxlZCB0YWJpbmRleFwiKS5jc3MoXCJkaXNwbGF5XCIsXCJcIiksYy5odG1sRXhwci50ZXN0KGMub3B0aW9ucy5uZXh0QXJyb3cpJiZjLiRuZXh0QXJyb3cucmVtb3ZlKCkpLGMuJHNsaWRlcyYmKGMuJHNsaWRlcy5yZW1vdmVDbGFzcyhcInNsaWNrLXNsaWRlIHNsaWNrLWFjdGl2ZSBzbGljay1jZW50ZXIgc2xpY2stdmlzaWJsZSBzbGljay1jdXJyZW50XCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlblwiKS5yZW1vdmVBdHRyKFwiZGF0YS1zbGljay1pbmRleFwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5hdHRyKFwic3R5bGVcIixhKHRoaXMpLmRhdGEoXCJvcmlnaW5hbFN0eWxpbmdcIikpfSksYy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpLGMuJHNsaWRlVHJhY2suZGV0YWNoKCksYy4kbGlzdC5kZXRhY2goKSxjLiRzbGlkZXIuYXBwZW5kKGMuJHNsaWRlcykpLGMuY2xlYW5VcFJvd3MoKSxjLiRzbGlkZXIucmVtb3ZlQ2xhc3MoXCJzbGljay1zbGlkZXJcIiksYy4kc2xpZGVyLnJlbW92ZUNsYXNzKFwic2xpY2staW5pdGlhbGl6ZWRcIiksYy4kc2xpZGVyLnJlbW92ZUNsYXNzKFwic2xpY2stZG90dGVkXCIpLGMudW5zbGlja2VkPSEwLGJ8fGMuJHNsaWRlci50cmlnZ2VyKFwiZGVzdHJveVwiLFtjXSl9LGIucHJvdG90eXBlLmRpc2FibGVUcmFuc2l0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz17fTtjW2IudHJhbnNpdGlvblR5cGVdPVwiXCIsYi5vcHRpb25zLmZhZGU9PT0hMT9iLiRzbGlkZVRyYWNrLmNzcyhjKTpiLiRzbGlkZXMuZXEoYSkuY3NzKGMpfSxiLnByb3RvdHlwZS5mYWRlU2xpZGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO2MuY3NzVHJhbnNpdGlvbnM9PT0hMT8oYy4kc2xpZGVzLmVxKGEpLmNzcyh7ekluZGV4OmMub3B0aW9ucy56SW5kZXh9KSxjLiRzbGlkZXMuZXEoYSkuYW5pbWF0ZSh7b3BhY2l0eToxfSxjLm9wdGlvbnMuc3BlZWQsYy5vcHRpb25zLmVhc2luZyxiKSk6KGMuYXBwbHlUcmFuc2l0aW9uKGEpLGMuJHNsaWRlcy5lcShhKS5jc3Moe29wYWNpdHk6MSx6SW5kZXg6Yy5vcHRpb25zLnpJbmRleH0pLGImJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtjLmRpc2FibGVUcmFuc2l0aW9uKGEpLGIuY2FsbCgpfSxjLm9wdGlvbnMuc3BlZWQpKX0sYi5wcm90b3R5cGUuZmFkZVNsaWRlT3V0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7Yi5jc3NUcmFuc2l0aW9ucz09PSExP2IuJHNsaWRlcy5lcShhKS5hbmltYXRlKHtvcGFjaXR5OjAsekluZGV4OmIub3B0aW9ucy56SW5kZXgtMn0sYi5vcHRpb25zLnNwZWVkLGIub3B0aW9ucy5lYXNpbmcpOihiLmFwcGx5VHJhbnNpdGlvbihhKSxiLiRzbGlkZXMuZXEoYSkuY3NzKHtvcGFjaXR5OjAsekluZGV4OmIub3B0aW9ucy56SW5kZXgtMn0pKX0sYi5wcm90b3R5cGUuZmlsdGVyU2xpZGVzPWIucHJvdG90eXBlLnNsaWNrRmlsdGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7bnVsbCE9PWEmJihiLiRzbGlkZXNDYWNoZT1iLiRzbGlkZXMsYi51bmxvYWQoKSxiLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCksYi4kc2xpZGVzQ2FjaGUuZmlsdGVyKGEpLmFwcGVuZFRvKGIuJHNsaWRlVHJhY2spLGIucmVpbml0KCkpfSxiLnByb3RvdHlwZS5mb2N1c0hhbmRsZXI9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2IuJHNsaWRlci5vZmYoXCJmb2N1cy5zbGljayBibHVyLnNsaWNrXCIpLm9uKFwiZm9jdXMuc2xpY2sgYmx1ci5zbGlja1wiLFwiKjpub3QoLnNsaWNrLWFycm93KVwiLGZ1bmN0aW9uKGMpe2Muc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7dmFyIGQ9YSh0aGlzKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5vcHRpb25zLnBhdXNlT25Gb2N1cyYmKGIuZm9jdXNzZWQ9ZC5pcyhcIjpmb2N1c1wiKSxiLmF1dG9QbGF5KCkpfSwwKX0pfSxiLnByb3RvdHlwZS5nZXRDdXJyZW50PWIucHJvdG90eXBlLnNsaWNrQ3VycmVudFNsaWRlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztyZXR1cm4gYS5jdXJyZW50U2xpZGV9LGIucHJvdG90eXBlLmdldERvdENvdW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPTAsYz0wLGQ9MDtpZihhLm9wdGlvbnMuaW5maW5pdGU9PT0hMClmb3IoO2I8YS5zbGlkZUNvdW50OykrK2QsYj1jK2Eub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCxjKz1hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw8PWEub3B0aW9ucy5zbGlkZXNUb1Nob3c/YS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsOmEub3B0aW9ucy5zbGlkZXNUb1Nob3c7ZWxzZSBpZihhLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwKWQ9YS5zbGlkZUNvdW50O2Vsc2UgaWYoYS5vcHRpb25zLmFzTmF2Rm9yKWZvcig7YjxhLnNsaWRlQ291bnQ7KSsrZCxiPWMrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLGMrPWEub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDw9YS5vcHRpb25zLnNsaWRlc1RvU2hvdz9hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6YS5vcHRpb25zLnNsaWRlc1RvU2hvdztlbHNlIGQ9MStNYXRoLmNlaWwoKGEuc2xpZGVDb3VudC1hLm9wdGlvbnMuc2xpZGVzVG9TaG93KS9hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpO3JldHVybiBkLTF9LGIucHJvdG90eXBlLmdldExlZnQ9ZnVuY3Rpb24oYSl7dmFyIGMsZCxmLGI9dGhpcyxlPTA7cmV0dXJuIGIuc2xpZGVPZmZzZXQ9MCxkPWIuJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KCEwKSxiLm9wdGlvbnMuaW5maW5pdGU9PT0hMD8oYi5zbGlkZUNvdW50PmIub3B0aW9ucy5zbGlkZXNUb1Nob3cmJihiLnNsaWRlT2Zmc2V0PWIuc2xpZGVXaWR0aCpiLm9wdGlvbnMuc2xpZGVzVG9TaG93Ki0xLGU9ZCpiLm9wdGlvbnMuc2xpZGVzVG9TaG93Ki0xKSxiLnNsaWRlQ291bnQlYi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIT09MCYmYStiLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw+Yi5zbGlkZUNvdW50JiZiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGE+Yi5zbGlkZUNvdW50PyhiLnNsaWRlT2Zmc2V0PShiLm9wdGlvbnMuc2xpZGVzVG9TaG93LShhLWIuc2xpZGVDb3VudCkpKmIuc2xpZGVXaWR0aCotMSxlPShiLm9wdGlvbnMuc2xpZGVzVG9TaG93LShhLWIuc2xpZGVDb3VudCkpKmQqLTEpOihiLnNsaWRlT2Zmc2V0PWIuc2xpZGVDb3VudCViLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwqYi5zbGlkZVdpZHRoKi0xLGU9Yi5zbGlkZUNvdW50JWIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCpkKi0xKSkpOmErYi5vcHRpb25zLnNsaWRlc1RvU2hvdz5iLnNsaWRlQ291bnQmJihiLnNsaWRlT2Zmc2V0PShhK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3ctYi5zbGlkZUNvdW50KSpiLnNsaWRlV2lkdGgsZT0oYStiLm9wdGlvbnMuc2xpZGVzVG9TaG93LWIuc2xpZGVDb3VudCkqZCksYi5zbGlkZUNvdW50PD1iLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYi5zbGlkZU9mZnNldD0wLGU9MCksYi5vcHRpb25zLmNlbnRlck1vZGU9PT0hMCYmYi5vcHRpb25zLmluZmluaXRlPT09ITA/Yi5zbGlkZU9mZnNldCs9Yi5zbGlkZVdpZHRoKk1hdGguZmxvb3IoYi5vcHRpb25zLnNsaWRlc1RvU2hvdy8yKS1iLnNsaWRlV2lkdGg6Yi5vcHRpb25zLmNlbnRlck1vZGU9PT0hMCYmKGIuc2xpZGVPZmZzZXQ9MCxiLnNsaWRlT2Zmc2V0Kz1iLnNsaWRlV2lkdGgqTWF0aC5mbG9vcihiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIpKSxjPWIub3B0aW9ucy52ZXJ0aWNhbD09PSExP2EqYi5zbGlkZVdpZHRoKi0xK2Iuc2xpZGVPZmZzZXQ6YSpkKi0xK2UsYi5vcHRpb25zLnZhcmlhYmxlV2lkdGg9PT0hMCYmKGY9Yi5zbGlkZUNvdW50PD1iLm9wdGlvbnMuc2xpZGVzVG9TaG93fHxiLm9wdGlvbnMuaW5maW5pdGU9PT0hMT9iLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmVxKGEpOmIuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikuZXEoYStiLm9wdGlvbnMuc2xpZGVzVG9TaG93KSxjPWIub3B0aW9ucy5ydGw9PT0hMD9mWzBdPy0xKihiLiRzbGlkZVRyYWNrLndpZHRoKCktZlswXS5vZmZzZXRMZWZ0LWYud2lkdGgoKSk6MDpmWzBdPy0xKmZbMF0ub2Zmc2V0TGVmdDowLGIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJihmPWIuc2xpZGVDb3VudDw9Yi5vcHRpb25zLnNsaWRlc1RvU2hvd3x8Yi5vcHRpb25zLmluZmluaXRlPT09ITE/Yi4kc2xpZGVUcmFjay5jaGlsZHJlbihcIi5zbGljay1zbGlkZVwiKS5lcShhKTpiLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmVxKGErYi5vcHRpb25zLnNsaWRlc1RvU2hvdysxKSxjPWIub3B0aW9ucy5ydGw9PT0hMD9mWzBdPy0xKihiLiRzbGlkZVRyYWNrLndpZHRoKCktZlswXS5vZmZzZXRMZWZ0LWYud2lkdGgoKSk6MDpmWzBdPy0xKmZbMF0ub2Zmc2V0TGVmdDowLGMrPShiLiRsaXN0LndpZHRoKCktZi5vdXRlcldpZHRoKCkpLzIpKSxjfSxiLnByb3RvdHlwZS5nZXRPcHRpb249Yi5wcm90b3R5cGUuc2xpY2tHZXRPcHRpb249ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gYi5vcHRpb25zW2FdfSxiLnByb3RvdHlwZS5nZXROYXZpZ2FibGVJbmRleGVzPWZ1bmN0aW9uKCl7dmFyIGUsYT10aGlzLGI9MCxjPTAsZD1bXTtmb3IoYS5vcHRpb25zLmluZmluaXRlPT09ITE/ZT1hLnNsaWRlQ291bnQ6KGI9LTEqYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLGM9LTEqYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLGU9MiphLnNsaWRlQ291bnQpO2U+YjspZC5wdXNoKGIpLGI9YythLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsYys9YS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsPD1hLm9wdGlvbnMuc2xpZGVzVG9TaG93P2Eub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDphLm9wdGlvbnMuc2xpZGVzVG9TaG93O3JldHVybiBkfSxiLnByb3RvdHlwZS5nZXRTbGljaz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxiLnByb3RvdHlwZS5nZXRTbGlkZUNvdW50PWZ1bmN0aW9uKCl7dmFyIGMsZCxlLGI9dGhpcztyZXR1cm4gZT1iLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwP2Iuc2xpZGVXaWR0aCpNYXRoLmZsb29yKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cvMik6MCxiLm9wdGlvbnMuc3dpcGVUb1NsaWRlPT09ITA/KGIuJHNsaWRlVHJhY2suZmluZChcIi5zbGljay1zbGlkZVwiKS5lYWNoKGZ1bmN0aW9uKGMsZil7cmV0dXJuIGYub2Zmc2V0TGVmdC1lK2EoZikub3V0ZXJXaWR0aCgpLzI+LTEqYi5zd2lwZUxlZnQ/KGQ9ZiwhMSk6dm9pZCAwfSksYz1NYXRoLmFicyhhKGQpLmF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIpLWIuY3VycmVudFNsaWRlKXx8MSk6Yi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsfSxiLnByb3RvdHlwZS5nb1RvPWIucHJvdG90eXBlLnNsaWNrR29Ubz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7Yy5jaGFuZ2VTbGlkZSh7ZGF0YTp7bWVzc2FnZTpcImluZGV4XCIsaW5kZXg6cGFyc2VJbnQoYSl9fSxiKX0sYi5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihiKXt2YXIgYz10aGlzO2EoYy4kc2xpZGVyKS5oYXNDbGFzcyhcInNsaWNrLWluaXRpYWxpemVkXCIpfHwoYShjLiRzbGlkZXIpLmFkZENsYXNzKFwic2xpY2staW5pdGlhbGl6ZWRcIiksYy5idWlsZFJvd3MoKSxjLmJ1aWxkT3V0KCksYy5zZXRQcm9wcygpLGMuc3RhcnRMb2FkKCksYy5sb2FkU2xpZGVyKCksYy5pbml0aWFsaXplRXZlbnRzKCksYy51cGRhdGVBcnJvd3MoKSxjLnVwZGF0ZURvdHMoKSxjLmNoZWNrUmVzcG9uc2l2ZSghMCksYy5mb2N1c0hhbmRsZXIoKSksYiYmYy4kc2xpZGVyLnRyaWdnZXIoXCJpbml0XCIsW2NdKSxjLm9wdGlvbnMuYWNjZXNzaWJpbGl0eT09PSEwJiZjLmluaXRBREEoKSxjLm9wdGlvbnMuYXV0b3BsYXkmJihjLnBhdXNlZD0hMSxjLmF1dG9QbGF5KCkpfSxiLnByb3RvdHlwZS5pbml0QURBPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcztiLiRzbGlkZXMuYWRkKGIuJHNsaWRlVHJhY2suZmluZChcIi5zbGljay1jbG9uZWRcIikpLmF0dHIoe1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIix0YWJpbmRleDpcIi0xXCJ9KS5maW5kKFwiYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0XCIpLmF0dHIoe3RhYmluZGV4OlwiLTFcIn0pLGIuJHNsaWRlVHJhY2suYXR0cihcInJvbGVcIixcImxpc3Rib3hcIiksYi4kc2xpZGVzLm5vdChiLiRzbGlkZVRyYWNrLmZpbmQoXCIuc2xpY2stY2xvbmVkXCIpKS5lYWNoKGZ1bmN0aW9uKGMpe2EodGhpcykuYXR0cih7cm9sZTpcIm9wdGlvblwiLFwiYXJpYS1kZXNjcmliZWRieVwiOlwic2xpY2stc2xpZGVcIitiLmluc3RhbmNlVWlkK2N9KX0pLG51bGwhPT1iLiRkb3RzJiZiLiRkb3RzLmF0dHIoXCJyb2xlXCIsXCJ0YWJsaXN0XCIpLmZpbmQoXCJsaVwiKS5lYWNoKGZ1bmN0aW9uKGMpe2EodGhpcykuYXR0cih7cm9sZTpcInByZXNlbnRhdGlvblwiLFwiYXJpYS1zZWxlY3RlZFwiOlwiZmFsc2VcIixcImFyaWEtY29udHJvbHNcIjpcIm5hdmlnYXRpb25cIitiLmluc3RhbmNlVWlkK2MsaWQ6XCJzbGljay1zbGlkZVwiK2IuaW5zdGFuY2VVaWQrY30pfSkuZmlyc3QoKS5hdHRyKFwiYXJpYS1zZWxlY3RlZFwiLFwidHJ1ZVwiKS5lbmQoKS5maW5kKFwiYnV0dG9uXCIpLmF0dHIoXCJyb2xlXCIsXCJidXR0b25cIikuZW5kKCkuY2xvc2VzdChcImRpdlwiKS5hdHRyKFwicm9sZVwiLFwidG9vbGJhclwiKSxiLmFjdGl2YXRlQURBKCl9LGIucHJvdG90eXBlLmluaXRBcnJvd0V2ZW50cz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5vcHRpb25zLmFycm93cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGEuJHByZXZBcnJvdy5vZmYoXCJjbGljay5zbGlja1wiKS5vbihcImNsaWNrLnNsaWNrXCIse21lc3NhZ2U6XCJwcmV2aW91c1wifSxhLmNoYW5nZVNsaWRlKSxhLiRuZXh0QXJyb3cub2ZmKFwiY2xpY2suc2xpY2tcIikub24oXCJjbGljay5zbGlja1wiLHttZXNzYWdlOlwibmV4dFwifSxhLmNoYW5nZVNsaWRlKSl9LGIucHJvdG90eXBlLmluaXREb3RFdmVudHM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2Iub3B0aW9ucy5kb3RzPT09ITAmJmIuc2xpZGVDb3VudD5iLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZhKFwibGlcIixiLiRkb3RzKS5vbihcImNsaWNrLnNsaWNrXCIse21lc3NhZ2U6XCJpbmRleFwifSxiLmNoYW5nZVNsaWRlKSxiLm9wdGlvbnMuZG90cz09PSEwJiZiLm9wdGlvbnMucGF1c2VPbkRvdHNIb3Zlcj09PSEwJiZhKFwibGlcIixiLiRkb3RzKS5vbihcIm1vdXNlZW50ZXIuc2xpY2tcIixhLnByb3h5KGIuaW50ZXJydXB0LGIsITApKS5vbihcIm1vdXNlbGVhdmUuc2xpY2tcIixhLnByb3h5KGIuaW50ZXJydXB0LGIsITEpKX0sYi5wcm90b3R5cGUuaW5pdFNsaWRlRXZlbnRzPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcztiLm9wdGlvbnMucGF1c2VPbkhvdmVyJiYoYi4kbGlzdC5vbihcIm1vdXNlZW50ZXIuc2xpY2tcIixhLnByb3h5KGIuaW50ZXJydXB0LGIsITApKSxiLiRsaXN0Lm9uKFwibW91c2VsZWF2ZS5zbGlja1wiLGEucHJveHkoYi5pbnRlcnJ1cHQsYiwhMSkpKX0sYi5wcm90b3R5cGUuaW5pdGlhbGl6ZUV2ZW50cz1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi5pbml0QXJyb3dFdmVudHMoKSxiLmluaXREb3RFdmVudHMoKSxiLmluaXRTbGlkZUV2ZW50cygpLGIuJGxpc3Qub24oXCJ0b3VjaHN0YXJ0LnNsaWNrIG1vdXNlZG93bi5zbGlja1wiLHthY3Rpb246XCJzdGFydFwifSxiLnN3aXBlSGFuZGxlciksYi4kbGlzdC5vbihcInRvdWNobW92ZS5zbGljayBtb3VzZW1vdmUuc2xpY2tcIix7YWN0aW9uOlwibW92ZVwifSxiLnN3aXBlSGFuZGxlciksYi4kbGlzdC5vbihcInRvdWNoZW5kLnNsaWNrIG1vdXNldXAuc2xpY2tcIix7YWN0aW9uOlwiZW5kXCJ9LGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9uKFwidG91Y2hjYW5jZWwuc2xpY2sgbW91c2VsZWF2ZS5zbGlja1wiLHthY3Rpb246XCJlbmRcIn0sYi5zd2lwZUhhbmRsZXIpLGIuJGxpc3Qub24oXCJjbGljay5zbGlja1wiLGIuY2xpY2tIYW5kbGVyKSxhKGRvY3VtZW50KS5vbihiLnZpc2liaWxpdHlDaGFuZ2UsYS5wcm94eShiLnZpc2liaWxpdHksYikpLGIub3B0aW9ucy5hY2Nlc3NpYmlsaXR5PT09ITAmJmIuJGxpc3Qub24oXCJrZXlkb3duLnNsaWNrXCIsYi5rZXlIYW5kbGVyKSxiLm9wdGlvbnMuZm9jdXNPblNlbGVjdD09PSEwJiZhKGIuJHNsaWRlVHJhY2spLmNoaWxkcmVuKCkub24oXCJjbGljay5zbGlja1wiLGIuc2VsZWN0SGFuZGxlciksYSh3aW5kb3cpLm9uKFwib3JpZW50YXRpb25jaGFuZ2Uuc2xpY2suc2xpY2stXCIrYi5pbnN0YW5jZVVpZCxhLnByb3h5KGIub3JpZW50YXRpb25DaGFuZ2UsYikpLGEod2luZG93KS5vbihcInJlc2l6ZS5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGEucHJveHkoYi5yZXNpemUsYikpLGEoXCJbZHJhZ2dhYmxlIT10cnVlXVwiLGIuJHNsaWRlVHJhY2spLm9uKFwiZHJhZ3N0YXJ0XCIsYi5wcmV2ZW50RGVmYXVsdCksYSh3aW5kb3cpLm9uKFwibG9hZC5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGIuc2V0UG9zaXRpb24pLGEoZG9jdW1lbnQpLm9uKFwicmVhZHkuc2xpY2suc2xpY2stXCIrYi5pbnN0YW5jZVVpZCxiLnNldFBvc2l0aW9uKX0sYi5wcm90b3R5cGUuaW5pdFVJPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLm9wdGlvbnMuYXJyb3dzPT09ITAmJmEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYS4kcHJldkFycm93LnNob3coKSxhLiRuZXh0QXJyb3cuc2hvdygpKSxhLm9wdGlvbnMuZG90cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS4kZG90cy5zaG93KCl9LGIucHJvdG90eXBlLmtleUhhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczthLnRhcmdldC50YWdOYW1lLm1hdGNoKFwiVEVYVEFSRUF8SU5QVVR8U0VMRUNUXCIpfHwoMzc9PT1hLmtleUNvZGUmJmIub3B0aW9ucy5hY2Nlc3NpYmlsaXR5PT09ITA/Yi5jaGFuZ2VTbGlkZSh7ZGF0YTp7bWVzc2FnZTpiLm9wdGlvbnMucnRsPT09ITA/XCJuZXh0XCI6XCJwcmV2aW91c1wifX0pOjM5PT09YS5rZXlDb2RlJiZiLm9wdGlvbnMuYWNjZXNzaWJpbGl0eT09PSEwJiZiLmNoYW5nZVNsaWRlKHtkYXRhOnttZXNzYWdlOmIub3B0aW9ucy5ydGw9PT0hMD9cInByZXZpb3VzXCI6XCJuZXh0XCJ9fSkpfSxiLnByb3RvdHlwZS5sYXp5TG9hZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGcoYyl7YShcImltZ1tkYXRhLWxhenldXCIsYykuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZD1hKHRoaXMpLmF0dHIoXCJkYXRhLWxhenlcIiksZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO2Uub25sb2FkPWZ1bmN0aW9uKCl7Yy5hbmltYXRlKHtvcGFjaXR5OjB9LDEwMCxmdW5jdGlvbigpe2MuYXR0cihcInNyY1wiLGQpLmFuaW1hdGUoe29wYWNpdHk6MX0sMjAwLGZ1bmN0aW9uKCl7Yy5yZW1vdmVBdHRyKFwiZGF0YS1sYXp5XCIpLnJlbW92ZUNsYXNzKFwic2xpY2stbG9hZGluZ1wiKX0pLGIuJHNsaWRlci50cmlnZ2VyKFwibGF6eUxvYWRlZFwiLFtiLGMsZF0pfSl9LGUub25lcnJvcj1mdW5jdGlvbigpe2MucmVtb3ZlQXR0cihcImRhdGEtbGF6eVwiKS5yZW1vdmVDbGFzcyhcInNsaWNrLWxvYWRpbmdcIikuYWRkQ2xhc3MoXCJzbGljay1sYXp5bG9hZC1lcnJvclwiKSxiLiRzbGlkZXIudHJpZ2dlcihcImxhenlMb2FkRXJyb3JcIixbYixjLGRdKX0sZS5zcmM9ZH0pfXZhciBjLGQsZSxmLGI9dGhpcztiLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwP2Iub3B0aW9ucy5pbmZpbml0ZT09PSEwPyhlPWIuY3VycmVudFNsaWRlKyhiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIrMSksZj1lK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3crMik6KGU9TWF0aC5tYXgoMCxiLmN1cnJlbnRTbGlkZS0oYi5vcHRpb25zLnNsaWRlc1RvU2hvdy8yKzEpKSxmPTIrKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cvMisxKStiLmN1cnJlbnRTbGlkZSk6KGU9Yi5vcHRpb25zLmluZmluaXRlP2Iub3B0aW9ucy5zbGlkZXNUb1Nob3crYi5jdXJyZW50U2xpZGU6Yi5jdXJyZW50U2xpZGUsZj1NYXRoLmNlaWwoZStiLm9wdGlvbnMuc2xpZGVzVG9TaG93KSxiLm9wdGlvbnMuZmFkZT09PSEwJiYoZT4wJiZlLS0sZjw9Yi5zbGlkZUNvdW50JiZmKyspKSxjPWIuJHNsaWRlci5maW5kKFwiLnNsaWNrLXNsaWRlXCIpLnNsaWNlKGUsZiksZyhjKSxiLnNsaWRlQ291bnQ8PWIub3B0aW9ucy5zbGlkZXNUb1Nob3c/KGQ9Yi4kc2xpZGVyLmZpbmQoXCIuc2xpY2stc2xpZGVcIiksZyhkKSk6Yi5jdXJyZW50U2xpZGU+PWIuc2xpZGVDb3VudC1iLm9wdGlvbnMuc2xpZGVzVG9TaG93PyhkPWIuJHNsaWRlci5maW5kKFwiLnNsaWNrLWNsb25lZFwiKS5zbGljZSgwLGIub3B0aW9ucy5zbGlkZXNUb1Nob3cpLGcoZCkpOjA9PT1iLmN1cnJlbnRTbGlkZSYmKGQ9Yi4kc2xpZGVyLmZpbmQoXCIuc2xpY2stY2xvbmVkXCIpLnNsaWNlKC0xKmIub3B0aW9ucy5zbGlkZXNUb1Nob3cpLGcoZCkpfSxiLnByb3RvdHlwZS5sb2FkU2xpZGVyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLnNldFBvc2l0aW9uKCksYS4kc2xpZGVUcmFjay5jc3Moe29wYWNpdHk6MX0pLGEuJHNsaWRlci5yZW1vdmVDbGFzcyhcInNsaWNrLWxvYWRpbmdcIiksYS5pbml0VUkoKSxcInByb2dyZXNzaXZlXCI9PT1hLm9wdGlvbnMubGF6eUxvYWQmJmEucHJvZ3Jlc3NpdmVMYXp5TG9hZCgpfSxiLnByb3RvdHlwZS5uZXh0PWIucHJvdG90eXBlLnNsaWNrTmV4dD1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5jaGFuZ2VTbGlkZSh7ZGF0YTp7bWVzc2FnZTpcIm5leHRcIn19KX0sYi5wcm90b3R5cGUub3JpZW50YXRpb25DaGFuZ2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2EuY2hlY2tSZXNwb25zaXZlKCksYS5zZXRQb3NpdGlvbigpfSxiLnByb3RvdHlwZS5wYXVzZT1iLnByb3RvdHlwZS5zbGlja1BhdXNlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLmF1dG9QbGF5Q2xlYXIoKSxhLnBhdXNlZD0hMH0sYi5wcm90b3R5cGUucGxheT1iLnByb3RvdHlwZS5zbGlja1BsYXk9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2EuYXV0b1BsYXkoKSxhLm9wdGlvbnMuYXV0b3BsYXk9ITAsYS5wYXVzZWQ9ITEsYS5mb2N1c3NlZD0hMSxhLmludGVycnVwdGVkPSExfSxiLnByb3RvdHlwZS5wb3N0U2xpZGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztiLnVuc2xpY2tlZHx8KGIuJHNsaWRlci50cmlnZ2VyKFwiYWZ0ZXJDaGFuZ2VcIixbYixhXSksYi5hbmltYXRpbmc9ITEsYi5zZXRQb3NpdGlvbigpLGIuc3dpcGVMZWZ0PW51bGwsYi5vcHRpb25zLmF1dG9wbGF5JiZiLmF1dG9QbGF5KCksYi5vcHRpb25zLmFjY2Vzc2liaWxpdHk9PT0hMCYmYi5pbml0QURBKCkpfSxiLnByb3RvdHlwZS5wcmV2PWIucHJvdG90eXBlLnNsaWNrUHJldj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5jaGFuZ2VTbGlkZSh7ZGF0YTp7bWVzc2FnZTpcInByZXZpb3VzXCJ9fSl9LGIucHJvdG90eXBlLnByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKX0sYi5wcm90b3R5cGUucHJvZ3Jlc3NpdmVMYXp5TG9hZD1mdW5jdGlvbihiKXtiPWJ8fDE7dmFyIGUsZixnLGM9dGhpcyxkPWEoXCJpbWdbZGF0YS1sYXp5XVwiLGMuJHNsaWRlcik7ZC5sZW5ndGg/KGU9ZC5maXJzdCgpLGY9ZS5hdHRyKFwiZGF0YS1sYXp5XCIpLGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKSxnLm9ubG9hZD1mdW5jdGlvbigpe2UuYXR0cihcInNyY1wiLGYpLnJlbW92ZUF0dHIoXCJkYXRhLWxhenlcIikucmVtb3ZlQ2xhc3MoXCJzbGljay1sb2FkaW5nXCIpLGMub3B0aW9ucy5hZGFwdGl2ZUhlaWdodD09PSEwJiZjLnNldFBvc2l0aW9uKCksYy4kc2xpZGVyLnRyaWdnZXIoXCJsYXp5TG9hZGVkXCIsW2MsZSxmXSksYy5wcm9ncmVzc2l2ZUxhenlMb2FkKCl9LGcub25lcnJvcj1mdW5jdGlvbigpezM+Yj9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5wcm9ncmVzc2l2ZUxhenlMb2FkKGIrMSl9LDUwMCk6KGUucmVtb3ZlQXR0cihcImRhdGEtbGF6eVwiKS5yZW1vdmVDbGFzcyhcInNsaWNrLWxvYWRpbmdcIikuYWRkQ2xhc3MoXCJzbGljay1sYXp5bG9hZC1lcnJvclwiKSxjLiRzbGlkZXIudHJpZ2dlcihcImxhenlMb2FkRXJyb3JcIixbYyxlLGZdKSxjLnByb2dyZXNzaXZlTGF6eUxvYWQoKSl9LGcuc3JjPWYpOmMuJHNsaWRlci50cmlnZ2VyKFwiYWxsSW1hZ2VzTG9hZGVkXCIsW2NdKX0sYi5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbihiKXt2YXIgZCxlLGM9dGhpcztlPWMuc2xpZGVDb3VudC1jLm9wdGlvbnMuc2xpZGVzVG9TaG93LCFjLm9wdGlvbnMuaW5maW5pdGUmJmMuY3VycmVudFNsaWRlPmUmJihjLmN1cnJlbnRTbGlkZT1lKSxjLnNsaWRlQ291bnQ8PWMub3B0aW9ucy5zbGlkZXNUb1Nob3cmJihjLmN1cnJlbnRTbGlkZT0wKSxkPWMuY3VycmVudFNsaWRlLGMuZGVzdHJveSghMCksYS5leHRlbmQoYyxjLmluaXRpYWxzLHtjdXJyZW50U2xpZGU6ZH0pLGMuaW5pdCgpLGJ8fGMuY2hhbmdlU2xpZGUoe2RhdGE6e21lc3NhZ2U6XCJpbmRleFwiLGluZGV4OmR9fSwhMSl9LGIucHJvdG90eXBlLnJlZ2lzdGVyQnJlYWtwb2ludHM9ZnVuY3Rpb24oKXt2YXIgYyxkLGUsYj10aGlzLGY9Yi5vcHRpb25zLnJlc3BvbnNpdmV8fG51bGw7aWYoXCJhcnJheVwiPT09YS50eXBlKGYpJiZmLmxlbmd0aCl7Yi5yZXNwb25kVG89Yi5vcHRpb25zLnJlc3BvbmRUb3x8XCJ3aW5kb3dcIjtmb3IoYyBpbiBmKWlmKGU9Yi5icmVha3BvaW50cy5sZW5ndGgtMSxkPWZbY10uYnJlYWtwb2ludCxmLmhhc093blByb3BlcnR5KGMpKXtmb3IoO2U+PTA7KWIuYnJlYWtwb2ludHNbZV0mJmIuYnJlYWtwb2ludHNbZV09PT1kJiZiLmJyZWFrcG9pbnRzLnNwbGljZShlLDEpLGUtLTtiLmJyZWFrcG9pbnRzLnB1c2goZCksYi5icmVha3BvaW50U2V0dGluZ3NbZF09ZltjXS5zZXR0aW5nc31iLmJyZWFrcG9pbnRzLnNvcnQoZnVuY3Rpb24oYSxjKXtyZXR1cm4gYi5vcHRpb25zLm1vYmlsZUZpcnN0P2EtYzpjLWF9KX19LGIucHJvdG90eXBlLnJlaW5pdD1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi4kc2xpZGVzPWIuJHNsaWRlVHJhY2suY2hpbGRyZW4oYi5vcHRpb25zLnNsaWRlKS5hZGRDbGFzcyhcInNsaWNrLXNsaWRlXCIpLGIuc2xpZGVDb3VudD1iLiRzbGlkZXMubGVuZ3RoLGIuY3VycmVudFNsaWRlPj1iLnNsaWRlQ291bnQmJjAhPT1iLmN1cnJlbnRTbGlkZSYmKGIuY3VycmVudFNsaWRlPWIuY3VycmVudFNsaWRlLWIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCksYi5zbGlkZUNvdW50PD1iLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYi5jdXJyZW50U2xpZGU9MCksYi5yZWdpc3RlckJyZWFrcG9pbnRzKCksYi5zZXRQcm9wcygpLGIuc2V0dXBJbmZpbml0ZSgpLGIuYnVpbGRBcnJvd3MoKSxiLnVwZGF0ZUFycm93cygpLGIuaW5pdEFycm93RXZlbnRzKCksYi5idWlsZERvdHMoKSxiLnVwZGF0ZURvdHMoKSxiLmluaXREb3RFdmVudHMoKSxiLmNsZWFuVXBTbGlkZUV2ZW50cygpLGIuaW5pdFNsaWRlRXZlbnRzKCksYi5jaGVja1Jlc3BvbnNpdmUoITEsITApLGIub3B0aW9ucy5mb2N1c09uU2VsZWN0PT09ITAmJmEoYi4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vbihcImNsaWNrLnNsaWNrXCIsYi5zZWxlY3RIYW5kbGVyKSxiLnNldFNsaWRlQ2xhc3NlcyhcIm51bWJlclwiPT10eXBlb2YgYi5jdXJyZW50U2xpZGU/Yi5jdXJyZW50U2xpZGU6MCksYi5zZXRQb3NpdGlvbigpLGIuZm9jdXNIYW5kbGVyKCksYi5wYXVzZWQ9IWIub3B0aW9ucy5hdXRvcGxheSxiLmF1dG9QbGF5KCksYi4kc2xpZGVyLnRyaWdnZXIoXCJyZUluaXRcIixbYl0pfSxiLnByb3RvdHlwZS5yZXNpemU9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2Eod2luZG93KS53aWR0aCgpIT09Yi53aW5kb3dXaWR0aCYmKGNsZWFyVGltZW91dChiLndpbmRvd0RlbGF5KSxiLndpbmRvd0RlbGF5PXdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi53aW5kb3dXaWR0aD1hKHdpbmRvdykud2lkdGgoKSxiLmNoZWNrUmVzcG9uc2l2ZSgpLGIudW5zbGlja2VkfHxiLnNldFBvc2l0aW9uKCl9LDUwKSl9LGIucHJvdG90eXBlLnJlbW92ZVNsaWRlPWIucHJvdG90eXBlLnNsaWNrUmVtb3ZlPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzO3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgYT8oYj1hLGE9Yj09PSEwPzA6ZC5zbGlkZUNvdW50LTEpOmE9Yj09PSEwPy0tYTphLGQuc2xpZGVDb3VudDwxfHwwPmF8fGE+ZC5zbGlkZUNvdW50LTE/ITE6KGQudW5sb2FkKCksYz09PSEwP2QuJHNsaWRlVHJhY2suY2hpbGRyZW4oKS5yZW1vdmUoKTpkLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZXEoYSkucmVtb3ZlKCksZC4kc2xpZGVzPWQuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKSxkLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCksZC4kc2xpZGVUcmFjay5hcHBlbmQoZC4kc2xpZGVzKSxkLiRzbGlkZXNDYWNoZT1kLiRzbGlkZXMsdm9pZCBkLnJlaW5pdCgpKX0sYi5wcm90b3R5cGUuc2V0Q1NTPWZ1bmN0aW9uKGEpe3ZhciBkLGUsYj10aGlzLGM9e307Yi5vcHRpb25zLnJ0bD09PSEwJiYoYT0tYSksZD1cImxlZnRcIj09Yi5wb3NpdGlvblByb3A/TWF0aC5jZWlsKGEpK1wicHhcIjpcIjBweFwiLGU9XCJ0b3BcIj09Yi5wb3NpdGlvblByb3A/TWF0aC5jZWlsKGEpK1wicHhcIjpcIjBweFwiLGNbYi5wb3NpdGlvblByb3BdPWEsYi50cmFuc2Zvcm1zRW5hYmxlZD09PSExP2IuJHNsaWRlVHJhY2suY3NzKGMpOihjPXt9LGIuY3NzVHJhbnNpdGlvbnM9PT0hMT8oY1tiLmFuaW1UeXBlXT1cInRyYW5zbGF0ZShcIitkK1wiLCBcIitlK1wiKVwiLGIuJHNsaWRlVHJhY2suY3NzKGMpKTooY1tiLmFuaW1UeXBlXT1cInRyYW5zbGF0ZTNkKFwiK2QrXCIsIFwiK2UrXCIsIDBweClcIixiLiRzbGlkZVRyYWNrLmNzcyhjKSkpfSxiLnByb3RvdHlwZS5zZXREaW1lbnNpb25zPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLm9wdGlvbnMudmVydGljYWw9PT0hMT9hLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwJiZhLiRsaXN0LmNzcyh7cGFkZGluZzpcIjBweCBcIithLm9wdGlvbnMuY2VudGVyUGFkZGluZ30pOihhLiRsaXN0LmhlaWdodChhLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCghMCkqYS5vcHRpb25zLnNsaWRlc1RvU2hvdyksYS5vcHRpb25zLmNlbnRlck1vZGU9PT0hMCYmYS4kbGlzdC5jc3Moe3BhZGRpbmc6YS5vcHRpb25zLmNlbnRlclBhZGRpbmcrXCIgMHB4XCJ9KSksYS5saXN0V2lkdGg9YS4kbGlzdC53aWR0aCgpLGEubGlzdEhlaWdodD1hLiRsaXN0LmhlaWdodCgpLGEub3B0aW9ucy52ZXJ0aWNhbD09PSExJiZhLm9wdGlvbnMudmFyaWFibGVXaWR0aD09PSExPyhhLnNsaWRlV2lkdGg9TWF0aC5jZWlsKGEubGlzdFdpZHRoL2Eub3B0aW9ucy5zbGlkZXNUb1Nob3cpLGEuJHNsaWRlVHJhY2sud2lkdGgoTWF0aC5jZWlsKGEuc2xpZGVXaWR0aCphLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmxlbmd0aCkpKTphLm9wdGlvbnMudmFyaWFibGVXaWR0aD09PSEwP2EuJHNsaWRlVHJhY2sud2lkdGgoNWUzKmEuc2xpZGVDb3VudCk6KGEuc2xpZGVXaWR0aD1NYXRoLmNlaWwoYS5saXN0V2lkdGgpLGEuJHNsaWRlVHJhY2suaGVpZ2h0KE1hdGguY2VpbChhLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCghMCkqYS4kc2xpZGVUcmFjay5jaGlsZHJlbihcIi5zbGljay1zbGlkZVwiKS5sZW5ndGgpKSk7dmFyIGI9YS4kc2xpZGVzLmZpcnN0KCkub3V0ZXJXaWR0aCghMCktYS4kc2xpZGVzLmZpcnN0KCkud2lkdGgoKTthLm9wdGlvbnMudmFyaWFibGVXaWR0aD09PSExJiZhLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLndpZHRoKGEuc2xpZGVXaWR0aC1iKX0sYi5wcm90b3R5cGUuc2V0RmFkZT1mdW5jdGlvbigpe3ZhciBjLGI9dGhpcztiLiRzbGlkZXMuZWFjaChmdW5jdGlvbihkLGUpe2M9Yi5zbGlkZVdpZHRoKmQqLTEsYi5vcHRpb25zLnJ0bD09PSEwP2EoZSkuY3NzKHtwb3NpdGlvbjpcInJlbGF0aXZlXCIscmlnaHQ6Yyx0b3A6MCx6SW5kZXg6Yi5vcHRpb25zLnpJbmRleC0yLG9wYWNpdHk6MH0pOmEoZSkuY3NzKHtwb3NpdGlvbjpcInJlbGF0aXZlXCIsbGVmdDpjLHRvcDowLHpJbmRleDpiLm9wdGlvbnMuekluZGV4LTIsb3BhY2l0eTowfSl9KSxiLiRzbGlkZXMuZXEoYi5jdXJyZW50U2xpZGUpLmNzcyh7ekluZGV4OmIub3B0aW9ucy56SW5kZXgtMSxvcGFjaXR5OjF9KX0sYi5wcm90b3R5cGUuc2V0SGVpZ2h0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztpZigxPT09YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0PT09ITAmJmEub3B0aW9ucy52ZXJ0aWNhbD09PSExKXt2YXIgYj1hLiRzbGlkZXMuZXEoYS5jdXJyZW50U2xpZGUpLm91dGVySGVpZ2h0KCEwKTthLiRsaXN0LmNzcyhcImhlaWdodFwiLGIpfX0sYi5wcm90b3R5cGUuc2V0T3B0aW9uPWIucHJvdG90eXBlLnNsaWNrU2V0T3B0aW9uPWZ1bmN0aW9uKCl7dmFyIGMsZCxlLGYsaCxiPXRoaXMsZz0hMTtpZihcIm9iamVjdFwiPT09YS50eXBlKGFyZ3VtZW50c1swXSk/KGU9YXJndW1lbnRzWzBdLGc9YXJndW1lbnRzWzFdLGg9XCJtdWx0aXBsZVwiKTpcInN0cmluZ1wiPT09YS50eXBlKGFyZ3VtZW50c1swXSkmJihlPWFyZ3VtZW50c1swXSxmPWFyZ3VtZW50c1sxXSxnPWFyZ3VtZW50c1syXSxcInJlc3BvbnNpdmVcIj09PWFyZ3VtZW50c1swXSYmXCJhcnJheVwiPT09YS50eXBlKGFyZ3VtZW50c1sxXSk/aD1cInJlc3BvbnNpdmVcIjpcInVuZGVmaW5lZFwiIT10eXBlb2YgYXJndW1lbnRzWzFdJiYoaD1cInNpbmdsZVwiKSksXCJzaW5nbGVcIj09PWgpYi5vcHRpb25zW2VdPWY7ZWxzZSBpZihcIm11bHRpcGxlXCI9PT1oKWEuZWFjaChlLGZ1bmN0aW9uKGEsYyl7Yi5vcHRpb25zW2FdPWN9KTtlbHNlIGlmKFwicmVzcG9uc2l2ZVwiPT09aClmb3IoZCBpbiBmKWlmKFwiYXJyYXlcIiE9PWEudHlwZShiLm9wdGlvbnMucmVzcG9uc2l2ZSkpYi5vcHRpb25zLnJlc3BvbnNpdmU9W2ZbZF1dO2Vsc2V7Zm9yKGM9Yi5vcHRpb25zLnJlc3BvbnNpdmUubGVuZ3RoLTE7Yz49MDspYi5vcHRpb25zLnJlc3BvbnNpdmVbY10uYnJlYWtwb2ludD09PWZbZF0uYnJlYWtwb2ludCYmYi5vcHRpb25zLnJlc3BvbnNpdmUuc3BsaWNlKGMsMSksYy0tO2Iub3B0aW9ucy5yZXNwb25zaXZlLnB1c2goZltkXSl9ZyYmKGIudW5sb2FkKCksYi5yZWluaXQoKSl9LGIucHJvdG90eXBlLnNldFBvc2l0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLnNldERpbWVuc2lvbnMoKSxhLnNldEhlaWdodCgpLGEub3B0aW9ucy5mYWRlPT09ITE/YS5zZXRDU1MoYS5nZXRMZWZ0KGEuY3VycmVudFNsaWRlKSk6YS5zZXRGYWRlKCksYS4kc2xpZGVyLnRyaWdnZXIoXCJzZXRQb3NpdGlvblwiLFthXSl9LGIucHJvdG90eXBlLnNldFByb3BzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWRvY3VtZW50LmJvZHkuc3R5bGU7YS5wb3NpdGlvblByb3A9YS5vcHRpb25zLnZlcnRpY2FsPT09ITA/XCJ0b3BcIjpcImxlZnRcIixcInRvcFwiPT09YS5wb3NpdGlvblByb3A/YS4kc2xpZGVyLmFkZENsYXNzKFwic2xpY2stdmVydGljYWxcIik6YS4kc2xpZGVyLnJlbW92ZUNsYXNzKFwic2xpY2stdmVydGljYWxcIiksKHZvaWQgMCE9PWIuV2Via2l0VHJhbnNpdGlvbnx8dm9pZCAwIT09Yi5Nb3pUcmFuc2l0aW9ufHx2b2lkIDAhPT1iLm1zVHJhbnNpdGlvbikmJmEub3B0aW9ucy51c2VDU1M9PT0hMCYmKGEuY3NzVHJhbnNpdGlvbnM9ITApLGEub3B0aW9ucy5mYWRlJiYoXCJudW1iZXJcIj09dHlwZW9mIGEub3B0aW9ucy56SW5kZXg/YS5vcHRpb25zLnpJbmRleDwzJiYoYS5vcHRpb25zLnpJbmRleD0zKTphLm9wdGlvbnMuekluZGV4PWEuZGVmYXVsdHMuekluZGV4KSx2b2lkIDAhPT1iLk9UcmFuc2Zvcm0mJihhLmFuaW1UeXBlPVwiT1RyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cIi1vLXRyYW5zZm9ybVwiLGEudHJhbnNpdGlvblR5cGU9XCJPVHJhbnNpdGlvblwiLHZvaWQgMD09PWIucGVyc3BlY3RpdmVQcm9wZXJ0eSYmdm9pZCAwPT09Yi53ZWJraXRQZXJzcGVjdGl2ZSYmKGEuYW5pbVR5cGU9ITEpKSx2b2lkIDAhPT1iLk1velRyYW5zZm9ybSYmKGEuYW5pbVR5cGU9XCJNb3pUcmFuc2Zvcm1cIixhLnRyYW5zZm9ybVR5cGU9XCItbW96LXRyYW5zZm9ybVwiLGEudHJhbnNpdGlvblR5cGU9XCJNb3pUcmFuc2l0aW9uXCIsdm9pZCAwPT09Yi5wZXJzcGVjdGl2ZVByb3BlcnR5JiZ2b2lkIDA9PT1iLk1velBlcnNwZWN0aXZlJiYoYS5hbmltVHlwZT0hMSkpLHZvaWQgMCE9PWIud2Via2l0VHJhbnNmb3JtJiYoYS5hbmltVHlwZT1cIndlYmtpdFRyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cIi13ZWJraXQtdHJhbnNmb3JtXCIsYS50cmFuc2l0aW9uVHlwZT1cIndlYmtpdFRyYW5zaXRpb25cIix2b2lkIDA9PT1iLnBlcnNwZWN0aXZlUHJvcGVydHkmJnZvaWQgMD09PWIud2Via2l0UGVyc3BlY3RpdmUmJihhLmFuaW1UeXBlPSExKSksdm9pZCAwIT09Yi5tc1RyYW5zZm9ybSYmKGEuYW5pbVR5cGU9XCJtc1RyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cIi1tcy10cmFuc2Zvcm1cIixhLnRyYW5zaXRpb25UeXBlPVwibXNUcmFuc2l0aW9uXCIsdm9pZCAwPT09Yi5tc1RyYW5zZm9ybSYmKGEuYW5pbVR5cGU9ITEpKSx2b2lkIDAhPT1iLnRyYW5zZm9ybSYmYS5hbmltVHlwZSE9PSExJiYoYS5hbmltVHlwZT1cInRyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cInRyYW5zZm9ybVwiLGEudHJhbnNpdGlvblR5cGU9XCJ0cmFuc2l0aW9uXCIpLGEudHJhbnNmb3Jtc0VuYWJsZWQ9YS5vcHRpb25zLnVzZVRyYW5zZm9ybSYmbnVsbCE9PWEuYW5pbVR5cGUmJmEuYW5pbVR5cGUhPT0hMX0sYi5wcm90b3R5cGUuc2V0U2xpZGVDbGFzc2VzPWZ1bmN0aW9uKGEpe3ZhciBjLGQsZSxmLGI9dGhpcztkPWIuJHNsaWRlci5maW5kKFwiLnNsaWNrLXNsaWRlXCIpLnJlbW92ZUNsYXNzKFwic2xpY2stYWN0aXZlIHNsaWNrLWNlbnRlciBzbGljay1jdXJyZW50XCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKSxiLiRzbGlkZXMuZXEoYSkuYWRkQ2xhc3MoXCJzbGljay1jdXJyZW50XCIpLGIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITA/KGM9TWF0aC5mbG9vcihiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIpLGIub3B0aW9ucy5pbmZpbml0ZT09PSEwJiYoYT49YyYmYTw9Yi5zbGlkZUNvdW50LTEtYz9iLiRzbGlkZXMuc2xpY2UoYS1jLGErYysxKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpOihlPWIub3B0aW9ucy5zbGlkZXNUb1Nob3crYSxcbmQuc2xpY2UoZS1jKzEsZStjKzIpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIikpLDA9PT1hP2QuZXEoZC5sZW5ndGgtMS1iLm9wdGlvbnMuc2xpZGVzVG9TaG93KS5hZGRDbGFzcyhcInNsaWNrLWNlbnRlclwiKTphPT09Yi5zbGlkZUNvdW50LTEmJmQuZXEoYi5vcHRpb25zLnNsaWRlc1RvU2hvdykuYWRkQ2xhc3MoXCJzbGljay1jZW50ZXJcIikpLGIuJHNsaWRlcy5lcShhKS5hZGRDbGFzcyhcInNsaWNrLWNlbnRlclwiKSk6YT49MCYmYTw9Yi5zbGlkZUNvdW50LWIub3B0aW9ucy5zbGlkZXNUb1Nob3c/Yi4kc2xpZGVzLnNsaWNlKGEsYStiLm9wdGlvbnMuc2xpZGVzVG9TaG93KS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpOmQubGVuZ3RoPD1iLm9wdGlvbnMuc2xpZGVzVG9TaG93P2QuYWRkQ2xhc3MoXCJzbGljay1hY3RpdmVcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJmYWxzZVwiKTooZj1iLnNsaWRlQ291bnQlYi5vcHRpb25zLnNsaWRlc1RvU2hvdyxlPWIub3B0aW9ucy5pbmZpbml0ZT09PSEwP2Iub3B0aW9ucy5zbGlkZXNUb1Nob3crYTphLGIub3B0aW9ucy5zbGlkZXNUb1Nob3c9PWIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCYmYi5zbGlkZUNvdW50LWE8Yi5vcHRpb25zLnNsaWRlc1RvU2hvdz9kLnNsaWNlKGUtKGIub3B0aW9ucy5zbGlkZXNUb1Nob3ctZiksZStmKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpOmQuc2xpY2UoZSxlK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3cpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIikpLFwib25kZW1hbmRcIj09PWIub3B0aW9ucy5sYXp5TG9hZCYmYi5sYXp5TG9hZCgpfSxiLnByb3RvdHlwZS5zZXR1cEluZmluaXRlPWZ1bmN0aW9uKCl7dmFyIGMsZCxlLGI9dGhpcztpZihiLm9wdGlvbnMuZmFkZT09PSEwJiYoYi5vcHRpb25zLmNlbnRlck1vZGU9ITEpLGIub3B0aW9ucy5pbmZpbml0ZT09PSEwJiZiLm9wdGlvbnMuZmFkZT09PSExJiYoZD1udWxsLGIuc2xpZGVDb3VudD5iLm9wdGlvbnMuc2xpZGVzVG9TaG93KSl7Zm9yKGU9Yi5vcHRpb25zLmNlbnRlck1vZGU9PT0hMD9iLm9wdGlvbnMuc2xpZGVzVG9TaG93KzE6Yi5vcHRpb25zLnNsaWRlc1RvU2hvdyxjPWIuc2xpZGVDb3VudDtjPmIuc2xpZGVDb3VudC1lO2MtPTEpZD1jLTEsYShiLiRzbGlkZXNbZF0pLmNsb25lKCEwKS5hdHRyKFwiaWRcIixcIlwiKS5hdHRyKFwiZGF0YS1zbGljay1pbmRleFwiLGQtYi5zbGlkZUNvdW50KS5wcmVwZW5kVG8oYi4kc2xpZGVUcmFjaykuYWRkQ2xhc3MoXCJzbGljay1jbG9uZWRcIik7Zm9yKGM9MDtlPmM7Yys9MSlkPWMsYShiLiRzbGlkZXNbZF0pLmNsb25lKCEwKS5hdHRyKFwiaWRcIixcIlwiKS5hdHRyKFwiZGF0YS1zbGljay1pbmRleFwiLGQrYi5zbGlkZUNvdW50KS5hcHBlbmRUbyhiLiRzbGlkZVRyYWNrKS5hZGRDbGFzcyhcInNsaWNrLWNsb25lZFwiKTtiLiRzbGlkZVRyYWNrLmZpbmQoXCIuc2xpY2stY2xvbmVkXCIpLmZpbmQoXCJbaWRdXCIpLmVhY2goZnVuY3Rpb24oKXthKHRoaXMpLmF0dHIoXCJpZFwiLFwiXCIpfSl9fSxiLnByb3RvdHlwZS5pbnRlcnJ1cHQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczthfHxiLmF1dG9QbGF5KCksYi5pbnRlcnJ1cHRlZD1hfSxiLnByb3RvdHlwZS5zZWxlY3RIYW5kbGVyPWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMsZD1hKGIudGFyZ2V0KS5pcyhcIi5zbGljay1zbGlkZVwiKT9hKGIudGFyZ2V0KTphKGIudGFyZ2V0KS5wYXJlbnRzKFwiLnNsaWNrLXNsaWRlXCIpLGU9cGFyc2VJbnQoZC5hdHRyKFwiZGF0YS1zbGljay1pbmRleFwiKSk7cmV0dXJuIGV8fChlPTApLGMuc2xpZGVDb3VudDw9Yy5vcHRpb25zLnNsaWRlc1RvU2hvdz8oYy5zZXRTbGlkZUNsYXNzZXMoZSksdm9pZCBjLmFzTmF2Rm9yKGUpKTp2b2lkIGMuc2xpZGVIYW5kbGVyKGUpfSxiLnByb3RvdHlwZS5zbGlkZUhhbmRsZXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGosaD1udWxsLGk9dGhpcztyZXR1cm4gYj1ifHwhMSxpLmFuaW1hdGluZz09PSEwJiZpLm9wdGlvbnMud2FpdEZvckFuaW1hdGU9PT0hMHx8aS5vcHRpb25zLmZhZGU9PT0hMCYmaS5jdXJyZW50U2xpZGU9PT1hfHxpLnNsaWRlQ291bnQ8PWkub3B0aW9ucy5zbGlkZXNUb1Nob3c/dm9pZCAwOihiPT09ITEmJmkuYXNOYXZGb3IoYSksZD1hLGg9aS5nZXRMZWZ0KGQpLGc9aS5nZXRMZWZ0KGkuY3VycmVudFNsaWRlKSxpLmN1cnJlbnRMZWZ0PW51bGw9PT1pLnN3aXBlTGVmdD9nOmkuc3dpcGVMZWZ0LGkub3B0aW9ucy5pbmZpbml0ZT09PSExJiZpLm9wdGlvbnMuY2VudGVyTW9kZT09PSExJiYoMD5hfHxhPmkuZ2V0RG90Q291bnQoKSppLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpP3ZvaWQoaS5vcHRpb25zLmZhZGU9PT0hMSYmKGQ9aS5jdXJyZW50U2xpZGUsYyE9PSEwP2kuYW5pbWF0ZVNsaWRlKGcsZnVuY3Rpb24oKXtpLnBvc3RTbGlkZShkKX0pOmkucG9zdFNsaWRlKGQpKSk6aS5vcHRpb25zLmluZmluaXRlPT09ITEmJmkub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJigwPmF8fGE+aS5zbGlkZUNvdW50LWkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCk/dm9pZChpLm9wdGlvbnMuZmFkZT09PSExJiYoZD1pLmN1cnJlbnRTbGlkZSxjIT09ITA/aS5hbmltYXRlU2xpZGUoZyxmdW5jdGlvbigpe2kucG9zdFNsaWRlKGQpfSk6aS5wb3N0U2xpZGUoZCkpKTooaS5vcHRpb25zLmF1dG9wbGF5JiZjbGVhckludGVydmFsKGkuYXV0b1BsYXlUaW1lciksZT0wPmQ/aS5zbGlkZUNvdW50JWkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCE9PTA/aS5zbGlkZUNvdW50LWkuc2xpZGVDb3VudCVpLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6aS5zbGlkZUNvdW50K2Q6ZD49aS5zbGlkZUNvdW50P2kuc2xpZGVDb3VudCVpLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwhPT0wPzA6ZC1pLnNsaWRlQ291bnQ6ZCxpLmFuaW1hdGluZz0hMCxpLiRzbGlkZXIudHJpZ2dlcihcImJlZm9yZUNoYW5nZVwiLFtpLGkuY3VycmVudFNsaWRlLGVdKSxmPWkuY3VycmVudFNsaWRlLGkuY3VycmVudFNsaWRlPWUsaS5zZXRTbGlkZUNsYXNzZXMoaS5jdXJyZW50U2xpZGUpLGkub3B0aW9ucy5hc05hdkZvciYmKGo9aS5nZXROYXZUYXJnZXQoKSxqPWouc2xpY2soXCJnZXRTbGlja1wiKSxqLnNsaWRlQ291bnQ8PWoub3B0aW9ucy5zbGlkZXNUb1Nob3cmJmouc2V0U2xpZGVDbGFzc2VzKGkuY3VycmVudFNsaWRlKSksaS51cGRhdGVEb3RzKCksaS51cGRhdGVBcnJvd3MoKSxpLm9wdGlvbnMuZmFkZT09PSEwPyhjIT09ITA/KGkuZmFkZVNsaWRlT3V0KGYpLGkuZmFkZVNsaWRlKGUsZnVuY3Rpb24oKXtpLnBvc3RTbGlkZShlKX0pKTppLnBvc3RTbGlkZShlKSx2b2lkIGkuYW5pbWF0ZUhlaWdodCgpKTp2b2lkKGMhPT0hMD9pLmFuaW1hdGVTbGlkZShoLGZ1bmN0aW9uKCl7aS5wb3N0U2xpZGUoZSl9KTppLnBvc3RTbGlkZShlKSkpKX0sYi5wcm90b3R5cGUuc3RhcnRMb2FkPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLm9wdGlvbnMuYXJyb3dzPT09ITAmJmEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYS4kcHJldkFycm93LmhpZGUoKSxhLiRuZXh0QXJyb3cuaGlkZSgpKSxhLm9wdGlvbnMuZG90cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS4kZG90cy5oaWRlKCksYS4kc2xpZGVyLmFkZENsYXNzKFwic2xpY2stbG9hZGluZ1wiKX0sYi5wcm90b3R5cGUuc3dpcGVEaXJlY3Rpb249ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlPXRoaXM7cmV0dXJuIGE9ZS50b3VjaE9iamVjdC5zdGFydFgtZS50b3VjaE9iamVjdC5jdXJYLGI9ZS50b3VjaE9iamVjdC5zdGFydFktZS50b3VjaE9iamVjdC5jdXJZLGM9TWF0aC5hdGFuMihiLGEpLGQ9TWF0aC5yb3VuZCgxODAqYy9NYXRoLlBJKSwwPmQmJihkPTM2MC1NYXRoLmFicyhkKSksNDU+PWQmJmQ+PTA/ZS5vcHRpb25zLnJ0bD09PSExP1wibGVmdFwiOlwicmlnaHRcIjozNjA+PWQmJmQ+PTMxNT9lLm9wdGlvbnMucnRsPT09ITE/XCJsZWZ0XCI6XCJyaWdodFwiOmQ+PTEzNSYmMjI1Pj1kP2Uub3B0aW9ucy5ydGw9PT0hMT9cInJpZ2h0XCI6XCJsZWZ0XCI6ZS5vcHRpb25zLnZlcnRpY2FsU3dpcGluZz09PSEwP2Q+PTM1JiYxMzU+PWQ/XCJkb3duXCI6XCJ1cFwiOlwidmVydGljYWxcIn0sYi5wcm90b3R5cGUuc3dpcGVFbmQ9ZnVuY3Rpb24oYSl7dmFyIGMsZCxiPXRoaXM7aWYoYi5kcmFnZ2luZz0hMSxiLmludGVycnVwdGVkPSExLGIuc2hvdWxkQ2xpY2s9Yi50b3VjaE9iamVjdC5zd2lwZUxlbmd0aD4xMD8hMTohMCx2b2lkIDA9PT1iLnRvdWNoT2JqZWN0LmN1clgpcmV0dXJuITE7aWYoYi50b3VjaE9iamVjdC5lZGdlSGl0PT09ITAmJmIuJHNsaWRlci50cmlnZ2VyKFwiZWRnZVwiLFtiLGIuc3dpcGVEaXJlY3Rpb24oKV0pLGIudG91Y2hPYmplY3Quc3dpcGVMZW5ndGg+PWIudG91Y2hPYmplY3QubWluU3dpcGUpe3N3aXRjaChkPWIuc3dpcGVEaXJlY3Rpb24oKSl7Y2FzZVwibGVmdFwiOmNhc2VcImRvd25cIjpjPWIub3B0aW9ucy5zd2lwZVRvU2xpZGU/Yi5jaGVja05hdmlnYWJsZShiLmN1cnJlbnRTbGlkZStiLmdldFNsaWRlQ291bnQoKSk6Yi5jdXJyZW50U2xpZGUrYi5nZXRTbGlkZUNvdW50KCksYi5jdXJyZW50RGlyZWN0aW9uPTA7YnJlYWs7Y2FzZVwicmlnaHRcIjpjYXNlXCJ1cFwiOmM9Yi5vcHRpb25zLnN3aXBlVG9TbGlkZT9iLmNoZWNrTmF2aWdhYmxlKGIuY3VycmVudFNsaWRlLWIuZ2V0U2xpZGVDb3VudCgpKTpiLmN1cnJlbnRTbGlkZS1iLmdldFNsaWRlQ291bnQoKSxiLmN1cnJlbnREaXJlY3Rpb249MX1cInZlcnRpY2FsXCIhPWQmJihiLnNsaWRlSGFuZGxlcihjKSxiLnRvdWNoT2JqZWN0PXt9LGIuJHNsaWRlci50cmlnZ2VyKFwic3dpcGVcIixbYixkXSkpfWVsc2UgYi50b3VjaE9iamVjdC5zdGFydFghPT1iLnRvdWNoT2JqZWN0LmN1clgmJihiLnNsaWRlSGFuZGxlcihiLmN1cnJlbnRTbGlkZSksYi50b3VjaE9iamVjdD17fSl9LGIucHJvdG90eXBlLnN3aXBlSGFuZGxlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2lmKCEoYi5vcHRpb25zLnN3aXBlPT09ITF8fFwib250b3VjaGVuZFwiaW4gZG9jdW1lbnQmJmIub3B0aW9ucy5zd2lwZT09PSExfHxiLm9wdGlvbnMuZHJhZ2dhYmxlPT09ITEmJi0xIT09YS50eXBlLmluZGV4T2YoXCJtb3VzZVwiKSkpc3dpdGNoKGIudG91Y2hPYmplY3QuZmluZ2VyQ291bnQ9YS5vcmlnaW5hbEV2ZW50JiZ2b2lkIDAhPT1hLm9yaWdpbmFsRXZlbnQudG91Y2hlcz9hLm9yaWdpbmFsRXZlbnQudG91Y2hlcy5sZW5ndGg6MSxiLnRvdWNoT2JqZWN0Lm1pblN3aXBlPWIubGlzdFdpZHRoL2Iub3B0aW9ucy50b3VjaFRocmVzaG9sZCxiLm9wdGlvbnMudmVydGljYWxTd2lwaW5nPT09ITAmJihiLnRvdWNoT2JqZWN0Lm1pblN3aXBlPWIubGlzdEhlaWdodC9iLm9wdGlvbnMudG91Y2hUaHJlc2hvbGQpLGEuZGF0YS5hY3Rpb24pe2Nhc2VcInN0YXJ0XCI6Yi5zd2lwZVN0YXJ0KGEpO2JyZWFrO2Nhc2VcIm1vdmVcIjpiLnN3aXBlTW92ZShhKTticmVhaztjYXNlXCJlbmRcIjpiLnN3aXBlRW5kKGEpfX0sYi5wcm90b3R5cGUuc3dpcGVNb3ZlPWZ1bmN0aW9uKGEpe3ZhciBkLGUsZixnLGgsYj10aGlzO3JldHVybiBoPXZvaWQgMCE9PWEub3JpZ2luYWxFdmVudD9hLm9yaWdpbmFsRXZlbnQudG91Y2hlczpudWxsLCFiLmRyYWdnaW5nfHxoJiYxIT09aC5sZW5ndGg/ITE6KGQ9Yi5nZXRMZWZ0KGIuY3VycmVudFNsaWRlKSxiLnRvdWNoT2JqZWN0LmN1clg9dm9pZCAwIT09aD9oWzBdLnBhZ2VYOmEuY2xpZW50WCxiLnRvdWNoT2JqZWN0LmN1clk9dm9pZCAwIT09aD9oWzBdLnBhZ2VZOmEuY2xpZW50WSxiLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoPU1hdGgucm91bmQoTWF0aC5zcXJ0KE1hdGgucG93KGIudG91Y2hPYmplY3QuY3VyWC1iLnRvdWNoT2JqZWN0LnN0YXJ0WCwyKSkpLGIub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmc9PT0hMCYmKGIudG91Y2hPYmplY3Quc3dpcGVMZW5ndGg9TWF0aC5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3coYi50b3VjaE9iamVjdC5jdXJZLWIudG91Y2hPYmplY3Quc3RhcnRZLDIpKSkpLGU9Yi5zd2lwZURpcmVjdGlvbigpLFwidmVydGljYWxcIiE9PWU/KHZvaWQgMCE9PWEub3JpZ2luYWxFdmVudCYmYi50b3VjaE9iamVjdC5zd2lwZUxlbmd0aD40JiZhLnByZXZlbnREZWZhdWx0KCksZz0oYi5vcHRpb25zLnJ0bD09PSExPzE6LTEpKihiLnRvdWNoT2JqZWN0LmN1clg+Yi50b3VjaE9iamVjdC5zdGFydFg/MTotMSksYi5vcHRpb25zLnZlcnRpY2FsU3dpcGluZz09PSEwJiYoZz1iLnRvdWNoT2JqZWN0LmN1clk+Yi50b3VjaE9iamVjdC5zdGFydFk/MTotMSksZj1iLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoLGIudG91Y2hPYmplY3QuZWRnZUhpdD0hMSxiLm9wdGlvbnMuaW5maW5pdGU9PT0hMSYmKDA9PT1iLmN1cnJlbnRTbGlkZSYmXCJyaWdodFwiPT09ZXx8Yi5jdXJyZW50U2xpZGU+PWIuZ2V0RG90Q291bnQoKSYmXCJsZWZ0XCI9PT1lKSYmKGY9Yi50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCpiLm9wdGlvbnMuZWRnZUZyaWN0aW9uLGIudG91Y2hPYmplY3QuZWRnZUhpdD0hMCksYi5vcHRpb25zLnZlcnRpY2FsPT09ITE/Yi5zd2lwZUxlZnQ9ZCtmKmc6Yi5zd2lwZUxlZnQ9ZCtmKihiLiRsaXN0LmhlaWdodCgpL2IubGlzdFdpZHRoKSpnLGIub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmc9PT0hMCYmKGIuc3dpcGVMZWZ0PWQrZipnKSxiLm9wdGlvbnMuZmFkZT09PSEwfHxiLm9wdGlvbnMudG91Y2hNb3ZlPT09ITE/ITE6Yi5hbmltYXRpbmc9PT0hMD8oYi5zd2lwZUxlZnQ9bnVsbCwhMSk6dm9pZCBiLnNldENTUyhiLnN3aXBlTGVmdCkpOnZvaWQgMCl9LGIucHJvdG90eXBlLnN3aXBlU3RhcnQ9ZnVuY3Rpb24oYSl7dmFyIGMsYj10aGlzO3JldHVybiBiLmludGVycnVwdGVkPSEwLDEhPT1iLnRvdWNoT2JqZWN0LmZpbmdlckNvdW50fHxiLnNsaWRlQ291bnQ8PWIub3B0aW9ucy5zbGlkZXNUb1Nob3c/KGIudG91Y2hPYmplY3Q9e30sITEpOih2b2lkIDAhPT1hLm9yaWdpbmFsRXZlbnQmJnZvaWQgMCE9PWEub3JpZ2luYWxFdmVudC50b3VjaGVzJiYoYz1hLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXSksYi50b3VjaE9iamVjdC5zdGFydFg9Yi50b3VjaE9iamVjdC5jdXJYPXZvaWQgMCE9PWM/Yy5wYWdlWDphLmNsaWVudFgsYi50b3VjaE9iamVjdC5zdGFydFk9Yi50b3VjaE9iamVjdC5jdXJZPXZvaWQgMCE9PWM/Yy5wYWdlWTphLmNsaWVudFksdm9pZChiLmRyYWdnaW5nPSEwKSl9LGIucHJvdG90eXBlLnVuZmlsdGVyU2xpZGVzPWIucHJvdG90eXBlLnNsaWNrVW5maWx0ZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO251bGwhPT1hLiRzbGlkZXNDYWNoZSYmKGEudW5sb2FkKCksYS4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpLGEuJHNsaWRlc0NhY2hlLmFwcGVuZFRvKGEuJHNsaWRlVHJhY2spLGEucmVpbml0KCkpfSxiLnByb3RvdHlwZS51bmxvYWQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2EoXCIuc2xpY2stY2xvbmVkXCIsYi4kc2xpZGVyKS5yZW1vdmUoKSxiLiRkb3RzJiZiLiRkb3RzLnJlbW92ZSgpLGIuJHByZXZBcnJvdyYmYi5odG1sRXhwci50ZXN0KGIub3B0aW9ucy5wcmV2QXJyb3cpJiZiLiRwcmV2QXJyb3cucmVtb3ZlKCksYi4kbmV4dEFycm93JiZiLmh0bWxFeHByLnRlc3QoYi5vcHRpb25zLm5leHRBcnJvdykmJmIuJG5leHRBcnJvdy5yZW1vdmUoKSxiLiRzbGlkZXMucmVtb3ZlQ2xhc3MoXCJzbGljay1zbGlkZSBzbGljay1hY3RpdmUgc2xpY2stdmlzaWJsZSBzbGljay1jdXJyZW50XCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKS5jc3MoXCJ3aWR0aFwiLFwiXCIpfSxiLnByb3RvdHlwZS51bnNsaWNrPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7Yi4kc2xpZGVyLnRyaWdnZXIoXCJ1bnNsaWNrXCIsW2IsYV0pLGIuZGVzdHJveSgpfSxiLnByb3RvdHlwZS51cGRhdGVBcnJvd3M9ZnVuY3Rpb24oKXt2YXIgYixhPXRoaXM7Yj1NYXRoLmZsb29yKGEub3B0aW9ucy5zbGlkZXNUb1Nob3cvMiksYS5vcHRpb25zLmFycm93cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmIWEub3B0aW9ucy5pbmZpbml0ZSYmKGEuJHByZXZBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsXCJmYWxzZVwiKSxhLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwiZmFsc2VcIiksMD09PWEuY3VycmVudFNsaWRlPyhhLiRwcmV2QXJyb3cuYWRkQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSxhLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwiZmFsc2VcIikpOmEuY3VycmVudFNsaWRlPj1hLnNsaWRlQ291bnQtYS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS5vcHRpb25zLmNlbnRlck1vZGU9PT0hMT8oYS4kbmV4dEFycm93LmFkZENsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcInRydWVcIiksYS4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcImZhbHNlXCIpKTphLmN1cnJlbnRTbGlkZT49YS5zbGlkZUNvdW50LTEmJmEub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJihhLiRuZXh0QXJyb3cuYWRkQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSxhLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwiZmFsc2VcIikpKX0sYi5wcm90b3R5cGUudXBkYXRlRG90cz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7bnVsbCE9PWEuJGRvdHMmJihhLiRkb3RzLmZpbmQoXCJsaVwiKS5yZW1vdmVDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIiksYS4kZG90cy5maW5kKFwibGlcIikuZXEoTWF0aC5mbG9vcihhLmN1cnJlbnRTbGlkZS9hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpKX0sYi5wcm90b3R5cGUudmlzaWJpbGl0eT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5vcHRpb25zLmF1dG9wbGF5JiYoZG9jdW1lbnRbYS5oaWRkZW5dP2EuaW50ZXJydXB0ZWQ9ITA6YS5pbnRlcnJ1cHRlZD0hMSl9LGEuZm4uc2xpY2s9ZnVuY3Rpb24oKXt2YXIgZixnLGE9dGhpcyxjPWFyZ3VtZW50c1swXSxkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxlPWEubGVuZ3RoO2ZvcihmPTA7ZT5mO2YrKylpZihcIm9iamVjdFwiPT10eXBlb2YgY3x8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGM/YVtmXS5zbGljaz1uZXcgYihhW2ZdLGMpOmc9YVtmXS5zbGlja1tjXS5hcHBseShhW2ZdLnNsaWNrLGQpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnKXJldHVybiBnO3JldHVybiBhfX0pOyIsIi8qISBwdXJsIHYyLjMuMSB8IE1JVCAqL1xuKGZ1bmN0aW9uKGZhY3Rvcnkpe2lmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShmYWN0b3J5KX1lbHNle3dpbmRvdy5wdXJsPWZhY3RvcnkoKX19KShmdW5jdGlvbigpe3ZhciB0YWcyYXR0cj17YTpcImhyZWZcIixpbWc6XCJzcmNcIixmb3JtOlwiYWN0aW9uXCIsYmFzZTpcImhyZWZcIixzY3JpcHQ6XCJzcmNcIixpZnJhbWU6XCJzcmNcIixsaW5rOlwiaHJlZlwifSxrZXk9W1wic291cmNlXCIsXCJwcm90b2NvbFwiLFwiYXV0aG9yaXR5XCIsXCJ1c2VySW5mb1wiLFwidXNlclwiLFwicGFzc3dvcmRcIixcImhvc3RcIixcInBvcnRcIixcInJlbGF0aXZlXCIsXCJwYXRoXCIsXCJkaXJlY3RvcnlcIixcImZpbGVcIixcInF1ZXJ5XCIsXCJmcmFnbWVudFwiXSxhbGlhc2VzPXthbmNob3I6XCJmcmFnbWVudFwifSxwYXJzZXI9e3N0cmljdDovXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooKFteOkBdKik6PyhbXjpAXSopKT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKT8oKCgoPzpbXj8jXFwvXSpcXC8pKikoW14/I10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS8sbG9vc2U6L14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoW146XFwvPyMuXSspOik/KD86XFwvXFwvKT8oKD86KChbXjpAXSopOj8oW146QF0qKSk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS99LGlzaW50PS9eWzAtOV0rJC87ZnVuY3Rpb24gcGFyc2VVcmkodXJsLHN0cmljdE1vZGUpe3ZhciBzdHI9ZGVjb2RlVVJJKHVybCkscmVzPXBhcnNlcltzdHJpY3RNb2RlfHxmYWxzZT9cInN0cmljdFwiOlwibG9vc2VcIl0uZXhlYyhzdHIpLHVyaT17YXR0cjp7fSxwYXJhbTp7fSxzZWc6e319LGk9MTQ7d2hpbGUoaS0tKXt1cmkuYXR0cltrZXlbaV1dPXJlc1tpXXx8XCJcIn11cmkucGFyYW1bXCJxdWVyeVwiXT1wYXJzZVN0cmluZyh1cmkuYXR0cltcInF1ZXJ5XCJdKTt1cmkucGFyYW1bXCJmcmFnbWVudFwiXT1wYXJzZVN0cmluZyh1cmkuYXR0cltcImZyYWdtZW50XCJdKTt1cmkuc2VnW1wicGF0aFwiXT11cmkuYXR0ci5wYXRoLnJlcGxhY2UoL15cXC8rfFxcLyskL2csXCJcIikuc3BsaXQoXCIvXCIpO3VyaS5zZWdbXCJmcmFnbWVudFwiXT11cmkuYXR0ci5mcmFnbWVudC5yZXBsYWNlKC9eXFwvK3xcXC8rJC9nLFwiXCIpLnNwbGl0KFwiL1wiKTt1cmkuYXR0cltcImJhc2VcIl09dXJpLmF0dHIuaG9zdD8odXJpLmF0dHIucHJvdG9jb2w/dXJpLmF0dHIucHJvdG9jb2wrXCI6Ly9cIit1cmkuYXR0ci5ob3N0OnVyaS5hdHRyLmhvc3QpKyh1cmkuYXR0ci5wb3J0P1wiOlwiK3VyaS5hdHRyLnBvcnQ6XCJcIik6XCJcIjtyZXR1cm4gdXJpfWZ1bmN0aW9uIGdldEF0dHJOYW1lKGVsbSl7dmFyIHRuPWVsbS50YWdOYW1lO2lmKHR5cGVvZiB0biE9PVwidW5kZWZpbmVkXCIpcmV0dXJuIHRhZzJhdHRyW3RuLnRvTG93ZXJDYXNlKCldO3JldHVybiB0bn1mdW5jdGlvbiBwcm9tb3RlKHBhcmVudCxrZXkpe2lmKHBhcmVudFtrZXldLmxlbmd0aD09PTApcmV0dXJuIHBhcmVudFtrZXldPXt9O3ZhciB0PXt9O2Zvcih2YXIgaSBpbiBwYXJlbnRba2V5XSl0W2ldPXBhcmVudFtrZXldW2ldO3BhcmVudFtrZXldPXQ7cmV0dXJuIHR9ZnVuY3Rpb24gcGFyc2UocGFydHMscGFyZW50LGtleSx2YWwpe3ZhciBwYXJ0PXBhcnRzLnNoaWZ0KCk7aWYoIXBhcnQpe2lmKGlzQXJyYXkocGFyZW50W2tleV0pKXtwYXJlbnRba2V5XS5wdXNoKHZhbCl9ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgcGFyZW50W2tleV0pe3BhcmVudFtrZXldPXZhbH1lbHNlIGlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBwYXJlbnRba2V5XSl7cGFyZW50W2tleV09dmFsfWVsc2V7cGFyZW50W2tleV09W3BhcmVudFtrZXldLHZhbF19fWVsc2V7dmFyIG9iaj1wYXJlbnRba2V5XT1wYXJlbnRba2V5XXx8W107aWYoXCJdXCI9PXBhcnQpe2lmKGlzQXJyYXkob2JqKSl7aWYoXCJcIiE9PXZhbClvYmoucHVzaCh2YWwpfWVsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIG9iail7b2JqW2tleXMob2JqKS5sZW5ndGhdPXZhbH1lbHNle29iaj1wYXJlbnRba2V5XT1bcGFyZW50W2tleV0sdmFsXX19ZWxzZSBpZih+cGFydC5pbmRleE9mKFwiXVwiKSl7cGFydD1wYXJ0LnN1YnN0cigwLHBhcnQubGVuZ3RoLTEpO2lmKCFpc2ludC50ZXN0KHBhcnQpJiZpc0FycmF5KG9iaikpb2JqPXByb21vdGUocGFyZW50LGtleSk7cGFyc2UocGFydHMsb2JqLHBhcnQsdmFsKX1lbHNle2lmKCFpc2ludC50ZXN0KHBhcnQpJiZpc0FycmF5KG9iaikpb2JqPXByb21vdGUocGFyZW50LGtleSk7cGFyc2UocGFydHMsb2JqLHBhcnQsdmFsKX19fWZ1bmN0aW9uIG1lcmdlKHBhcmVudCxrZXksdmFsKXtpZih+a2V5LmluZGV4T2YoXCJdXCIpKXt2YXIgcGFydHM9a2V5LnNwbGl0KFwiW1wiKTtwYXJzZShwYXJ0cyxwYXJlbnQsXCJiYXNlXCIsdmFsKX1lbHNle2lmKCFpc2ludC50ZXN0KGtleSkmJmlzQXJyYXkocGFyZW50LmJhc2UpKXt2YXIgdD17fTtmb3IodmFyIGsgaW4gcGFyZW50LmJhc2UpdFtrXT1wYXJlbnQuYmFzZVtrXTtwYXJlbnQuYmFzZT10fWlmKGtleSE9PVwiXCIpe3NldChwYXJlbnQuYmFzZSxrZXksdmFsKX19cmV0dXJuIHBhcmVudH1mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpe3JldHVybiByZWR1Y2UoU3RyaW5nKHN0cikuc3BsaXQoLyZ8Oy8pLGZ1bmN0aW9uKHJldCxwYWlyKXt0cnl7cGFpcj1kZWNvZGVVUklDb21wb25lbnQocGFpci5yZXBsYWNlKC9cXCsvZyxcIiBcIikpfWNhdGNoKGUpe312YXIgZXFsPXBhaXIuaW5kZXhPZihcIj1cIiksYnJhY2U9bGFzdEJyYWNlSW5LZXkocGFpciksa2V5PXBhaXIuc3Vic3RyKDAsYnJhY2V8fGVxbCksdmFsPXBhaXIuc3Vic3RyKGJyYWNlfHxlcWwscGFpci5sZW5ndGgpO3ZhbD12YWwuc3Vic3RyKHZhbC5pbmRleE9mKFwiPVwiKSsxLHZhbC5sZW5ndGgpO2lmKGtleT09PVwiXCIpe2tleT1wYWlyO3ZhbD1cIlwifXJldHVybiBtZXJnZShyZXQsa2V5LHZhbCl9LHtiYXNlOnt9fSkuYmFzZX1mdW5jdGlvbiBzZXQob2JqLGtleSx2YWwpe3ZhciB2PW9ialtrZXldO2lmKHR5cGVvZiB2PT09XCJ1bmRlZmluZWRcIil7b2JqW2tleV09dmFsfWVsc2UgaWYoaXNBcnJheSh2KSl7di5wdXNoKHZhbCl9ZWxzZXtvYmpba2V5XT1bdix2YWxdfX1mdW5jdGlvbiBsYXN0QnJhY2VJbktleShzdHIpe3ZhciBsZW49c3RyLmxlbmd0aCxicmFjZSxjO2Zvcih2YXIgaT0wO2k8bGVuOysraSl7Yz1zdHJbaV07aWYoXCJdXCI9PWMpYnJhY2U9ZmFsc2U7aWYoXCJbXCI9PWMpYnJhY2U9dHJ1ZTtpZihcIj1cIj09YyYmIWJyYWNlKXJldHVybiBpfX1mdW5jdGlvbiByZWR1Y2Uob2JqLGFjY3VtdWxhdG9yKXt2YXIgaT0wLGw9b2JqLmxlbmd0aD4+MCxjdXJyPWFyZ3VtZW50c1syXTt3aGlsZShpPGwpe2lmKGkgaW4gb2JqKWN1cnI9YWNjdW11bGF0b3IuY2FsbCh1bmRlZmluZWQsY3VycixvYmpbaV0saSxvYmopOysraX1yZXR1cm4gY3Vycn1mdW5jdGlvbiBpc0FycmF5KHZBcmcpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodkFyZyk9PT1cIltvYmplY3QgQXJyYXldXCJ9ZnVuY3Rpb24ga2V5cyhvYmope3ZhciBrZXlfYXJyYXk9W107Zm9yKHZhciBwcm9wIGluIG9iail7aWYob2JqLmhhc093blByb3BlcnR5KHByb3ApKWtleV9hcnJheS5wdXNoKHByb3ApfXJldHVybiBrZXlfYXJyYXl9ZnVuY3Rpb24gcHVybCh1cmwsc3RyaWN0TW9kZSl7aWYoYXJndW1lbnRzLmxlbmd0aD09PTEmJnVybD09PXRydWUpe3N0cmljdE1vZGU9dHJ1ZTt1cmw9dW5kZWZpbmVkfXN0cmljdE1vZGU9c3RyaWN0TW9kZXx8ZmFsc2U7dXJsPXVybHx8d2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCk7cmV0dXJue2RhdGE6cGFyc2VVcmkodXJsLHN0cmljdE1vZGUpLGF0dHI6ZnVuY3Rpb24oYXR0cil7YXR0cj1hbGlhc2VzW2F0dHJdfHxhdHRyO3JldHVybiB0eXBlb2YgYXR0ciE9PVwidW5kZWZpbmVkXCI/dGhpcy5kYXRhLmF0dHJbYXR0cl06dGhpcy5kYXRhLmF0dHJ9LHBhcmFtOmZ1bmN0aW9uKHBhcmFtKXtyZXR1cm4gdHlwZW9mIHBhcmFtIT09XCJ1bmRlZmluZWRcIj90aGlzLmRhdGEucGFyYW0ucXVlcnlbcGFyYW1dOnRoaXMuZGF0YS5wYXJhbS5xdWVyeX0sZnBhcmFtOmZ1bmN0aW9uKHBhcmFtKXtyZXR1cm4gdHlwZW9mIHBhcmFtIT09XCJ1bmRlZmluZWRcIj90aGlzLmRhdGEucGFyYW0uZnJhZ21lbnRbcGFyYW1dOnRoaXMuZGF0YS5wYXJhbS5mcmFnbWVudH0sc2VnbWVudDpmdW5jdGlvbihzZWcpe2lmKHR5cGVvZiBzZWc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gdGhpcy5kYXRhLnNlZy5wYXRofWVsc2V7c2VnPXNlZzwwP3RoaXMuZGF0YS5zZWcucGF0aC5sZW5ndGgrc2VnOnNlZy0xO3JldHVybiB0aGlzLmRhdGEuc2VnLnBhdGhbc2VnXX19LGZzZWdtZW50OmZ1bmN0aW9uKHNlZyl7aWYodHlwZW9mIHNlZz09PVwidW5kZWZpbmVkXCIpe3JldHVybiB0aGlzLmRhdGEuc2VnLmZyYWdtZW50fWVsc2V7c2VnPXNlZzwwP3RoaXMuZGF0YS5zZWcuZnJhZ21lbnQubGVuZ3RoK3NlZzpzZWctMTtyZXR1cm4gdGhpcy5kYXRhLnNlZy5mcmFnbWVudFtzZWddfX19fXB1cmwualF1ZXJ5PWZ1bmN0aW9uKCQpe2lmKCQhPW51bGwpeyQuZm4udXJsPWZ1bmN0aW9uKHN0cmljdE1vZGUpe3ZhciB1cmw9XCJcIjtpZih0aGlzLmxlbmd0aCl7dXJsPSQodGhpcykuYXR0cihnZXRBdHRyTmFtZSh0aGlzWzBdKSl8fFwiXCJ9cmV0dXJuIHB1cmwodXJsLHN0cmljdE1vZGUpfTskLnVybD1wdXJsfX07cHVybC5qUXVlcnkod2luZG93LmpRdWVyeSk7cmV0dXJuIHB1cmx9KTsiXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
